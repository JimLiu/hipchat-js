import XDMRPC from './xdmrpc';
import Utils from '../common/util';

class Connect {

  constructor() {
    this._xdm = new XDMRPC();
  }

  /**
   * Send a message to iframes matching the targetSpec. This message is added to
   *  a message queue for delivery to ensure the message is received if an iframe 
   *  has not yet loaded
   * 
   * @param type The name of the event type
   * @param targetSpec The spec to match against extensions when sending this event
   * @param event The event payload
   * @param callback A callback to be executed when the remote iframe calls its callback
   */
  dispatch(type, targetSpec, event, callback) {
    this._xdm.queueEvent(type, targetSpec, event, callback);
    return this.getExtensions(targetSpec);
  }
  
  /**
   * Send a message to iframes matching the targetSpec immediately. This message will 
   *  only be sent to iframes that are already open, and will not be delivered if none
   *  are currently open.
   * 
   * @param type The name of the event type
   * @param targetSpec The spec to match against extensions when sending this event
   * @param event The event payload
   */
  broadcast(type, targetSpec, event) {
    this._xdm.dispatch(type, targetSpec, event, null, null);
    return this.getExtensions(targetSpec);    
  }

  _createId(extension) {
    if(!extension.addon_key || !extension.key){
      throw Error('Extensions require addon_key and key');
    }
    return extension.addon_key + '__' + extension.key + '__' + Utils.randomString();
  }
  /**
  * Creates a new iframed module, without actually creating the DOM element.
  * The iframe attributes are passed to the 'setupCallback', which is responsible for creating
  * the DOM element and returning the window reference.
  *
  * @param extension The extension definition. Example:
  *   {
  *     addon_key: 'my-addon',
  *     key: 'my-module',
  *     url: 'https://example.com/my-module',
  *     options: { autoresize: false }
  *   }
  *
  * @param initCallback The optional initCallback is called when the bridge between host and iframe is established.
  **/
  create(extension, initCallback) {
    let extension_id = this.registerExtension(extension, initCallback);

    let data = {
      extension_id: extension_id,
      api: this._xdm.getApiSpec(),
      origin: Utils.locationOrigin(),
      options: extension.options || {}
    };

    return {
      id: extension_id,
      name: JSON.stringify(data),
      src: extension.url
    };
  }

  registerRequestNotifier(callback) {
    this._xdm.registerRequestNotifier(callback);
  }

  registerExtension(extension, initCallback) {
    let extension_id = this._createId(extension);
    this._xdm.registerExtension(extension_id, {
      extension: extension,
      initCallback: initCallback
    });
    return extension_id;
  }

  registerKeyListener(extension_id, key, modifiers, callback) {
    this._xdm.registerKeyListener(extension_id, key, modifiers, callback);
  }

  unregisterKeyListener(extension_id, key, modifiers, callback) {
   this._xdm.unregisterKeyListener(extension_id, key, modifiers, callback);
  }

  defineModule(moduleName, module) {
    this._xdm.defineAPIModule(module, moduleName);
  }

  defineGlobals(module) {
    this._xdm.defineAPIModule(module);
  }

  getExtensions(filter) {
    return this._xdm.getRegisteredExtensions(filter);
  }

  unregisterExtension(filter) {
    return this._xdm.unregisterExtension(filter);
  }

}

module.exports = new Connect();


/** WEBPACK FOOTER **
 ** ./~/simple-xdm/src/host/index.js
 **/