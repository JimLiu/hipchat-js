/**
* Postmessage format:
*
* Initialization
* --------------
* {
*   type: 'init',
*   eid: 'my-addon__my-module-xyz'  // the extension identifier, unique across iframes
* }
*
* Request
* -------
* {
*   type: 'req',
*   eid: 'my-addon__my-module-xyz',  // the extension identifier, unique for iframe
*   mid: 'xyz',  // a unique message identifier, required for callbacks
*   mod: 'cookie',  // the module name
*   fn: 'read',  // the method name
*   args: [arguments]  // the method arguments
* }
*
* Response
* --------
* {
*   type: 'resp'
*   eid: 'my-addon__my-module-xyz',  // the extension identifier, unique for iframe
*   mid: 'xyz',  // a unique message identifier, obtained from the request
*   args: [arguments]  // the callback arguments
* }
*
* Event
* -----
* {
*   type: 'evt',
*   etyp: 'some-event',
*   evnt: { ... }  // the event data
*   mid: 'xyz', // a unique message identifier for the event
* }
**/

import Utils from '../common/util';
import PostMessage from '../common/postmessage';

let VALID_EVENT_TIME_MS = 30000; //30 seconds

class XDMRPC extends PostMessage {

  constructor(config) {
    config = config || {};
    super(config);
    this._registeredExtensions = config.extensions || {};
    this._registeredAPIModules = {};
    this._pendingCallbacks = {};
    this._keycodeCallbacks = {};
    this._pendingEvents = {};
    this._messageHandlers = {
      init: this._handleInit,
      req: this._handleRequest,
      resp: this._handleResponse,
      event_query: this._handleEventQuery,
      broadcast: this._handleBroadcast,
      key_listen: this._handleKeyListen
    };
  }

  _handleInit(event, reg) {
    this._registeredExtensions[reg.extension_id].source = event.source;
    if (reg.initCallback) {
      reg.initCallback(event.data.eid);
      delete reg.initCallback;
    }
  }

  _handleResponse(event) {
    var data = event.data;
    var pendingCallback = this._pendingCallbacks[data.mid];
    if (pendingCallback) {
      delete this._pendingCallbacks[data.mid];
      pendingCallback.apply(window, data.args);
    }
  }

  registerRequestNotifier(cb) {
    this._registeredRequestNotifier = cb;
  }

  _handleRequest(event, reg) {
    function sendResponse() {
      var args = Utils.argumentsToArray(arguments);
      event.source.postMessage({
        mid: event.data.mid,
        type: 'resp',
        args: args
      }, reg.extension.url);
    }

    var data = event.data;
    var module = this._registeredAPIModules[data.mod];
    const extension = this.getRegisteredExtensions(reg.extension)[0];
    if (module) {
      let fnName = data.fn;
      if (data._cls) {
        const Cls = module[data._cls];
        const ns = data.mod + '-' + data._cls + '-';
        sendResponse._id = data._id;
        if (fnName === 'constructor') {
          if (!Cls._construct) {
            Cls.constructor.prototype._destroy = function() {
              delete this._context._proxies[ns + this._id];
            };
            Cls._construct = function(...args) {
              const inst = new Cls.constructor(...args);
              const callback = args[args.length - 1];
              inst._id = callback._id;
              inst._context = callback._context;
              inst._context._proxies[ns + inst._id] = inst;
              return inst;
            };
          }
          module = Cls;
          fnName = '_construct';
        } else {
          module = extension._proxies[ns + data._id];
        }
      }
      let method = module[fnName];
      if (method) {
        var methodArgs = data.args;
        sendResponse._context = extension;
        methodArgs.push(sendResponse);
        method.apply(module, methodArgs);
        if(this._registeredRequestNotifier) {
          this._registeredRequestNotifier.call(null, {
            module: data.mod,
            fn: data.fn,
            type: data.type,
            addon_key: reg.extension.addon_key,
            key: reg.extension.key,
            extension_id: reg.extension_id
          });
        }
      }
    }
  }

  _handleBroadcast(event, reg) {
    var event_data = event.data;
    var targetSpec = r => r.extension.addon_key === reg.extension.addon_key && r.extension_id !== reg.extension_id;
    this.dispatch(event_data.etyp, targetSpec, event_data.evnt, null, null);
  }

  _handleKeyListen(event, reg) {
    var eventData = event.data;
    var keycodeEntry = this._keycodeKey(eventData.keycode, eventData.modifiers, reg.extension_id);
    var listeners = this._keycodeCallbacks[keycodeEntry];
    if(listeners) {
      listeners.forEach((listener) => {
        listener.call(null, {
          addon_key: reg.extension.addon_key,
          key: reg.extension.key,
          extension_id: reg.extension_id,
          keycode: eventData.keycode,
          modifiers: eventData.modifiers
        });
      }, this);
    }
  }

  defineAPIModule(module, moduleName){
    if(moduleName){
      this._registeredAPIModules[moduleName] = module;
    } else {
      this._registeredAPIModules._globals = Utils.extend({}, this._registeredAPIModules._globals, module);
    }
    return this._registeredAPIModules;
  }

  _fullKey(targetSpec){
    var key = targetSpec.addon_key || 'global';
    if(targetSpec.key){
      key = `${key}@@${targetSpec.key}`;
    }

    return key;
  }

  queueEvent(type, targetSpec, event, callback) {
    var loaded_frame,
    targets = this._findRegistrations(targetSpec);

    loaded_frame = targets.some((target) => {
      return target.registered_events !== undefined;
    }, this);

    if(loaded_frame){
      this.dispatch(type, targetSpec, event, callback);
    } else {
      this._pendingEvents[this._fullKey(targetSpec)] = {
        type,
        targetSpec,
        event,
        callback,
        time: new Date().getTime(),
        uid: Utils.randomString()
      };
    }
  }

  _handleEventQuery(message, extension) {
    let executed = {};
    let now = new Date().getTime();
    let keys = Object.keys(this._pendingEvents);
    keys.forEach((index) => {
      let element = this._pendingEvents[index];
      let eventIsValid = (now - element.time) <= VALID_EVENT_TIME_MS;
      let isSameTarget = !element.targetSpec || this._findRegistrations(element.targetSpec).length !== 0;

      if (eventIsValid && isSameTarget) {
        executed[index] = element;
        element.targetSpec = element.targetSpec || {};
        element.targetSpec.addon_key = extension.extension.addon_key;
        element.targetSpec.key = extension.extension.key;
        this.dispatch(element.type, element.targetSpec, element.event, element.callback, message.source);
      } else if (!eventIsValid) {
        delete this._pendingEvents[index];
      }
    });

    this._registeredExtensions[extension.extension_id].registered_events = message.data.args;

    return executed;
  }

  dispatch(type, targetSpec, event, callback, source) {
    function sendEvent(reg, evnt) {
      if (reg.source) {
        var mid;
        if (callback) {
          mid = Utils.randomString();
          this._pendingCallbacks[mid] = callback;
        }

        reg.source.postMessage({
          type: 'evt',
          mid: mid,
          etyp: type,
          evnt: evnt
        }, reg.extension.url);
      }
    }

    var registrations = this._findRegistrations(targetSpec || {});
    registrations.forEach(function (reg) {
      if(source){
        reg.source = source;
      }

      if (reg.source) {
        Utils._bind(this, sendEvent)(reg, event);
      }
    }, this);
  }

  _findRegistrations(targetSpec) {
    if(this._registeredExtensions.length === 0){
      Utils.error('no registered extensions', this._registeredExtensions);
      return [];
    }
    var keys = Object.getOwnPropertyNames(targetSpec);
    var registrations = Object.getOwnPropertyNames(this._registeredExtensions).map((key) => {
      return this._registeredExtensions[key];
    });

    if (targetSpec instanceof Function) {
      return registrations.filter(targetSpec);
    } else {
      return registrations.filter(function (reg) {
        return keys.every(function (key) {
          return reg.extension[key] === targetSpec[key];
        });
      });
    }
  }

  registerExtension(extension_id, data) {
    // delete duplicate registrations
    if(data.extension.addon_key && data.extension.key){
      let existingView = this._findRegistrations({
        addon_key: data.extension.addon_key,
        key: data.extension.key
      });
      if(existingView.length !== 0){
        delete this._registeredExtensions[existingView[0].extension_id];
      }
    }
    data._proxies = {};
    data.extension_id = extension_id;
    this._registeredExtensions[extension_id] = data;
  }

  _keycodeKey(key, modifiers, extension_id) {
    var code = key;

    if(modifiers) {
      if(typeof modifiers === "string") {
        modifiers = [modifiers];
      }
      modifiers.sort();
      modifiers.forEach((modifier) => {
        code += '$$' + modifier;
      }, this);
    }

    return code + '__' + extension_id;
  }

  registerKeyListener(extension_id, key, modifiers, callback) {
    if(typeof modifiers === "string") {
      modifiers = [modifiers];
    }
    var extension = this._registeredExtensions[extension_id];
    var keycodeEntry = this._keycodeKey(key, modifiers, extension_id);
    if(!this._keycodeCallbacks[keycodeEntry]) {
      this._keycodeCallbacks[keycodeEntry] = [];
      extension.source.postMessage({
        type: 'key_listen',
        keycode: key,
        modifiers: modifiers,
        action: 'add'
      }, extension.source.location.href);
    }
    this._keycodeCallbacks[keycodeEntry].push(callback);
  }

  unregisterKeyListener(extension_id, key, modifiers, callback) {
    var keycodeEntry = this._keycodeKey(key, modifiers, extension_id);
    var potentialCallbacks = this._keycodeCallbacks[keycodeEntry];
    var extension = this._registeredExtensions[extension_id];

    if(potentialCallbacks) {
      if(callback) {
        var index = potentialCallbacks.indexOf(callback);
         this._keycodeCallbacks[keycodeEntry].splice(index, 1);
      } else {
        delete this._keycodeCallbacks[keycodeEntry];
      }

      extension.source.postMessage({
        type: 'key_listen',
        keycode: key,
        modifiers: modifiers,
        action: 'remove'
      }, extension.source.location.href);
    }
  }

  getApiSpec() {
    let that = this;
    function createModule(moduleName) {
      var module = that._registeredAPIModules[moduleName];
      if(!module){
        throw new Error("unregistered API module: " + moduleName);
      }
      function getModuleDefinition(mod) {
        return Object.getOwnPropertyNames(mod).reduce((accumulator, memberName) => {
          const member = mod[memberName];
          switch (typeof member) {
            case 'function':
              accumulator[memberName] = {
                args: Utils.argumentNames(member)
              };
              break;
            case 'object':
              if (member.hasOwnProperty('constructor')) {
                accumulator[memberName] = getModuleDefinition(member);
              }
              break;
          }
          return accumulator;
        }, {});
      }
      return getModuleDefinition(module);
    }
    return Object.getOwnPropertyNames(this._registeredAPIModules).reduce((accumulator, moduleName) => {
        accumulator[moduleName] = createModule(moduleName);
        return accumulator;
    }, {});
  }


  // validate origin of postMessage
  _checkOrigin(event, reg) {
    let no_source_types = ['init', 'event_query'];
    let isNoSourceType = reg && !reg.source && no_source_types.indexOf(event.data.type) > -1;
    let sourceTypeMatches = reg && event.source === reg.source;
    let hasExtensionUrl = reg && reg.extension.url.indexOf(event.origin) === 0;
    let isValidOrigin = hasExtensionUrl && (isNoSourceType || sourceTypeMatches);
    if(!isValidOrigin) {
        Utils.warn("Failed to validate origin: " + event.origin);
    }
    return isValidOrigin;
  }

  getRegisteredExtensions(filter) {
    if(filter) {
      return this._findRegistrations(filter);
    }
    return this._registeredExtensions;
  }

  unregisterExtension(filter) {
    let registrations = this._findRegistrations(filter);
    if(registrations.length !== 0){
      registrations.forEach(function(registration) {
        let keys = Object.keys(this._pendingEvents);
        keys.forEach((index) => {
          let element = this._pendingEvents[index];
          let targetSpec = element.targetSpec || {};

          if (targetSpec.addon_key === registration.extension.addon_key) {
            delete this._pendingEvents[index];
          }
        });

        delete this._registeredExtensions[registration.extension_id];
      }, this);
    }
  }

}

module.exports = XDMRPC;



/** WEBPACK FOOTER **
 ** ./~/simple-xdm/src/host/xdmrpc.js
 **/