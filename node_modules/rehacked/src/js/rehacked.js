var parse = require('../lib/Slick.Parser-1.1.7').Slick.parse;
var _ = require('./util');

function Rehacked() {
  this._hackRegistry = {};
}

var _assert = function(condition, message) {
  if (!condition) throw message;
};

/**
 * Returns if any hacks are registered with Rehacked
 * @returns {boolean} if any hacks are registered
 */
Rehacked.prototype.isAnythingBeingHacked = function () {
  return this._hackRegistry.length !== 0;
};

/**
 * Returns if a specific component is being hacked with Rehacked
 * @param {string} componentName the display name of the component
 * @returns {boolean} if any hacks are registered for the specified component
 */
Rehacked.prototype.isBeingHacked = function (componentName) {
  return typeof this._hackRegistry[componentName] !== 'undefined';
};

/**
 * Render an element before a selector in a component’s DOM tree
 * @param {string} componentName the display name of the component
 * @param {string} selector a CSS3 selector specifying which elements to hack
 * @param {Object} reactClass a React.js element to render before the found elements
 * @param {Object=} opts an optional options hash
 */
Rehacked.prototype.before = function (componentName, selector, reactClass, opts) {
  this._hack(componentName, selector, reactClass, _.extend({location: -1}, opts))
};

/**
 * Render an element after a selector in a component’s DOM tree
 * @param {string} componentName the display name of the component
 * @param {string} selector a CSS3 selector specifying which elements to hack
 * @param {Object} reactClass a React.js element to render before the found elements
 * @param {Object=} opts an optional options hash
 */
Rehacked.prototype.after = function (componentName, selector, reactClass, opts) {
  this._hack(componentName, selector, reactClass, _.extend({location: 1}, opts))
};

/**
 * Render an element in place of a selector in a component’s DOM tree (experimental)
 * @param {string} componentName the display name of the component
 * @param {string} selector a CSS3 selector specifying which elements to hack
 * @param {Object} reactClass a React.js element to render before the found elements
 * @param {Object=} opts an optional options hash
 */
Rehacked.prototype.on = function (componentName, selector, reactClass, opts) {
  this._hack(componentName, selector, reactClass, _.extend({location: 0}, opts))
};

Rehacked.prototype._getEntry = function (componentName) {
  return this._hackRegistry[componentName];
};

Rehacked.prototype._hack = function (componentName, selector, reactClass, opts) {
  _assert(componentName, "You must specify a component type to hack");
  _assert(selector, "You must specify a selector");
  _assert(reactClass, "You must provide an element to render");
  _assert(opts.location !== -1 || opts.location !== 0 || opts.location !== 1, "You must specify a place for the hack to appear");

  var isComponentBeingHacked = this.isBeingHacked(componentName);
  var entry = {
    selector: parse(selector),
    location: opts.location,
    reactClass: reactClass
  };

  if (isComponentBeingHacked) {
    this._hackRegistry[componentName].push(entry);
  } else {
    this._hackRegistry[componentName] = [entry];
  }
};

Rehacked.prototype._clear = function () {
  this._hackRegistry = {};
};

module.exports = Rehacked;



/** WEBPACK FOOTER **
 ** ./~/rehacked/src/js/rehacked.js
 **/