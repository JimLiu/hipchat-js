/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*global HC_WEB_BASEURL, VERSION_ID*/
	
	(function () {
	  var HipChatClient = __webpack_require__(1);
	  var utils = __webpack_require__(99);
	
	  var $body = $('body');
	
	  var client = new HipChatClient({
	    el: document.getElementById('hipchat'),
	    base_url: (undefined),
	    client_type: 'web',
	    client_version_id: ("4.30.3"),
	    client_os_version_id: [utils.browser.userAgent().browser.name || 'unknown', utils.browser.userAgent().browser.major || 1].join(" "),
	    asset_base_uri: window.assetBaseUri,
	    is_guest: !!(window.HC && window.HC.is_guest),
	    html5_routing_enabled: true,
	    initState: $body.data('init-state'),
	    feature_flags: $body.data('feature-flags')
	  });
	  $body.removeAttr('data-init-state data-feature-flags').removeData(['initState', 'featureFlags']);
	  client.render();
	})();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(2);
	
	__webpack_require__(3);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics = __webpack_require__(188);
	
	var _analytics2 = _interopRequireDefault(_analytics);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _app_header_store = __webpack_require__(96);
	
	var _app_header_store2 = _interopRequireDefault(_app_header_store);
	
	var _appDispatcherEvents = __webpack_require__(255);
	
	var _appDispatcherEvents2 = _interopRequireDefault(_appDispatcherEvents);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _configuration_model = __webpack_require__(201);
	
	var _configuration_model2 = _interopRequireDefault(_configuration_model);
	
	var _notifier = __webpack_require__(180);
	
	var _notifier2 = _interopRequireDefault(_notifier);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	var _hc_global = __webpack_require__(294);
	
	var _hc_global2 = _interopRequireDefault(_hc_global);
	
	var _main_layout = __webpack_require__(307);
	
	var _main_layout2 = _interopRequireDefault(_main_layout);
	
	var _guest_layout = __webpack_require__(627);
	
	var _guest_layout2 = _interopRequireDefault(_guest_layout);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _client_type = __webpack_require__(212);
	
	var _client_type2 = _interopRequireDefault(_client_type);
	
	var _error_detect = __webpack_require__(632);
	
	var _error_detect2 = _interopRequireDefault(_error_detect);
	
	var _network_status_helper = __webpack_require__(218);
	
	var _network_status_helper2 = _interopRequireDefault(_network_status_helper);
	
	__webpack_require__(633);
	
	__webpack_require__(290);
	
	__webpack_require__(635);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*global Strophe HC_HOT_RELOAD*/
	
	// Beginning of the application bootstrapping process before any client code has been executed. We're storing this
	// moment in time for use in analytics event later when the analytics module is loaded.
	// NOTE: We're checking for an existing value here to allow the native clients to have the opportunity to set this
	//       value to whatever their actual start time is, rather than when they load the code in the web view.
	//       We will also set this value on the web side in the php layer so that we can get a better handle on the
	//       true starting point (rather than here when the entire minified application script has loaded).
	window.hc_client_launch_time = window.hc_client_launch_time || new Date().getTime(); //setup event handlers for logger before anything else
	
	
	window.onerror = _logger2.default.error.bind(_logger2.default);
	
	// Modules not directly used but need to be imported.
	
	
	/**
	 * Create a new HipChatClient
	 *
	 * @param {Object}  config the configuration object for this client object instance
	 * @param {String}  config.client_type='web' the type for this client (used for connection and analytics)
	 * @param {String}  config.client_subtype='unknown' the subtype for this client (used for connection and analytics)
	 * @param {String}  config.base_url='https://www.hipchat.com' the base url of the HipChat instance to connect to
	 * @param {String}  config.client_version_id='0' the version identifier for this HipChat client
	 * @param {String}  config.client_os_version_id='0' the version identifier for this OS (or browser)
	 * @param {URL}     config.asset_base_uri='' the base uri for assets (images/sounds)
	 * @param {boolean} config.is_guest=false if this user is a guest user
	 * @param {boolean} config.html5_routing_enabled=true if HTML5 style routing should be used, or hash based
	 * @param {Object}  config.keyboard_shortcuts shortcuts object
	 * @param {Object}  config.app_config_overrides any overrides for the application config that this client uses
	 * @param {Object}  config.release_dialog_content {"title": "Title", "intro": "Intro", "bullets": ["Bullet1", "Bullet2"], "outro": "Outro", "cta": "Call to Action"}
	 * @param {Object}  config.keyboard_shortcuts["ctrl+n"] {"action": "newChat"}
	 * available default actions "newChat", "inviteUsersToRoom", "closeRoom", "navigateRoomsUp", "navigateRoomsDown",
	 * "searchHistory", "toggleSoundNotifications", "viewShortcuts" - "action" can also accept a function:
	 * {"action": function()(alert("hey"))} - optionally add a title {"title": "New chat", "action": "newChat"}
	 * note: titles are automatically create for the default actions. If you pass a function you should pass a title.
	 *
	 * @returns {Object} a HipChatClient
	 */
	
	function HipChatClient(opts) {
	  var defaultConfig = {
	    base_url: '',
	    video_base_url: 'https://hipchat.com/video/join',
	    client_type: _client_type2.default.WEB,
	    client_os_version_id: 'unknown os version',
	    client_version_id: '0',
	    asset_base_uri: '',
	    video_chat_uri: '',
	    is_guest: false,
	    read_only_mode: false,
	    read_only_input_markdown: '',
	    html5_routing_enabled: true,
	    health_check_enabled: true,
	    keyboard_shortcuts: null,
	    app_config_overrides: {},
	    native_feature_flags: {},
	    release_dialog_content: {},
	    ui: {}
	  };
	
	  // Set native_feature_flags if client is native
	  // and feature_flags have been passed in
	  if (_utils2.default.clientSubType.isNative(opts.client_subtype)) {
	    opts.native_feature_flags = _.clone(opts.feature_flags);
	  }
	
	  var initState = opts.initState || {};
	  delete opts.initState;
	
	  var normalizedOpts = _.defaultsDeep(opts, defaultConfig);
	  var mergedOpts = _.merge(normalizedOpts, initState);
	  var config = new _configuration_model2.default(mergedOpts);
	
	  _application_store2.default.configure({
	    config: config,
	    asset_base_uri: config.asset_base_uri,
	    client_type: config.client_type,
	    video_chat_uri: config.video_chat_uri,
	    client_subtype: config.client_subtype,
	    client_version_id: config.client_version_id,
	    html5_routing_enabled: config.html5_routing_enabled,
	    release_dialog_content: config.release_dialog_content
	  });
	
	  // TODO: Get this into a spi. This is a temporary stop-gap
	  _connection_manager2.default.setOAuthTokenCallback(initState.onRefreshOAuthAccessToken);
	
	  _logger2.default.debug("[HipChatClient]", 'config received', _logger2.default.sanitize(_configuration_store2.default.getAll()));
	
	  _app_header_store2.default.set({
	    notification_permission: _spi2.default.getNotificationPermission()
	  });
	
	  _network_status_helper2.default.initialize({
	    doHealthCheck: !!config.health_check_enabled
	  });
	
	  // Setup HC global
	  window.HC = new _hc_global2.default({ is_guest: config.is_guest });
	
	  // Let's inform everyone else that the global is available
	  $(document).trigger("hc-ready", window.HC);
	
	  _notifier2.default.initialize(config.asset_base_uri, config.app_config_overrides);
	  _utils2.default.emoticons.asset_base_uri = config.asset_base_uri;
	  _utils2.default.emoticons.web_server = config.web_server;
	
	  if (config.smileys) {
	    _utils2.default.emoticons.addSmileys(config.smileys);
	  }
	
	  var clientIdentifier = {
	    client_type: config.client_type,
	    client_subtype: config.client_subtype,
	    client_version_id: config.client_version_id,
	    client_os_version_id: config.client_os_version_id
	  };
	
	  // disable analytics for btf:
	  // this could potentially be an issue if
	  // wrappers stop passing in the btf flag
	  if (!_.get(config, 'feature_flags.btf')) {
	    new _analytics2.default(initState, clientIdentifier);
	  }
	
	  _analytics_dispatcher2.default.dispatch("analytics-hc-client-start");
	
	  (0, _appDispatcherEvents2.default)(config);
	  _app_dispatcher2.default.dispatch('hipchat-client-configured');
	
	  var detector = new _error_detect2.default(function (type, err) {
	    _spi2.default.onUnrecoverableError(type, err);
	  });
	
	  detector.addRule('invariant', {
	    detect: function detect(err) {
	      return err.name === "Invariant Violation" || /^Invariant Violation/.test(err.message);
	    },
	    threshold: 3,
	    time: 5 * 1000
	  });
	  detector.install();
	  _mouse_position2.default.track();
	}
	/**
	 * Render the HipChatClient to the DOM
	 * @param el an options element to render to, or an element matching #hipchat is used
	 */
	HipChatClient.prototype.render = function (el) {
	  var targetEl = el || document.querySelector('#hipchat');
	
	  // Determine which layout to use
	  var Layout = _configuration_store2.default.isGuest() ? _guest_layout2.default : _main_layout2.default;
	
	  // Don't hold up rendering for data
	  var rootInstance = ReactDOM.render(React.createElement(Layout, { is_guest: _configuration_store2.default.isGuest() }), targetEl);
	
	  if (false) {
	    require('react-hot-loader/Injection').RootInstanceProvider.injectProvider({
	      getRootInstances: function getRootInstances() {
	        // Help React Hot Loader figure out the root component instances on the page:
	        return [rootInstance];
	      }
	    });
	  }
	
	  $(window).on('beforeunload', function () {
	    _app_dispatcher2.default.dispatch('unload-app');
	  }).blur(function () {
	    _app_dispatcher2.default.dispatch('application-blurred');
	  }).focus(function () {
	    _app_dispatcher2.default.dispatch('application-focused');
	  });
	};
	
	module.exports = HipChatClient;

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function polyfills() {
	
	  // http://tosbourn.com/a-fix-for-window-location-origin-in-internet-explorer/
	  if (!window.location.origin) {
	    window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
	  }
	}
	
	exports.default = polyfills();
	module.exports = exports['default'];

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Subscribes to many important events through the app and logs output
	 *
	 * @class EventLogger
	 */
	var AppDispatcher = __webpack_require__(9);
	var logger = __webpack_require__(90);
	
	var EventLogger = function () {
	  function EventLogger() {
	    (0, _classCallCheck3.default)(this, EventLogger);
	
	    this.registerCallbacks();
	  }
	
	  (0, _createClass3.default)(EventLogger, [{
	    key: 'registerCallbacks',
	    value: function registerCallbacks() {
	      $(document).on('hc-ready', function (e, data) {
	        logger.debug('[event: hc-ready]', "window.HC", { verbose: data });
	      }).on('app-state-ready', function () {
	        logger.debug('[event: app-state-ready]');
	      });
	
	      AppDispatcher.register({
	        //app level stuff
	        'app-state-connected': function appStateConnected() {
	          logger.debug('[event: app-state-connected]');
	        },
	        'app-state-reconnected': function appStateReconnected() {
	          logger.debug('[event: app-state-reconnected]');
	        },
	        'attempt-disconnect': function attemptDisconnect(data) {
	          logger.debug('[event: attempt-disconnect]', data);
	        },
	        'attempt-reconnect': function attemptReconnect() {
	          logger.debug('[event: attempt-reconnect]');
	        },
	        'application-blurred': function applicationBlurred() {
	          if (logger.isVerbose()) {
	            logger.debug('[event: application-blurred]');
	          }
	        },
	        'application-focused': function applicationFocused() {
	          if (logger.isVerbose()) {
	            logger.debug('[event: application-focused]');
	          }
	        },
	        'unload-app': function unloadApp() {
	          logger.debug('[event: unload-app]');
	        },
	        'exit-app': function exitApp(data) {
	          logger.debug('[event: exit-app]', data);
	        },
	        'signout': function signout() {
	          logger.debug('[event: signout]');
	        },
	
	        //files
	        'upload-successful': function uploadSuccessful(data) {
	          logger.debug('[event: upload-successful]', logger.sanitize(data));
	        },
	        'upload-failed': function uploadFailed(error) {
	          logger.debug('[event: upload-failed]', error);
	        },
	        'file-error': function fileError(data) {
	          logger.debug('[event: file-error]', logger.sanitize(data));
	        },
	
	        //user/presences, etc.
	        'request-profile': function requestProfile(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: request-profile]', data);
	          }
	        },
	        'send-user-state-message': function sendUserStateMessage(data) {
	          logger.debug('[event: send-user-state-message]', data);
	        },
	        'unmark-participant': function unmarkParticipant(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: unmark-participant]', data);
	          }
	        },
	        'mark-participant-unknown': function markParticipantUnknown(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: mark-participant-unknown]', data);
	          }
	        },
	        'fetch-presences': function fetchPresences(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: fetch-presences]', data);
	          }
	        },
	        'filter-presences': function filterPresences(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: filter-presences]', data);
	          }
	        },
	        'update-presence': function updatePresence(data) {
	          logger.debug('[event: update-presence]', data);
	        },
	
	        //routing, etc.
	        'set-route': function setRoute(data) {
	          logger.debug('[event: set-route]', data);
	        },
	        'fetch-previous': function fetchPrevious(data) {
	          logger.debug('[event: fetch-previous]', data);
	        },
	        'requesting-ancient-history': function requestingAncientHistory(data) {
	          logger.debug('[event: requesting-ancient-history]', data);
	        },
	
	        //rooms, etc.
	        'close-room': function closeRoom(data) {
	          logger.debug('[event: close-room]', data);
	        },
	        'room-closed': function roomClosed(data) {
	          logger.debug('[event: room-closed]', data);
	        },
	        'open-room': function openRoom(data) {
	          logger.debug('[event: open-room]', data);
	        },
	        'room-deleted': function roomDeleted(data) {
	          logger.debug('[event: room-deleted]', data);
	        },
	        'DAL:handle-created-room': function DALHandleCreatedRoom(data) {
	          logger.debug('[event: DAL:handle-created-room]', data);
	        },
	        'API:update-room': function APIUpdateRoom(data) {
	          logger.debug('[event: API:update-room]', data);
	        },
	        'update-room-order': function updateRoomOrder(data) {
	          logger.debug('[event: update-room-order]', data);
	        },
	        'focus-video-window': function focusVideoWindow(data) {
	          logger.debug('[event: focus-video-window]', data);
	        },
	        'new-active-chat': function newActiveChat(data) {
	          logger.debug('[event: new-active-chat]', data);
	        },
	        'open-chat-by-mention-name': function openChatByMentionName(data) {
	          logger.debug('[event: open-chat-by-mention-name]', data);
	        },
	        'join-room': function joinRoom(data) {
	          logger.debug('[event: join-room]', data);
	        },
	        'DAL:handle-joined-rooms': function DALHandleJoinedRooms(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: DAL:handle-joined-rooms]', data);
	          }
	        },
	        'save-client-preferences': function saveClientPreferences(data) {
	          logger.debug('[event: save-client-preferences]', data);
	        },
	        'edit-topic': function editTopic() {
	          logger.debug('[event: edit-topic]');
	        },
	        'delete-room': function deleteRoom(data) {
	          logger.debug('[event: delete-room]', data);
	        },
	        'set-guest-access': function setGuestAccess(data) {
	          logger.debug('[event: set-guest-access]', data);
	        },
	        'navigate-rooms': function navigateRooms(data) {
	          logger.debug('[event: navigate-rooms]', data);
	        },
	        'add-link-from-message': function addLinkFromMessage(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: add-link-from-message]', data);
	          }
	        },
	        'add-file-from-message': function addFileFromMessage(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: add-file-from-message]', logger.sanitize(data));
	          }
	        },
	        'remove-room-participant': function removeRoomParticipant(data) {
	          logger.debug('[event: remove-room-participant]', data);
	        },
	        'guest-access-revoked': function guestAccessRevoked() {
	          logger.debug('[event: guest-access-revoked]');
	        },
	        'user-removed': function userRemoved(data) {
	          logger.debug('[event: user-removed]', data);
	        },
	        'add-room-visitor': function addRoomVisitor(data) {
	          logger.debug('[event: add-room-visitor]', data);
	        },
	        'room-presence-received': function roomPresenceReceived(data) {
	          if (logger.isVerbose()) {
	            logger.debug('[event: room-presence-received]', data);
	          }
	        },
	        'chat-fully-initialized': function chatFullyInitialized(data) {
	          logger.debug('[event: chat-fully-initialized]', data);
	        },
	        'archive-room': function archiveRoom(data) {
	          logger.debug('[event: archive-room]', data);
	        },
	        'unarchive-room': function unarchiveRoom(data) {
	          logger.debug('[event: unarchive-room]', data);
	        },
	        'room-archived': function roomArchived(data) {
	          logger.debug('[event: room-archived]', data);
	        },
	        'room-unarchived': function roomUnarchived(data) {
	          logger.debug('[event: room-unarchived]', data);
	        },
	
	        //dialogs, etc.
	        'show-flag': function showFlag(data) {
	          logger.debug('[event: show-flag]', data);
	        },
	        'show-modal-dialog': function showModalDialog(data) {
	          logger.debug('[event: show-modal-dialog]', data);
	        },
	        'files-fetched': function filesFetched(data) {
	          logger.debug('[event: files-fetched]', data);
	        },
	        'links-fetched': function linksFetched(data) {
	          logger.debug('[event: links-fetched]', data);
	        },
	        'hide-modal-dialog': function hideModalDialog() {
	          logger.debug('[event: hide-modal-dialog]');
	        },
	        'remove-flag': function removeFlag(data) {
	          logger.debug('[event: remove-flag]', data);
	        },
	        'show-integration-view': function showIntegrationView(data) {
	          logger.debug('[event: show-integration-view]', data);
	        },
	        'refresh-integrations': function refreshIntegrations(data) {
	          logger.debug('[event: refresh-integrations]', data);
	        },
	        'integration-update': function integrationUpdate(data) {
	          logger.debug('[event: integration-update]', data);
	        },
	
	        //search
	        'search-history': function searchHistory(data) {
	          logger.debug('[event: search-history]', data);
	        },
	        'set-search-text': function setSearchText(data) {
	          logger.debug('[event: set-search-text]', data);
	        },
	        'blur-search': function blurSearch() {
	          logger.debug('[event: blur-search]');
	        },
	
	        //video
	        'video-window-event': function videoWindowEvent(data) {
	          logger.debug('[event: video-window-event]', data);
	        },
	        'missed-call': function missedCall(data) {
	          logger.debug('[event: missed-call]', data);
	        },
	
	        //other
	        'enable-dark-feature': function enableDarkFeature(data) {
	          logger.debug('[event: enable-dark-feature]', data);
	        },
	        'dismiss-notification-banner': function dismissNotificationBanner() {
	          logger.debug('[event: dismiss-notification-banner]');
	        },
	        'dismiss-notification-banner-forever': function dismissNotificationBannerForever() {
	          logger.debug('[event: dismiss-notification-banner-forever]');
	        },
	        'request-notification-permission': function requestNotificationPermission() {
	          logger.debug('[event: request-notification-permission]');
	        },
	        'resend-message': function resendMessage(data) {
	          logger.debug('[event: resend-message]', data);
	        },
	        'groupchat-invite-accepted': function groupchatInviteAccepted(data) {
	          logger.debug('[event: groupchat-invite-accepted]', data);
	        },
	        'error-message-received': function errorMessageReceived(data) {
	          logger.debug('[event: error-message-received]', data);
	        },
	        'replacement-message-received': function replacementMessageReceived(data) {
	          logger.debug('[event: replacement-message-received]', data);
	        },
	        'handle-cached-room': function handleCachedRoom(data) {
	          logger.debug('[event: handle-cached-room]', data);
	        },
	        'groupchat-invite-received': function groupchatInviteReceived(data) {
	          logger.debug('[event: groupchat-invite-received]', data);
	        },
	        'private-chat-invite-received': function privateChatInviteReceived(data) {
	          logger.debug('[event: private-chat-invite-received]', data);
	        },
	        'guest-access-enabled': function guestAccessEnabled(data) {
	          logger.debug('[event: guest-access-enabled]', data);
	        },
	        'remove-chat-state-message': function removeChatStateMessage(data) {
	          logger.debug('[event: remove-chat-state-message]', data);
	        }
	      });
	    }
	  }]);
	  return EventLogger;
	}();
	
	module.exports = new EventLogger();

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(6);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(7), __esModule: true };

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(8);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ },
/* 8 */
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _dispatcher = __webpack_require__(58);
	
	var _dispatcher2 = _interopRequireDefault(_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AppDispatcher = function (_Dispatcher) {
	  (0, _inherits3.default)(AppDispatcher, _Dispatcher);
	
	  function AppDispatcher() {
	    (0, _classCallCheck3.default)(this, AppDispatcher);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AppDispatcher).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(AppDispatcher, [{
	    key: 'dispatch',
	    value: function dispatch(action) {
	      var _Logger$type, _get2;
	
	      var Logger = __webpack_require__(90);
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      (_Logger$type = Logger.type('app-dispatcher:' + action)).log.apply(_Logger$type, args);
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(AppDispatcher.prototype), 'dispatch', this)).call.apply(_get2, [this, action].concat(args));
	    }
	  }]);
	  return AppDispatcher;
	}(_dispatcher2.default);
	
	exports.default = new AppDispatcher();
	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(11), __esModule: true };

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(12);
	module.exports = __webpack_require__(18).Object.getPrototypeOf;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(13);
	
	__webpack_require__(15)('getPrototypeOf', function($getPrototypeOf){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(14);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(16)
	  , core    = __webpack_require__(18)
	  , fails   = __webpack_require__(21);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(17)
	  , core      = __webpack_require__(18)
	  , ctx       = __webpack_require__(19)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ },
/* 17 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 18 */
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(20);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(23);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Symbol = __webpack_require__(24)["default"];
	
	exports["default"] = function (obj) {
	  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
	};
	
	exports.__esModule = true;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(25), __esModule: true };

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(26);
	__webpack_require__(46);
	module.exports = __webpack_require__(18).Symbol;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $              = __webpack_require__(8)
	  , global         = __webpack_require__(17)
	  , has            = __webpack_require__(27)
	  , DESCRIPTORS    = __webpack_require__(28)
	  , $export        = __webpack_require__(16)
	  , redefine       = __webpack_require__(29)
	  , $fails         = __webpack_require__(21)
	  , shared         = __webpack_require__(32)
	  , setToStringTag = __webpack_require__(33)
	  , uid            = __webpack_require__(35)
	  , wks            = __webpack_require__(34)
	  , keyOf          = __webpack_require__(36)
	  , $names         = __webpack_require__(40)
	  , enumKeys       = __webpack_require__(41)
	  , isArray        = __webpack_require__(42)
	  , anObject       = __webpack_require__(43)
	  , toIObject      = __webpack_require__(37)
	  , createDesc     = __webpack_require__(31)
	  , getDesc        = $.getDesc
	  , setDesc        = $.setDesc
	  , _create        = $.create
	  , getNames       = $names.get
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , HIDDEN         = wks('_hidden')
	  , isEnum         = $.isEnum
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , useNative      = typeof $Symbol == 'function'
	  , ObjectProto    = Object.prototype;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(setDesc({}, 'a', {
	    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = getDesc(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  setDesc(it, key, D);
	  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	} : setDesc;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol.prototype);
	  sym._k = tag;
	  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};
	
	var isSymbol = function(it){
	  return typeof it == 'symbol';
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toIObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	  var args = [it]
	    , i    = 1
	    , $$   = arguments
	    , replacer, $replacer;
	  while($$.length > i)args.push($$[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var buggyJSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});
	
	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  redefine($Symbol.prototype, 'toString', function toString(){
	    return this._k;
	  });
	
	  isSymbol = function(it){
	    return it instanceof $Symbol;
	  };
	
	  $.create     = $create;
	  $.isEnum     = $propertyIsEnumerable;
	  $.getDesc    = $getOwnPropertyDescriptor;
	  $.setDesc    = $defineProperty;
	  $.setDescs   = $defineProperties;
	  $.getNames   = $names.get = $getOwnPropertyNames;
	  $.getSymbols = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(45)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}
	
	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	  'species,split,toPrimitive,toStringTag,unscopables'
	).split(','), function(it){
	  var sym = wks(it);
	  symbolStatics[it] = useNative ? sym : wrap(sym);
	});
	
	setter = true;
	
	$export($export.G + $export.W, {Symbol: $Symbol});
	
	$export($export.S, 'Symbol', symbolStatics);
	
	$export($export.S + $export.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
	
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 27 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(21)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(30);

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(8)
	  , createDesc = __webpack_require__(31);
	module.exports = __webpack_require__(28) ? function(object, key, value){
	  return $.setDesc(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(17)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(8).setDesc
	  , has = __webpack_require__(27)
	  , TAG = __webpack_require__(34)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var store  = __webpack_require__(32)('wks')
	  , uid    = __webpack_require__(35)
	  , Symbol = __webpack_require__(17).Symbol;
	module.exports = function(name){
	  return store[name] || (store[name] =
	    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(8)
	  , toIObject = __webpack_require__(37);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(38)
	  , defined = __webpack_require__(14);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(39);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(37)
	  , getNames  = __webpack_require__(8).getNames
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return getNames(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.get = function getOwnPropertyNames(it){
	  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
	  return getNames(toIObject(it));
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var $ = __webpack_require__(8);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getSymbols = $.getSymbols;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = $.isEnum
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
	  }
	  return keys;
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(39);
	module.exports = Array.isArray || function(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(44);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 46 */
/***/ function(module, exports) {



/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Object$getOwnPropertyDescriptor = __webpack_require__(48)["default"];
	
	exports["default"] = function get(_x, _x2, _x3) {
	  var _again = true;
	
	  _function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;
	    _again = false;
	    if (object === null) object = Function.prototype;
	
	    var desc = _Object$getOwnPropertyDescriptor(object, property);
	
	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);
	
	      if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;
	        _x2 = property;
	        _x3 = receiver;
	        _again = true;
	        desc = parent = undefined;
	        continue _function;
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;
	
	      if (getter === undefined) {
	        return undefined;
	      }
	
	      return getter.call(receiver);
	    }
	  }
	};
	
	exports.__esModule = true;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(49), __esModule: true };

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(8);
	__webpack_require__(50);
	module.exports = function getOwnPropertyDescriptor(it, key){
	  return $.getDesc(it, key);
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(37);
	
	__webpack_require__(15)('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Object$create = __webpack_require__(52)["default"];
	
	var _Object$setPrototypeOf = __webpack_require__(54)["default"];
	
	exports["default"] = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }
	
	  subClass.prototype = _Object$create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};
	
	exports.__esModule = true;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(53), __esModule: true };

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(8);
	module.exports = function create(P, D){
	  return $.create(P, D);
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(55), __esModule: true };

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(56);
	module.exports = __webpack_require__(18).Object.setPrototypeOf;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(16);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(57).set});

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var getDesc  = __webpack_require__(8).getDesc
	  , isObject = __webpack_require__(44)
	  , anObject = __webpack_require__(43);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(19)(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var EventEmitter = __webpack_require__(89).EventEmitter;
	
	var Dispatcher = function (_EventEmitter) {
	  (0, _inherits3.default)(Dispatcher, _EventEmitter);
	
	  function Dispatcher() {
	    (0, _classCallCheck3.default)(this, Dispatcher);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Dispatcher).call(this));
	
	    _this.setMaxListeners(20);
	    return _this;
	  }
	
	  (0, _createClass3.default)(Dispatcher, [{
	    key: "dispatch",
	    value: function dispatch(action) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      this.emit.apply(this, ["before:" + action].concat(args));
	      this.emit.apply(this, arguments);
	      this.emit.apply(this, ["after:" + action].concat(args));
	    }
	  }, {
	    key: "registerOnce",
	    value: function registerOnce(action, callback) {
	      var _this2 = this;
	
	      if (_.isArray(action)) {
	        var promises = action.map(function (evt) {
	          return new _promise2.default(function (resolve) {
	            _this2.once(evt, function () {
	              for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	                args[_key2] = arguments[_key2];
	              }
	
	              resolve({
	                action: evt,
	                data: args
	              });
	            });
	          });
	        });
	
	        return _promise2.default.all(promises).then(function (returns) {
	          var data = {};
	
	          _.forEach(returns, function (val) {
	            data[val.action] = val.data;
	          });
	
	          callback(data);
	        });
	      } else if (_.isString(action)) {
	        this.once(action, callback);
	      } else if (_.isObject(action)) {
	        _.forOwn(action, function (val, key) {
	          _this2.once(key, val);
	        });
	      }
	    }
	  }, {
	    key: "register",
	    value: function register(action, callback) {
	      var _this3 = this;
	
	      if (_.isString(action)) {
	        this.on(action, callback);
	      } else if (_.isObject(action)) {
	        _.forOwn(action, function (val, key) {
	          _this3.on(key, val);
	        });
	      }
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(action, callback) {
	      var _this4 = this;
	
	      if (_.isString(action)) {
	        this.removeListener(action, callback);
	      } else if (_.isObject(action)) {
	        _.forOwn(action, function (val, key) {
	          _this4.removeListener(key, val);
	        });
	      }
	    }
	  }]);
	  return Dispatcher;
	}(EventEmitter);
	
	module.exports = Dispatcher;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(60), __esModule: true };

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(46);
	__webpack_require__(61);
	__webpack_require__(67);
	__webpack_require__(71);
	module.exports = __webpack_require__(18).Promise;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(62)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(64)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(63)
	  , defined   = __webpack_require__(14);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 63 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(45)
	  , $export        = __webpack_require__(16)
	  , redefine       = __webpack_require__(29)
	  , hide           = __webpack_require__(30)
	  , has            = __webpack_require__(27)
	  , Iterators      = __webpack_require__(65)
	  , $iterCreate    = __webpack_require__(66)
	  , setToStringTag = __webpack_require__(33)
	  , getProto       = __webpack_require__(8).getProto
	  , ITERATOR       = __webpack_require__(34)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , methods, key;
	  // Fix native
	  if($native){
	    var IteratorPrototype = getProto($default.call(new Base));
	    // Set @@toStringTag to native iterators
	    setToStringTag(IteratorPrototype, TAG, true);
	    // FF fix
	    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    // fix Array#{values, @@iterator}.name in V8 / FF
	    if(DEF_VALUES && $native.name !== VALUES){
	      VALUES_BUG = true;
	      $default = function values(){ return $native.call(this); };
	    }
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES  ? $default : getMethod(VALUES),
	      keys:    IS_SET      ? $default : getMethod(KEYS),
	      entries: !DEF_VALUES ? $default : getMethod('entries')
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $              = __webpack_require__(8)
	  , descriptor     = __webpack_require__(31)
	  , setToStringTag = __webpack_require__(33)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(30)(IteratorPrototype, __webpack_require__(34)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(68);
	var Iterators = __webpack_require__(65);
	Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(69)
	  , step             = __webpack_require__(70)
	  , Iterators        = __webpack_require__(65)
	  , toIObject        = __webpack_require__(37);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(64)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(8)
	  , LIBRARY    = __webpack_require__(45)
	  , global     = __webpack_require__(17)
	  , ctx        = __webpack_require__(19)
	  , classof    = __webpack_require__(72)
	  , $export    = __webpack_require__(16)
	  , isObject   = __webpack_require__(44)
	  , anObject   = __webpack_require__(43)
	  , aFunction  = __webpack_require__(20)
	  , strictNew  = __webpack_require__(73)
	  , forOf      = __webpack_require__(74)
	  , setProto   = __webpack_require__(57).set
	  , same       = __webpack_require__(79)
	  , SPECIES    = __webpack_require__(34)('species')
	  , speciesConstructor = __webpack_require__(80)
	  , asap       = __webpack_require__(81)
	  , PROMISE    = 'Promise'
	  , process    = global.process
	  , isNode     = classof(process) == 'process'
	  , P          = global[PROMISE]
	  , Wrapper;
	
	var testResolve = function(sub){
	  var test = new P(function(){});
	  if(sub)test.constructor = Object;
	  return P.resolve(test) === test;
	};
	
	var USE_NATIVE = function(){
	  var works = false;
	  function P2(x){
	    var self = new P(x);
	    setProto(self, P2.prototype);
	    return self;
	  }
	  try {
	    works = P && P.resolve && testResolve();
	    setProto(P2, P);
	    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
	    // actual Firefox has broken subclass support, test that
	    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
	      works = false;
	    }
	    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
	    if(works && __webpack_require__(28)){
	      var thenableThenGotten = false;
	      P.resolve($.setDesc({}, 'then', {
	        get: function(){ thenableThenGotten = true; }
	      }));
	      works = thenableThenGotten;
	    }
	  } catch(e){ works = false; }
	  return works;
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // library wrapper special case
	  if(LIBRARY && a === P && b === Wrapper)return true;
	  return same(a, b);
	};
	var getConstructor = function(C){
	  var S = anObject(C)[SPECIES];
	  return S != undefined ? S : C;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var PromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve),
	  this.reject  = aFunction(reject)
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(record, isReject){
	  if(record.n)return;
	  record.n = true;
	  var chain = record.c;
	  asap(function(){
	    var value = record.v
	      , ok    = record.s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , result, then;
	      try {
	        if(handler){
	          if(!ok)record.h = true;
	          result = handler === true ? value : handler(value);
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    chain.length = 0;
	    record.n = false;
	    if(isReject)setTimeout(function(){
	      var promise = record.p
	        , handler, console;
	      if(isUnhandled(promise)){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      } record.a = undefined;
	    }, 1);
	  });
	};
	var isUnhandled = function(promise){
	  var record = promise._d
	    , chain  = record.a || record.c
	    , i      = 0
	    , reaction;
	  if(record.h)return false;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var $reject = function(value){
	  var record = this;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  record.v = value;
	  record.s = 2;
	  record.a = record.c.slice();
	  notify(record, true);
	};
	var $resolve = function(value){
	  var record = this
	    , then;
	  if(record.d)return;
	  record.d = true;
	  record = record.r || record; // unwrap
	  try {
	    if(record.p === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      asap(function(){
	        var wrapper = {r: record, d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      record.v = value;
	      record.s = 1;
	      notify(record, false);
	    }
	  } catch(e){
	    $reject.call({r: record, d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  P = function Promise(executor){
	    aFunction(executor);
	    var record = this._d = {
	      p: strictNew(this, P, PROMISE),         // <- promise
	      c: [],                                  // <- awaiting reactions
	      a: undefined,                           // <- checked in isUnhandled reactions
	      s: 0,                                   // <- state
	      d: false,                               // <- done
	      v: undefined,                           // <- value
	      h: false,                               // <- handled rejection
	      n: false                                // <- notify
	    };
	    try {
	      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
	    } catch(err){
	      $reject.call(record, err);
	    }
	  };
	  __webpack_require__(86)(P.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction = new PromiseCapability(speciesConstructor(this, P))
	        , promise  = reaction.promise
	        , record   = this._d;
	      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      record.c.push(reaction);
	      if(record.a)record.a.push(reaction);
	      if(record.s)notify(record, false);
	      return promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
	__webpack_require__(33)(P, PROMISE);
	__webpack_require__(87)(PROMISE);
	Wrapper = __webpack_require__(18)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = new PromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof P && sameConstructor(x.constructor, this))return x;
	    var capability = new PromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(88)(function(iter){
	  P.all(iter)['catch'](function(){});
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = getConstructor(this)
	      , capability = new PromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject
	      , values     = [];
	    var abrupt = perform(function(){
	      forOf(iterable, false, values.push, values);
	      var remaining = values.length
	        , results   = Array(remaining);
	      if(remaining)$.each.call(values, function(promise, index){
	        var alreadyCalled = false;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled = true;
	          results[index] = value;
	          --remaining || resolve(results);
	        }, reject);
	      });
	      else resolve(results);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = getConstructor(this)
	      , capability = new PromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(39)
	  , TAG = __webpack_require__(34)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(19)
	  , call        = __webpack_require__(75)
	  , isArrayIter = __webpack_require__(76)
	  , anObject    = __webpack_require__(43)
	  , toLength    = __webpack_require__(77)
	  , getIterFn   = __webpack_require__(78);
	module.exports = function(iterable, entries, fn, that){
	  var iterFn = getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(43);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(65)
	  , ITERATOR   = __webpack_require__(34)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(63)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(72)
	  , ITERATOR  = __webpack_require__(34)('iterator')
	  , Iterators = __webpack_require__(65);
	module.exports = __webpack_require__(18).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 79 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(43)
	  , aFunction = __webpack_require__(20)
	  , SPECIES   = __webpack_require__(34)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(17)
	  , macrotask = __webpack_require__(82).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(39)(process) == 'process'
	  , head, last, notify;
	
	var flush = function(){
	  var parent, domain, fn;
	  if(isNode && (parent = process.domain)){
	    process.domain = null;
	    parent.exit();
	  }
	  while(head){
	    domain = head.domain;
	    fn     = head.fn;
	    if(domain)domain.enter();
	    fn(); // <- currently we use it only for Promise - try / catch not required
	    if(domain)domain.exit();
	    head = head.next;
	  } last = undefined;
	  if(parent)parent.enter();
	};
	
	// Node.js
	if(isNode){
	  notify = function(){
	    process.nextTick(flush);
	  };
	// browsers with MutationObserver
	} else if(Observer){
	  var toggle = 1
	    , node   = document.createTextNode('');
	  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	  notify = function(){
	    node.data = toggle = -toggle;
	  };
	// environments with maybe non-completely correct, but existent Promise
	} else if(Promise && Promise.resolve){
	  notify = function(){
	    Promise.resolve().then(flush);
	  };
	// for other environments - macrotask based on:
	// - setImmediate
	// - MessageChannel
	// - window.postMessag
	// - onreadystatechange
	// - setTimeout
	} else {
	  notify = function(){
	    // strange IE + webpack dev server bug - use .call(global)
	    macrotask.call(global, flush);
	  };
	}
	
	module.exports = function asap(fn){
	  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
	  if(last)last.next = task;
	  if(!head){
	    head = task;
	    notify();
	  } last = task;
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(19)
	  , invoke             = __webpack_require__(83)
	  , html               = __webpack_require__(84)
	  , cel                = __webpack_require__(85)
	  , global             = __webpack_require__(17)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listner = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(39)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listner;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listner, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 83 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(17).document && document.documentElement;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(44)
	  , document = __webpack_require__(17).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(29);
	module.exports = function(target, src){
	  for(var key in src)redefine(target, key, src[key]);
	  return target;
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var core        = __webpack_require__(18)
	  , $           = __webpack_require__(8)
	  , DESCRIPTORS = __webpack_require__(28)
	  , SPECIES     = __webpack_require__(34)('species');
	
	module.exports = function(KEY){
	  var C = core[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(34)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ safe = true; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 89 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _logger_sanitizer = __webpack_require__(186);
	
	var _logger_sanitizer2 = _interopRequireDefault(_logger_sanitizer);
	
	var _constants = __webpack_require__(163);
	
	var Constants = _interopRequireWildcard(_constants);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* global Strophe */
	
	
	var STROPHE = '[Strophe]';
	var DEFAULT_REGEXP_STRING = '/^.*?$/';
	var OLD_LOGGER_TYPE = 'old-logger';
	
	/*
	 * NOTE: Do not use DAL.Cache for browser storage in the logger. We need the logger to be
	 * able to log from earliest init. Can't hold logging until after DAL.Cache is configured
	 */
	
	var Logger = function () {
	  function Logger() {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, Logger);
	
	
	    window.HC_LOG = window.HC_LOG || this.storage.getItem('logging');
	    window.HC_LOG_VERBOSE = window.HC_LOG_VERBOSE || !!this.storage.getItem('verbose-logging');
	    window.HC_LOG_CALL_STACK = window.HC_LOG_CALL_STACK || !!this.storage.getItem('logging-call-stack');
	    window.HC_LOG_FORCE_COLORS = window.HC_LOG_FORCE_COLORS || !!this.storage.getItem('logging-force-colors');
	    window.HC_LOG_FORCE_EXPANDED = window.HC_LOG_FORCE_EXPANDED || !!this.storage.getItem('logging-force-expanded');
	
	    this.verbose_mode_enabled = window.HC_LOG_VERBOSE;
	
	    // Implement logging for Strophe when in verbose mode
	    Strophe.log = function (level, message) {
	      if (_this.isVerbose() || _this.isNewLogger()) {
	        switch (level) {
	
	          case Strophe.LogLevel.INFO:
	            _this.info(STROPHE, message);
	            _this.type('strophe').withFilter().info(message);
	            break;
	
	          case Strophe.LogLevel.WARN:
	            _this.warn(STROPHE, message);
	            _this.type('strophe').withFilter().warn(message);
	            break;
	
	          case Strophe.LogLevel.ERROR:
	          case Strophe.LogLevel.FATAL:
	            _this.error(STROPHE, message);
	            _this.type('strophe').withFilter().error(message);
	            break;
	
	          default:
	            _this.debug(STROPHE, message);
	            _this.type('strophe').withFilter().debug(message);
	        }
	      }
	    };
	
	    this.verbose_mode_reminder_logged = false;
	
	    this.colors = ['maroon', 'olive', 'green', 'purple', 'teal', 'navy'];
	
	    this.levels = ['error', 'warn', 'info', 'debug', 'log'];
	
	    this.resetLogger();
	  }
	
	  (0, _createClass3.default)(Logger, [{
	    key: 'error',
	    value: function error() {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      args.unshift('error');
	      return this.doLog.apply(this, args);
	    }
	  }, {
	    key: 'warn',
	    value: function warn() {
	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	
	      args.unshift('warn');
	      return this.doLog.apply(this, args);
	    }
	  }, {
	    key: 'info',
	    value: function info() {
	      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	
	      args.unshift('info');
	      return this.doLog.apply(this, args);
	    }
	  }, {
	    key: 'debug',
	    value: function debug() {
	      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }
	
	      args.unshift('debug');
	      return this.doLog.apply(this, args);
	    }
	  }, {
	    key: 'log',
	    value: function log() {
	      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	        args[_key5] = arguments[_key5];
	      }
	
	      args.unshift('log');
	      return this.doLog.apply(this, args);
	    }
	  }, {
	    key: 'logXML',
	    value: function logXML(elem, type) {
	      try {
	        if (!this.shouldLogXML()) {
	          return;
	        }
	
	        // <body> is always the base element, but we don't want it polluting all the logs
	        // Iterate through the child nodes and log them individually (usually there should be only one)
	        for (var i = 0; i < elem.childNodes.length; i++) {
	          var xml = this.sanitizeXML(elem.childNodes[i]);
	          var xmlString = _utils2.default.xml.toString(xml);
	          var logString = '[XML ' + type + '] ' + xmlString;
	
	          if (logString.length > Constants.XMPP_LOG_MAX_CHARS) {
	            var truncatedChars = logString.length - Constants.XMPP_LOG_MAX_CHARS;
	            var truncatedString = logString.substring(0, Math.min(Constants.XMPP_LOG_MAX_CHARS, logString.length));
	            this.debug(truncatedString + '... [truncated ' + truncatedChars + ' chars]');
	          } else {
	            this.debug(logString);
	          }
	        }
	      } catch (e) {
	        if ('console' in window) {
	          console.error(e.message);
	        }
	        _spi2.default.onLogMessage('[ERROR] ' + e.message);
	      }
	    }
	  }, {
	    key: 'type',
	    value: function type(_type) {
	      this._log_type = _type;
	      return this;
	    }
	  }, {
	    key: 'desc',
	    value: function desc(description) {
	      this._log_description = description;
	      return this;
	    }
	  }, {
	    key: 'withCallStack',
	    value: function withCallStack() {
	      this._log_call_stack = true;
	      return this;
	    }
	  }, {
	    key: 'alwaysExpanded',
	    value: function alwaysExpanded() {
	      this._log_always_expanded = true;
	      return this;
	    }
	  }, {
	    key: 'withFilter',
	    value: function withFilter() {
	      this._log_with_filter = true;
	      return this;
	    }
	  }, {
	    key: 'isNewLogger',
	    value: function isNewLogger() {
	      return window.HC_LOG && Number(window.HC_LOG) !== 1 && ('' + window.HC_LOG).length;
	    }
	  }, {
	    key: 'doLog',
	    value: function doLog() {
	      var _this2 = this;
	
	      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	        args[_key6] = arguments[_key6];
	      }
	
	      var currentTime = +new Date();
	      var diff = currentTime - (this.prevTime || currentTime);
	      this.prevTime = currentTime;
	
	      this.updateVerboseMode(window.HC_LOG_VERBOSE);
	
	      try {
	        var level = args.shift(),
	            verboseArgs = _.map(_.filter(args, 'verbose'), 'verbose');
	
	        if (verboseArgs.length > 0) {
	          // if verbose objects found strip them out of the args list
	          args = _.reject(args, 'verbose');
	          if (this.isVerbose()) {
	            // restore objects without {verbose: object} container
	            verboseArgs.forEach(function (val) {
	              args.push(val);
	            });
	          } else {
	            // leave a message that the verbose object was removed
	            args.push("[verbose]");
	            if (!this.verbose_mode_reminder_logged) {
	              // leave friendly to inform user that verbose mode is off
	              this.verbose_mode_reminder_logged = true;
	              this.info('Enable Verbose Mode for complete logs - window.HC_LOG_VERBOSE');
	            }
	          }
	        }
	
	        if (!window.HC_LOG) {
	          this.storage.removeItem('logging');
	        }
	
	        if (!window.HC_LOG_CALL_STACK) {
	          this.storage.removeItem('logging-call-stack');
	        }
	
	        if (!window.HC_LOG_FORCE_COLORS) {
	          this.storage.removeItem('logging-force-colors');
	        }
	
	        if (!window.HC_LOG_FORCE_EXPANDED) {
	          this.storage.removeItem('logging-force-expanded');
	        }
	
	        if ('console' in window && window.HC_LOG) {
	
	          var matchFilter = void 0;
	
	          this.storage.setItem('logging', window.HC_LOG);
	
	          if (window.HC_LOG_CALL_STACK) {
	            this.storage.setItem('logging-call-stack', true);
	          }
	
	          if (window.HC_LOG_FORCE_COLORS) {
	            this.storage.setItem('logging-force-colors', true);
	          }
	
	          if (window.HC_LOG_FORCE_EXPANDED) {
	            this.storage.setItem('logging-force-expanded', true);
	          }
	
	          // Todo: remove me when all logs will use new logger system.
	          if (!this._log_type) {
	            this._log_type = OLD_LOGGER_TYPE;
	            this._log_description = 'Migrate me to new logger system or skip with HC_LOG="*,-*' + OLD_LOGGER_TYPE + '"';
	            this._log_call_stack = true;
	          }
	
	          if (this.isNewLogger() && this._log_type) {
	
	            // add additional prefix for important level types
	            if (!(level === 'log' || level === 'debug')) {
	              this._log_type = level + ':' + this._log_type;
	            }
	
	            if (this._log_types !== window.HC_LOG) {
	              this._log_types = window.HC_LOG;
	              var newFilters = ('' + window.HC_LOG).split(',').map(function (filter) {
	                return filter.trim();
	              });
	              var toRegExp = function toRegExp(filter) {
	                return new RegExp('^' + filter.replace(/\*/g, '.*?') + '$');
	              };
	              this._ignoreFilters = newFilters.filter(function (filter) {
	                return filter.indexOf('-') === 0;
	              }).map(function (filter) {
	                return filter.slice(1);
	              }).map(toRegExp);
	              this._filters = newFilters.filter(function (filter) {
	                return filter.indexOf('-') !== 0;
	              }).map(toRegExp);
	            }
	
	            var ignored = false;
	
	            this._ignoreFilters.forEach(function (filter) {
	              if (_this2._log_type.search(filter) !== -1) {
	                ignored = true;
	              }
	            });
	
	            if (!ignored) {
	              this._filters.forEach(function (filter) {
	                if (!_this2._log_with_filter || _this2._log_with_filter && filter.toString() !== DEFAULT_REGEXP_STRING ||
	                // Todo: remove me when all logs will use new logger system.
	                _this2._log_type === OLD_LOGGER_TYPE) {
	                  if (_this2._log_type.search(filter) !== -1) {
	                    matchFilter = true;
	                  }
	                }
	              });
	            }
	          }
	
	          if (matchFilter && this._log_type) {
	
	            args = args.map(function (arg) {
	              if (_.isFunction(arg)) {
	                return "[function call]";
	              } else if (_.isPlainObject(arg) || _.isArray(arg)) {
	                try {
	                  return JSON.parse((0, _stringify2.default)(arg));
	                } catch (e) {
	                  console.error(e);
	                }
	              }
	              return arg;
	            });
	
	            this.evenLog = !this.evenLog;
	            this.colorIndex = this.colorIndex || 0;
	
	            var groupArgs = [];
	
	            if (_utils2.default.browser.is.chrome() || window.HC_LOG_FORCE_COLORS) {
	              groupArgs.push('%c' + this._log_type + ' %c+' + diff + 'ms %c' + this._log_description, 'color: ' + (this.evenLog ? 'gray' : 'dimgray'), 'color: ' + this.colors[this.colorIndex], 'color: blue');
	            } else {
	              groupArgs.push(this._log_type + ' +' + diff + 'ms ' + this._log_description);
	            }
	
	            if (this.colorIndex >= this.colors.length - 1) {
	              this.colorIndex = 0;
	            } else {
	              this.colorIndex++;
	            }
	
	            var isSingleObjectArg = args.length === 1 && _.isObject(args[0]) && !_.isEmpty(args[0]) && _.values(args[0]).every(function (value) {
	              return !_.isObject(value);
	            });
	
	            var nonObjectArgs = args.every(function (value) {
	              return !_.isObject(value);
	            });
	
	            // Todo: remove first line when all logs will use new logger system.
	            var isCollapsed = this._log_type !== OLD_LOGGER_TYPE && !window.HC_LOG_FORCE_EXPANDED && !this._log_always_expanded && !isSingleObjectArg && !nonObjectArgs && (args.some(_.isObject) || args.every(_.isEmpty)) && (level === 'log' || level === 'debug');
	
	            var group = isCollapsed ? console.groupCollapsed : console.group;
	
	            group.apply(console, groupArgs);
	            console[level].apply(console, args);
	            if (window.HC_LOG_CALL_STACK || this._log_call_stack) {
	              if (console.trace) {
	                console.trace();
	              } else {
	                console.log(new Error().stack);
	              }
	            }
	            console.groupEnd();
	
	            // Todo: remove part of expression when all logs will use new logger system.
	          } else if (Number(window.HC_LOG) === 1 && (!this._log_type || this._log_type === OLD_LOGGER_TYPE)) {
	              console[level].apply(console, args);
	            }
	        }
	
	        if (this.shouldLogToFile() && (!this._log_type || this._log_type === OLD_LOGGER_TYPE)) {
	          var message = this.formatLogMessage(level, args);
	          _spi2.default.onLogMessage(message);
	        }
	      } catch (e) {
	        if ('console' in window) {
	          console.error(e.message);
	        }
	        _spi2.default.onLogMessage('[ERROR] ' + e.message);
	      }
	
	      this.resetLogger();
	    }
	  }, {
	    key: 'resetLogger',
	    value: function resetLogger() {
	      this._log_type = null;
	      this._log_description = "";
	      this._log_call_stack = false;
	      this._log_with_filter = false;
	      this._log_always_expanded = false;
	    }
	  }, {
	    key: 'formatLogMessage',
	    value: function formatLogMessage(level, args) {
	      var _this3 = this;
	
	      var curlevel = '[' + level.toUpperCase() + ']',
	          formattedArgs = [];
	
	      try {
	        args.forEach(function (el) {
	          el = _this3.sanitize(el);
	          if (_.isObject(el)) {
	            el = (0, _stringify2.default)(el);
	          }
	          formattedArgs.push(el);
	        });
	      } catch (e) {
	        return "Value cannot be logged.";
	      }
	      return curlevel + ' ' + formattedArgs.join(" ");
	    }
	  }, {
	    key: 'updateVerboseMode',
	    value: function updateVerboseMode(bool) {
	      bool = !!bool;
	      if (bool) {
	        this.storage.setItem('verbose-logging', true);
	      } else {
	        this.storage.removeItem('verbose-logging');
	      }
	      if (this.isVerbose() !== bool) {
	        this.verbose_mode_enabled = bool;
	      }
	    }
	  }, {
	    key: 'isVerbose',
	    value: function isVerbose() {
	      return this.verbose_mode_enabled;
	    }
	  }, {
	    key: 'shouldLogXML',
	    value: function shouldLogXML() {
	      return this.shouldLogToFile() || this.isVerbose();
	    }
	  }, {
	    key: 'shouldLogToFile',
	    value: function shouldLogToFile() {
	      return _preferences_store2.default.shouldLog() || _configuration_store2.default.shouldLogToFile();
	    }
	  }, {
	    key: 'sanitize',
	    value: function sanitize(val) {
	      return _logger_sanitizer2.default.sanitize(val);
	    }
	  }, {
	    key: 'sanitizeXML',
	    value: function sanitizeXML(el) {
	      return _logger_sanitizer2.default.sanitizeXML(el);
	    }
	  }, {
	    key: 'isNativeClient',
	    value: function isNativeClient() {
	      return _utils2.default.clientSubType.isNative(_configuration_store2.default.get("client_subtype"));
	    }
	  }, {
	    key: 'storage',
	    get: function get() {
	      if (!this.isNativeClient()) {
	        return window.sessionStorage;
	      }
	      return window.localStorage;
	    }
	  }]);
	  return Logger;
	}();
	
	module.exports = new Logger();

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(92), __esModule: true };

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(18);
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return (core.JSON && core.JSON.stringify || JSON.stringify).apply(JSON, arguments);
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _SpiBase = __webpack_require__(94);
	
	var _SpiBase2 = _interopRequireDefault(_SpiBase);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _video_window_model = __webpack_require__(171);
	
	var _video_window_model2 = _interopRequireDefault(_video_window_model);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function SpiWeb() {}
	
	SpiWeb.prototype = _SpiBase2.default.prototype;
	
	SpiWeb.prototype.onNotification = function (notification) {
	  this.notifier = this.notifier || __webpack_require__(180);
	  this.notifier.notify(notification);
	};
	
	SpiWeb.prototype.onTotalUnreadCountUpdate = function (count, hasMention) {
	  this.notifier = this.notifier || __webpack_require__(180);
	  this.notifier.updateTotalUnreadCount(count, hasMention);
	};
	
	SpiWeb.prototype.getNotificationPermission = function () {
	  if (typeof Notification !== 'undefined') {
	    return Notification.permission !== 'default';
	  }
	};
	
	SpiWeb.prototype.showPreferencesDialog = function () {
	  _dialog_actions2.default.showSettingDialog();
	};
	
	SpiWeb.prototype.onSignOut = function (hc, data) {
	  var location = _utils2.default.getWindowLocation(),
	      is_guest = data.is_guest && data.guest_key,
	      url = is_guest ? _utils2.default.urls.guestSignOut(data.guest_key) : _utils2.default.urls.signOut(),
	      timeout = is_guest ? 1000 : 0;
	
	  if (is_guest) {
	    hc.leaveRoom(data.jid, data.type);
	  }
	  hc.terminateChatSession(false);
	
	  setTimeout(function () {
	    location.href = url;
	  }, timeout);
	};
	
	SpiWeb.prototype.fetchPdfViewerResources = function (moduleName, baseUri) {
	  var resources = {
	    'pdf-viewer': baseUri + 'vendor/fileviewer-1.4.1/fileviewer-document.custom.min.js',
	    'pdf-viewer-css': baseUri + 'vendor/fileviewer-1.4.1/fileviewer-document.custom.min.css'
	  };
	
	  function loadResource(name) {
	    var el = void 0;
	
	    if (name === 'pdf-viewer') {
	      el = document.createElement('script');
	      el.async = true;
	      el.src = resources[name];
	    } else if (name === 'pdf-viewer-css') {
	      el = document.createElement('link');
	      el.type = 'text/css';
	      el.rel = 'stylesheet';
	      el.href = resources[name];
	    }
	
	    document['head'].appendChild(el);
	
	    return new _promise2.default(function (resolve, reject) {
	      el.onload = function () {
	        resolve(el);
	      };
	      el.onerror = function (err) {
	        reject(err);
	      };
	    });
	  }
	
	  return _promise2.default.all([loadResource(moduleName), loadResource(moduleName + '-css')]);
	};
	
	SpiWeb.prototype.onStropheAuthFailed = function (error) {
	  _app_dispatcher2.default.dispatch('signout');
	};
	
	SpiWeb.prototype.onStrophePolicyViolation = function (data) {
	  $(document).trigger("app-error", data);
	};
	
	SpiWeb.prototype.onReconnectionError = function (error) {
	  _app_dispatcher2.default.dispatch('signout');
	};
	
	SpiWeb.prototype.onLogInToAnotherTeam = function () {
	  return window.open('https://www.hipchat.com/sign_in', '_blank');
	};
	
	SpiWeb.prototype.openInternalWindow = function () {
	  var _window;
	
	  return (_window = window).open.apply(_window, arguments);
	};
	
	SpiWeb.prototype.openExternalWindow = function () {
	  var _window2;
	
	  return (_window2 = window).open.apply(_window2, arguments);
	};
	
	SpiWeb.prototype.downloadFile = function (url) {
	  return _file_helper2.default.downloadFileAtUrl(url);
	};
	
	SpiWeb.prototype.openExternalWindowWithPromise = function (promise) {
	  // Prepare a new window before setting the location. This is used as a work-around for popup-blockers.
	  var externalWindow = window.open('');
	
	  return promise.then(function (url) {
	    externalWindow.location = url;
	    return externalWindow;
	  }).catch(function () {
	    externalWindow.close();
	  });
	};
	
	/**
	 * Video Window
	 */
	
	SpiWeb.prototype.initializeVideoWindow = function () {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  return new _promise2.default(function (resolve, reject) {
	    try {
	      resolve(new (Function.prototype.bind.apply(_video_window_model2.default, [null].concat(args)))());
	    } catch (e) {
	      reject(e);
	    }
	  });
	};
	
	SpiWeb.prototype.prepareVideoWindow = function (name, props) {
	  try {
	    var preppedWindow = window.open('', name, props);
	    preppedWindow.document.write('\n      <body style="\n        font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        margin: 0;\n        padding: 0;\n        ">\n        <p>' + _video_call_strings2.default.connecting + '</p>\n      </body>');
	    return preppedWindow;
	  } catch (e) {
	    return false;
	  }
	};
	
	SpiWeb.prototype.hasActiveVideoSession = function () {
	  return new _promise2.default(function (resolve) {
	    resolve(false);
	  });
	};
	
	SpiWeb.prototype.handleVideoCallInvite = function (answerCall, declineCall, data) {
	  return false;
	};
	
	SpiWeb.prototype.dismissVideoCallInvite = function () {
	  return false;
	};
	
	SpiWeb.prototype.onChangeUserStatus = function (status) {
	  return false;
	};
	
	SpiWeb.prototype.onChangeActiveChat = function (isChat) {
	  return false;
	};
	
	module.exports = new SpiWeb();

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*global define*/
	
	/**
	 * A base implementation of the HipChat web client's SPI
	 * to be implemented by native/non-native consumers
	 *
	 * @module SPIBase
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  function SpiBase() {}
	
	  /**
	   * Called when web core requests begin timing out
	   *
	   * @method onHostRequestTimeout
	   */
	  SpiBase.prototype.onHostRequestTimeout = function () {
	    return false;
	  };
	
	  /**
	   * Called when we want to bring the app to the foreground due to some activity
	   * (e.g. dropping a file on the app)
	   *
	   * @method focusApp
	   */
	  SpiBase.prototype.focusApp = function () {
	    return false;
	  };
	
	  /**
	   * Fired when the preloader is dismissed and the application has fully loaded
	   * Is passed the completed application configuration, including preferences.
	   * See [ConfigurationModel]{@link class:ConfigurationModel}
	   *
	   * @method onAppStateReady
	   * @param {ConfigurationModel} config
	   */
	  SpiBase.prototype.onAppStateReady = function (config) {
	    return false;
	  };
	
	  /**
	   * Fired when an error is caught when trying to re-establish a session
	   * on reconnection
	   *
	   * @method onReconnectionError
	   * @param {string} error
	   */
	  SpiBase.prototype.onReconnectionError = function (error) {
	    return false;
	  };
	
	  /**
	   * Fired when Strophe returns a status of CONNFAIL or AUTHFAIL
	   * with a condition when the connection changes
	   *
	   * @method onStropheAuthFailed
	   * @param {string} error
	   */
	  SpiBase.prototype.onStropheAuthFailed = function (error) {
	    return false;
	  };
	
	  /**
	   * Fired when Strophe returns a status of CONNFAIL or AUTHFAIL
	   * without a condition when the connection changes
	   *
	   * @method onStropheConnectionFailed
	   * @param {string} error
	   */
	  SpiBase.prototype.onStropheConnectionFailed = function (error) {
	    return false;
	  };
	
	  /**
	   * Fired when Strophe hits the 10 concurrent client max and session limit is reached.
	   *
	   * @method onStrophePolicyViolation
	   * @param {object} data
	   * @param {string} data.reason
	   * @param {string} data.web_server
	   */
	  SpiBase.prototype.onStrophePolicyViolation = function (data) {
	    return false;
	  };
	
	  /**
	   * This method will be called to determine if the default
	   * notification permission banner should be displayed
	   *
	   * @method getNotificationPermission
	   * @static
	   */
	  SpiBase.prototype.getNotificationPermission = function () {
	    return false;
	  };
	
	  /**
	   * This method is called when the Desktop 4 release dialog is shown
	   *
	   * @method onDesktop4DialogShown
	   */
	  SpiBase.prototype.onDesktop4DialogShown = function () {
	    return false;
	  };
	
	  /**
	   * This method is called when the internal token is updated
	   * @param {string} token - the new internal token data
	   *
	   * @method onInternalTokenRefreshed
	   */
	  SpiBase.prototype.onInternalTokenRefreshed = function (token) {
	    return false;
	  };
	
	  /**
	   * This method is called when a user select login into another team
	   *
	   * @method onLoginToAnotherTeam
	   */
	  SpiBase.prototype.onLoginToAnotherTeam = function () {
	    return false;
	  };
	
	  /**
	   * This method is called when web client logs a message. Note: this must be turned on via passing the config
	   * property - logging_enabled: true
	   * @returns {*}
	   *
	   * @method onLogMessage
	   * @static
	   */
	  SpiBase.prototype.onLogMessage = function (data) {
	    return false;
	  };
	
	  /**
	   * This method will be called when a notification should be sent to the user
	   * @param {Object} notification notification data
	   * @param {string} notification.jid the jid this notification is associated with
	   * @param {number} notification.group_id the group_id for the notification
	   * @param {string} notification.group_name the group_name for the notification
	   * @param {string} notification.title the title text for this notification (room/sender name)
	   * @param {string} notification.body the notification body
	   * @param {string} notification.html_body the notification html_body
	   * @param {URL} notification.icon an icon to use for this notification
	   * @param {Object} notification.notification_types key/value pairs of notification types and their permission
	   * @returns {*}
	   *
	   * @method onNotification
	   * @static
	   */
	  SpiBase.prototype.onNotification = function (notification) {
	    return false;
	  };
	
	  /**
	   * This method is called when a user preference has been changed
	   * @returns {*}
	   *
	   * @method onPreferencesUpdated
	   * @static
	   */
	  SpiBase.prototype.onPreferencesUpdated = function (data) {
	    return false;
	  };
	
	  /**
	   * This method is called when a user changes the active chat. It
	   * passes an object with boolean properties to indicate what room
	   * actions are currently available to the user in the active chat
	   * based on room status, user permissions and enabled features.
	   *
	   * @param {object} data
	   * @param {boolean} data.room_notifications
	   * @param {boolean} data.integrations
	   * @param {boolean} data.create_new_room
	   * @param {boolean} data.invite_users
	   * @param {boolean} data.remove_users
	   * @param {boolean} data.enable_guest_access
	   * @param {boolean} data.disable_guest_access
	   * @param {boolean} data.archive_room
	   * @param {boolean} data.unarchive_room
	   * @param {boolean} data.change_topic
	   * @param {boolean} data.change_privacy
	   * @param {boolean} data.delete_room
	   * @param {boolean} data.rename_room
	   * @returns {boolean}
	   */
	  SpiBase.prototype.onRoomActionsChanged = function (data) {
	    return false;
	  };
	
	  /**
	   * This method is called when a user is signing out
	   * @param {object} hc - HipChat client instance
	   * @param {object} data - sign out data
	   *
	   * @method onSignOut
	   */
	  SpiBase.prototype.onSignOut = function (hc, data) {
	    return false;
	  };
	
	  /**
	   * This method will be called when a notification should be sent to the user
	   * @param {Integer} count the current unread message count
	   * @param {bool} hasMention if any of the unread messages include a user mention
	   * @returns {*}
	   *
	   * @method onTotalUnreadCountUpdate
	   * @static
	   */
	  SpiBase.prototype.onTotalUnreadCountUpdate = function (count, hasMention) {
	    return false;
	  };
	
	  /**
	   * This method is called when the web client explicitly wants to open a new window owned by HipChat.
	   * To be used by video in order to launch a window inside the native wrapper and not the browser.
	   * If you would like to open a new browser window see [openExternalWindow]{@link module:SPIBase.openExternalWindow} method.
	   * @param {string} url - the url to open
	   * @param {string} name - name of the new window
	   * @param {string} props - see default window.open browser API for props
	   * @returns {*}
	   *
	   * @method openInternalWindow
	   * @static
	   */
	  SpiBase.prototype.openInternalWindow = function (url, name, props) {
	    return false;
	  };
	
	  /**
	   * This method is called when the web client wants to open a window in the browser. Note, this
	   * method is a replacement for the default browser window.open API. In most SPI implementations
	   * it will simply wrap window.open.
	   * @param {string} url - the url to open
	   * @param {string} name - name of the new window
	   * @param {string} props - see default window.open browser API for props
	   * @returns {*}
	   *
	   * @method openExternalWindow
	   * @static
	   */
	  SpiBase.prototype.openExternalWindow = function (url, name, props) {
	    return false;
	  };
	
	  /**
	   * This method takes a promise and calls openExternalWindow once that promise is resolved. This
	   * can be used as a work-around for popup blockers.
	   *
	   * @param promise
	   */
	  SpiBase.prototype.openExternalWindowWithPromise = function (promise) {
	    return promise.then(function (url) {
	      return this.openExternalWindow(url);
	    }.bind(this));
	  };
	
	  /**
	   * This method is called when an external feedback collector is specified and
	   * the 'Provide Feedback' action is triggered by the user.
	   * @param {string} url - the feedback url to use
	   * @returns {*}
	   *
	   * @method showFeedbackCollector
	   * @static
	   */
	  SpiBase.prototype.showFeedbackCollector = function (url) {
	    return false;
	  };
	
	  /**
	   * This method is called when the web client is giving the user a file chooser interface
	   *
	   * @returns {*}
	   *
	   * @method showFileChooser
	   * @static
	   */
	  SpiBase.prototype.showFileChooser = function () {
	    return false;
	  };
	
	  /**
	   * This method is called when a user chooses to show app preference dialog (or window
	   * if the implementation enables it)
	   * @returns {*}
	   *
	   * @method showPreferencesDialog
	   * @static
	   */
	  SpiBase.prototype.showPreferencesDialog = function () {
	    if (window.HC && window.HC.api && window.HC.api.showPreferencesDialog) {
	      console.log("showPreferencesDialog - implementation not found - showing default preferences dialog");
	      return window.HC.api.showPreferencesDialog();
	    }
	    return false;
	  };
	
	  /**
	   * This method is called when the Proxy Settings button is clicked
	   *
	   * @method buttonClickedProxySettings
	   */
	  SpiBase.prototype.buttonClickedProxySettings = function () {
	    return false;
	  };
	
	  /**
	   * This method is called when an unrecoverable error is encountered
	   *
	   * @method onUnrecoverableError
	   * @param {string} type the error type encountered
	   */
	  SpiBase.prototype.onUnrecoverableError = function (type) {
	    return false;
	  };
	
	  /**
	   * This method is called by the service selector when the cloud login
	   * page is going to be shown. It is native only.
	   *
	   * @method onCloudLoginShow
	   */
	  SpiBase.prototype.onCloudLoginShow = function () {
	    return false;
	  };
	
	  /**
	   * This method is called by the service selector when the server login
	   * verification page is going to be shown. It is native only.
	   *
	   * @method onServerLoginShow
	   */
	  SpiBase.prototype.onServerLoginShow = function () {
	    return false;
	  };
	
	  /**
	   * This method is called by the service selector when a user will be
	   * sent to download the legacy client. It is native only.
	   *
	   * @method onLegacyDownloadLinkClicked
	   */
	  SpiBase.prototype.onLegacyDownloadLinkClicked = function () {
	    return false;
	  };
	
	  /**
	   * This method is called by the service selector when it is time to do
	   * the server oauth login flow. It is native only.
	   *
	   * @method onServerOauthLogin
	   */
	  SpiBase.prototype.onServerOauthLogin = function () {
	    return false;
	  };
	
	  /**
	   * This method is called by the service selector when it is time to get
	   * the default value for lastServerUrl. It is native only.
	   *
	   * @method getLastServerUrl
	   */
	  SpiBase.prototype.getLastServerUrl = function () {
	    return false;
	  };
	
	  /**
	   * This method is called when we're creating a video session, and returns a promise which
	   * resolves with a VideoWindow instance which looks like the following:
	   *
	   * {
	   *    focus: function() {},
	   *    close: function() {}
	   * }
	   *
	   * @method initializeVideoWindow
	   * @param {string} url - the url to point the external window to
	   * @param {string} name - the name of the external window
	   * @param {string} props - the properties of the external window, such as 'resizable=yes,width=400,height=300'
	   * @param {string} passedWindow - optional, a prepared window already opened
	   *
	   * @returns {Promise<VideoWindow>} - returns a promise which resolves with a VideoWindow instance
	   */
	  SpiBase.prototype.initializeVideoWindow = function (url, name, props, passedWindow) {
	    return new _promise2.default(function (resolve) {
	      resolve({
	        focus: function focus() {},
	        close: function close() {}
	      });
	    });
	  };
	
	  /**
	   * This method is called when we're preparing a video session, and returns
	   * false unless we can prepare video windows.
	   *
	   * This is used to initiate the pop up before the token call, to bypass
	   * popup blocking in browsers that occurs on an async popup.
	   *
	   * @method initializeVideoWindow
	   * @param {string} name - the name of the external window
	   * @param {string} props - the properties of the external window, such as 'resizable=yes,width=400,height=300'
	   *
	   * @returns {window} or {boolean}
	   */
	  SpiBase.prototype.prepareVideoWindow = function (name, props) {
	    return false;
	  };
	
	  /**
	   * Signals incoming video call invite
	   *
	   * @method handleVideoCallInvite
	   * @param {Function} answerCall - the callback for answering call
	   * @param {Function} declineCall - the callback for declining call
	   * @param {Object} data additional call information
	   * @property {string} data.id - the invite id
	   * @property {string} data.avatar - caller avatar url
	   * @property {string} data.name - caller name
	   */
	  SpiBase.prototype.handleVideoCallInvite = function (answerCall, declineCall, data) {
	    return false;
	  };
	
	  /**
	   * Signals video call invite end
	   *
	   * @method dismissVideoCallInvite
	   * @param {string} id - the invite id
	   */
	  SpiBase.prototype.dismissVideoCallInvite = function (id) {
	    return false;
	  };
	
	  /**
	   * @method hasActiveVideoSession
	   * @returns {Promise}
	   */
	  SpiBase.prototype.hasActiveVideoSession = function () {
	    return new _promise2.default(function (resolve) {
	      resolve(false);
	    });
	  };
	
	  /**
	   * This method is called when the user attempts to begin a call
	   */
	  SpiBase.prototype.callPlaced = function (jid, profile) {
	    return false;
	  };
	
	  /**
	   * This method is called when the user answers a call
	   */
	  SpiBase.prototype.callAnswered = function (jid, profile) {
	    return false;
	  };
	
	  /**
	   * This method is called when the user's call is declined
	   */
	  SpiBase.prototype.callDeclined = function (jid, profile) {
	    return false;
	  };
	
	  /**
	   * This method is called when the user's call is ended
	   */
	  SpiBase.prototype.callHungup = function (jid, profile) {
	    return false;
	  };
	
	  /**
	   * Used to signal native that the addlive credentials for this call are received
	   *
	   * @typedef {object} AddLiveCredentials
	   * @property {number} credentials.app_id
	   * @property {number} credentials.user_id
	   * @property {string} credentials.scope_id
	   * @property {string} credentials.salt
	   * @property {number} credentials.expires
	   * @property {string} credentials.signature
	   */
	  SpiBase.prototype.addLiveCredentialsReceived = function (credentials) {
	    return false;
	  };
	
	  /**
	   * This method is called by the file viewer when we want to download a file directly
	   *
	   * @method downloadFile
	   * @param {string} url - the download url
	   */
	  SpiBase.prototype.downloadFile = function (url) {
	    return false;
	  };
	
	  /**
	   * This method is called by the FileViewer to fetch assets
	   *
	   * @method fetchPdfViewerResources
	   * @param {string} moduleName
	   * @param {string} baseUri - base URI from AppStore
	   *
	   * @returns {Promise}
	   */
	  SpiBase.prototype.fetchPdfViewerResources = function (moduleName, baseUri) {
	    return new _promise2.default(function (resolve) {
	      resolve(true);
	    });
	  };
	
	  /**
	   * This method is called whenever the user's status changes
	   *
	   * @method onChangeUserStatus
	   * @param {string} status - ['chat', 'away', 'xa', 'dnd', 'unavailable']
	   */
	  SpiBase.prototype.onChangeUserStatus = function (status) {
	    return false;
	  };
	
	  /**
	   * This method is called whenever the active "chat" changes
	   *
	   * @method onChangeActiveChat
	   * @param {boolean} isChat - indicates whether the newly active chat is actually
	   *          a chat or is something else like the Lobby or Search results
	   */
	  SpiBase.prototype.onChangeActiveChat = function (isChat) {
	    return false;
	  };
	
	  return SpiBase;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_header_store = __webpack_require__(96);
	
	var _app_header_store2 = _interopRequireDefault(_app_header_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * DialogActions
	 *
	 * Exposed a window. Used for exposing actions to non react managed actions
	 * like mention clicks, etc.
	 */
	
	exports.default = {
	
	  closeDialog: function closeDialog() {
	    _app_dispatcher2.default.dispatch("hide-modal-dialog");
	  },
	
	  /*
	   showAddonDialog
	    Display an ADG dialog overlayed over the chat, with the content provided by an add-on.
	    @param {object} data - Object with properties addon_key, addon_url, addon_options & module_key.
	    addon_key: identifier as in the add-on's the descriptor
	    addon_url: url from with the dialog content will be retrieved via HTTP GET
	    addon_options: object representing UI toggles: {
	                       resize (boolean) - enable / disable the auto-resizer
	                       width / height - as pixels or % of the web client
	                       chrome (boolean) - if the dialog should have a header and footer
	                       header (text) - the text to be written into the dialog header
	                    }
	    module_key: identifier of the add-on module corresponding to the dialog, as in its descriptor
	   */
	  showAddonDialog: function showAddonDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "addon-dialog",
	      dialog_data: {
	        addon_key: data.addon_key,
	        module_key: data.module_key,
	        addon_url: data.addon_url,
	        addon_options: data.addon_options
	      }
	    });
	  },
	
	  showIntegrationDialog: function showIntegrationDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "integration-dialog",
	      dialog_data: data
	    });
	  },
	
	  showIntegrationsManagementDialog: function showIntegrationsManagementDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "integrations-management-dialog",
	      dialog_data: data
	    });
	  },
	
	  startBtnLoading: function startBtnLoading() {
	    _app_dispatcher2.default.dispatch("modal-dialog-btn-loading", {
	      loading: true
	    });
	  },
	
	  stopBtnLoading: function stopBtnLoading() {
	    _app_dispatcher2.default.dispatch("modal-dialog-btn-loading", {
	      loading: false
	    });
	  },
	
	  showSettingDialog: function showSettingDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "settings-dialog",
	      dialog_data: data
	    });
	  },
	
	  showInviteTeammatesDialog: function showInviteTeammatesDialog(data) {
	    var user_is_admin = _app_header_store2.default.get("user_is_admin"),
	        invite_url = _app_header_store2.default.get("invite_url");
	
	    if (user_is_admin || invite_url) {
	      _app_dispatcher2.default.dispatch("show-modal-dialog", {
	        dialog_type: "invite-teammates-dialog",
	        dialog_data: data || {}
	      });
	    }
	  },
	
	  showInviteUsersDialog: function showInviteUsersDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "invite-users-dialog",
	      dialog_data: data || false
	    });
	  },
	
	  showRemoveUsersDialog: function showRemoveUsersDialog() {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "remove-users-dialog",
	      dialog_data: false
	    });
	  },
	
	  showCreateRoomDialog: function showCreateRoomDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "create-room-dialog",
	      dialog_data: data || false
	    });
	  },
	
	  showRoomPrivacyDialog: function showRoomPrivacyDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "room-privacy-dialog",
	      dialog_data: data
	    });
	  },
	
	  showRenameRoomDialog: function showRenameRoomDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "rename-room-dialog",
	      dialog_data: data
	    });
	  },
	
	  showDeleteRoomDialog: function showDeleteRoomDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "delete-room-dialog",
	      dialog_data: data
	    });
	  },
	
	  showArchiveRoomDialog: function showArchiveRoomDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "archive-room-dialog",
	      dialog_data: data
	    });
	  },
	
	  showDisableGuestAccessDialog: function showDisableGuestAccessDialog() {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "disable-guest-dialog",
	      dialog_data: false
	    });
	  },
	
	  showRoomNotificationsDialog: function showRoomNotificationsDialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "room-notifications-dialog",
	      dialog_data: data
	    });
	  },
	
	  showKeyboardShortcutsDialog: function showKeyboardShortcutsDialog(shortcuts) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "keyboard-shortcuts-dialog",
	      dialog_data: {
	        shortcuts: shortcuts
	      }
	    });
	  },
	
	  showQuickSwitcherDialog: function showQuickSwitcherDialog() {
	    var hideHint = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "quick-switcher-dialog",
	      dialog_data: {
	        bgDismiss: true,
	        hideHint: hideHint === true
	      }
	    });
	  },
	
	  showReleaseNotesDialog: function showReleaseNotesDialog() {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "release-notes-dialog",
	      dialog_data: {
	        bgDismiss: true
	      }
	    });
	  },
	
	  showDesktop4Dialog: function showDesktop4Dialog(data) {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "desktop-4-dialog",
	      dialog_data: data
	    });
	  },
	
	  showEditMessageDialog: function showEditMessageDialog(data) {
	    if (!data) {
	      return;
	    }
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "edit-message-dialog",
	      dialog_data: {
	        bgDismiss: false,
	        message: data
	      }
	    });
	  },
	
	  showDeleteMessageDialog: function showDeleteMessageDialog(data) {
	    if (!data) {
	      return;
	    }
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "delete-message-dialog",
	      dialog_data: {
	        bgDismiss: false,
	        message: data
	      }
	    });
	  },
	
	  showNotEditableDialog: function showNotEditableDialog(data) {
	    if (!data) {
	      return;
	    }
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "not-editable-dialog",
	      dialog_data: {
	        action: data.action
	      }
	    });
	  },
	
	  showWelcomeDialog: function showWelcomeDialog() {
	    _app_dispatcher2.default.dispatch("show-modal-dialog", {
	      dialog_type: "welcome-dialog",
	      dialog_data: false
	    });
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _dal = __webpack_require__(144);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AppHeaderStore = function (_Store) {
	  (0, _inherits3.default)(AppHeaderStore, _Store);
	
	  function AppHeaderStore() {
	    (0, _classCallCheck3.default)(this, AppHeaderStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AppHeaderStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(AppHeaderStore, [{
	    key: "getDefaults",
	    value: function getDefaults() {
	      return {
	        ready: false,
	        active_chat: false,
	        search_text: '',
	        focus_search: false,
	        notification_supported: typeof Notification !== 'undefined',
	        notification_dismissed: null,
	        notification_dismissed_forever: null,
	        notification_preference: false,
	        notification_permission: false,
	        user_is_admin: false,
	        invite_url: false,
	        feature_flags: {},
	        web_server: _app_config2.default.default_web_server,
	        banner_shown: false,
	        client_subtype: false
	      };
	    }
	  }, {
	    key: "registerListeners",
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'DAL:cache-configured': function DALCacheConfigured() {
	          _promise2.default.all([_dal2.default.get(_dal2.default.Keys.NOTIF_BANNER_DISMISSAL_COUNT), _dal2.default.get(_dal2.default.Keys.NOTIF_BANNER_DISMISSED_FOREVER)]).then(function (cached) {
	            _this2.set({
	              notification_dismissed: cached[0],
	              notification_dismissed_forever: cached[1]
	            });
	          });
	        },
	        'app-state-ready': function appStateReady() {
	          _this2.set({
	            ready: true
	          });
	        },
	        'hc-init': function hcInit(data) {
	          _this2.handleConfig(data);
	        }
	      });
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(config) {
	          _this2.handleConfig(config);
	        },
	        'updated:client_subtype': function updatedClient_subtype(client_subtype) {
	          if (client_subtype) {
	            _this2.set({
	              client_subtype: client_subtype
	            });
	          }
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.set({
	            active_chat: jid
	          });
	        },
	        'updated:preferences': function updatedPreferences() {
	          _this2.set({
	            notification_preference: _preferences_store2.default.getShowToasters(),
	            should_animate_avatar: _preferences_store2.default.shouldAnimateAvatars()
	          });
	        },
	        'updated:web_server': function updatedWeb_server(web_server) {
	          _this2.set("web_server", web_server);
	        },
	        'search-history': function searchHistory(data) {
	          _this2.handleSearch(data);
	        },
	        'search-history-externally': function searchHistoryExternally(data) {
	          _this2.handleSearch(data);
	        },
	        'set-search-text': function setSearchText(data) {
	          _this2.set('search_text', data.text);
	        },
	        'request-notification-permission': function requestNotificationPermission() {
	          Notification.requestPermission();
	        },
	        'dismiss-notification-banner': function dismissNotificationBanner() {
	          _this2.getDismissalCount().then(function (val) {
	            var count = val ? val + 1 : 1;
	            _dal2.default.set(_dal2.default.Keys.NOTIF_BANNER_DISMISSAL_COUNT, count);
	          });
	        },
	        'dismiss-notification-banner-forever': function dismissNotificationBannerForever() {
	          _dal2.default.set(_dal2.default.Keys.NOTIF_BANNER_DISMISSED_FOREVER, true);
	        },
	        'focus-search': function focusSearch() {
	          _this2.set('focus_search', true);
	        },
	        'blur-search': function blurSearch() {
	          _this2.set('focus_search', false);
	        },
	        'notification-banner-status': function notificationBannerStatus(data) {
	          _this2.set('banner_shown', data.shown);
	        }
	      });
	    }
	  }, {
	    key: "handleConfig",
	    value: function handleConfig(config) {
	      this.set({
	        user_is_admin: _.get(config, "is_admin", false),
	        invite_url: _.get(config, "invite_url", false),
	        feature_flags: _.get(config, "feature_flags", {})
	      });
	    }
	  }, {
	    key: "handleSearch",
	    value: function handleSearch() {
	      this.set('search_text', '');
	    }
	  }, {
	    key: "getDismissalCount",
	    value: function getDismissalCount() {
	      return _dal2.default.get(_dal2.default.Keys.NOTIF_BANNER_DISMISSAL_COUNT);
	    }
	  }]);
	  return AppHeaderStore;
	}(_store2.default);
	
	exports.default = new AppHeaderStore();
	module.exports = exports['default'];

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _emitter = __webpack_require__(98);
	
	var _emitter2 = _interopRequireDefault(_emitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Store = function (_Emitter) {
	  (0, _inherits3.default)(Store, _Emitter);
	
	  function Store() {
	    (0, _classCallCheck3.default)(this, Store);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Store).call(this));
	
	    _this.data = _this.getDefaults();
	
	    _this.registerListeners();
	
	    _this._logger_name = _.kebabCase(_this.constructor.name);
	    return _this;
	  }
	
	  (0, _createClass3.default)(Store, [{
	    key: "has",
	    value: function has(key) {
	      return this.data.hasOwnProperty(key);
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      return this.data[key];
	    }
	  }, {
	    key: "getAll",
	    value: function getAll() {
	      return this.data;
	    }
	  }, {
	    key: "setIfNotEqual",
	    value: function setIfNotEqual(key, value) {
	      var data = key;
	
	      if (value !== undefined) {
	        data = {};
	        data[key] = value;
	      }
	
	      this.doSet(data, true);
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      var data = key;
	
	      if (value !== undefined) {
	        data = {};
	        data[key] = value;
	      }
	
	      this.doSet(data, false);
	    }
	  }, {
	    key: "doSet",
	    value: function doSet(data, doEqualityCheck) {
	      var _this2 = this;
	
	      var changeset = {};
	      var hasChange = false;
	
	      _.keys(data).forEach(function (key) {
	
	        var shouldSet = !doEqualityCheck || doEqualityCheck && !_.isEqual(data[key], _this2.data[key]);
	
	        if (shouldSet) {
	          hasChange = true;
	          var oldValue = _this2.get(key),
	              value = data[key];
	
	          _this2.data[key] = value;
	          changeset[key] = value;
	          _this2.emit("change:" + key, value, oldValue);
	
	          var Logger = __webpack_require__(90);
	          Logger.type(_this2._logger_name + ":data:" + key).withFilter().withCallStack().log({
	            new_value: value,
	            old_value: oldValue
	          });
	        }
	      });
	
	      if (!doEqualityCheck || doEqualityCheck && hasChange) {
	        this.emit("change", changeset);
	      }
	    }
	  }, {
	    key: "unset",
	    value: function unset(key) {
	      if (this.has(key)) {
	        var oldValue = this.get(key);
	        delete this.data[key];
	
	        this.emit("change:" + key, undefined, oldValue);
	      }
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _this3 = this;
	
	      var changeset = {};
	
	      _.keys(this.data).forEach(function (key) {
	        changeset[key] = _this3.get(key);
	        _this3.unset(key);
	      });
	
	      this.emit("change", changeset);
	    }
	
	    /**
	     * Registers listeners.
	     */
	
	  }, {
	    key: "registerListeners",
	    value: function registerListeners() {}
	
	    /**
	     * Returns the default value of the store
	     */
	
	  }, {
	    key: "getDefaults",
	    value: function getDefaults() {
	      return {};
	    }
	  }, {
	    key: "reset",
	    value: function reset() {
	      this.data = this.getDefaults();
	    }
	  }]);
	  return Store;
	}(_emitter2.default);
	
	module.exports = Store;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(47);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Utils = __webpack_require__(99),
	    EventEmitter = __webpack_require__(89).EventEmitter;
	
	var Emitter = function (_EventEmitter) {
	  (0, _inherits3.default)(Emitter, _EventEmitter);
	
	  function Emitter() {
	    (0, _classCallCheck3.default)(this, Emitter);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Emitter).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Emitter, [{
	    key: 'on',
	    value: function on(type, callback) {
	      var _this2 = this;
	
	      Utils.toArray(type).forEach(function (t) {
	        return (0, _get3.default)((0, _getPrototypeOf2.default)(Emitter.prototype), 'on', _this2).call(_this2, t, callback);
	      });
	    }
	  }, {
	    key: 'once',
	    value: function once(type, callback) {
	      var _this3 = this;
	
	      Utils.toArray(type).forEach(function (t) {
	        return (0, _get3.default)((0, _getPrototypeOf2.default)(Emitter.prototype), 'once', _this3).call(_this3, t, callback);
	      });
	    }
	  }, {
	    key: 'off',
	    value: function off(type, callback) {
	      var _this4 = this;
	
	      Utils.toArray(type).forEach(function (t) {
	        return (0, _get3.default)((0, _getPrototypeOf2.default)(Emitter.prototype), 'removeListener', _this4).call(_this4, t, callback);
	      });
	    }
	  }]);
	  return Emitter;
	}(EventEmitter);
	
	module.exports = Emitter;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _linkify = __webpack_require__(105);
	
	var _linkify2 = _interopRequireDefault(_linkify);
	
	var _emoticons = __webpack_require__(110);
	
	var _emoticons2 = _interopRequireDefault(_emoticons);
	
	var _file_utils = __webpack_require__(122);
	
	var _file_utils2 = _interopRequireDefault(_file_utils);
	
	var _jid_utils = __webpack_require__(109);
	
	var _jid_utils2 = _interopRequireDefault(_jid_utils);
	
	var _room_utils = __webpack_require__(125);
	
	var _room_utils2 = _interopRequireDefault(_room_utils);
	
	var _user_utils = __webpack_require__(126);
	
	var _user_utils2 = _interopRequireDefault(_user_utils);
	
	var _video_utils = __webpack_require__(132);
	
	var _video_utils2 = _interopRequireDefault(_video_utils);
	
	var _browser_utils = __webpack_require__(133);
	
	var _browser_utils2 = _interopRequireDefault(_browser_utils);
	
	var _versionInfo = __webpack_require__(141);
	
	var _versionInfo2 = _interopRequireDefault(_versionInfo);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _uri = __webpack_require__(142);
	
	var _uri2 = _interopRequireDefault(_uri);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var CONNECT_API_VERSION = _versionInfo2.default.connect_api_version;
	var randomBetween = function randomBetween(min, max) {
	  return Math.floor(Math.random() * (max - min + 1)) + min;
	};
	
	/**
	 * utils
	 * @module helpers/utils
	 */
	var utils = {
	
	  TRUNCATE_CHARS: 800,
	  TRUNCATE_LINES: 6,
	
	  emoticons: _emoticons2.default.init(),
	  file: _file_utils2.default,
	  jid: _jid_utils2.default,
	  room: _room_utils2.default,
	  user: _user_utils2.default,
	  browser: _browser_utils2.default,
	  video: _video_utils2.default,
	  platform: _browser_utils.platform,
	  clientSubType: _browser_utils.clientSubType,
	
	  roster_names: {}, // roster names keyed by mention name
	
	  now: function now() {
	    return new Date().getTime();
	  },
	
	
	  decorrelatedJitter: function decorrelatedJitter(cap, base, sleep, backoff_factor) {
	    return Math.min(cap, randomBetween(base, sleep * backoff_factor));
	  },
	
	  escapeRegEx: function escapeRegEx() {
	    var str = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	
	    return str.replace(/[-\\^$*+?.()|\[\]{}]/g, '\\$&');
	  },
	
	  getWindowLocation: function getWindowLocation() {
	    return window.location;
	  },
	
	  url: {
	    clearWebCookies: function clearWebCookies(webServer) {
	      if (_.isString(webServer)) {
	        return 'https://' + webServer + '/users/clear_cookies';
	      }
	    },
	    revokeOauth2Token: function revokeOauth2Token(apiHost, token) {
	      if (_.isString(apiHost) && token) {
	        return 'https://' + apiHost + '/v2/oauth/token/' + token;
	      }
	    },
	    featureFlagsAPI: function featureFlagsAPI(baseUrl) {
	      if (_.isString(baseUrl)) {
	        return baseUrl + '/api/features';
	      }
	    },
	    networkCheckAPI: function networkCheckAPI(apiHost) {
	      if (_.isString(apiHost)) {
	        return 'https://' + apiHost + '/v2/health-check';
	      }
	    }
	  },
	
	  /**
	   * merges two objects then removes properties with leading underscores
	   * if the same property without an underscore already exists
	   * @param {object} data
	   * @param {object} data
	   */
	  mergeAndSquash: function mergeAndSquash(obj1, obj2) {
	    var newObj = _.merge(obj1, obj2);
	    if ('jid' in newObj) {
	      newObj.key = newObj.jid.split('@')[0];
	    }
	    _.forEach(newObj, function (v, k) {
	      if (/^_/.test(k) && newObj.hasOwnProperty(k.substring(1))) {
	        delete newObj[k];
	      }
	    });
	    return newObj;
	  },
	
	  camelToSnake: function camelToSnake(str) {
	    return str.replace(/\W+/g, '_').replace(/([a-z\d])([A-Z])/g, '$1_$2').toLowerCase();
	  },
	
	  /**
	   * Coerce a boolean from an unknown type value
	   * @param {*} val
	   * @param {*} [defaultValue=false]
	   * @returns {boolean}
	   */
	  coerceBoolean: function coerceBoolean(val) {
	    var defaultValue = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    switch (val) {
	      case true:
	      case 'true':
	      case 'True':
	      case 1:
	      case '1':
	        return true;
	      case false:
	      case 'false':
	      case 'False':
	      case 0:
	      case '0':
	        return false;
	      default:
	        return defaultValue;
	    }
	  },
	
	
	  generateMID: function generateMID() {
	    var d = new Date().getTime();
	    var id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = (d + Math.random() * 16) % 16 | 0;
	      d = Math.floor(d / 16);
	      return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);
	    });
	    return id;
	  },
	
	  validateMID: function validateMID(mid) {
	    var re = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/i;
	    return re.test(mid);
	  },
	
	  getAttachToMid: function getAttachToMid(msg) {
	    return _.get(msg, 'attach-to.id');
	  },
	
	  isAttachedCardsCollapsed: function isAttachedCardsCollapsed(msg) {
	    var defaultVal = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    return _.get(msg, 'is_attached_cards_collapsed', defaultVal);
	  },
	  getRealMid: function getRealMid(mid) {
	    return mid.split('-link')[0];
	  },
	
	
	  /**
	   *
	   * @param {String|Number|undefined} time
	   * @param {Boolean} is24hr
	   * @returns {String} formatted time in user timezone
	   */
	  format_time: function format_time(time, is24hr) {
	    var format = is24hr ? "HH:mm" : "h:mm A";
	
	    if (!time) {
	      return this.getCurrentTime().format(format);
	    } else if (/^-?\d*\.?\d*$/.test(time)) {
	      time = _moment2.default.unix(time);
	    } else {
	      time = (0, _moment2.default)(time);
	    }
	
	    if (!this.getCurrentTime().isSame(time, 'day')) {
	      format = 'MMM-D ' + format;
	    }
	
	    return time.format(format);
	  },
	
	  /**
	   * Timestamps are in seconds with microsecond precision.
	   * Moment doesn't make this easy so working around it.
	   * @param {String} date - an ISO-8691 formatted date string. Example: '2015-10-15T21:28:13.122119+00:00'
	   * @returns {Number} timestamp formatted with microsecond precision. Example: 1445022940.211578
	   */
	  getTimestampFromIsoDate: function getTimestampFromIsoDate(date) {
	    var time = (0, _moment2.default)(date),
	        sec = date ? time.unix() : 0,
	        micro = date ? date.split('.')[1].split(/\+\d\d|Z/)[0] : 0;
	
	    return Number(sec + '.' + micro);
	  },
	
	  getCurrentTime: function getCurrentTime() {
	    return (0, _moment2.default)();
	  },
	
	  getDateDiff: function getDateDiff(first_date, second_date, unit) {
	    var date1 = (0, _moment2.default)(first_date),
	        date2 = (0, _moment2.default)(second_date);
	
	    return date2.diff(date1, unit);
	  },
	
	  format_time_for_history: function format_time_for_history(ts) {
	    var time = _moment2.default.utc(ts, 'X'),
	        iso = time.format('YYYY-MM-DDTHH:mm:ss'),
	        ms = time.format('SSSSSS');
	
	    return iso + 'Z ' + ms;
	  },
	
	  format_time_for_separator: function format_time_for_separator(time) {
	    return _moment2.default.unix(time).format("dddd MMMM D, YYYY");
	  },
	
	  getMoment: function getMoment(time) {
	    var m = time ? (0, _moment2.default)(time) : (0, _moment2.default)();
	    return parseInt(m.format('x'), 10) / 1000;
	  },
	
	  toArray: function toArray(obj) {
	    if (_.isArray(obj)) {
	      return obj;
	    }
	    return [obj];
	  },
	
	  escape: function escape(str) {
	    if (!str) {
	      return str;
	    }
	
	    str = str.replace(/&/g, '&amp;');
	    str = str.replace(/</g, '&lt;');
	    str = str.replace(/>/g, '&gt;');
	
	    return str;
	  },
	
	  get_roster_name: function get_roster_name(mention_name) {
	    var name = "";
	    if (!_.isEmpty(utils.roster_names)) {
	      var str = ' ' + (0, _keys2.default)(utils.roster_names).join(' ') + ' ';
	      var regexp = new RegExp('\\s' + mention_name + '\\s', 'i');
	      var match = regexp.exec(str);
	      if (match) {
	        name = utils.roster_names[match[0].trim()];
	      }
	    }
	    return name;
	  },
	
	  formatMessageBody: function formatMessageBody(message) {
	    //This gets extended by the message processor
	    return message;
	  },
	
	  replaceEmoteMessage: function replaceEmoteMessage(messageBody, senderName) {
	    return messageBody.replace(_app_config2.default.emote_regex, senderName + ' ');
	  },
	
	  escapeAndLinkify: function escapeAndLinkify(str, args) {
	    var _this = this;
	
	    if (!str) {
	      return str;
	    }
	
	    if (typeof str !== 'string') {
	      str = str.toString();
	    }
	    args = _.defaults(args || {}, {
	      name_tag_regex: null,
	      mention_regex: null,
	      escape_whitespace: false,
	      matches: null,
	      do_escape: true,
	      do_linkify: true,
	      do_emoticons: true,
	      do_word_breaks: true,
	      do_mentions: true,
	      do_hex_colors: true
	    });
	    var name_regex = _.result(args, "name_tag_regex");
	    var mention_regex = _.result(args, "mention_regex");
	    var guest_regex = _.result(args, "guest_regex");
	    var escape_whitespace = _.result(args, "escape_whitespace");
	    var matches = _.result(args, "matches");
	    var do_escape = _.result(args, "do_escape");
	    var do_linkify = _.result(args, "do_linkify");
	    var do_emoticons = _.result(args, "do_emoticons");
	    var do_word_breaks = _.result(args, "do_word_breaks");
	    var do_mentions = _.result(args, "do_mentions");
	    var do_hex_colors = _.result(args, "do_hex_colors");
	
	    var LINE_SEPARATOR = '\n';
	    var TOKEN_SEPARATOR = ' ';
	
	    str = str.split(LINE_SEPARATOR).map(function (line) {
	      return line.split(TOKEN_SEPARATOR).map(function (token) {
	        if (do_escape) {
	          token = _this.escape(token);
	        }
	
	        var linkified = false;
	        if (do_linkify) {
	          var token_matches = [];
	          token = _linkify2.default.linkify(token, token_matches, {
	            truncate_length: 100,
	            no_referrer: true,
	            add_wbrs: do_word_breaks
	          });
	          linkified = !_.isEmpty(token_matches);
	          // a nice little side-effect here with matches is that it acts as an accumulator
	          matches = _.union(matches, token_matches);
	        }
	
	        if (do_hex_colors) {
	          token = token.replace(/(?:^)(#[\da-fA-F]{6})\b/gm, "$1 <span class='hexPreview' style='background-color: $1'>&nbsp;</span>");
	        }
	
	        // Add check for emoticonification
	        if (!linkified && do_emoticons) {
	          token = _emoticons2.default.render(token);
	        }
	
	        if (!linkified && do_mentions) {
	          var name_matches = void 0,
	              mention_matches = void 0,
	              guest_matches = void 0;
	
	          if (name_regex) {
	            name_matches = token.match(name_regex);
	            if (name_matches && name_matches.length) {
	              var mentionKey = name_matches[0].substr(1);
	              var userName = _.escape(utils.get_roster_name(mentionKey)).replace('@', '&#64;');
	              var content = '<span class=\'hc-mention-user hc-mention-me\' aria-label=\'' + userName + '\'>@$1</span>';
	              token = token.replace(name_regex, content);
	            }
	          }
	          if (mention_regex) {
	            mention_matches = token.match(mention_regex);
	            if (mention_matches && mention_matches[0]) {
	              var _mentionKey = mention_matches[0].substr(1);
	              var _userName = _.escape(utils.get_roster_name(_mentionKey)).replace('@', '&#64;');
	              var _content = '<span class=\'hc-mention-user\'><a onClick=\'HC.Actions.AppActions.openChatByMentionName(this)\' aria-label=\'' + _userName + '\' data-mention-name=\'$1\'>@$1</a></span>';
	              token = token.replace(mention_regex, _content);
	            }
	          }
	          if (guest_regex) {
	            guest_matches = token.match(guest_regex);
	            if (guest_matches && guest_matches[0] && !name_matches && !mention_matches) {
	              var guestKey = guest_matches[0].substr(1);
	              var guestName = _.escape(utils.get_roster_name(guestKey)).replace('@', '&#64;');
	              var guest_content = '<span class=\'hc-mention-user\'><a title=\'' + guestName + '\' data-mention-name=\'$1\'>@$1</a></span>';
	              token = token.replace(guest_regex, guest_content);
	            }
	          }
	        }
	
	        return token;
	      }).join(TOKEN_SEPARATOR);
	    }).join(LINE_SEPARATOR);
	
	    // Add br's AFTER linkifying - doing it before could result in bad linkify
	    if (escape_whitespace) {
	      str = str.replace(/\r\n/g, '\n').replace(/[\r\n\u2028]/g, '<br />');
	    }
	
	    if (matches && matches.length === 0 && do_word_breaks && !/[<>]/.test(str)) {
	      // Break at commas first (for JSON)
	      str = str.replace(/(,)/g, '$1<wbr>');
	
	      // Also break if we have a string of 70 characters w/o spaces (and no wbrs)
	      str = str.replace(/([^<>\s&;]{70})/g, '$1<wbr>');
	    }
	
	    if (escape_whitespace) {
	      if (str.indexOf('  ') !== -1) {
	        str = str.replace(/ {2}/g, '&ensp;&ensp;');
	      }
	      if (str.indexOf('\t') !== -1) {
	        str = str.replace(/\t/g, '&ensp;&ensp;');
	      }
	    }
	
	    return str;
	  },
	
	  getNumberOfLines: function getNumberOfLines(messageBody) {
	    var matches = messageBody.match(/<br\s*\/?>/);
	    if (!matches || matches.length === 0) {
	      matches = messageBody.match(/[\n\r\u2028]+.+/g);
	    }
	    return matches ? matches.length + 1 : 1;
	  },
	
	  messageShouldBeTruncated: function messageShouldBeTruncated(messageBody) {
	    return utils.getNumberOfLines(messageBody) >= utils.TRUNCATE_LINES || messageBody.length >= utils.TRUNCATE_CHARS;
	  },
	
	  fetch: function fetch(val, dflt) {
	    return val || dflt;
	  },
	
	  formatNumber: function formatNumber(num) {
	    if (typeof num !== 'string' && num.toString) {
	      num = num.toString();
	    }
	    return num.replace(/\B(?=(\d{3})+(?!\d))/g, ",") || num;
	  },
	
	  formatMultilineBlock: function formatMultilineBlock(text) {
	    var matches = text.match(/\n.+/gm);
	    if (!matches) {
	      return text;
	    }
	
	    // Add one to numlines because the last line won't have a \n on it
	    var numLines = matches.length + 1;
	    if (numLines > 1) {
	      matches = text.match(/^( {2}|\t)/gm);
	      // remove leading whitespace common to all lines
	      while (matches && matches.length === numLines) {
	        text = text.replace(/^( {2}|\t)/gm, '');
	        matches = text.match(/^( {2}|\t)/gm);
	      }
	    }
	    return text;
	  },
	
	  isFormattedMessage: function isFormattedMessage(message) {
	    return message.format === 'monospace' || message.format === 'code' || message.format === 'quotation';
	  },
	
	
	  isHistoryMessage: function isHistoryMessage(message) {
	    return typeof message.delay !== 'undefined' && !message.id;
	  },
	
	  getSenderFromMeta: function getSenderFromMeta(type) {
	    var sender;
	
	    switch (type) {
	      case 'video':
	        sender = 'Video';
	        break;
	      case 'twitter_status':
	      case 'twitter_user':
	        sender = 'Twitter';
	        break;
	      case 'link':
	        sender = 'Link';
	        break;
	      default:
	        sender = 'HipChat';
	        break;
	    }
	
	    return sender;
	  },
	
	  getCaretPosition: function getCaretPosition(input) {
	    if ('selectionStart' in input) {
	      return input.selectionStart;
	    } else if (document.selection) {
	      // IE
	      input.focus();
	      var sel = document.selection.createRange();
	      var selLen = document.selection.createRange().text.length;
	      sel.moveStart('character', -input.value.length);
	      return sel.text.length - selLen;
	    }
	  },
	
	  getEndSelection: function getEndSelection(input) {
	    return input.selectionEnd;
	  },
	
	  setCaretPosition: function setCaretPosition(input, posn) {
	    try {
	      if (input.createTextRange) {
	        var range = input.createTextRange();
	        range.move('character', posn);
	        range.select();
	      } else {
	        if (!_.isUndefined(input.selectionStart)) {
	          input.focus();
	          input.setSelectionRange(posn, posn);
	          input.focus();
	        } else {
	          input.focus();
	        }
	      }
	    } catch (e) {/*ignored*/}
	  },
	
	  // Mimicks webkit's scrollIntoViewIfNeeded for other browsers
	  // https://gist.github.com/hsablonniere/2581101
	  scrollIntoViewIfNeeded: function scrollIntoViewIfNeeded(node, parent, centerIfNeeded) {
	    centerIfNeeded = arguments.length === 0 ? true : !!centerIfNeeded;
	
	    if (!node) {
	      return;
	    }
	
	    if ('scrollIntoViewIfNeeded' in node) {
	      node.scrollIntoViewIfNeeded(centerIfNeeded);
	      return;
	    }
	
	    var parentComputedStyle = window.getComputedStyle(parent, null),
	        parentBorderTopWidth = parseInt(parentComputedStyle.getPropertyValue('border-top-width'), 10) || 0,
	        parentBorderLeftWidth = parseInt(parentComputedStyle.getPropertyValue('border-left-width'), 10) || 0,
	        overTop = node.offsetTop - parent.offsetTop < parent.scrollTop,
	        overBottom = node.offsetTop - parent.offsetTop + node.clientHeight - parentBorderTopWidth > parent.scrollTop + parent.clientHeight,
	        overLeft = node.offsetLeft - parent.offsetLeft < parent.scrollLeft,
	        overRight = node.offsetLeft - parent.offsetLeft + node.clientWidth - parentBorderLeftWidth > parent.scrollLeft + parent.clientWidth,
	        alignWithTop = overTop && !overBottom;
	
	    if ((overTop || overBottom) && centerIfNeeded) {
	      parent.scrollTop = node.offsetTop - parent.offsetTop - parent.clientHeight / 2 - parentBorderTopWidth + node.clientHeight / 2;
	    }
	
	    if ((overLeft || overRight) && centerIfNeeded) {
	      parent.scrollLeft = node.offsetLeft - parent.offsetLeft - parent.clientWidth / 2 - parentBorderLeftWidth + node.clientWidth / 2;
	    }
	
	    if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {
	      node.scrollIntoView(alignWithTop);
	    }
	  },
	
	  createSafePredicate: function createSafePredicate(predicate, context) {
	    return function () {
	      try {
	        return predicate.apply(context, arguments);
	      } catch (e) {
	        return true;
	      }
	    };
	  },
	  appendQueryParameter: function appendQueryParameter(url, name, value) {
	    if (_.startsWith(url, 'data:')) {
	      return url;
	    }
	    var uri = _uri2.default.parse(url);
	    uri.setParameterValues(name, value);
	    return uri.toString();
	  },
	  setHashFragment: function setHashFragment(url, value) {
	    if (_.startsWith(url, 'data:')) {
	      return url;
	    }
	    var uri = _uri2.default.parse(url);
	    uri.setFragment(value);
	    return uri.toString();
	  },
	  addConnectApiVersionToUrl: function addConnectApiVersionToUrl(url) {
	    return this.appendQueryParameter(url, 'connect_client_api_version', CONNECT_API_VERSION);
	  },
	
	
	  strings: {
	    ellipsis: function ellipsis(content, max_length) {
	      var ellipsis = "...",
	          new_text;
	
	      if (_.isString(content)) {
	        content = content.trim();
	        if (content.length > max_length) {
	          new_text = content.substring(0, max_length - ellipsis.length);
	          new_text = new_text.trim();
	          new_text = new_text.concat(ellipsis);
	        } else {
	          new_text = content;
	        }
	      }
	      return new_text || "";
	    },
	
	    splitUnit: function splitUnit(unit) {
	      var match = unit.match("(^[0-9\.]+)(.*)$");
	      return match ? {
	        num: Number(match[1]),
	        unit: match[2]
	      } : null;
	    },
	
	    stripHiddenCharacters: function stripHiddenCharacters(str) {
	      if (typeof str !== 'string') {
	        return str;
	      }
	      return str.replace(/(?:[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, '');
	    }
	  },
	
	  roster: {
	    format_for_select2: function format_for_select2(participants, roster) {
	      var roster_jids = _.keys(roster),
	          invite_user_jids = _.difference(roster_jids, participants),
	          sorted_roster;
	
	      sorted_roster = _.sortBy(_.map(invite_user_jids, function (user_jid) {
	        return roster[user_jid];
	      }), function (person) {
	        return person.name;
	      });
	
	      return _.map(sorted_roster, function (person) {
	        return {
	          id: person.jid,
	          text: person.name
	        };
	      });
	    },
	    get_non_guest_users: function get_non_guest_users(users) {
	      return _.transform(users, function (acc, value, key) {
	        if (!value.is_guest) {
	          acc[key] = value;
	        }
	        return acc;
	      });
	    }
	  },
	
	  highlight_matches: function highlight_matches(text, matches) {
	    var escaped_text = _.escape(text);
	
	    if (_.isString(matches)) {
	      matches = _.escape(matches);
	      return escaped_text.replace(matches, '<strong>' + matches + '</strong>');
	    }
	
	    var idx = 0;
	
	    return _.reduce(matches, function (markup, match) {
	      match = _.escape(match);
	      var match_index = escaped_text.indexOf(match, idx),
	          text_between_matches = escaped_text.slice(idx, match_index);
	      idx = match_index + match.length;
	      return markup.concat(text_between_matches + '<strong>' + match + '</strong>');
	    }, '').concat(escaped_text.slice(idx));
	  },
	
	  promise: {
	
	    defer: function defer() {
	      var result = {};
	      result.promise = new _promise2.default(function (resolve, reject) {
	        result.resolve = resolve;
	        result.reject = reject;
	      });
	      return result;
	    }
	  },
	
	  alphaNumeric: function alphaNumeric(length) {
	    var alphanum = "abcdefghijklmnopqrstuvwxyz0123456789",
	        hash = '';
	    _.times(length, function () {
	      hash += alphanum.charAt(Math.floor(Math.random() * alphanum.length));
	    });
	    return hash;
	  },
	
	  timings: {
	    getPerfTiming: function getPerfTiming() {
	
	      var perfTimingKeys = [
	      //"navigationStart",
	      "unloadEventStart", "unloadEventEnd", "redirectStart", "redirectEnd", "fetchStart", "domainLookupStart", "domainLookupEnd", "connectStart", "connectEnd", "secureConnectionStart", "requestStart", "responseStart", "responseEnd", "domLoading", "domInteractive", "domContentLoadedEventStart", "domContentLoadedEventEnd", "domComplete", "loadEventStart", "loadEventEnd"];
	
	      if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart !== "undefined") {
	        var metrics = {};
	        perfTimingKeys.forEach(function (property) {
	          var value = window.performance.timing[property] - window.performance.timing['navigationStart'];
	          if (value > 0) {
	            metrics[property] = value;
	          }
	        });
	        return metrics;
	      }
	      return {};
	    },
	
	    now: function now() {
	      if (window.performance) {
	        return window.performance.now();
	      }
	      return Date.now();
	    }
	  },
	
	  keyCode: {
	    LeftArrow: 37,
	    UpArrow: 38,
	    RightArrow: 39,
	    DownArrow: 40,
	    Home: 36,
	    End: 35,
	    Enter: 13,
	    Esc: 27,
	    Tab: 9,
	    PageUp: 33,
	    PageDown: 34,
	    Delete: 46,
	    Backspace: 8,
	    Space: 32,
	    isSelected: function isSelected(evt) {
	      return evt.shiftKey && (evt.keyCode === this.LeftArrow || evt.keyCode === this.RightArrow);
	    },
	    isModified: function isModified(evt) {
	      return evt.shiftKey || evt.ctrlKey || evt.altKey || evt.metaKey;
	    }
	  },
	
	  /**
	   * Converts to valid html string
	   * @param {string} html Html string. For example: <a href='http://example.com'>which never ends!
	   * @returns {string} Valid html string For example: <a href="http://example.com">which never ends!</a>
	   */
	  getFixedHtml: function getFixedHtml(html) {
	    var el = document.createElement('div');
	    el.innerHTML = html;
	    return el.innerHTML;
	  },
	
	  urls: {
	    signOut: function signOut() {
	      return '/home?src=chat_exit';
	    },
	
	    guestSignOut: function guestSignOut(key) {
	      if (key) {
	        return '/g' + key + '?src=chat_exit';
	      }
	    }
	  },
	
	  request: {
	    getXHR: function getXHR() {
	      return new XMLHttpRequest();
	    },
	    simplePost: function simplePost(url) {
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	      var xhr = arguments.length <= 2 || arguments[2] === undefined ? this.getXHR() : arguments[2];
	
	      if (_.isString(url) && xhr) {
	        xhr.open("POST", url, true);
	        xhr.onreadystatechange = function () {
	          if (xhr.readyState === 4) {
	            cb(xhr.responseText);
	          }
	        };
	        xhr.send();
	      }
	    }
	  },
	
	  image: {
	    load: function load(src, loading_timeout) {
	
	      return new _promise2.default(function (resolve, reject) {
	
	        var img = new Image(),
	            timeout = null,
	            cleanup = function cleanup() {
	          if (timeout) {
	            clearTimeout(timeout);
	          }
	          img.onload = img.onerror = null;
	        };
	
	        img.onload = function () {
	          cleanup();
	          resolve(img);
	        };
	
	        img.onerror = function () {
	          cleanup();
	          reject();
	        };
	
	        timeout = setTimeout(function () {
	          cleanup();
	          reject();
	        }, loading_timeout);
	
	        img.src = src;
	      });
	    },
	
	
	    /**
	     * Promise wrapper for changing the source of image
	     * @param image
	     * @param src
	     * @param timeout
	     * @returns {Promise}
	     */
	    changeSrc: function changeSrc(image, src) {
	      var timeout = arguments.length <= 2 || arguments[2] === undefined ? 10000 : arguments[2];
	
	      return new _promise2.default(function (resolve, reject) {
	        var timeoutId = setTimeout(function () {
	          image.onload = image.onerror = null;
	          reject();
	        }, timeout);
	
	        image.onload = function () {
	          image._isLoaded = true;
	          clearTimeout(timeoutId);
	          resolve(image);
	        };
	        image.onerror = function () {
	          clearTimeout(timeoutId);
	          reject.apply(undefined, arguments);
	        };
	
	        image.src = src;
	      });
	    },
	
	
	    /**
	     * Resize image to appropriate sizes
	     * @param <Object> imageObjectURL - object URL for image
	     * @param <Integer> maxWidth
	     * @param <Integer> maxHeight
	     */
	    resizeImage: function resizeImage(imageObjectURL) {
	      var _this2 = this;
	
	      var maxWidth = arguments.length <= 1 || arguments[1] === undefined ? 150 : arguments[1];
	      var maxHeight = arguments.length <= 2 || arguments[2] === undefined ? 100 : arguments[2];
	
	      return new _promise2.default(function (resolve, reject) {
	        var canvas = document.createElement('canvas');
	        var ratio = void 0;
	
	        _this2.load(imageObjectURL, _app_config2.default.message_image_loading_timeout).then(function (img) {
	          var width = void 0;
	          var height = void 0;
	          ratio = img.naturalWidth / img.naturalHeight;
	
	          if (ratio >= 1 && img.naturalWidth > maxWidth) {
	            height = img.naturalHeight * (maxWidth / img.naturalWidth);
	            width = maxWidth;
	          } else if (img.naturalHeight > maxHeight) {
	            width = img.naturalWidth * (maxHeight / img.naturalHeight);
	            height = maxHeight;
	          } else {
	            width = img.naturalWidth;
	            height = img.naturalHeight;
	          }
	
	          canvas.width = width;
	          canvas.height = height;
	
	          var context = canvas.getContext('2d');
	          context.drawImage(img, 0, 0, width, height);
	
	          if (canvas.toBlob) {
	            canvas.toBlob(resolve);
	          } else if (canvas.msToBlob) {
	            var pngImageBlob = canvas.msToBlob();
	            resolve(pngImageBlob);
	          } else if (canvas.toDataURL && _this2._checkImageSize(img)) {
	            var dataURL = canvas.toDataURL();
	            resolve(utils.file.base64_to_blob(dataURL));
	          } else {
	            reject(new Error('Could not save processed image'));
	          }
	        });
	      });
	    },
	
	
	    /**
	     * Checks the size of image to convert it to base64
	     * @param {Image} img
	     * @returns {boolean}
	     * @private
	     */
	    _checkImageSize: function _checkImageSize(img) {
	      return img.naturalHeight <= _app_config2.default.max_image_size_for_base64 && img.naturalWidth <= _app_config2.default.max_image_size_for_base64;
	    }
	  },
	
	  features: {
	    reconcileFeatureFlags: function reconcileFeatureFlags(nativeFlags, featureFlags) {
	      var overrides = _.isObject(nativeFlags) ? nativeFlags : {},
	          flags = _.isObject(featureFlags) ? featureFlags : {};
	
	      return _.assign({}, flags, overrides);
	    },
	
	    btf_capabilities: function btf_capabilities(featureFlags) {
	      var is_128_or_higher = featureFlags.hasOwnProperty('xmpp_compression');
	      var is_137_or_higher = featureFlags.hasOwnProperty('web_client_reconnect_header');
	
	      // These are the other feature flag -> version number mappings that aren't used
	      //var is_125_or_higher = featureFlags.hasOwnProperty('gravatar');
	      //var is_131_or_higher = featureFlags.hasOwnProperty('web_client_per_room_notifications');
	      //var is_134_or_higher = featureFlags.hasOwnProperty('clinky');
	
	      var capabilities = {};
	      capabilities.nonce = is_128_or_higher;
	      capabilities.oauth = is_137_or_higher;
	      return capabilities;
	    }
	  },
	
	  dom: {
	    findParentMatching: function findParentMatching(element, selector) {
	      var until = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	      var currentElement = element;
	      var matchedParent = null;
	
	      while (currentElement) {
	        if (selector(currentElement)) {
	          matchedParent = currentElement;
	          break;
	        }
	
	        if (currentElement.parentElement === document.body || until && currentElement.parentElement === until) {
	          break;
	        }
	
	        currentElement = currentElement.parentElement;
	      }
	
	      return matchedParent;
	    },
	
	
	    matchers: {
	      tag: function tag(tagName) {
	        return function (e) {
	          return e.tagName === tagName.toUpperCase();
	        };
	      }
	    }
	  },
	
	  xml: {
	    toString: function toString(xml) {
	      return new XMLSerializer().serializeToString(xml);
	    }
	  },
	
	  mouseButton: {
	    left: 1,
	    middle: 2,
	    right: 3
	  }
	
	};
	
	exports.default = utils;
	module.exports = exports['default'];

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(101), __esModule: true };

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(102);
	module.exports = __webpack_require__(18).Object.keys;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(13);
	
	__webpack_require__(15)('keys', function($keys){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.12.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';
	
	    var hookCallback;
	
	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }
	
	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }
	
	    function isArray(input) {
	        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }
	
	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }
	
	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }
	
	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }
	
	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false
	        };
	    }
	
	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }
	
	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            m._isValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated;
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }
	
	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }
	
	        return m;
	    }
	
	    function isUndefined(input) {
	        return input === void 0;
	    }
	
	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = utils_hooks__hooks.momentProperties = [];
	
	    function copyConfig(to, from) {
	        var i, prop, val;
	
	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }
	
	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }
	
	        return to;
	    }
	
	    var updateInProgress = false;
	
	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }
	
	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }
	
	    function absFloor (number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }
	
	        return value;
	    }
	
	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
	                (typeof console !==  'undefined') && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }
	
	    function deprecate(msg, fn) {
	        var firstTime = true;
	
	        return extend(function () {
	            if (firstTime) {
	                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }
	
	    var deprecations = {};
	
	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }
	
	    utils_hooks__hooks.suppressDeprecationWarnings = false;
	
	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }
	
	    function isObject(input) {
	        return Object.prototype.toString.call(input) === '[object Object]';
	    }
	
	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (isFunction(prop)) {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }
	
	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig), prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        return res;
	    }
	
	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }
	
	    // internal storage for locale config files
	    var locales = {};
	    var globalLocale;
	
	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;
	
	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }
	
	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && (typeof module !== 'undefined') &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }
	
	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }
	
	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }
	
	        return globalLocale._abbr;
	    }
	
	    function defineLocale (name, config) {
	        if (config !== null) {
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple('defineLocaleOverride',
	                        'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale');
	                config = mergeConfigs(locales[name]._config, config);
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    config = mergeConfigs(locales[config.parentLocale]._config, config);
	                } else {
	                    // treat as if there is no base config
	                    deprecateSimple('parentLocaleUndefined',
	                            'specified parentLocale is not defined yet');
	                }
	            }
	            locales[name] = new Locale(config);
	
	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	
	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }
	
	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale;
	            if (locales[name] != null) {
	                config = mergeConfigs(locales[name]._config, config);
	            }
	            locale = new Locale(config);
	            locale.parentLocale = locales[name];
	            locales[name] = locale;
	
	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }
	
	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;
	
	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }
	
	        if (!key) {
	            return globalLocale;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }
	
	        return chooseLocale(key);
	    }
	
	    function locale_locales__listLocales() {
	        return Object.keys(locales);
	    }
	
	    var aliases = {};
	
	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }
	
	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;
	
	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }
	
	    function get_set__get (mom, unit) {
	        return mom.isValid() ?
	            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }
	
	    function get_set__set (mom, unit, value) {
	        if (mom.isValid()) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }
	
	    // MOMENTS
	
	    function getSet (units, value) {
	        var unit;
	        if (typeof units === 'object') {
	            for (unit in units) {
	                this.set(unit, units[unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }
	
	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }
	
	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	
	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	
	    var formatFunctions = {};
	
	    var formatTokenFunctions = {};
	
	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }
	
	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, locale) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
	
	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf
	
	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
	
	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	
	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
	
	
	    var regexes = {};
	
	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }
	
	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }
	
	        return regexes[token](config._strict, config._locale);
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }));
	    }
	
	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    var tokens = {};
	
	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }
	
	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }
	
	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }
	
	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8;
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    // FORMATTING
	
	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });
	
	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });
	
	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });
	
	    // ALIASES
	
	    addUnitAlias('month', 'M');
	
	    // PARSING
	
	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });
	
	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });
	
	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });
	
	    // LOCALES
	
	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m, format) {
	        return isArray(this._months) ? this._months[m.month()] :
	            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }
	
	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m, format) {
	        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }
	
	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;
	
	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }
	
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function setMonth (mom, value) {
	        var dayOfMonth;
	
	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }
	
	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (typeof value !== 'number') {
	                    return mom;
	                }
	            }
	        }
	
	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }
	
	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }
	
	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }
	
	    var defaultMonthsShortRegex = matchWord;
	    function monthsShortRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            return this._monthsShortStrictRegex && isStrict ?
	                this._monthsShortStrictRegex : this._monthsShortRegex;
	        }
	    }
	
	    var defaultMonthsRegex = matchWord;
	    function monthsRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            return this._monthsStrictRegex && isStrict ?
	                this._monthsStrictRegex : this._monthsRegex;
	        }
	    }
	
	    function computeMonthsParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }
	
	        var shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }
	
	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
	        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
	    }
	
	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;
	
	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }
	
	            getParsingFlags(m).overflow = overflow;
	        }
	
	        return m;
	    }
	
	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	
	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
	
	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	        ['YYYY-DDD', /\d{4}-\d{3}/],
	        ['YYYY-MM', /\d{4}-\d\d/, false],
	        ['YYYYYYMMDD', /[+-]\d{10}/],
	        ['YYYYMMDD', /\d{8}/],
	        // YYYYMM is NOT allowed by the standard
	        ['GGGG[W]WWE', /\d{4}W\d{3}/],
	        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	        ['YYYYDDD', /\d{7}/]
	    ];
	
	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	        ['HH:mm', /\d\d:\d\d/],
	        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	        ['HHmmss', /\d\d\d\d\d\d/],
	        ['HHmm', /\d\d\d\d/],
	        ['HH', /\d\d/]
	    ];
	
	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
	
	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime, dateFormat, timeFormat, tzFormat;
	
	        if (match) {
	            getParsingFlags(config).iso = true;
	
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }
	
	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);
	
	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }
	
	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );
	
	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	
	        //the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    // FORMATTING
	
	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? '' + y : '+' + y;
	    });
	
	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });
	
	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
	
	    // ALIASES
	
	    addUnitAlias('year', 'y');
	
	    // PARSING
	
	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);
	
	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });
	
	    // HELPERS
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    // HOOKS
	
	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };
	
	    // MOMENTS
	
	    var getSetYear = makeGetSet('FullYear', false);
	
	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }
	
	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
	
	        return -fwdlw + fwd - 1;
	    }
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear, resDayOfYear;
	
	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }
	
	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear
	        };
	    }
	
	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek, resYear;
	
	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }
	
	        return {
	            week: resWeek,
	            year: resYear
	        };
	    }
	
	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }
	
	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }
	
	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(utils_hooks__hooks.now());
	        if (config._useUTC) {
	            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }
	
	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }
	
	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }
	
	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }
	
	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
	
	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;
	
	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;
	
	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);
	
	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }
	
	    // constant that refers to the ISO standard
	    utils_hooks__hooks.ISO_8601 = function () {};
	
	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }
	
	        config._a = [];
	        getParsingFlags(config).empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            // console.log('token', token, 'parsedInput', parsedInput,
	            //         'regex', getParseRegexForToken(token, config));
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }
	
	        // clear _12h flag if hour is <= 12
	        if (getParsingFlags(config).bigHour === true &&
	                config._a[HOUR] <= 12 &&
	                config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	
	        configFromArray(config);
	        checkOverflow(config);
	    }
	
	
	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;
	
	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }
	
	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);
	
	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;
	
	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	
	            getParsingFlags(tempConfig).score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }
	
	        var i = normalizeObjectUnits(config._i);
	        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	            return obj && parseInt(obj, 10);
	        });
	
	        configFromArray(config);
	    }
	
	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }
	
	        return res;
	    }
	
	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;
	
	        config._locale = config._locale || locale_locales__getLocale(config._l);
	
	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }
	
	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else {
	            configFromInput(config);
	        }
	
	        if (!valid__isValid(config)) {
	            config._d = null;
	        }
	
	        return config;
	    }
	
	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date(utils_hooks__hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};
	
	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;
	
	        return createFromConfig(c);
	    }
	
	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }
	
	    var prototypeMin = deprecate(
	         'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	         function () {
	             var other = local__createLocal.apply(null, arguments);
	             if (this.isValid() && other.isValid()) {
	                 return other < this ? this : other;
	             } else {
	                 return valid__createInvalid();
	             }
	         }
	     );
	
	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other > this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );
	
	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }
	
	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isBefore', args);
	    }
	
	    function max () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isAfter', args);
	    }
	
	    var now = function () {
	        return Date.now ? Date.now() : +(new Date());
	    };
	
	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;
	
	        this._data = {};
	
	        this._locale = locale_locales__getLocale();
	
	        this._bubble();
	    }
	
	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }
	
	    // FORMATTING
	
	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }
	
	    offset('Z', ':');
	    offset('ZZ', '');
	
	    // PARSING
	
	    addRegexToken('Z',  matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });
	
	    // HELPERS
	
	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;
	
	    function offsetFromString(matcher, string) {
	        var matches = ((string || '').match(matcher) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? minutes : -minutes;
	    }
	
	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }
	
	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }
	
	    // HOOKS
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};
	
	    // MOMENTS
	
	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	            } else if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }
	
	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }
	
	            this.utcOffset(input, keepLocalTime);
	
	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }
	
	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }
	
	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;
	
	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }
	
	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            this.utcOffset(offsetFromString(matchOffset, this._i));
	        }
	        return this;
	    }
	
	    function hasAlignedHourOffset (input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? local__createLocal(input).utcOffset() : 0;
	
	        return (this.utcOffset() - input) % 60 === 0;
	    }
	
	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }
	
	    function isDaylightSavingTimeShifted () {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }
	
	        var c = {};
	
	        copyConfig(c, this);
	        c = prepareConfig(c);
	
	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }
	
	        return this._isDSTShifted;
	    }
	
	    function isLocal () {
	        return this.isValid() ? !this._isUTC : false;
	    }
	
	    function isUtcOffset () {
	        return this.isValid() ? this._isUTC : false;
	    }
	
	    function isUtc () {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }
	
	    // ASP.NET json date format regex
	    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
	
	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    // and further modified to allow for strings containing both week and day
	    var isoRegex = /^(-)?P(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)W)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?$/;
	
	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;
	
	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])        * sign,
	                h  : toInt(match[HOUR])        * sign,
	                m  : toInt(match[MINUTE])      * sign,
	                s  : toInt(match[SECOND])      * sign,
	                ms : toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                w : parseIso(match[4], sign),
	                d : parseIso(match[5], sign),
	                h : parseIso(match[6], sign),
	                m : parseIso(match[7], sign),
	                s : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
	
	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }
	
	        ret = new Duration(duration);
	
	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }
	
	        return ret;
	    }
	
	    create__createDuration.fn = Duration.prototype;
	
	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }
	
	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};
	
	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }
	
	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
	
	        return res;
	    }
	
	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return {milliseconds: 0, months: 0};
	        }
	
	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }
	
	        return res;
	    }
	
	    function absRound (number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }
	
	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }
	
	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }
	
	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);
	
	        if (!mom.isValid()) {
	            // No op
	            return;
	        }
	
	        updateOffset = updateOffset == null ? true : updateOffset;
	
	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }
	
	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');
	
	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            diff = this.diff(sod, 'days', true),
	            format = diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	
	        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);
	
	        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
	    }
	
	    function clone () {
	        return new Moment(this);
	    }
	
	    function isAfter (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return +this > +localInput;
	        } else {
	            return +localInput < +this.clone().startOf(units);
	        }
	    }
	
	    function isBefore (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return +this < +localInput;
	        } else {
	            return +this.clone().endOf(units) < +localInput;
	        }
	    }
	
	    function isBetween (from, to, units) {
	        return this.isAfter(from, units) && this.isBefore(to, units);
	    }
	
	    function isSame (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            return +this === +localInput;
	        } else {
	            inputMs = +localInput;
	            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	        }
	    }
	
	    function isSameOrAfter (input, units) {
	        return this.isSame(input, units) || this.isAfter(input,units);
	    }
	
	    function isSameOrBefore (input, units) {
	        return this.isSame(input, units) || this.isBefore(input,units);
	    }
	
	    function diff (input, units, asFloat) {
	        var that,
	            zoneDelta,
	            delta, output;
	
	        if (!this.isValid()) {
	            return NaN;
	        }
	
	        that = cloneWithOffset(input, this);
	
	        if (!that.isValid()) {
	            return NaN;
	        }
	
	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
	
	        units = normalizeUnits(units);
	
	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }
	
	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;
	
	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }
	
	        return -(wholeMonthDiff + adjust);
	    }
	
	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	
	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }
	
	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if (isFunction(Date.prototype.toISOString)) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }
	
	    function format (inputString) {
	        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
	        return this.localeData().postformat(output);
	    }
	
	    function from (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }
	
	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }
	
	    function to (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }
	
	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }
	
	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale (key) {
	        var newLocaleData;
	
	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }
	
	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );
	
	    function localeData () {
	        return this._locale;
	    }
	
	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	        }
	
	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }
	
	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }
	
	        return this;
	    }
	
	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }
	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }
	
	    function to_type__valueOf () {
	        return +this._d - ((this._offset || 0) * 60000);
	    }
	
	    function unix () {
	        return Math.floor(+this / 1000);
	    }
	
	    function toDate () {
	        return this._offset ? new Date(+this) : this._d;
	    }
	
	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }
	
	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }
	
	    function toJSON () {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }
	
	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }
	
	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }
	
	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }
	
	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict
	        };
	    }
	
	    // FORMATTING
	
	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });
	
	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });
	
	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }
	
	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
	
	    // ALIASES
	
	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');
	
	    // PARSING
	
	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);
	
	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });
	
	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	
	    // MOMENTS
	
	    function getSetWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input,
	                this.week(),
	                this.weekday(),
	                this.localeData()._week.dow,
	                this.localeData()._week.doy);
	    }
	
	    function getSetISOWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }
	
	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }
	
	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }
	
	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }
	
	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
	
	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }
	
	    // FORMATTING
	
	    addFormatToken('Q', 0, 'Qo', 'quarter');
	
	    // ALIASES
	
	    addUnitAlias('quarter', 'Q');
	
	    // PARSING
	
	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });
	
	    // MOMENTS
	
	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }
	
	    // FORMATTING
	
	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
	
	    // ALIASES
	
	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');
	
	    // PARSING
	
	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);
	
	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });
	
	    // HELPERS
	
	    // LOCALES
	
	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }
	
	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };
	
	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }
	
	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }
	
	    // MOMENTS
	
	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    // FORMATTING
	
	    addFormatToken('D', ['DD', 2], 'Do', 'date');
	
	    // ALIASES
	
	    addUnitAlias('date', 'D');
	
	    // PARSING
	
	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });
	
	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });
	
	    // MOMENTS
	
	    var getSetDayOfMonth = makeGetSet('Date', true);
	
	    // FORMATTING
	
	    addFormatToken('d', 0, 'do', 'day');
	
	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });
	
	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });
	
	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });
	
	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');
	
	    // ALIASES
	
	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');
	
	    // PARSING
	
	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   matchWord);
	    addRegexToken('ddd',  matchWord);
	    addRegexToken('dddd', matchWord);
	
	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });
	
	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });
	
	    // HELPERS
	
	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }
	
	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }
	
	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }
	
	        return null;
	    }
	
	    // LOCALES
	
	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m, format) {
	        return isArray(this._weekdays) ? this._weekdays[m.day()] :
	            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	    }
	
	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return this._weekdaysShort[m.day()];
	    }
	
	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return this._weekdaysMin[m.day()];
	    }
	
	    function localeWeekdaysParse (weekdayName, format, strict) {
	        var i, mom, regex;
	
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }
	
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	
	            mom = local__createLocal([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	            }
	            if (!this._weekdaysParse[i]) {
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function getSetDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }
	
	    function getSetLocaleDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }
	
	    function getSetISODayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.
	        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	    }
	
	    // FORMATTING
	
	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
	
	    // ALIASES
	
	    addUnitAlias('dayOfYear', 'DDD');
	
	    // PARSING
	
	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });
	
	    // HELPERS
	
	    // MOMENTS
	
	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }
	
	    // FORMATTING
	
	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }
	
	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	
	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });
	
	    addFormatToken('hmmss', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });
	
	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });
	
	    addFormatToken('Hmmss', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });
	
	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }
	
	    meridiem('a', true);
	    meridiem('A', false);
	
	    // ALIASES
	
	    addUnitAlias('hour', 'h');
	
	    // PARSING
	
	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }
	
	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	
	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);
	
	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });
	
	    // LOCALES
	
	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }
	
	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }
	
	
	    // MOMENTS
	
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);
	
	    // FORMATTING
	
	    addFormatToken('m', ['mm', 2], 0, 'minute');
	
	    // ALIASES
	
	    addUnitAlias('minute', 'm');
	
	    // PARSING
	
	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);
	
	    // MOMENTS
	
	    var getSetMinute = makeGetSet('Minutes', false);
	
	    // FORMATTING
	
	    addFormatToken('s', ['ss', 2], 0, 'second');
	
	    // ALIASES
	
	    addUnitAlias('second', 's');
	
	    // PARSING
	
	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);
	
	    // MOMENTS
	
	    var getSetSecond = makeGetSet('Seconds', false);
	
	    // FORMATTING
	
	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });
	
	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });
	
	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });
	
	
	    // ALIASES
	
	    addUnitAlias('millisecond', 'ms');
	
	    // PARSING
	
	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);
	
	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }
	
	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }
	
	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS
	
	    var getSetMillisecond = makeGetSet('Milliseconds', false);
	
	    // FORMATTING
	
	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');
	
	    // MOMENTS
	
	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }
	
	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }
	
	    var momentPrototype__proto = Moment.prototype;
	
	    momentPrototype__proto.add               = add_subtract__add;
	    momentPrototype__proto.calendar          = moment_calendar__calendar;
	    momentPrototype__proto.clone             = clone;
	    momentPrototype__proto.diff              = diff;
	    momentPrototype__proto.endOf             = endOf;
	    momentPrototype__proto.format            = format;
	    momentPrototype__proto.from              = from;
	    momentPrototype__proto.fromNow           = fromNow;
	    momentPrototype__proto.to                = to;
	    momentPrototype__proto.toNow             = toNow;
	    momentPrototype__proto.get               = getSet;
	    momentPrototype__proto.invalidAt         = invalidAt;
	    momentPrototype__proto.isAfter           = isAfter;
	    momentPrototype__proto.isBefore          = isBefore;
	    momentPrototype__proto.isBetween         = isBetween;
	    momentPrototype__proto.isSame            = isSame;
	    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
	    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
	    momentPrototype__proto.isValid           = moment_valid__isValid;
	    momentPrototype__proto.lang              = lang;
	    momentPrototype__proto.locale            = locale;
	    momentPrototype__proto.localeData        = localeData;
	    momentPrototype__proto.max               = prototypeMax;
	    momentPrototype__proto.min               = prototypeMin;
	    momentPrototype__proto.parsingFlags      = parsingFlags;
	    momentPrototype__proto.set               = getSet;
	    momentPrototype__proto.startOf           = startOf;
	    momentPrototype__proto.subtract          = add_subtract__subtract;
	    momentPrototype__proto.toArray           = toArray;
	    momentPrototype__proto.toObject          = toObject;
	    momentPrototype__proto.toDate            = toDate;
	    momentPrototype__proto.toISOString       = moment_format__toISOString;
	    momentPrototype__proto.toJSON            = toJSON;
	    momentPrototype__proto.toString          = toString;
	    momentPrototype__proto.unix              = unix;
	    momentPrototype__proto.valueOf           = to_type__valueOf;
	    momentPrototype__proto.creationData      = creationData;
	
	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;
	
	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
	
	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
	
	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;
	
	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
	
	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;
	
	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
	
	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
	
	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
	
	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
	
	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;
	
	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;
	
	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
	
	    var momentPrototype = momentPrototype__proto;
	
	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }
	
	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }
	
	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };
	
	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }
	
	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };
	
	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];
	
	        if (format || !formatUpper) {
	            return format;
	        }
	
	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });
	
	        return this._longDateFormat[key];
	    }
	
	    var defaultInvalidDate = 'Invalid date';
	
	    function invalidDate () {
	        return this._invalidDate;
	    }
	
	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;
	
	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }
	
	    function preParsePostFormat (string) {
	        return string;
	    }
	
	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };
	
	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (isFunction(output)) ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }
	
	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }
	
	    var prototype__proto = Locale.prototype;
	
	    prototype__proto._calendar       = defaultCalendar;
	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto._longDateFormat = defaultLongDateFormat;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto._invalidDate    = defaultInvalidDate;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto._ordinal        = defaultOrdinal;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto._ordinalParse   = defaultOrdinalParse;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto._relativeTime   = defaultRelativeTime;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;
	
	    // Month
	    prototype__proto.months            =        localeMonths;
	    prototype__proto._months           = defaultLocaleMonths;
	    prototype__proto.monthsShort       =        localeMonthsShort;
	    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
	    prototype__proto.monthsParse       =        localeMonthsParse;
	    prototype__proto._monthsRegex      = defaultMonthsRegex;
	    prototype__proto.monthsRegex       = monthsRegex;
	    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
	    prototype__proto.monthsShortRegex  = monthsShortRegex;
	
	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto._week = defaultLocaleWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
	
	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto._weekdays      = defaultLocaleWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;
	
	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
	    prototype__proto.meridiem = localeMeridiem;
	
	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }
	
	    function list (format, index, field, count, setter) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	
	        if (index != null) {
	            return lists__get(format, index, field, setter);
	        }
	
	        var i;
	        var out = [];
	        for (i = 0; i < count; i++) {
	            out[i] = lists__get(format, i, field, setter);
	        }
	        return out;
	    }
	
	    function lists__listMonths (format, index) {
	        return list(format, index, 'months', 12, 'month');
	    }
	
	    function lists__listMonthsShort (format, index) {
	        return list(format, index, 'monthsShort', 12, 'month');
	    }
	
	    function lists__listWeekdays (format, index) {
	        return list(format, index, 'weekdays', 7, 'day');
	    }
	
	    function lists__listWeekdaysShort (format, index) {
	        return list(format, index, 'weekdaysShort', 7, 'day');
	    }
	
	    function lists__listWeekdaysMin (format, index) {
	        return list(format, index, 'weekdaysMin', 7, 'day');
	    }
	
	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
	
	    var mathAbs = Math.abs;
	
	    function duration_abs__abs () {
	        var data           = this._data;
	
	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);
	
	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);
	
	        return this;
	    }
	
	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);
	
	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;
	
	        return duration._bubble();
	    }
	
	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }
	
	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }
	
	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }
	
	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;
	
	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }
	
	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;
	
	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;
	
	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;
	
	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;
	
	        days += absFloor(hours / 24);
	
	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));
	
	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;
	
	        data.days   = days;
	        data.months = months;
	        data.years  = years;
	
	        return this;
	    }
	
	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }
	
	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }
	
	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;
	
	        units = normalizeUnits(units);
	
	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }
	
	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }
	
	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }
	
	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');
	
	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }
	
	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }
	
	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');
	
	    function weeks () {
	        return absFloor(this.days() / 7);
	    }
	
	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));
	
	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes <= 1           && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   <= 1           && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    <= 1           && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  <= 1           && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   <= 1           && ['y']           || ['yy', years];
	
	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }
	
	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }
	
	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
	
	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }
	
	        return locale.postformat(output);
	    }
	
	    var iso_string__abs = Math.abs;
	
	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;
	
	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;
	
	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;
	
	
	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();
	
	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }
	
	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }
	
	    var duration_prototype__proto = Duration.prototype;
	
	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;
	
	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;
	
	    // Side effect imports
	
	    // FORMATTING
	
	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');
	
	    // PARSING
	
	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });
	
	    // Side effect imports
	
	
	    utils_hooks__hooks.version = '2.12.0';
	
	    setHookCallback(local__createLocal);
	
	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.now                   = now;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.updateLocale          = updateLocale;
	    utils_hooks__hooks.locales               = locale_locales__listLocales;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	    utils_hooks__hooks.prototype             = momentPrototype;
	
	    var _moment = utils_hooks__hooks;
	
	    return _moment;
	
	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(104)(module)))

/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regex_helpers = __webpack_require__(106);
	
	var _regex_helpers2 = _interopRequireDefault(_regex_helpers);
	
	var _link_utils = __webpack_require__(108);
	
	var _link_utils2 = _interopRequireDefault(_link_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MIN_URL_LENGTH = 4;
	var regExpStorage = {
	  simple_word: new RegExp(_regex_helpers2.default.simple_word, 'gi'),
	  url: new RegExp(_regex_helpers2.default.url, 'gi'),
	  email: new RegExp(_regex_helpers2.default.email, 'gi')
	};
	
	exports.default = {
	  /**
	   * Linkify a string, replacing text urls with <a href="url">url</a>
	   * Note: init must be called before this function can be used
	   *
	   * @param text - String to be linkified
	   * @param matched_links - Return param (pass by ref) - Array of links matched during linkification
	   * @param config - Hash of options for linkifier
	   *          add_wbrs (bool) - Add <wbr> tags to displayed text to allow wrapping?
	   *          truncate_length (int) - Truncate displayed links to this length
	   *          link_target (str) - Target attribute for links
	   *          link_titles (bool) - Add titles for links?
	   **/
	  linkify: function linkify(text, matched_links, config) {
	    regExpStorage.simple_word.lastIndex = 0;
	    if (text.length >= MIN_URL_LENGTH && !regExpStorage.simple_word.test(text)) {
	      text = this.match_and_replace(text, true, matched_links, config);
	    }
	    return text;
	  },
	
	  /**
	   * Internal helper function for linkification
	   **/
	  match_and_replace: function match_and_replace(input, add_http, matched_links, config) {
	    var start = 0;
	    var offset = 0;
	    var match_length = 0;
	    var end_tag_pos = 0;
	    var close_anchor_re = /<\/a>/i;
	
	    var url_re = regExpStorage.url;
	    url_re.lastIndex = 0;
	
	    // used in the while loop to check that the entire match is an email rather than an email inside of a larger url
	    var email_re = new RegExp('^' + _regex_helpers2.default.email + '$', 'gi');
	
	    // config
	    var add_wbrs = config.hasOwnProperty("add_wbrs") ? config.add_wbrs : null;
	    var truncate_length = config.hasOwnProperty("truncate_length") ? config.truncate_length : 100;
	    var link_target = config.hasOwnProperty("link_target") ? config.link_target : "_blank";
	    var link_titles = config.hasOwnProperty("link_titles") ? config.link_titles : null;
	    var no_referrer = config.hasOwnProperty("no_referrer") ? config.no_referrer : null;
	
	    var match = {};
	    var max_iter = 20;
	    var cur_iter = 0;
	    while (match = url_re.exec(input)) {
	      cur_iter++;
	      if (cur_iter > max_iter) {
	        break;
	      }
	
	      start = match.index; // start of match
	
	      // If we find an opening a tag, advance to its end and continue looking
	      var substr = input.substring(offset, start);
	      if (substr.search(/<a/i) >= 0) {
	        close_anchor_re.lastIndex = offset;
	        var close_anchor_pos = input.substring(offset, input.length).search(close_anchor_re);
	
	        // If we find an opening tag without a matching closing tag, just return the input we have
	        if (close_anchor_pos < 0) {
	          return input;
	        }
	
	        end_tag_pos = close_anchor_pos + offset;
	
	        // RegExp.lastIndex is used to tell the regexp where to start matching
	        url_re.lastIndex = end_tag_pos + 4;
	        offset = end_tag_pos + 4;
	
	        continue;
	      }
	
	      /* if the last character of the url match ends in a punctuation character
	       * and the match index is not at the beginning of the text input,
	       * we should remove the last character of the match
	       *  ex: (http://en.wikipedia.org/wiki/PC_Tools_(Central_Point_Software)) should not convert the last
	       *  parenthesis as part of the link
	       */
	      match[0] = _link_utils2.default.wrapped_url_fix(input, match[0]);
	
	      /* if the first character after the match is not url end punctuation
	       * we should break and not replace the match in the input text
	       *  ex: sys.tr would be linkified in "sys.trace" without this fix
	       */
	      if (!_link_utils2.default.url_should_be_replaced(input, match[0])) {
	        break;
	      }
	
	      // Do the actual replacement of text with anchor tag
	      match_length = match[0].length;
	      var address = input.substr(start, match_length);
	
	      // Since we escape before linkifying, we need to make sure that the matched link
	      // doesn't actually end with an escaped character (< or >)
	      // If it does, move the match backwards so as not to include the escaped character
	      var escaped_char_match_pos = address.search(/&(gt|lt)$/);
	      if (escaped_char_match_pos > 0 && input.length > start + match_length && input[start + match_length] === ';') {
	        var num_chars_matched = address.length - escaped_char_match_pos;
	        match_length -= num_chars_matched;
	        address = input.substr(start, match_length);
	      }
	      var actual = address;
	
	      var is_email = email_re.test(actual);
	
	      if (add_http && !match[2] && !is_email) {
	        actual = 'http://' + actual;
	      }
	
	      var replacement = '<a';
	
	      // link target?
	      if (link_target) {
	        replacement += ' target="' + link_target + '"';
	      }
	
	      if (no_referrer) {
	        replacement += ' rel="noopener noreferrer"';
	      }
	
	      replacement += ' href="';
	
	      if (is_email) {
	        replacement += 'mailto:';
	      }
	
	      actual = actual.replace(/"/g, '%22');
	      replacement += actual + '"';
	
	      // add title
	      if (link_titles) {
	        var title = is_email ? 'Email ' + actual : actual;
	        replacement += ' title="' + title + '"';
	      }
	
	      // Truncate displayed text if requested
	      if (truncate_length && address.length > truncate_length) {
	        address = address.substr(0, truncate_length) + '...';
	      }
	
	      // Add word break tags to allow wrapping where appropriate
	      if (add_wbrs) {
	        address = address.replace(new RegExp("([/=])", 'g'), "<wbr>$1");
	      }
	
	      replacement += '>' + address + '</a>';
	
	      // Record what was matched
	      if (matched_links) {
	        matched_links.push(actual);
	      }
	
	      // Do the replacement
	      input = input.slice(0, start) + replacement + input.slice(start + match_length, input.length);
	      url_re.lastIndex = start + replacement.length;
	      offset = start + replacement.length;
	    }
	
	    return input;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _tld_list = __webpack_require__(107);
	
	var _tld_list2 = _interopRequireDefault(_tld_list);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Create TLD list
	var tld_blacklist = ["py", "sh"]; // remove py and sh to avoid linking script filenames
	var tlds = _.pullAll(_tld_list2.default, tld_blacklist).join("|");
	
	var url_fragments = {
	  // url protocol blacklist taken from https://extranet.atlassian.com/display/SECURITY/URI+scheme+whitelisting
	  required_url_protocol: "((?:(?!javascript|file|vbscript|view-source|resource|about|chrome|livescript|mocha|data)[a-z][\\w\\-]+:)(?:/{1,3}))",
	  optional_url_protocol: "((?:(?!javascript|file|vbscript|view-source|resource|about|chrome|livescript|mocha|data)[a-z][\\w\\-]+:)?(?:/{1,3}))?",
	  optional_user_pass_auth: "(?:\\S+(?::\\S*)?@.+)?",
	  ip_address_exclusion:
	  // IP address exclusion
	  // private & local networks
	  "(?!(?:10|127)(?:\\.\\d{1,3}){3})" + "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" + "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})",
	  ip_dotted_notation:
	  // IP address dotted notation octets
	  // excludes loopback network 0.0.0.0
	  // excludes reserved space >= 224.0.0.0
	  // excludes network & broacast addresses
	  // (first & last IP address of each class)
	  "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))",
	  host_name: "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)",
	  domain_name: "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)?",
	  tld_identifier: "(?:\\.(?:" + tlds + "))\\.?(?:" + tlds + ")?",
	  tld_matcher: "(?:\\.(?:[a-zA-Z]{2,12}))\\.?",
	  port_number: "(?::\\d{2,5})?",
	  resource_path: "(?:(?:,\\-|,\\+|[/?#:'()])\\S*)?"
	};
	
	exports.default = {
	  simple_word: "^[a-zA-Z0-9]*$",
	  email: "[a-z0-9]+(?:[.\\-+][a-z0-9!#$%&'*+=?^_`{|}~\\-]+)*@(?:[a-z0-9](?:[a-z0-9\\-]*[a-z0-9])?[.])+[a-z0-9](?:[a-z0-9\\-]*[a-z0-9])?",
	  // Adapted from https://gist.github.com/dperini/729294 - MIT
	  url: "\\b" + "(?:" + "(" + url_fragments.required_url_protocol + url_fragments.optional_user_pass_auth + "(?:" + "[a-zA-Z\\u00a1-\\uffff0-9_\\-.()]+" + ")" + url_fragments.port_number + url_fragments.resource_path + ")|(" + url_fragments.optional_url_protocol + url_fragments.optional_user_pass_auth + "(?:" + "localhost" + "|" + url_fragments.ip_dotted_notation + "|" + url_fragments.host_name + url_fragments.domain_name + url_fragments.tld_identifier + ")" + url_fragments.port_number + url_fragments.resource_path + ")" + ")",
	  protocol: url_fragments.required_url_protocol,
	  url_end_punctuation: '[\\s`!?()\\[\\]:{};\'".,<>&]',
	  invite_user_url: '^\\s*http(s?):\/\/((\\w+)\.)?hipchat\\.com\/invite\/(\\d+)\/(\\w+)((\\?utm_campaign\\=company_room_link)?)\\s*$'
	};
	module.exports = exports['default'];

/***/ },
/* 107 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ["aero", "arpa", "asia", "biz", "cat", "com", "coop", "corp", "edu", "gov", "green", "info", "int", "io", "jobs", "local", "mil", "mobi", "museum", "name", "net", "org", "post", "pro", "rocks", "tel", "travel", "xxx", "ac", "ad", "ae", "af", "ag", "ai", "al", "am", "an", "ao", "aq", "ar", "as", "at", "au", "aw", "ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bm", "bn", "bo", "br", "bs", "bt", "bv", "bw", "by", "bz", "ca", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn", "co", "cr", "cs", "cu", "cv", "cx", "cy", "cz", "dd", "de", "dj", "dk", "dm", "do", "dz", "ec", "ee", "eg", "eh", "er", "es", "et", "eu", "fi", "fj", "fk", "fm", "fo", "fr", "ga", "gb", "gd", "ge", "gf", "gg", "gh", "gi", "gl", "gm", "gn", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn", "hr", "ht", "hu", "id", "ie", "il", "im", "in", "iq", "ir", "is", "it", "je", "jm", "jo", "jp", "ke", "kg", "kh", "ki", "km", "kn", "kp", "kr", "kw", "ky", "kz", "la", "lb", "lc", "li", "lk", "lr", "ls", "lt", "lu", "lv", "ly", "ma", "mc", "md", "me", "mg", "mh", "mk", "ml", "mm", "mn", "mo", "mp", "mq", "mr", "ms", "mt", "mu", "mv", "mw", "mx", "my", "mz", "na", "nc", "ne", "nf", "ng", "ni", "nl", "no", "np", "nr", "nu", "nz", "om", "pa", "pe", "pf", "pg", "ph", "pk", "pl", "pm", "pn", "pr", "ps", "pt", "pw", "py", "qa", "qc", "qs", "re", "ro", "rs", "ru", "rw", "sa", "sb", "sc", "sd", "se", "sg", "sh", "si", "sj", "ja", "sk", "sl", "sm", "sn", "so", "sr", "ss", "st", "su", "sv", "sx", "sy", "sz", "tc", "td", "tf", "tg", "th", "tj", "tk", "tl", "tm", "tn", "to", "tp", "tr", "tt", "tv", "tw", "tz", "ua", "ug", "uk", "us", "uy", "uz", "va", "vc", "ve", "vg", "vi", "vn", "vu", "wf", "ws", "ye", "yt", "yu", "za", "zm", "zw"];
	module.exports = exports['default'];

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _regex_helpers = __webpack_require__(106);
	
	var _regex_helpers2 = _interopRequireDefault(_regex_helpers);
	
	var _jid_utils = __webpack_require__(109);
	
	var _jid_utils2 = _interopRequireDefault(_jid_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  url_regex: new RegExp(_regex_helpers2.default.url, "i"),
	  urls_regex: new RegExp(_regex_helpers2.default.url, "gi"),
	  url_end_punct_regex: new RegExp(_regex_helpers2.default.url_end_punctuation),
	  paired_punctuation: {
	    "}": "{",
	    ")": "(",
	    ">": "<"
	  },
	
	  /**
	   * Remove the query string from a url
	   *
	   * @method remove_query_string
	   * @param {String} url
	   * @returns {String} url without query string
	   */
	  remove_query_string: function remove_query_string(url) {
	    return url.split(/[?#]/)[0];
	  },
	
	  /**
	   * Creates a link object
	   *
	   * @method create_link_object
	   * @param {String} jid
	   * @param {String} ts
	   * @param {String} url
	   * @param {String} sender_name
	   * @returns {Object} a link object
	   */
	  create_link_object: function create_link_object(jid, ts, url, sender_name) {
	    var protocol_re = new RegExp(_regex_helpers2.default.protocol, 'i');
	    if (!protocol_re.test(url)) {
	      url = 'http://' + url;
	    }
	    return {
	      date: _moment2.default.utc(ts * 1000).toDate(),
	      group_id: _jid_utils2.default.group_id(jid),
	      id: _.uniqueId(),
	      user_name: sender_name,
	      url: url,
	      display_url: url.replace(/.*?:\/\//g, "")
	    };
	  },
	
	  /**
	   * Gets the urls from a string
	   *
	   * @method get_urls_from_string
	   * @param {String} input
	   * @returns {Array} array of urls found in the input
	   */
	  get_urls_from_string: function get_urls_from_string(input) {
	    return input.match(this.urls_regex);
	  },
	
	  /**
	   * Determines if the string contains a url
	   *
	   * @method contains_url
	   * @param {String} input
	   * @returns {Boolean}
	   */
	  contains_url: function contains_url(input) {
	    return this.url_regex.test(input);
	  },
	
	  /**
	   * Removes the resolution from a url (@2x.jpg, etc...)
	   *
	   * @method remove_resolution
	   * @param {String} url
	   * @returns {String} url without the resolution
	   */
	  remove_resolution: function remove_resolution(url) {
	    return url.replace(/@\d+x/i, "");
	  },
	
	
	  /**
	   * If the last character of the url match ends in a punctuation character
	   * and the match index is not at the beginning of the text input,
	   * we should remove the last character of the match
	   *  ex: (http://en.wikipedia.org/wiki/PC_Tools_(Central_Point_Software)) should not convert the last
	   *  parenthesis as part of the link
	   *
	   * @method wrapped_url_fix
	   * @param {String} input
	   * @param {String} match
	   * @returns {String} url
	   */
	  wrapped_url_fix: function wrapped_url_fix(input, match) {
	    var match_index = input.indexOf(match);
	    var last_char_of_match = input.charAt(match_index + (match.length - 1));
	    var is_matched = this.url_end_punct_regex.test(last_char_of_match);
	
	    if (is_matched && this._should_slice(input, match)) {
	      return this.wrapped_url_fix(input, match.slice(0, -1));
	    }
	
	    return match;
	  },
	
	
	  /**
	   * Checks if the number of character is balanced
	   * (e.g. "http://wikipedia.org/Curry(Computer Science)" returns true
	   * but "http://wikipedia.org/Curry(Computer Science))" returns false)
	   *
	   * @param {String} Input
	   * @param {String} Last matching character
	   * @returns {Boolean}
	   */
	  _num_of_chars_balanced: function _num_of_chars_balanced(match, close_punctuation) {
	    var open_punctuation = this.paired_punctuation[close_punctuation];
	
	    // Use square brackets for non-escaping
	    var rule_for_open = new RegExp('[' + open_punctuation + ']', 'g');
	    var rule_for_close = new RegExp('[' + close_punctuation + ']', 'g');
	
	    var open_matches = match.match(rule_for_open) || [];
	    var close_matches = match.match(rule_for_close) || [];
	
	    return open_matches.length === close_matches.length ? true : false;
	  },
	
	
	  /**
	   * Check if the last character should be removed
	   * @param input
	   * @param match
	   * @returns {boolean}
	   * @private
	   */
	  _should_slice: function _should_slice(input, match) {
	    var match_index = input.indexOf(match);
	    var last_char = input.charAt(match_index + (match.length - 1));
	
	    if (this.paired_punctuation[last_char]) {
	      if (!this._num_of_chars_balanced(match, last_char)) {
	        return true;
	      }
	
	      return false;
	    }
	
	    return true;
	  },
	
	
	  /**
	   * If the first character after the match is not url end punctuation
	   * we should break and not replace the match in the input text
	   *  ex: sys.tr would be linkified in "sys.trace" without this fix
	   *
	   * @method url_should_be_replaced
	   * @param {String} input
	   * @param {String} match
	   * @returns {Boolean}
	   */
	  url_should_be_replaced: function url_should_be_replaced(input, match) {
	    var match_index = input.indexOf(match);
	    var first_char_after_match = input.charAt(match_index + match.length);
	    if (first_char_after_match && !this.url_end_punct_regex.test(first_char_after_match)) {
	      return false;
	    }
	    return true;
	  },
	
	
	  /**
	   * Indentify that provided input text is invite link like https://hipchat.com/invite/3/dd0f069a19e1df8465287d5291aa347e
	   * or http://subdomain.hipchat.com/invite/3/dd0f069a19e1df8465287d5291aa347e?utm_campaign=company_room_link
	   *
	   * @param {String} input
	   * @returns {Boolean}
	   */
	  identify_invite_link: function identify_invite_link(input) {
	    var invite_link_regexp = new RegExp(_regex_helpers2.default.invite_user_url);
	    return invite_link_regexp.test(input);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 109 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	
	  display_names: {},
	
	  is_private_chat: function is_private_chat(jid) {
	    return (/@chat/.test(jid)
	    );
	  },
	
	  is_room: function is_room(jid) {
	    return (/@conf/.test(jid)
	    );
	  },
	
	  is_lobby: function is_lobby(jid) {
	    return jid === 'lobby' || /^lobby@/.test(jid);
	  },
	
	  is_search: function is_search(jid) {
	    return jid === 'search' || /^search@/.test(jid);
	  },
	
	  is_chat: function is_chat(jid) {
	    return (this.is_private_chat(jid) || this.is_room(jid)) && !this.is_lobby(jid) && !this.is_search(jid);
	  },
	
	  bare_jid: function bare_jid(val) {
	    if (!val) {
	      return false;
	    }
	
	    return val.split('/')[0];
	  },
	
	  domain: function domain(val) {
	    if (!val) {
	      return false;
	    }
	
	    return val.split('@')[1].split('/')[0];
	  },
	
	  group_id: function group_id(val) {
	    var node = this.node(val);
	    var id = node.substr(0, node.indexOf('_'));
	    return parseInt(id, 10);
	  },
	
	  is_private_room: function is_private_room(privacy) {
	    return privacy === 'private';
	  },
	
	  is_public_room: function is_public_room(privacy) {
	    return privacy === 'public';
	  },
	
	  node: function node(val) {
	    if (!val) {
	      return false;
	    }
	
	    return val.split('@')[0];
	  },
	
	  resource: function resource(val) {
	    // we don't want to use val.split('/') here because there may be a slash
	    // in the resource
	    var i = val.indexOf('/');
	    if (i === -1) {
	      return null;
	    }
	    return val.substr(i + 1);
	  },
	
	  room_name: function room_name(val) {
	    var node = this.node(val);
	    var name = node.substr(node.indexOf('_') + 1);
	    return name;
	  },
	
	  // used to sanitize jids before using them in something HTML/Xpath like a jQuery search
	  sanitize: function sanitize(val) {
	    return val.replace('\\', '\\\\');
	  },
	
	  user_id: function user_id(val) {
	    var node = this.node(val);
	    if (node) {
	      var id = node.substr(node.indexOf('_') + 1);
	      if (id.match(/[0123456789]+/)) {
	        return parseInt(id, 10);
	      }
	    }
	
	    return null;
	  },
	
	  user_name: function user_name(jid) {
	    return jid.split("/")[1];
	  },
	
	  get_display_name: function get_display_name(jid, default_name) {
	
	    if (typeof default_name === 'undefined') {
	      default_name = 'Unknown';
	    }
	    if (!jid || typeof jid === 'undefined') {
	      return default_name;
	    }
	
	    jid = this.bare_jid(jid);
	    var member = this.display_names[jid];
	    if (member) {
	      return member.name;
	    }
	
	    return default_name;
	  },
	
	  /**
	   * Builds a jid for the group instance
	   *
	   * @param groupName the name of the group
	   * @param groupId the id of the group
	   * @param conf the conference server string
	   * @returns {string}
	   */
	  build_group_jid: function build_group_jid(groupName, groupId, conf) {
	    return groupId + "_" + (typeof groupName === 'string' ? groupName.toLowerCase() : groupName) + "@" + conf;
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _regenerator = __webpack_require__(111);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _getIterator2 = __webpack_require__(114);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _toConsumableArray2 = __webpack_require__(117);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var EMOTICON_FINDER = /\([A-Z0-9]+\)/gim;
	
	
	function getEmoteRegex(shortcut) {
	  // Capture space/beginning char in regex to avoid emoticoning links like
	  // http://coderwall.com/p/euwpig?i=3&p=1&t=git (& becomes &amp; and matches ;p)
	  var regex = '(?:<([A-Z][A-Z0-9]*)\\b.*?(?:\\/>|<\\/\\1>)|(&[a-zA-Z0-9]{2,6};)(?!:-\\()|';
	  if (shortcut.indexOf('(') !== 1) {
	    regex += '(?:\\s|^)(' + shortcut + ')(?!\\w))';
	  } else {
	    regex += '(' + shortcut + '))';
	  }
	  return new RegExp(regex, 'gim');
	}
	
	var Emoticons = {
	  path_prefix: '/',
	  emoticons: {},
	  smileys: {},
	  asset_base_uri: '',
	  web_server: '',
	  specials: {
	    scumbag: '_scumbagify',
	    dealwithit: '_shadesify'
	  },
	
	  init: function init() {
	    this.addSmileys(this.emoticons);
	    return this;
	  },
	
	  addSmileys: function addSmileys(smileys) {
	    var _this = this;
	
	    _.each(smileys, function (smiley, key) {
	      if (smiley.shortcut === ':') {
	        smiley.shortcut = ':\\';
	      } else if (smiley.shortcut === '&gt;:-(') {
	        // Fix encoded angry face
	        smiley.shortcut = '>:-(';
	      }
	      if (!_.isRegExp(smiley.regex)) {
	        smiley.regex = getEmoteRegex(smiley.regex);
	      }
	
	      _this.smileys[key] = smiley;
	    });
	
	    return this.smileys;
	  },
	
	  /**
	   * Add an word-based emoticon to the list of emoticons to check for
	   *
	   * @param filename - Name of the image file (the full path is created in the emoticon_text function)
	   * @param shortcut - Text used to create the emoticon (e.g. "embarrassed" or "puking" )
	   * @param height - Height in pixels of the image
	   * @param width - Width in pixels of the image
	   **/
	  add: function add(filename, shortcut, height, width, type) {
	    var str = "(" + shortcut + ")";
	    // Capture optional space char in regex to be compatible with non paren emoticons
	    // We need to check for space with emoticons like ;p to avoid emoticoning links like
	    // http://coderwall.com/p/euwpig?i=3&p=1&t=git (& becomes &amp; and matches ;p)
	    this.emoticons[str] = {
	      file: filename,
	      height: height,
	      width: width,
	      shortcut: '(' + shortcut + ')',
	      type: type
	    };
	  },
	
	  addBulk: function addBulk(emoticons) {
	    var _this2 = this;
	
	    var collection = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	    this.emoticons = _.cloneDeep(collection);
	
	    _.each(emoticons, function (emoticon) {
	      _this2.add(emoticon.path, emoticon.shortcut, emoticon.h, emoticon.w, emoticon.type);
	    });
	
	    return this.emoticons;
	  },
	
	  removeBulk: function removeBulk(emoticons) {
	    var _this3 = this;
	
	    var emoticonsMap = {};
	
	    var _arr = [].concat((0, _toConsumableArray3.default)(this.getEmoticonsKeys(emoticons)));
	
	    for (var _i = 0; _i < _arr.length; _i++) {
	      var key = _arr[_i];
	      emoticonsMap[key] = true;
	    }
	
	    _.forIn(this.emoticons, function (emoticon, key) {
	      if (!emoticonsMap[key]) {
	        delete _this3.emoticons[key];
	      }
	    });
	
	    return this.emoticons;
	  },
	
	  getEmoticonsKeys: _regenerator2.default.mark(function getEmoticonsKeys(emoticons) {
	    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, emoticon;
	
	    return _regenerator2.default.wrap(function getEmoticonsKeys$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _iteratorNormalCompletion = true;
	            _didIteratorError = false;
	            _iteratorError = undefined;
	            _context.prev = 3;
	            _iterator = (0, _getIterator3.default)(emoticons);
	
	          case 5:
	            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	              _context.next = 12;
	              break;
	            }
	
	            emoticon = _step.value;
	            _context.next = 9;
	            return '(' + emoticon.shortcut + ')';
	
	          case 9:
	            _iteratorNormalCompletion = true;
	            _context.next = 5;
	            break;
	
	          case 12:
	            _context.next = 18;
	            break;
	
	          case 14:
	            _context.prev = 14;
	            _context.t0 = _context['catch'](3);
	            _didIteratorError = true;
	            _iteratorError = _context.t0;
	
	          case 18:
	            _context.prev = 18;
	            _context.prev = 19;
	
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	
	          case 21:
	            _context.prev = 21;
	
	            if (!_didIteratorError) {
	              _context.next = 24;
	              break;
	            }
	
	            throw _iteratorError;
	
	          case 24:
	            return _context.finish(21);
	
	          case 25:
	            return _context.finish(18);
	
	          case 26:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, getEmoticonsKeys, this, [[3, 14, 18, 26], [19,, 21, 25]]);
	  }),
	
	  getEmoticons: function getEmoticons(message) {
	    return message.match(EMOTICON_FINDER) || [];
	  },
	
	  getEmoticonsInfo: function getEmoticonsInfo(message) {
	    var usedEmoticons = this.getEmoticons(message);
	    return _.filter(this.emoticons, function (emoticon) {
	      return usedEmoticons.indexOf(emoticon.shortcut) !== -1;
	    });
	  },
	
	
	  /**
	   * Replace text emoticons with images
	   **/
	  render: function render(message) {
	    var _this4 = this;
	
	    var emoticons = this.getEmoticons(message);
	
	    if (emoticons.length) {
	      _.each(emoticons, function (shortcut) {
	        var emoticon = _this4.emoticons[shortcut.toLowerCase()];
	
	        if (emoticon) {
	          message = _this4._replaceWithImage(message, emoticon);
	        }
	      });
	    }
	
	    _.each(this.smileys, function (smiley) {
	      return message = _this4._replaceWithImage(message, smiley);
	    });
	
	    return message;
	  },
	
	  _replaceWithImage: function _replaceWithImage(text, emoticon) {
	    var src = this._generateSrc(emoticon.file);
	    if (!emoticon.regex) {
	      emoticon.regex = getEmoteRegex('\\(' + emoticon.shortcut + '\\)');
	    }
	
	    // (not a word character)(smiley regex)(not a word character)
	    return text.replace(emoticon.regex, function (match, p1, p2, p3) {
	      if (p3) {
	        return '<img class="remoticon" aria-label="' + emoticon.shortcut + '" alt="' + emoticon.shortcut + '" height="' + emoticon.height + '" width="' + emoticon.width + '" src="' + src + '" onerror="if (HC.emoticon_resolution_helper) { HC.emoticon_resolution_helper(this); }" />';
	      }
	      return match;
	    });
	  },
	
	  renderConsole: function renderConsole(message) {
	    var _this5 = this;
	
	    try {
	      var emoticons = this.getEmoticons(message),
	          font = "font-family: Helvetica Neue, Helvetica, Arial; font-size: 14px; font-weight: bold;",
	          msg = "%c" + message,
	          args = [font];
	
	      emoticons.forEach(function (emoticon) {
	        var emoticonInfo = _this5._getEmoticonInfo(emoticon, 1);
	
	        if (_.identity(emoticonInfo)) {
	          msg = msg.replace(emoticonInfo.regex, function (match, p1, p2, p3) {
	            if (p3) {
	              return "%c%c";
	            }
	          });
	          args.push("font-size: " + emoticonInfo.height + "px; padding-left: " + (emoticonInfo.width + 5) + "px;" + " line-height: 30px; background: url(" + emoticonInfo.src + ") no-repeat 0/auto " + emoticonInfo.height + "px;");
	          args.push(font);
	        }
	      });
	
	      args.unshift(msg);
	      console.log.apply(console, args);
	    } catch (ignored) {
	      console.log(message);
	    }
	  },
	
	  _getEmoticonInfo: function _getEmoticonInfo(shortcut, resolution) {
	    var emoticon = this.smileys[shortcut] || this.emoticons[shortcut];
	    if (!emoticon) {
	      return undefined;
	    }
	    var fileName = emoticon.file;
	    if (!emoticon.regex) {
	      emoticon.regex = getEmoteRegex('\\(' + emoticon.shortcut + '\\)');
	    }
	    return {
	      src: this._generateSrc(fileName, resolution),
	      regex: emoticon.regex,
	      height: parseInt(emoticon.height, 10) > 26 ? 26 : emoticon.height,
	      width: parseInt(emoticon.width, 10) > 26 ? 26 : emoticon.width
	    };
	  },
	
	  _generateSrc: function _generateSrc(fileName) {
	    var resolution = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];
	
	    if (resolution > 1) {
	      var resolutionSuffix = '@' + resolution + 'x';
	      if (fileName.indexOf(resolutionSuffix) === -1) {
	        fileName = fileName.split('.').join(resolution > 1 ? resolutionSuffix + '.' : '.');
	      }
	    }
	    return this.path_prefix + '/' + fileName;
	  },
	
	
	  _replaceSpecials: function _replaceSpecials(node) {
	    var _this6 = this;
	
	    var emotes = $(node).find('img.remoticon');
	    _.forOwn(this.specials, function (apply, emote) {
	      for (var i = 0; i < emotes.length; i++) {
	        if (emotes[i].getAttribute('src').match('img/emoticons/' + emote) && emotes[i + 1] && emotes[i].nextSibling === emotes[i + 1] && emotes[i].getAttribute('src') !== emotes[i + 1].getAttribute('src')) {
	          _this6[apply](emotes[i], emotes[i + 1]);
	        }
	      }
	    });
	  },
	
	  _scumbagify: function _scumbagify(hat, scumbag) {
	    $(scumbag).on('load', function () {
	      var width = $(scumbag).width();
	      hat.style.display = 'block';
	      hat.parentNode.style.position = 'relative';
	      hat.style.position = 'absolute';
	      hat.style.top = scumbag.offsetTop - 3 + 'px';
	      hat.style.left = scumbag.offsetLeft + width / 2 - 10 + 'px';
	    });
	  },
	
	  _shadesify: function _shadesify(shades, coolDude) {
	    $(shades).attr({
	      src: 'https://' + this.web_server + '/wc/' + _app_config2.default.shades_icon,
	      width: 18,
	      height: 'auto'
	    });
	    $(coolDude).on('load', function () {
	      var width = $(coolDude).width(),
	          height = $(coolDude).height();
	      shades.parentNode.style.position = 'relative';
	      shades.style.display = 'block';
	      shades.style.position = 'absolute';
	      shades.style.top = coolDude.offsetTop + height / 2 - 3 + 'px';
	      shades.style.left = coolDude.offsetLeft + width / 2 - 9 + 'px';
	      $(shades).addClass('shadesify');
	    });
	  }
	};
	
	if (console) {
	  console.emote = function (msg) {
	    Emoticons.renderConsole.call(Emoticons, msg);
	  };
	}
	
	module.exports = Emoticons;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(112);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	module.exports = { "default": module.exports, __esModule: true };
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	"use strict";
	
	var _Symbol = __webpack_require__(24)["default"];
	
	var _Object$create = __webpack_require__(52)["default"];
	
	var _Object$setPrototypeOf = __webpack_require__(54)["default"];
	
	var _Promise = __webpack_require__(59)["default"];
	
	!(function (global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = _Object$create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      prototype[method] = function (arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function (genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor ? ctor === GeneratorFunction ||
	    // For the native GeneratorFunction constructor, the best we can
	    // do is to check its .name property.
	    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	  };
	
	  runtime.mark = function (genFun) {
	    if (_Object$setPrototypeOf) {
	      _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = _Object$create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function (arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return _Promise.resolve(value.arg).then(function (value) {
	            invoke("next", value, resolve, reject);
	          }, function (err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return _Promise.resolve(value).then(function (unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new _Promise(function (resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	      // If enqueue has been called before, then we want to wait until
	      // all previous Promises have been resolved before calling invoke,
	      // so that results are always delivered in the correct order. If
	      // enqueue has not been called before, then it is important to
	      // call invoke immediately, without waiting on a callback to fire,
	      // so that the async generator function has the opportunity to do
	      // any necessary setup in a predictable way. This predictability
	      // is why the Promise constructor synchronously invokes its
	      // executor callback, and why async functions synchronously
	      // execute code before the first await. Since we implement simple
	      // async functions in terms of async generators, it is especially
	      // important to get this right, even though it requires care.
	      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
	      // Avoid propagating failures to Promises returned by later
	      // invocations of the iterator.
	      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
	
	    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	    : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done ? GenStateCompleted : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function () {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function () {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function (object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1,
	            next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function reset(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function stop() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function dispatchException(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function complete(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" || record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	// Among the various tricks for obtaining a reference to the global
	// object, this seems to be the most reliable technique that does not
	// use indirect eval (which violates Content Security Policy).
	typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(113)))

/***/ },
/* 113 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(115), __esModule: true };

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(67);
	__webpack_require__(61);
	module.exports = __webpack_require__(116);

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(43)
	  , get      = __webpack_require__(78);
	module.exports = __webpack_require__(18).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(119), __esModule: true };

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(61);
	__webpack_require__(120);
	module.exports = __webpack_require__(18).Array.from;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx         = __webpack_require__(19)
	  , $export     = __webpack_require__(16)
	  , toObject    = __webpack_require__(13)
	  , call        = __webpack_require__(75)
	  , isArrayIter = __webpack_require__(76)
	  , toLength    = __webpack_require__(77)
	  , getIterFn   = __webpack_require__(78);
	$export($export.S + $export.F * !__webpack_require__(88)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , $$      = arguments
	      , $$len   = $$.length
	      , mapfn   = $$len > 1 ? $$[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        result[index] = mapping ? mapfn(O[index], index) : O[index];
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 121 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  analytics_publish_interval: 30000, // publish analytics events with this interval
	  analytics_save_interval: 3000, // save to storage analytics events with this interval
	  default_web_server: "www.hipchat.com", // default web server
	  save_preferences_throttle_interval: 5 * 1000, //the throttle timer for persisting preferences to the server
	  max_upload_size: 50, //max upload file size in Mb
	  file_download_timeout: 10000, //timeout for downloading files
	  scroll_to_bottom_offset: 5, //Scroll to bottom check offset
	  frozen_scroll_offset: 100, //Offset when we handle frozen scroll case
	  chat_scroll_duration: 200, //The duration of the autoscroll animation when a new message comes in
	  render_twitter_cards: false, //Embedded Twitter cards
	  chat_room_idle_timeout_minutes: 1, //Time to elapse before we begin trimming the history
	  chat_room_trim_buffer: 50, //The minimum number of messages before beginning to trim
	  message_retrieval_chunk_size: 50, //Number of messages to request during a history load
	  composing_message_linger_timeout: 6000, //How long "so and so is typing..." messages hang around
	  sent_active_message_delay: 2000, //Delay for sending "active" message and stop "so and so is typing..."
	  sent_composing_message_interval: 3000, //How often we ping composing state for "so and so is typing..."
	  request_participant_presences_timeout: 500, //Throttle timeout to request all participant presences
	  filter_participant_presences_timeout: 5000,
	  fetch_room_participants_timeout: 500,
	  avatar_loading_timeout: 3000, //Load default avatar after this timeout
	  set_active_rooms_timeout: 500, //Debounce timeout to set activeRooms
	  room_participant_page_limit: 500, //Set limit for room participant API paging
	  message_image_size_check_interval: 100, //Interval to check naturalHeight till image loading
	  message_image_loading_timeout: 10000, //Time elapsed before image was marked as failed to load.
	  message_image_max_size: 8000, //Maximum acceptable image size in pixels for images to be rendered as metadata for messages
	  max_image_size_for_base64: 6500,
	  initial_room_participants_limit: 21, //Limit room occupant presences on join - count includes the current user
	  notification_limit: 5, //limit unique OS notifications
	  leave_room_message_confirmation_timeout: 10 * 1000, //Time elapsed before showing "user left the room" message
	  input_history_max: 50, // Maximum number of saved input history items
	  chat_history_fetching_attempts: 5, // How many times we are trying re-fetch history on error
	  chat_history_fetching_attempt_timeout: 60 * 1000, // Timeout on history re-fetching on error
	  default_message_confirmation_timeout: 75 * 1000, //Time elapsed before considering an non-echoed message failed
	  flaky_network_message_timeout: 12 * 1000, //Time it takes to show the user that something's up
	  reconnect_failures_before_showing_banner: 5, //Number of reconnection failures before showing "can't connect" header banner
	  flag_close_animation_time: 1000, //Time for flag closing animation to complete
	  notify_sound_asset: "assets/audio/notify", //Url to notify sound asset
	  incoming_sound_asset: "assets/audio/incoming_call", //Url to incoming call sound asset
	  outgoing_sound_asset: "assets/audio/outgoing_call", //Url to outgoing call sound asset
	  new_hotness_image_asset: "assets/img/embedded/new-hotness.gif",
	  new_hotness_native_asset: "assets/img/embedded/new-hotness-no-animation.png",
	  help_link_url: 'https://help.hipchat.com',
	  get_started_url: 'https://confluence.atlassian.com/get-started-with-hipchat/get-started-with-hipchat-854033505.html',
	  feedback_issue_url: 'https://jira.atlassian.com/secure/CreateIssue.jspa?pid=18110&issuetype=10000',
	  status_page_url: 'https://status.hipchat.com/',
	  notification_close_timeout: 5000, //The duration that desktop notifications hang around
	  message_filter_predicate: _.constant(true), //An optional predicate to filter messages
	  outgoing_message_filter_predicate: _.constant(true), //An optional predicate to filter outgoing messages
	  notification_banner_slide: 200, //The duration of the notification banner slide
	  notification_title_max_character_length: 33, //The max character length for browser notification titles
	  notification_icon: 'assets/img/embedded/notification.png',
	  notification_attach_to_reorder_limit_mins: 5, //The max number of minutes to allow an attached notification to be reordered next to the original.
	  //If time is greater, it will appear at the time it was sent.
	  fetching_files_limit: 100, //Limit of files that we receive on history call
	  fetching_links_limit: 100, //Limit of links that we receive on history call
	  fetch_thumbnails_timeout: 100, //Timeout for thumbnails fetching (ms)
	
	  shades_icon: 'assets/img/embedded/shades.png',
	  select2_max_displayed_items: 20, //Select2 autocomplete maximum displayed items in dropdown list
	  favicon_bg_color: '#707070', //Background color for the favicon notification badge
	  default_backdrop_dismiss_on_click: true, //A click on backdrop will dismiss modal dialog
	  default_theme: 'light',
	  default_density: 'normal',
	  default_chat_view: 'classic_neue',
	  default_name_display: 'names',
	  default_animated_avatars: 'animated',
	  default_notification_level: 'loud',
	  chat_input_id: 'hc-message-input', //Id attribute value for chat input
	  favicon_bg_color_with_mention: '#3873AE', //Background color for the favicon notification badge, when the user is mentioned
	  slash_replacement_regex: new RegExp('^s/([^/]+)/([^/]*)/?$'), //S-slash command replacement regex
	  integrations_base_url: 'https://{base_url}/addons', // Integrations base url
	  integrations_url: 'https://{base_url}/rooms/addons/{room_id}?required_user={user_id}&from_location_id={from_location_id}&source_id={source_id}', // URL used to install integrations in a room (use IntegrationHelper.getIntegrationsUrl())
	  integrations_config_url: 'https://{base_url}/addons/{addon_key}?room={room_id}', // URL used to configure integration in a room
	  integrations_update_url: 'https://{base_url}/addons/{addon_key}?room={room_id}&update=true', // URL used to configure integration in a room
	  column_width_limits: { //Column width limits
	    left: {
	      max: 450,
	      min: 95,
	      default: 220
	    },
	    right: {
	      max: 450,
	      min: 95,
	      default: 200
	    }
	  },
	  video_width: 960,
	  video_height: 540,
	  min_video_width: 640,
	  min_video_height: 360,
	  default_connect_dialog_height: 400, //connect dialog default height
	  default_connect_dialog_width: 600, //connect dialog default width
	  connect_aui_dialog_chrome_height: 122, //connect dialog AUI header / footer combined height
	  default_connect_aui_dialog_vertical_mergin: 170, //connect dialog default distance from the top of the window
	  onboarding: {
	    rooms_threshold: 5,
	    oto_threshold: 5
	  },
	  login_page_redirect_regex: new RegExp('(log|sign)[_\-]?in', "gi"), //if in app search redirects user to sign_in page we check the iframe location and handle apprpriately
	  emoticon_regex: new RegExp(/[^\(a-zA-Z0-9\-\:'=]+/),
	  emote_regex: /^(\/me\s|\/em\s)/,
	  quote_regex: /^(\/quote\s)/,
	  code_regex: /^(\/code\s)/,
	  pre_regex: /^(\/pre\s*|\/monospace\s*)/,
	  core_mentions: [{
	    mention_name: "all",
	    name: 'All room members',
	    isUser: false,
	    jid: 'all@chat' // to pass utils.jid.is_private_chat (is person)
	  }, {
	    mention_name: "here",
	    name: 'Available room members',
	    isUser: false,
	    jid: 'here@chat' // to pass utils.jid.is_private_chat (is person)
	  }, {
	    mention_name: "HipChat",
	    name: 'HipChat',
	    isUser: true,
	    jid: 'hipchat@chat' // to pass utils.jid.is_private_chat (is person)
	  }],
	  spinner_colors: {
	    light: '#000000', // Default color for loading spinner
	    dark: '#c7c7c7' // Loading spinner color for dark mode
	  },
	  missed_video_call_timeout: 30000,
	  default_group_avatar_bg: "#59afe1",
	  default_guest_avatar_bg: "#cccccc",
	  delayed_video_message_timeout: 3000,
	  max_message_text_length: Math.pow(2, 15), // Max message length - matches backend limit
	  max_file_description_length: 1000, // Max file description length - matches backend limit
	  max_topic_text_length: 250, // Max topic length - too many characters cause crashes
	  max_presence_text_length: 1024,
	  integrations: {
	    persistent_store_max_size_bytes: 100 * 1024, // 100KB in bytes
	    glance_remote_metadata_timeout: 10000,
	    loading_indicator_delay_ms: 100,
	    signed_url_timeout: 2000,
	    spinner_delay: 100
	  },
	  dialog: {
	    max_size_margin: 160,
	    filter_debounce_wait: 250
	  },
	  modal_transition_allowance: 250,
	  people_glance: {
	    full_key: "atlassian.hipchat.internal.people:people",
	    addon_key: "atlassian.hipchat.internal.people",
	    addon_version: "internal.people.1",
	    key: "people",
	    name: "Members",
	    target: "people",
	    type: "glance",
	    icon: {
	      aui_icon: "aui-icon aui-icon-small aui-iconfont-group"
	    },
	    weight: 0,
	    internal: true,
	    max_items_to_render_collapsed: 24
	  },
	  files_glance: {
	    full_key: "atlassian.hipchat.internal.files:files",
	    addon_key: "atlassian.hipchat.internal.files",
	    addon_version: "internal.files.1",
	    key: "files",
	    name: "Files",
	    target: "files",
	    type: "glance",
	    icon: {
	      aui_icon: "hipchat-icon-small icon-file"
	    },
	    weight: 1,
	    internal: true
	  },
	  links_glance: {
	    full_key: "atlassian.hipchat.internal.links:links",
	    addon_key: "atlassian.hipchat.internal.links",
	    addon_version: "internal.links.1",
	    key: "links",
	    name: "Links",
	    target: "links",
	    type: "glance",
	    icon: {
	      aui_icon: "hipchat-icon-small icon-link"
	    },
	    weight: 2,
	    internal: true
	  },
	  max_unread_count: 99,
	  default_avatar_colors: [// Used to identify the default group avatar
	  '#88d3ff', '#59afe1', '#2774a0', '#1a8cff', '#b2e020', '#8eb021', '#2f7a0e', '#0bbe30', '#14892c', '#005812', '#fe5e50', '#d04437', '#88170c', '#f6c342', '#f79232', '#b05600', '#d39c3f', '#815b3a', '#594300', '#a659f5', '#654982', '#3d1368', '#f691b2', '#f15c75', '#be1733', '#ff4f92', '#ff0d6e', '#b3003e', '#ffe400', '#ffae00', '#00d2ff', '#0096ff', '#d84dff', '#b400ff', '#7e00ff', '#ffd200', '#ff7f00', '#ff2f00'],
	  tipsify: {
	    window_margin: 10,
	    distance: 5,
	    delay: 300,
	    max_dom_traverse_depth: 3
	  },
	  cards: {
	    feedback_url: 'https://docs.google.com/a/atlassian.com/forms/d/1vcNJHyni4mCwwljRskil_Xdz9o_ssgxeu-cD0pmv1ts/viewform?entry.640157496='
	  },
	  guest_access_information: {
	    focus_and_select_delay: 200,
	    mouseout_delay: 300
	  },
	  roster_panel: {
	    group_title_item_height: 39,
	    person_item_height: 26,
	    breakpoints: {
	      small: 20,
	      medium: 100,
	      large: 500,
	      xlarge: Infinity
	    }
	  },
	  edit_message_threshold: 1000 * 60 * 60 * 24, // amount of time (in milliseconds) that we will allow users to edit/delete messages
	  max_users_in_group_join_notification: 10, // max number of users in group that will get client notification, that new user joined
	  welcome_dialog: {
	    max_size_of_group_to_display: 5,
	    max_displayed_people: 4,
	    max_displayed_rooms: 4,
	    max_amount_of_people_icons: 6,
	    max_length_of_welcome_message: 150
	  },
	  alert_flag_poll_interval: 1000 * 60 * 10
	};
	module.exports = exports['default'];

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _jid_utils = __webpack_require__(109);
	
	var _jid_utils2 = _interopRequireDefault(_jid_utils);
	
	var _file_types = __webpack_require__(123);
	
	var _file_types2 = _interopRequireDefault(_file_types);
	
	var _mime_types = __webpack_require__(124);
	
	var _mime_types2 = _interopRequireDefault(_mime_types);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var file_utils = {
	
	  file_types: _file_types2.default.init(),
	  mime_types: _mime_types2.default.init(),
	
	  is_gif: function is_gif(fileurl) {
	    var ext = file_utils.get_extension(fileurl);
	    return ext.toLowerCase() === 'gif';
	  },
	
	  get_file_name: function get_file_name(filename) {
	    return _.isString(filename) ? filename.split("/").pop() : "";
	  },
	
	  get_extension: function get_extension(filename) {
	    var file = file_utils.get_file_name(filename),
	        ext = file.split(".").pop();
	    return ext === file ? "" : ext.toLowerCase();
	  },
	
	  get_extension_for_mime_type: function get_extension_for_mime_type(mimeType) {
	    if (file_utils.mime_types[mimeType]) {
	      return file_utils.mime_types[mimeType];
	    } else if (mimeType.split("/").pop().length === 3) {
	      return mimeType.split("/").pop();
	    }
	  },
	
	  get_file_type: function get_file_type(filename, return_default) {
	    var extension = file_utils.get_extension(filename),
	        type;
	    _.find(file_utils.file_types, function (extension_list, key) {
	      if (_.includes(extension_list, extension)) {
	        type = key;
	      }
	    });
	    return return_default ? type || "text" : type;
	  },
	
	  get_size_string: function get_size_string(size) {
	    if (!size) {
	      return '';
	    }
	
	    var precision = size > 1024 ? 0 : 2,
	        sizeString = Number(size / 1024).toFixed(precision),
	        magnitude = 'K';
	
	    if (size > 1048576) {
	      precision = 1;
	      sizeString = Number(size / 1048576).toFixed(precision);
	      magnitude = 'MB';
	    }
	
	    return sizeString + magnitude;
	  },
	
	  get_selected_file_type: function get_selected_file_type(file) {
	    var fileType = {
	      major: "unknown",
	      minor: "unknown"
	    };
	    if (file && file.type && file.type.indexOf("/") > -1) {
	      var fileTypeSplit = file.type.toLowerCase().split("/");
	      fileType.major = fileTypeSplit[0];
	      fileType.minor = fileTypeSplit[1];
	    }
	
	    return fileType;
	  },
	
	  get_icon_class: function get_icon_class(filename) {
	    var file_type = file_utils.get_file_type(filename);
	    return file_type ? "icon-" + file_type : "icon-text";
	  },
	
	  clean_base64_type: function clean_base64_type(base64_type) {
	    var type;
	
	    if (_.isString(base64_type)) {
	      type = base64_type.replace("data:", "").replace(";base64", "");
	    }
	    return type;
	  },
	
	  get_base64_type: function get_base64_type(base64) {
	    if (_.isString(base64)) {
	      return file_utils.clean_base64_type(base64.split(",")[0]);
	    }
	  },
	
	  get_base64_data: function get_base64_data(base64) {
	    if (_.isString(base64)) {
	      var base_data = base64.split(",");
	      if (_.isArray(base_data) && base_data.length > 1) {
	        return base_data[1];
	      }
	    }
	  },
	
	  base64_to_blob: function base64_to_blob(base64) {
	    var fileName = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	    var blob,
	        content_type,
	        base64_data,
	        byteChars,
	        sliceSize = 512,
	        slice,
	        byteNums,
	        byteArray = [],
	        fileType,
	        byteCollection = [];
	
	    if (_.isString(base64)) {
	      base64_data = file_utils.get_base64_data(base64);
	      content_type = file_utils.get_base64_type(base64);
	      byteChars = atob(base64_data);
	
	      for (var offset = 0; offset < byteChars.length; offset += sliceSize) {
	        slice = byteChars.slice(offset, offset + sliceSize);
	        byteNums = new Array(slice.length);
	
	        for (var i = 0; i < slice.length; i++) {
	          byteNums[i] = slice.charCodeAt(i);
	        }
	
	        byteArray = new Uint8Array(byteNums);
	        byteCollection.push(byteArray);
	      }
	
	      if (content_type === 'application/octet-stream') {
	        fileType = this.get_extension(fileName);
	
	        if (fileType === 'mp4') {
	          content_type = 'video/mp4';
	        } else if (fileType === 'mov') {
	          content_type = 'video/quicktime';
	        }
	      }
	
	      blob = new Blob(byteCollection, { type: content_type });
	    }
	    return blob;
	  },
	
	  blob_to_file: function blob_to_file(blob, name) {
	    var date = arguments.length <= 2 || arguments[2] === undefined ? new Date() : arguments[2];
	
	    if (blob instanceof Blob) {
	      blob.lastModifiedDate = date;
	      blob.name = name ? name : "";
	    }
	    return blob;
	  },
	
	  create_file_object: function create_file_object(jid, file, ts, sender_name) {
	    var base_id = _.uniqueId();
	    return _.assign(file, {
	      id: file.id || base_id,
	      group_id: _jid_utils2.default.group_id(jid),
	      user_name: sender_name,
	      date: _moment2.default.utc(ts * 1000).toDate(),
	      icon_class: file_utils.get_icon_class(file.name)
	    });
	  }
	};
	
	exports.default = file_utils;
	module.exports = exports['default'];

/***/ },
/* 123 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	  init: function init() {
	    return {
	      "audio": ["aif", "aiff", "mp3", "wav", "wma"],
	      "code": ["asp", "coffee", "css", "html", "htm", "java", "js", "json", "jsp", "less", "lib", "php", "prl", "py", "sass", "sh", "xml"],
	      "doc": ["doc", "docm", "docx", "dotm", "dotx", "gdoc", "pages"],
	      "ai": ["ai"],
	      "psd": ["psd"],
	      "img": ["bmp", "gif", "jpg", "jpeg", "png", "tif", "tiff"],
	      "pdf": ["pdf"],
	      "presentation": ["keynote", "ppam", "ppsm", "ppsx", "ppt", "pptm", "pptx"],
	      "spreadsheet": ["numbers", "ods", "xlam", "xls", "xlsb", "xlsm", "xlsx", "xltm", "xltx"],
	      "vector": ["dxf", "eps", "svg"],
	      "video": ["flv", "m4v", "mov", "mp4", "wmv", "webm", "ogv"],
	      "zip": ["apk", "gz", "rar", "tar", "zip", "zipx"]
	    };
	  }
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	  init: function init() {
	    return {
	      "image/jpg": "jpg",
	      "image/jpeg": "jpg",
	      "image/png": "png",
	      "image/gif": "gif",
	      "image/svg+xml": "svg",
	      "audio/mpeg3": "mpg3",
	      "audio/wav": "wav",
	      "application/pdf": "pdf",
	      "application/text": "txt",
	      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
	      "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
	      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
	      "video/mp4": "mp4",
	      "video/quicktime": "mov"
	    };
	  }
	};

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _jid_utils = __webpack_require__(109);
	
	var _jid_utils2 = _interopRequireDefault(_jid_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var room_utils = {
	  get_room_name: function get_room_name(rooms, room_jid) {
	    return rooms[room_jid] ? rooms[room_jid].name : "Unknown";
	  },
	  get_room_id: function get_room_id(rooms, room_jid) {
	    return rooms[room_jid] ? rooms[room_jid].id : false;
	  },
	  detect_chat_type: function detect_chat_type(jid) {
	    return _jid_utils2.default.is_room(jid) ? 'groupchat' : 'chat';
	  },
	  is_archived: function is_archived() {
	    var room = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    if (_.isBoolean(room.is_archived)) {
	      return room.is_archived;
	    }
	    return !!parseInt(room.is_archived, 10) || room.is_archived === '';
	  },
	  is_guest: function is_guest(participant) {
	    return _.get(participant, 'is_guest');
	  },
	  is_admin: function is_admin(participant) {
	    return _.get(participant, 'is_group_admin');
	  }
	};
	
	exports.default = room_utils;
	module.exports = exports['default'];

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray2 = __webpack_require__(127);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _status_strings = __webpack_require__(131);
	
	var _status_strings2 = _interopRequireDefault(_status_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var user_utils = {
	
	  get_user_name: function get_user_name(users, group_id, user_id) {
	    var jid_fragment = group_id + "_" + user_id + "@",
	        user_name = "Unknown";
	    _.find(users, function (val, key) {
	      if (key.indexOf(jid_fragment) > -1) {
	        user_name = val.name;
	      }
	    });
	    return user_name;
	  },
	
	  get_user_status: function get_user_status(presence_show) {
	    var status;
	
	    switch (presence_show) {
	      case "chat":
	        status = _status_strings2.default.available;
	        break;
	      case "away":
	        status = _status_strings2.default.idle;
	        break;
	      case "xa":
	        status = _status_strings2.default.away;
	        break;
	      case "dnd":
	        status = _status_strings2.default.dnd;
	        break;
	      case "mobile":
	        status = _status_strings2.default.mobile;
	        break;
	      default:
	        status = _status_strings2.default.unavailable;
	    }
	    return status;
	  },
	
	  chat_header_status: function chat_header_status(presence_status) {
	    var status;
	    switch (presence_status) {
	      case "chat":
	        status = _status_strings2.default.available;
	        break;
	      case "away":
	        status = _status_strings2.default.away;
	        break;
	      case "xa":
	        status = _status_strings2.default.away;
	        break;
	      case "dnd":
	        status = _status_strings2.default.dnd;
	        break;
	      case "mobile":
	        status = _status_strings2.default.mobile;
	        break;
	      default:
	        status = _status_strings2.default.unavailable;
	    }
	    return status;
	  },
	
	  format_idle_time: function format_idle_time(seconds) {
	    var time_msg = "",
	        days = Math.floor(seconds / 86400),
	        hours = Math.floor(seconds % 86400 / 3600),
	        mins = Math.floor(seconds % 86400 % 3600 / 60);
	
	    if (days > 0) {
	      time_msg = days + "d ";
	    }
	    if (hours > 0) {
	      time_msg += hours + "h ";
	    }
	    if (mins > 0) {
	      time_msg += mins + "m";
	    }
	    return $.trim(time_msg);
	  },
	
	  is_admin: function is_admin(admins, ownerId, user) {
	    var result = false,
	        uid = Number(_.get(user, "user_id") || _.get(user, "id")),
	        oid = Number(ownerId);
	
	    if (_.get(user, "is_admin") || _.get(user, 'is_group_admin')) {
	      result = true;
	    } else if (uid) {
	      if (admins) {
	        result = _.some(admins, function (val) {
	          return val === uid;
	        });
	      }
	      if (!result && oid) {
	        result = oid === uid;
	      }
	    }
	    return result;
	  },
	
	  is_guest: function is_guest(user) {
	    return !('subscription' in user);
	  },
	
	  sort_users: function sort_users(results, query) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var matchingRegex = new RegExp('^' + _utils2.default.escapeRegEx(query), 'gmi');
	
	    var _results$reduce = results.reduce(function (acc, el) {
	      var sortableValue = key ? el[key] : el;
	      var words = sortableValue.trim().split(' ');
	      var isMatched = words.some(function (name) {
	        return name.match(matchingRegex);
	      });
	      var isExact = isMatched ? words.some(function (name) {
	        return name.toLowerCase() === query.toLowerCase();
	      }) : false;
	
	      if (isExact) {
	        acc.exact.push(el);
	      } else if (isMatched) {
	        acc.highPriority.push(el);
	      } else {
	        acc.lowPriority.push(el);
	      }
	
	      return acc;
	    }, { exact: [], highPriority: [], lowPriority: [] });
	
	    var exact = _results$reduce.exact;
	    var highPriority = _results$reduce.highPriority;
	    var lowPriority = _results$reduce.lowPriority;
	
	
	    var sortFunc = function sortFunc(a, b) {
	      var _ref = key ? [a[key], b[key]] : [a, b];
	
	      var _ref2 = (0, _slicedToArray3.default)(_ref, 2);
	
	      var valueA = _ref2[0];
	      var valueB = _ref2[1];
	
	      return valueA.toLowerCase() > valueB.toLowerCase();
	    };
	
	    exact = exact.sort(sortFunc);
	    highPriority = highPriority.sort(sortFunc);
	    lowPriority = lowPriority.sort(sortFunc);
	
	    return exact.concat(highPriority).concat(lowPriority);
	  }
	};
	
	exports.default = user_utils;
	module.exports = exports['default'];

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(128);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(114);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(129), __esModule: true };

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(67);
	__webpack_require__(61);
	module.exports = __webpack_require__(130);

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(72)
	  , ITERATOR  = __webpack_require__(34)('iterator')
	  , Iterators = __webpack_require__(65);
	module.exports = __webpack_require__(18).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 131 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  available: 'Available',
	  idle: 'Idle',
	  away: 'Away',
	  dnd: 'Do Not Disturb',
	  mobile: 'Mobile',
	  unavailable: 'Unavailable'
	};
	module.exports = exports['default'];

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var video_utils = {
	
	  isVideoLink: function isVideoLink(link) {
	    // Using the global HC object here because importing the ConfigStore throws an error
	    //  TypeError: "Super expression must either be null or a function, not object"
	    var base_url = _.get(window, 'HC.ApplicationStore.data.config.video_base_url', '').replace(/https?\:\/\//, '');
	
	    var whitelist = ['hipchat.com/video/join', 'hipchat.me', 'enso.me/join'];
	
	    if (base_url && whitelist.indexOf(base_url) === -1) {
	      whitelist.unshift(base_url);
	    }
	
	    for (var i = 0; i < whitelist.length; i++) {
	      var video_url = whitelist[i].replace(/\/join$/, '/(join|call|meeting)'),
	          video_re = new RegExp('^(https?://)?(www\\.)?' + video_url + '/.*', 'i');
	
	      if (video_re.test(link)) {
	        return true;
	      }
	    }
	
	    return false;
	  },
	
	  get_video_window_props: function get_video_window_props() {
	    var window_size = video_utils.size_window(_app_config.video_width, _app_config.video_height, _app_config.min_video_width, _app_config.min_video_height),
	        width = window_size.width,
	        height = window_size.height;
	
	    var width_ratio = width / _app_config.video_width;
	    var height_ratio = height / _app_config.video_height;
	
	    if (width_ratio < 1 && height_ratio < 1) {
	      if (width_ratio < height_ratio) {
	        width = Math.floor(_app_config.video_width * height_ratio);
	      } else {
	        height = Math.floor(_app_config.video_height * width_ratio);
	      }
	    } else if (height_ratio < 1) {
	      width = Math.floor(_app_config.video_width * height_ratio);
	    } else if (width_ratio < 1) {
	      height = Math.floor(_app_config.video_height * width_ratio);
	    }
	    var pos = video_utils.center_window(width, height);
	
	    return 'resizable=yes,width=' + width + ',height=' + height + ',top=' + pos.top + ',left=' + pos.left;
	  },
	
	  size_window: function size_window(target_w, target_h, min_w, min_h) {
	    var max_ratio = 0.9;
	    return {
	      width: Math.max(Math.min(Math.floor(window.screen.availWidth * max_ratio), target_w), min_w || 100),
	      height: Math.max(Math.min(Math.floor(window.screen.availHeight * max_ratio), target_h), min_h || 100)
	    };
	  },
	
	  center_window: function center_window(width, height) {
	    var w = window,
	        s = w.screen,
	        screenLeft = w.screenLeft !== null && w.screenLeft !== undefined ? w.screenLeft : s.left,
	        screenTop = w.screenTop !== null && w.screenTop !== undefined ? w.screenTop : s.top;
	    return {
	      left: Math.floor((s.availWidth - width) / 2) + screenLeft,
	      top: Math.floor((s.availHeight - height) / 3) + screenTop
	    };
	  }
	
	};
	
	exports.default = video_utils;
	module.exports = exports['default'];

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.clientSubType = exports.platform = undefined;
	
	var _client_subtype_keys = __webpack_require__(134);
	
	var _client_subtype_keys2 = _interopRequireDefault(_client_subtype_keys);
	
	var _browser_family_keys = __webpack_require__(135);
	
	var _browser_family_keys2 = _interopRequireDefault(_browser_family_keys);
	
	var _uaParserJs = __webpack_require__(139);
	
	var _uaParserJs2 = _interopRequireDefault(_uaParserJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var browser = {
	  is: {
	    ie_edge: function ie_edge() {
	      return _.includes(navigator.userAgent, 'Edge');
	    },
	    ie: function ie() {
	      return _.includes(navigator.userAgent, 'MSIE') || _.includes(navigator.appVersion, 'Trident/');
	    },
	    safari: function safari() {
	      return _.includes(navigator.userAgent, 'Safari') && !browser.is.chrome();
	    },
	    chrome: function chrome() {
	      return _.includes(navigator.userAgent, 'Chrome') && !browser.is.ie_edge();
	    },
	    firefox: function firefox() {
	      return _.includes(navigator.userAgent, 'Firefox') && !browser.is.ie_edge();
	    }
	  },
	
	  family: function family() {
	    var family = _browser_family_keys2.default.UNKNOWN;
	
	    if (browser.is.ie()) {
	      family = _browser_family_keys2.default.IE;
	    } else if (browser.is.ie_edge()) {
	      family = _browser_family_keys2.default.EDGE;
	    } else if (browser.is.safari()) {
	      family = _browser_family_keys2.default.SAFARI;
	    } else if (browser.is.chrome()) {
	      family = _browser_family_keys2.default.CHROME;
	    } else if (browser.is.firefox()) {
	      family = _browser_family_keys2.default.FIREFOX;
	    }
	
	    return family;
	  },
	
	  userAgent: function userAgent() {
	    if (!browser._userAgent) {
	      browser._userAgent = (0, _uaParserJs2.default)();
	    }
	    return browser._userAgent;
	  }
	};
	
	var platform = {
	  isMac: function isMac() {
	    var pltfrm = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    return platform._checkPlatform('MAC', pltfrm);
	  },
	  isWindows: function isWindows() {
	    var pltfrm = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    return platform._checkPlatform('WIN', pltfrm);
	  },
	  isLinux: function isLinux() {
	    var pltfrm = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    return platform._checkPlatform('LINUX', pltfrm);
	  },
	  _checkPlatform: function _checkPlatform(check, pltfrm) {
	    if (!pltfrm) {
	      pltfrm = navigator.platform;
	    }
	    return pltfrm.toUpperCase().indexOf(check) !== -1;
	  }
	};
	
	var clientSubType = {
	  isNative: function isNative(client_subtype) {
	    return clientSubType.isMac(client_subtype) || clientSubType.isQT(client_subtype);
	  },
	
	  isQT: function isQT(client_subtype) {
	    return clientSubType.isWindows(client_subtype) || clientSubType.isLinux(client_subtype) || clientSubType.isQTMac(client_subtype);
	  },
	
	  isWindows: function isWindows(client_subtype) {
	    return client_subtype === _client_subtype_keys2.default.QT_WINDOWS;
	  },
	
	  isQTMac: function isQTMac(client_subtype) {
	    return client_subtype === _client_subtype_keys2.default.QT_MAC;
	  },
	
	  isLinux: function isLinux(client_subtype) {
	    return client_subtype === _client_subtype_keys2.default.QT_LINUX;
	  },
	
	  isMac: function isMac(client_subtype) {
	    return client_subtype === _client_subtype_keys2.default.MAC_NATIVE;
	  }
	};
	
	exports.default = browser;
	exports.platform = platform;
	exports.clientSubType = clientSubType;

/***/ },
/* 134 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @typedef {{name: string, key: string}} clientSubtypeKeys
	 * @type {Object.<string, string>}
	 */
	module.exports = {
	  QT_WINDOWS: "windows",
	  QT_MAC: "mac",
	  QT_LINUX: "linux",
	  MAC_NATIVE: "macweb"
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _freeze2.default)({
	  UNKNOWN: 'unknown',
	  IE: 'ie',
	  EDGE: 'edge',
	  SAFARI: 'safari',
	  CHROME: 'chrome',
	  FIREFOX: 'firefox'
	});
	module.exports = exports['default'];

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(137), __esModule: true };

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(138);
	module.exports = __webpack_require__(18).Object.freeze;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(44);
	
	__webpack_require__(15)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(it) : it;
	  };
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * UAParser.js v0.7.10
	 * Lightweight JavaScript-based User-Agent string parser
	 * https://github.com/faisalman/ua-parser-js
	 *
	 * Copyright  2012-2015 Faisal Salman <fyzlman@gmail.com>
	 * Dual licensed under GPLv2 & MIT
	 */
	
	(function (window, undefined) {
	
	    'use strict';
	
	    //////////////
	    // Constants
	    /////////////
	
	
	    var LIBVERSION  = '0.7.10',
	        EMPTY       = '',
	        UNKNOWN     = '?',
	        FUNC_TYPE   = 'function',
	        UNDEF_TYPE  = 'undefined',
	        OBJ_TYPE    = 'object',
	        STR_TYPE    = 'string',
	        MAJOR       = 'major', // deprecated
	        MODEL       = 'model',
	        NAME        = 'name',
	        TYPE        = 'type',
	        VENDOR      = 'vendor',
	        VERSION     = 'version',
	        ARCHITECTURE= 'architecture',
	        CONSOLE     = 'console',
	        MOBILE      = 'mobile',
	        TABLET      = 'tablet',
	        SMARTTV     = 'smarttv',
	        WEARABLE    = 'wearable',
	        EMBEDDED    = 'embedded';
	
	
	    ///////////
	    // Helper
	    //////////
	
	
	    var util = {
	        extend : function (regexes, extensions) {
	            for (var i in extensions) {
	                if ("browser cpu device engine os".indexOf(i) !== -1 && extensions[i].length % 2 === 0) {
	                    regexes[i] = extensions[i].concat(regexes[i]);
	                }
	            }
	            return regexes;
	        },
	        has : function (str1, str2) {
	          if (typeof str1 === "string") {
	            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
	          } else {
	            return false;
	          }
	        },
	        lowerize : function (str) {
	            return str.toLowerCase();
	        },
	        major : function (version) {
	            return typeof(version) === STR_TYPE ? version.split(".")[0] : undefined;
	        }
	    };
	
	
	    ///////////////
	    // Map helper
	    //////////////
	
	
	    var mapper = {
	
	        rgx : function () {
	
	            var result, i = 0, j, k, p, q, matches, match, args = arguments;
	
	            // loop through all regexes maps
	            while (i < args.length && !matches) {
	
	                var regex = args[i],       // even sequence (0,2,4,..)
	                    props = args[i + 1];   // odd sequence (1,3,5,..)
	
	                // construct object barebones
	                if (typeof result === UNDEF_TYPE) {
	                    result = {};
	                    for (p in props) {
	                        if (props.hasOwnProperty(p)){
	                            q = props[p];
	                            if (typeof q === OBJ_TYPE) {
	                                result[q[0]] = undefined;
	                            } else {
	                                result[q] = undefined;
	                            }
	                        }
	                    }
	                }
	
	                // try matching uastring with regexes
	                j = k = 0;
	                while (j < regex.length && !matches) {
	                    matches = regex[j++].exec(this.getUA());
	                    if (!!matches) {
	                        for (p = 0; p < props.length; p++) {
	                            match = matches[++k];
	                            q = props[p];
	                            // check if given property is actually array
	                            if (typeof q === OBJ_TYPE && q.length > 0) {
	                                if (q.length == 2) {
	                                    if (typeof q[1] == FUNC_TYPE) {
	                                        // assign modified match
	                                        result[q[0]] = q[1].call(this, match);
	                                    } else {
	                                        // assign given value, ignore regex match
	                                        result[q[0]] = q[1];
	                                    }
	                                } else if (q.length == 3) {
	                                    // check whether function or regex
	                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
	                                        // call function (usually string mapper)
	                                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
	                                    } else {
	                                        // sanitize match using given regex
	                                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
	                                    }
	                                } else if (q.length == 4) {
	                                        result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
	                                }
	                            } else {
	                                result[q] = match ? match : undefined;
	                            }
	                        }
	                    }
	                }
	                i += 2;
	            }
	            return result;
	        },
	
	        str : function (str, map) {
	
	            for (var i in map) {
	                // check if array
	                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
	                    for (var j = 0; j < map[i].length; j++) {
	                        if (util.has(map[i][j], str)) {
	                            return (i === UNKNOWN) ? undefined : i;
	                        }
	                    }
	                } else if (util.has(map[i], str)) {
	                    return (i === UNKNOWN) ? undefined : i;
	                }
	            }
	            return str;
	        }
	    };
	
	
	    ///////////////
	    // String map
	    //////////////
	
	
	    var maps = {
	
	        browser : {
	            oldsafari : {
	                version : {
	                    '1.0'   : '/8',
	                    '1.2'   : '/1',
	                    '1.3'   : '/3',
	                    '2.0'   : '/412',
	                    '2.0.2' : '/416',
	                    '2.0.3' : '/417',
	                    '2.0.4' : '/419',
	                    '?'     : '/'
	                }
	            }
	        },
	
	        device : {
	            amazon : {
	                model : {
	                    'Fire Phone' : ['SD', 'KF']
	                }
	            },
	            sprint : {
	                model : {
	                    'Evo Shift 4G' : '7373KT'
	                },
	                vendor : {
	                    'HTC'       : 'APA',
	                    'Sprint'    : 'Sprint'
	                }
	            }
	        },
	
	        os : {
	            windows : {
	                version : {
	                    'ME'        : '4.90',
	                    'NT 3.11'   : 'NT3.51',
	                    'NT 4.0'    : 'NT4.0',
	                    '2000'      : 'NT 5.0',
	                    'XP'        : ['NT 5.1', 'NT 5.2'],
	                    'Vista'     : 'NT 6.0',
	                    '7'         : 'NT 6.1',
	                    '8'         : 'NT 6.2',
	                    '8.1'       : 'NT 6.3',
	                    '10'        : ['NT 6.4', 'NT 10.0'],
	                    'RT'        : 'ARM'
	                }
	            }
	        }
	    };
	
	
	    //////////////
	    // Regex map
	    /////////////
	
	
	    var regexes = {
	
	        browser : [[
	
	            // Presto based
	            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
	            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
	            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
	            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
	
	            ], [NAME, VERSION], [
	
	            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
	            ], [[NAME, 'Opera'], VERSION], [
	
	            // Mixed
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,
	                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer
	
	            // Trident based
	            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
	                                                                                // Avant/IEMobile/SlimBrowser/Baidu
	            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer
	
	            // Webkit/KHTML based
	            /(rekonq)\/([\w\.]+)*/i,                                            // Rekonq
	            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs)\/([\w\.-]+)/i
	                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS
	            ], [NAME, VERSION], [
	
	            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
	            ], [[NAME, 'IE'], VERSION], [
	
	            /(edge)\/((\d+)?[\w\.]+)/i                                          // Microsoft Edge
	            ], [NAME, VERSION], [
	
	            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
	            ], [[NAME, 'Yandex'], VERSION], [
	
	            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
	            ], [[NAME, /_/g, ' '], VERSION], [
	
	            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i,
	                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
	            /(qqbrowser)[\/\s]?([\w\.]+)/i
	                                                                                // QQBrowser
	            ], [NAME, VERSION], [
	
	            /(uc\s?browser)[\/\s]?([\w\.]+)/i,
	            /ucweb.+(ucbrowser)[\/\s]?([\w\.]+)/i,
	            /JUC.+(ucweb)[\/\s]?([\w\.]+)/i
	                                                                                // UCBrowser
	            ], [[NAME, 'UCBrowser'], VERSION], [
	
	            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
	            ], [[NAME, 'Dolphin'], VERSION], [
	
	            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
	            ], [[NAME, 'Chrome'], VERSION], [
	
	            /XiaoMi\/MiuiBrowser\/([\w\.]+)/i                                   // MIUI Browser
	            ], [VERSION, [NAME, 'MIUI Browser']], [
	
	            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)/i         // Android Browser
	            ], [VERSION, [NAME, 'Android Browser']], [
	
	            /FBAV\/([\w\.]+);/i                                                 // Facebook App for iOS
	            ], [VERSION, [NAME, 'Facebook']], [
	
	            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
	            ], [VERSION, [NAME, 'Firefox']], [
	
	            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
	            ], [VERSION, [NAME, 'Mobile Safari']], [
	
	            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
	            ], [VERSION, NAME], [
	
	            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
	            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [
	
	            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
	            /(webkit|khtml)\/([\w\.]+)/i
	            ], [NAME, VERSION], [
	
	            // Gecko based
	            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
	            ], [[NAME, 'Netscape'], VERSION], [
	            /(swiftfox)/i,                                                      // Swiftfox
	            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
	                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
	            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,
	                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
	            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla
	
	            // Other
	            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
	                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
	            /(links)\s\(([\w\.]+)/i,                                            // Links
	            /(gobrowser)\/?([\w\.]+)*/i,                                        // GoBrowser
	            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
	            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
	            ], [NAME, VERSION]
	
	            /* /////////////////////
	            // Media players BEGIN
	            ////////////////////////
	
	            , [
	
	            /(apple(?:coremedia|))\/((\d+)[\w\._]+)/i,                          // Generic Apple CoreMedia
	            /(coremedia) v((\d+)[\w\._]+)/i
	            ], [NAME, VERSION], [
	
	            /(aqualung|lyssna|bsplayer)\/((\d+)?[\w\.-]+)/i                     // Aqualung/Lyssna/BSPlayer
	            ], [NAME, VERSION], [
	
	            /(ares|ossproxy)\s((\d+)[\w\.-]+)/i                                 // Ares/OSSProxy
	            ], [NAME, VERSION], [
	
	            /(audacious|audimusicstream|amarok|bass|core|dalvik|gnomemplayer|music on console|nsplayer|psp-internetradioplayer|videos)\/((\d+)[\w\.-]+)/i,
	                                                                                // Audacious/AudiMusicStream/Amarok/BASS/OpenCORE/Dalvik/GnomeMplayer/MoC
	                                                                                // NSPlayer/PSP-InternetRadioPlayer/Videos
	            /(clementine|music player daemon)\s((\d+)[\w\.-]+)/i,               // Clementine/MPD
	            /(lg player|nexplayer)\s((\d+)[\d\.]+)/i,
	            /player\/(nexplayer|lg player)\s((\d+)[\w\.-]+)/i                   // NexPlayer/LG Player
	            ], [NAME, VERSION], [
	            /(nexplayer)\s((\d+)[\w\.-]+)/i                                     // Nexplayer
	            ], [NAME, VERSION], [
	
	            /(flrp)\/((\d+)[\w\.-]+)/i                                          // Flip Player
	            ], [[NAME, 'Flip Player'], VERSION], [
	
	            /(fstream|nativehost|queryseekspider|ia-archiver|facebookexternalhit)/i
	                                                                                // FStream/NativeHost/QuerySeekSpider/IA Archiver/facebookexternalhit
	            ], [NAME], [
	
	            /(gstreamer) souphttpsrc (?:\([^\)]+\)){0,1} libsoup\/((\d+)[\w\.-]+)/i
	                                                                                // Gstreamer
	            ], [NAME, VERSION], [
	
	            /(htc streaming player)\s[\w_]+\s\/\s((\d+)[\d\.]+)/i,              // HTC Streaming Player
	            /(java|python-urllib|python-requests|wget|libcurl)\/((\d+)[\w\.-_]+)/i,
	                                                                                // Java/urllib/requests/wget/cURL
	            /(lavf)((\d+)[\d\.]+)/i                                             // Lavf (FFMPEG)
	            ], [NAME, VERSION], [
	
	            /(htc_one_s)\/((\d+)[\d\.]+)/i                                      // HTC One S
	            ], [[NAME, /_/g, ' '], VERSION], [
	
	            /(mplayer)(?:\s|\/)(?:(?:sherpya-){0,1}svn)(?:-|\s)(r\d+(?:-\d+[\w\.-]+){0,1})/i
	                                                                                // MPlayer SVN
	            ], [NAME, VERSION], [
	
	            /(mplayer)(?:\s|\/|[unkow-]+)((\d+)[\w\.-]+)/i                      // MPlayer
	            ], [NAME, VERSION], [
	
	            /(mplayer)/i,                                                       // MPlayer (no other info)
	            /(yourmuze)/i,                                                      // YourMuze
	            /(media player classic|nero showtime)/i                             // Media Player Classic/Nero ShowTime
	            ], [NAME], [
	
	            /(nero (?:home|scout))\/((\d+)[\w\.-]+)/i                           // Nero Home/Nero Scout
	            ], [NAME, VERSION], [
	
	            /(nokia\d+)\/((\d+)[\w\.-]+)/i                                      // Nokia
	            ], [NAME, VERSION], [
	
	            /\s(songbird)\/((\d+)[\w\.-]+)/i                                    // Songbird/Philips-Songbird
	            ], [NAME, VERSION], [
	
	            /(winamp)3 version ((\d+)[\w\.-]+)/i,                               // Winamp
	            /(winamp)\s((\d+)[\w\.-]+)/i,
	            /(winamp)mpeg\/((\d+)[\w\.-]+)/i
	            ], [NAME, VERSION], [
	
	            /(ocms-bot|tapinradio|tunein radio|unknown|winamp|inlight radio)/i  // OCMS-bot/tap in radio/tunein/unknown/winamp (no other info)
	                                                                                // inlight radio
	            ], [NAME], [
	
	            /(quicktime|rma|radioapp|radioclientapplication|soundtap|totem|stagefright|streamium)\/((\d+)[\w\.-]+)/i
	                                                                                // QuickTime/RealMedia/RadioApp/RadioClientApplication/
	                                                                                // SoundTap/Totem/Stagefright/Streamium
	            ], [NAME, VERSION], [
	
	            /(smp)((\d+)[\d\.]+)/i                                              // SMP
	            ], [NAME, VERSION], [
	
	            /(vlc) media player - version ((\d+)[\w\.]+)/i,                     // VLC Videolan
	            /(vlc)\/((\d+)[\w\.-]+)/i,
	            /(xbmc|gvfs|xine|xmms|irapp)\/((\d+)[\w\.-]+)/i,                    // XBMC/gvfs/Xine/XMMS/irapp
	            /(foobar2000)\/((\d+)[\d\.]+)/i,                                    // Foobar2000
	            /(itunes)\/((\d+)[\d\.]+)/i                                         // iTunes
	            ], [NAME, VERSION], [
	
	            /(wmplayer)\/((\d+)[\w\.-]+)/i,                                     // Windows Media Player
	            /(windows-media-player)\/((\d+)[\w\.-]+)/i
	            ], [[NAME, /-/g, ' '], VERSION], [
	
	            /windows\/((\d+)[\w\.-]+) upnp\/[\d\.]+ dlnadoc\/[\d\.]+ (home media server)/i
	                                                                                // Windows Media Server
	            ], [VERSION, [NAME, 'Windows']], [
	
	            /(com\.riseupradioalarm)\/((\d+)[\d\.]*)/i                          // RiseUP Radio Alarm
	            ], [NAME, VERSION], [
	
	            /(rad.io)\s((\d+)[\d\.]+)/i,                                        // Rad.io
	            /(radio.(?:de|at|fr))\s((\d+)[\d\.]+)/i
	            ], [[NAME, 'rad.io'], VERSION]
	
	            //////////////////////
	            // Media players END
	            ////////////////////*/
	
	        ],
	
	        cpu : [[
	
	            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
	            ], [[ARCHITECTURE, 'amd64']], [
	
	            /(ia32(?=;))/i                                                      // IA32 (quicktime)
	            ], [[ARCHITECTURE, util.lowerize]], [
	
	            /((?:i[346]|x)86)[;\)]/i                                            // IA32
	            ], [[ARCHITECTURE, 'ia32']], [
	
	            // PocketPC mistakenly identified as PowerPC
	            /windows\s(ce|mobile);\sppc;/i
	            ], [[ARCHITECTURE, 'arm']], [
	
	            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
	            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [
	
	            /(sun4\w)[;\)]/i                                                    // SPARC
	            ], [[ARCHITECTURE, 'sparc']], [
	
	            /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
	                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
	            ], [[ARCHITECTURE, util.lowerize]]
	        ],
	
	        device : [[
	
	            /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
	            ], [MODEL, VENDOR, [TYPE, TABLET]], [
	
	            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
	            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [
	
	            /(apple\s{0,1}tv)/i                                                 // Apple TV
	            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [
	
	            /(archos)\s(gamepad2?)/i,                                           // Archos
	            /(hp).+(touchpad)/i,                                                // HP TouchPad
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
	            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
	            ], [VENDOR, MODEL, [TYPE, TABLET]], [
	
	            /(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i                               // Kindle Fire HD
	            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
	            /(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i                  // Fire Phone
	            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [
	
	            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
	            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
	            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
	            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [
	
	            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
	            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|huawei|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i,
	                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Huawei/Meizu/Motorola/Polytron
	            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
	            /(asus)-?(\w+)/i                                                    // Asus
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
	            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
	            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
	                                                                                // Asus Tablets
	            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7)/i
	            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [
	
	            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
	            /(sony)?(?:sgp.+)\sbuild\//i
	            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
	            /(?:sony)?(?:(?:(?:c|d)\d{4})|(?:so[-l].+))\sbuild\//i
	            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Phone'], [TYPE, MOBILE]], [
	
	            /\s(ouya)\s/i,                                                      // Ouya
	            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
	            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
	
	            /android.+;\s(shield)\sbuild/i                                      // Nvidia
	            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
	
	            /(playstation\s[34portablevi]+)/i                                   // Playstation
	            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [
	
	            /(sprint\s(\w+))/i                                                  // Sprint Phones
	            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [
	
	            /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i                         // Lenovo tablets
	            ], [VENDOR, MODEL, [TYPE, TABLET]], [
	
	            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
	            /(zte)-(\w+)*/i,                                                    // ZTE
	            /(alcatel|geeksphone|huawei|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i
	                                                                                // Alcatel/GeeksPhone/Huawei/Lenovo/Nexian/Panasonic/Sony
	            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [
	                
	            /(nexus\s9)/i                                                       // HTC Nexus 9
	            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
	
	            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
	            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
	            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
	            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [
	
	                                                                                // Motorola
	            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i,
	            /mot[\s-]?(\w+)*/i,
	            /(XT\d{3,4}) build\//i,
	            /(nexus\s[6])/i
	            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
	            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
	            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [
	
	            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n8000|sgh-t8[56]9|nexus 10))/i,
	            /((SM-T\w+))/i
	            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
	            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-n900))/i,
	            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,
	            /sec-((sgh\w+))/i
	            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [
	            /(samsung);smarttv/i
	            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
	
	            /\(dtv[\);].+(aquos)/i                                              // Sharp
	            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [
	            /sie-(\w+)*/i                                                       // Siemens
	            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
	
	            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
	            /(nokia)[\s_-]?([\w-]+)*/i
	            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [
	
	            /android\s3\.[\s\w;-]{10}(a\d{3})/i                                 // Acer
	            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [
	
	            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
	            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
	            /(lg) netcast\.tv/i                                                 // LG SmartTV
	            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
	            /(nexus\s[45])/i,                                                   // LG
	            /lg[e;\s\/-]+(\w+)*/i
	            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [
	
	            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
	            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [
	
	            /linux;.+((jolla));/i                                               // Jolla
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
	
	            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
	            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
	
	            /android.+;\s(glass)\s\d/i                                          // Google Glass
	            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [
	
	            /android.+(\w+)\s+build\/hm\1/i,                                        // Xiaomi Hongmi 'numeric' models
	            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,                   // Xiaomi Hongmi
	            /android.+(mi[\s\-_]*(?:one|one[\s_]plus)?[\s_]*(?:\d\w)?)\s+build/i    // Xiaomi Mi
	            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
	
	            /\s(tablet)[;\/\s]/i,                                               // Unidentifiable Tablet
	            /\s(mobile)[;\/\s]/i                                                // Unidentifiable Mobile
	            ], [[TYPE, util.lowerize], VENDOR, MODEL]
	
	            /*//////////////////////////
	            // TODO: move to string map
	            ////////////////////////////
	
	            /(C6603)/i                                                          // Sony Xperia Z C6603
	            ], [[MODEL, 'Xperia Z C6603'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [
	            /(C6903)/i                                                          // Sony Xperia Z 1
	            ], [[MODEL, 'Xperia Z 1'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [
	
	            /(SM-G900[F|H])/i                                                   // Samsung Galaxy S5
	            ], [[MODEL, 'Galaxy S5'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
	            /(SM-G7102)/i                                                       // Samsung Galaxy Grand 2
	            ], [[MODEL, 'Galaxy Grand 2'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
	            /(SM-G530H)/i                                                       // Samsung Galaxy Grand Prime
	            ], [[MODEL, 'Galaxy Grand Prime'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
	            /(SM-G313HZ)/i                                                      // Samsung Galaxy V
	            ], [[MODEL, 'Galaxy V'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
	            /(SM-T805)/i                                                        // Samsung Galaxy Tab S 10.5
	            ], [[MODEL, 'Galaxy Tab S 10.5'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [
	            /(SM-G800F)/i                                                       // Samsung Galaxy S5 Mini
	            ], [[MODEL, 'Galaxy S5 Mini'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
	            /(SM-T311)/i                                                        // Samsung Galaxy Tab 3 8.0
	            ], [[MODEL, 'Galaxy Tab 3 8.0'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [
	
	            /(R1001)/i                                                          // Oppo R1001
	            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [
	            /(X9006)/i                                                          // Oppo Find 7a
	            ], [[MODEL, 'Find 7a'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [
	            /(R2001)/i                                                          // Oppo YOYO R2001
	            ], [[MODEL, 'Yoyo R2001'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [
	            /(R815)/i                                                           // Oppo Clover R815
	            ], [[MODEL, 'Clover R815'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [
	             /(U707)/i                                                          // Oppo Find Way S
	            ], [[MODEL, 'Find Way S'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [
	
	            /(T3C)/i                                                            // Advan Vandroid T3C
	            ], [MODEL, [VENDOR, 'Advan'], [TYPE, TABLET]], [
	            /(ADVAN T1J\+)/i                                                    // Advan Vandroid T1J+
	            ], [[MODEL, 'Vandroid T1J+'], [VENDOR, 'Advan'], [TYPE, TABLET]], [
	            /(ADVAN S4A)/i                                                      // Advan Vandroid S4A
	            ], [[MODEL, 'Vandroid S4A'], [VENDOR, 'Advan'], [TYPE, MOBILE]], [
	
	            /(V972M)/i                                                          // ZTE V972M
	            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
	
	            /(i-mobile)\s(IQ\s[\d\.]+)/i                                        // i-mobile IQ
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
	            /(IQ6.3)/i                                                          // i-mobile IQ IQ 6.3
	            ], [[MODEL, 'IQ 6.3'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [
	            /(i-mobile)\s(i-style\s[\d\.]+)/i                                   // i-mobile i-STYLE
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
	            /(i-STYLE2.1)/i                                                     // i-mobile i-STYLE 2.1
	            ], [[MODEL, 'i-STYLE 2.1'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [
	            
	            /(mobiistar touch LAI 512)/i                                        // mobiistar touch LAI 512
	            ], [[MODEL, 'Touch LAI 512'], [VENDOR, 'mobiistar'], [TYPE, MOBILE]], [
	
	            /////////////
	            // END TODO
	            ///////////*/
	
	        ],
	
	        engine : [[
	
	            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
	            ], [VERSION, [NAME, 'EdgeHTML']], [
	
	            /(presto)\/([\w\.]+)/i,                                             // Presto
	            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
	            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
	            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
	            ], [NAME, VERSION], [
	
	            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
	            ], [VERSION, NAME]
	        ],
	
	        os : [[
	
	            // Windows based
	            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
	            ], [NAME, VERSION], [
	            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
	            /(windows\sphone(?:\sos)*|windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
	            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
	            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
	            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [
	
	            // Mobile/Embedded OS
	            /\((bb)(10);/i                                                      // BlackBerry 10
	            ], [[NAME, 'BlackBerry'], VERSION], [
	            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
	            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
	            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,
	                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
	            /linux;.+(sailfish);/i                                              // Sailfish OS
	            ], [NAME, VERSION], [
	            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
	            ], [[NAME, 'Symbian'], VERSION], [
	            /\((series40);/i                                                    // Series 40
	            ], [NAME], [
	            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
	            ], [[NAME, 'Firefox OS'], VERSION], [
	
	            // Console
	            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation
	
	            // GNU/Linux based
	            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
	            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
	            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?([\w\.-]+)*/i,
	                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
	                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
	            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
	            /(gnu)\s?([\w\.]+)*/i                                               // GNU
	            ], [NAME, VERSION], [
	
	            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
	            ], [[NAME, 'Chromium OS'], VERSION],[
	
	            // Solaris
	            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
	            ], [[NAME, 'Solaris'], VERSION], [
	
	            // BSD based
	            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
	            ], [NAME, VERSION],[
	
	            /(ip[honead]+)(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i              // iOS
	            ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [
	
	            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i,
	            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
	            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [
	
	            // Other
	            /((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,                            // Solaris
	            /(haiku)\s(\w+)/i,                                                  // Haiku
	            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
	            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
	                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
	            /(unix)\s?([\w\.]+)*/i                                              // UNIX
	            ], [NAME, VERSION]
	        ]
	    };
	
	
	    /////////////////
	    // Constructor
	    ////////////////
	
	
	    var UAParser = function (uastring, extensions) {
	
	        if (!(this instanceof UAParser)) {
	            return new UAParser(uastring, extensions).getResult();
	        }
	
	        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
	        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
	
	        this.getBrowser = function () {
	            var browser = mapper.rgx.apply(this, rgxmap.browser);
	            browser.major = util.major(browser.version);
	            return browser;
	        };
	        this.getCPU = function () {
	            return mapper.rgx.apply(this, rgxmap.cpu);
	        };
	        this.getDevice = function () {
	            return mapper.rgx.apply(this, rgxmap.device);
	        };
	        this.getEngine = function () {
	            return mapper.rgx.apply(this, rgxmap.engine);
	        };
	        this.getOS = function () {
	            return mapper.rgx.apply(this, rgxmap.os);
	        };
	        this.getResult = function() {
	            return {
	                ua      : this.getUA(),
	                browser : this.getBrowser(),
	                engine  : this.getEngine(),
	                os      : this.getOS(),
	                device  : this.getDevice(),
	                cpu     : this.getCPU()
	            };
	        };
	        this.getUA = function () {
	            return ua;
	        };
	        this.setUA = function (uastring) {
	            ua = uastring;
	            return this;
	        };
	        this.setUA(ua);
	        return this;
	    };
	
	    UAParser.VERSION = LIBVERSION;
	    UAParser.BROWSER = {
	        NAME    : NAME,
	        MAJOR   : MAJOR, // deprecated
	        VERSION : VERSION
	    };
	    UAParser.CPU = {
	        ARCHITECTURE : ARCHITECTURE
	    };
	    UAParser.DEVICE = {
	        MODEL   : MODEL,
	        VENDOR  : VENDOR,
	        TYPE    : TYPE,
	        CONSOLE : CONSOLE,
	        MOBILE  : MOBILE,
	        SMARTTV : SMARTTV,
	        TABLET  : TABLET,
	        WEARABLE: WEARABLE,
	        EMBEDDED: EMBEDDED
	    };
	    UAParser.ENGINE = {
	        NAME    : NAME,
	        VERSION : VERSION
	    };
	    UAParser.OS = {
	        NAME    : NAME,
	        VERSION : VERSION
	    };
	
	
	    ///////////
	    // Export
	    //////////
	
	
	    // check js environment
	    if (typeof(exports) !== UNDEF_TYPE) {
	        // nodejs env
	        if (typeof module !== UNDEF_TYPE && module.exports) {
	            exports = module.exports = UAParser;
	        }
	        exports.UAParser = UAParser;
	    } else {
	        // requirejs env (optional)
	        if ("function" === FUNC_TYPE && __webpack_require__(140)) {
	            !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	                return UAParser;
	            }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	        } else {
	            // browser env
	            window.UAParser = UAParser;
	        }
	    }
	
	    // jQuery/Zepto specific (optional)
	    // Note: 
	    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
	    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
	    //   and we should catch that.
	    var $ = window.jQuery || window.Zepto;
	    if (typeof $ !== UNDEF_TYPE) {
	        var parser = new UAParser();
	        $.ua = parser.getResult();
	        $.ua.get = function() {
	            return parser.getUA();
	        };
	        $.ua.set = function (uastring) {
	            parser.setUA(uastring);
	            var result = parser.getResult();
	            for (var prop in result) {
	                $.ua[prop] = result[prop];
	            }
	        };
	    }
	
	})(typeof window === 'object' ? window : this);


/***/ },
/* 140 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 141 */
/***/ function(module, exports) {

	module.exports = {
		"connect_api_version": 1,
		"minimum_connect_api_version": 1
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _uri = __webpack_require__(143);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var URI = function () {
	  (0, _createClass3.default)(URI, null, [{
	    key: 'getProtocol',
	
	
	    /**
	     * Returns the scheme of a URI without parsing the URI, e.g. for URI templates and similar.
	     * This method is here for backward compatibility and URI.parse(uri).getScheme() should be used for new code.
	     * @param {string} uri The raw URI
	     * @returns {string} The scheme of the URI, e.g. 'https' for 'https://example.com'
	     */
	    value: function getProtocol(uri) {
	      var parts = uri.split(':');
	      return parts.length > 0 ? parts[0] : '';
	    }
	
	    /**
	     * Parses a URI
	     * @param {string} uri The raw URI
	     * @returns {URI|null} The URI or null, if 'uri' does not parse.
	     */
	
	  }, {
	    key: 'parse',
	    value: function parse(uri) {
	      var parsed = _uri.URI.parse(uri);
	      return parsed ? new URI(parsed) : null;
	    }
	  }]);
	
	  function URI(cajaUri) {
	    (0, _classCallCheck3.default)(this, URI);
	
	    this.uri = cajaUri;
	  }
	
	  /**
	   * Checks if a URI matches the native HipChat URI scheme: hipchat://www.hipchat.com/room/123.
	   * The host part must be 'www.hipchat.com' or match the base URL of the HC Server.
	   * @returns {boolean} true if it matches, false otherwise
	   */
	
	
	  (0, _createClass3.default)(URI, [{
	    key: 'isHipchatNative',
	    value: function isHipchatNative(baseUrl) {
	      var base = _uri.URI.parse(baseUrl);
	      var host = this.uri.getDomain();
	      return "hipchat" === this.uri.getScheme() && ("www.hipchat.com" === host || base.getDomain() === host);
	    }
	
	    /**
	     * Returns the room ID or name for HipChat native URIs
	     * @returns {string|null} null if the URI is not a native URI or does not point to a room. Returns the room ID or name
	     */
	
	  }, {
	    key: 'getRoom',
	    value: function getRoom() {
	      return this._nativePathElement('room');
	    }
	
	    /**
	     * Checks whether the URI is a HipChat native URI and points to a room
	     * @returns {boolean} true if it points to a room, false otherwise
	     */
	
	  }, {
	    key: 'containsRoom',
	    value: function containsRoom() {
	      return this.getRoom() !== null;
	    }
	
	    /**
	     * Returns the user ID, @mention or email for HipChat native URIs
	     * @returns {string|null} null if the URI is not a native URI or does not point to a user;
	     */
	
	  }, {
	    key: 'getUser',
	    value: function getUser() {
	      return this._nativePathElement('user');
	    }
	
	    /**
	     * Checks whether the URI is a HipChat native URI and points to a user
	     * @returns {boolean} true if it points to a user, false otherwise
	     */
	
	  }, {
	    key: 'containsUser',
	    value: function containsUser() {
	      return this.getUser() !== null;
	    }
	
	    /**
	     * Returns the base URI, e.g. 'https://example.com' for 'https://example.com/path/?q=query
	     * @returns {string} the base URI
	     */
	
	  }, {
	    key: 'getBase',
	    value: function getBase() {
	      var baseUri = _uri.URI.create(this.uri.getScheme(), this.uri.getCredentials(), this.uri.getDomain(), this.uri.getPort());
	      return baseUri.toString();
	    }
	
	    /**
	     * @returns {string} The scheme of the URI, e.g. 'https' for 'https://example.com'
	     */
	
	  }, {
	    key: 'getScheme',
	    value: function getScheme() {
	      return this.uri.getScheme();
	    }
	
	    /**
	     * @returns {boolean} whether the URI has a scheme
	     */
	
	  }, {
	    key: 'hasScheme',
	    value: function hasScheme() {
	      return this.uri.hasScheme();
	    }
	
	    /**
	     * @returns {string} The decoded domain of the URI, e.g. 'example.com' for 'https://example.com:80'
	     */
	
	  }, {
	    key: 'getDomain',
	    value: function getDomain() {
	      return this.uri.getDomain();
	    }
	
	    /**
	     * @returns {boolean} whether the URI has a domain
	     */
	
	  }, {
	    key: 'hasDomain',
	    value: function hasDomain() {
	      return this.uri.hasDomain();
	    }
	
	    /**
	     * @returns {string} The port of the URI, e.g. '80' for 'https://example.com:80'
	     */
	
	  }, {
	    key: 'getPort',
	    value: function getPort() {
	      return this.uri.getPort();
	    }
	
	    /**
	     * @returns {boolean} whether the URI has a port
	     */
	
	  }, {
	    key: 'hasPort',
	    value: function hasPort() {
	      return this.uri.hasPort();
	    }
	
	    /**
	     * @returns {string} The decoded path of the URI, e.g. '/path' for 'https://example.com/path'
	     */
	
	  }, {
	    key: 'getPath',
	    value: function getPath() {
	      return this.uri.getPath();
	    }
	
	    /**
	     * @returns {boolean} whether the URI has a path
	     */
	
	  }, {
	    key: 'hasPath',
	    value: function hasPath() {
	      return this.uri.hasPath();
	    }
	
	    /**
	     * @returns {string} The decoded query of the URI, e.g. '?q=query' for 'https://example.com/path?q=query'
	     */
	
	  }, {
	    key: 'getQuery',
	    value: function getQuery() {
	      return this.uri.getQuery();
	    }
	
	    /**
	     * @returns {boolean} whether the URI has a query
	     */
	
	  }, {
	    key: 'hasQuery',
	    value: function hasQuery() {
	      return this.uri.hasQuery();
	    }
	
	    /**
	     * @returns {string} The decoded fragment of the URI, e.g. 'frag' for 'https://example.com/path#frag'
	     */
	
	  }, {
	    key: 'getFragment',
	    value: function getFragment() {
	      return this.uri.getFragment();
	    }
	
	    /**
	     * @returns {boolean} whether the URI has a fragment
	     */
	
	  }, {
	    key: 'hasFragment',
	    value: function hasFragment() {
	      return this.uri.hasFragment();
	    }
	
	    /**
	     * Returns all query parameters as an array of keys and values like [ key0, value0, key1, value1, ... ]
	     * @returns {Array.<string>}
	     */
	
	  }, {
	    key: 'getAllParameters',
	    value: function getAllParameters() {
	      return this.uri.getAllParameters();
	    }
	
	    /**
	     * Returns the decoded values of a particular query parameter. E.g. ['a','b'] for 'q' where the query is '?q=a&q=b'
	     * @param paramNameUnescaped the name of the query parameter (not escaped)
	     * @returns {Array.<string>}
	     */
	
	  }, {
	    key: 'getParameterValues',
	    value: function getParameterValues(paramNameUnescaped) {
	      return this.uri.getParameterValues(paramNameUnescaped);
	    }
	
	    /**
	     * Returns a map of non-empty lists for the query parameters. E.g. {x:['a'],y:['b']} for '?x=a&y=b'
	     * @returns {Object.<string, Array.<string>>}
	     */
	
	  }, {
	    key: 'getParameterMap',
	    value: function getParameterMap() {
	      return this.uri.getParameterMap();
	    }
	
	    /**
	     * Returns the first value for a given query parameter or null if the given
	     * parameter name does not appear in the query string.
	     * If the given parameter name does appear, but has no '=' following
	     * it, then the empty string will be returned.
	     * @param paramNameUnescaped the name of the query parameter (not escaped)
	     * @returns {string|null}
	     */
	
	  }, {
	    key: 'getParameterValue',
	    value: function getParameterValue(paramNameUnescaped) {
	      return this.uri.getParameterValue(paramNameUnescaped);
	    }
	
	    /**
	     * Sets the value(s) of query parameter
	     * @param {string} key The query parameter key
	     * @param {string|Array.<string>} values The value or values of the query parameter
	     */
	
	  }, {
	    key: 'setParameterValues',
	    value: function setParameterValues(key, values) {
	      this.uri.setParameterValues(key, _.isArray(values) ? values : [values]);
	      return this;
	    }
	
	    /**
	     * Removes a query parameter
	     * @param {string} key
	     */
	
	  }, {
	    key: 'removeParameter',
	    value: function removeParameter(key) {
	      this.uri.removeParameter(key);
	      return this;
	    }
	
	    /**
	     * @param {string} fragment the url fragment
	     * @returns {string} The decoded fragment of the URI, e.g. 'frag' for 'https://example.com/path#frag'
	     */
	
	  }, {
	    key: 'setFragment',
	    value: function setFragment(fragment) {
	      if (_.isObject(fragment)) {
	        var parts = [];
	        for (var key in fragment) {
	          parts.push(key + '=' + fragment[key]);
	        }
	        fragment = parts.join('&');
	      }
	      this.uri.setRawFragment(fragment);
	      return this;
	    }
	
	    /**
	     * Get the string representation of the URI
	     * @returns {string}
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      var uri = this.uri.toString();
	      return _.endsWith(uri, '?') ? uri.substr(0, uri.length - 1) : uri;
	    }
	  }, {
	    key: '_nativePathElement',
	    value: function _nativePathElement(context) {
	      var pathElements = this.uri.getPath().split('/');
	      if (pathElements.length === 3 && pathElements[1] === context) {
	        return pathElements[2];
	      }
	      return null;
	    }
	  }]);
	  return URI;
	}();
	
	exports.default = URI;
	module.exports = exports['default'];

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright (C) 2010 Google Inc.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//      http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	
	/**
	 * @fileoverview
	 * Implements RFC 3986 for parsing/formatting URIs.
	 *
	 * @author mikesamuel@gmail.com
	 * \@provides URI
	 * \@overrides window
	 */
	
	var URI = (function () {
	
	    /**
	     * creates a uri from the string form.  The parser is relaxed, so special
	     * characters that aren't escaped but don't cause ambiguities will not cause
	     * parse failures.
	     *
	     * @return {URI|null}
	     */
	    function parse(uriStr) {
	        var m = ('' + uriStr).match(URI_RE_);
	        if (!m) { return null; }
	        return new URI(
	            nullIfAbsent(m[1]),
	            nullIfAbsent(m[2]),
	            nullIfAbsent(m[3]),
	            nullIfAbsent(m[4]),
	            nullIfAbsent(m[5]),
	            nullIfAbsent(m[6]),
	            nullIfAbsent(m[7]));
	    }
	
	
	    /**
	     * creates a uri from the given parts.
	     *
	     * @param scheme {string} an unencoded scheme such as "http" or null
	     * @param credentials {string} unencoded user credentials or null
	     * @param domain {string} an unencoded domain name or null
	     * @param port {number} a port number in [1, 32768].
	     *    -1 indicates no port, as does null.
	     * @param path {string} an unencoded path
	     * @param query {Array.<string>|string|null} a list of unencoded cgi
	     *   parameters where even values are keys and odds the corresponding values
	     *   or an unencoded query.
	     * @param fragment {string} an unencoded fragment without the "#" or null.
	     * @return {URI}
	     */
	    function create(scheme, credentials, domain, port, path, query, fragment) {
	        var uri = new URI(
	            encodeIfExists2(scheme, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),
	            encodeIfExists2(
	                credentials, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),
	            encodeIfExists(domain),
	            port > 0 ? port.toString() : null,
	            encodeIfExists2(path, URI_DISALLOWED_IN_PATH_),
	            null,
	            encodeIfExists(fragment));
	        if (query) {
	            if ('string' === typeof query) {
	                uri.setRawQuery(query.replace(/[^?&=0-9A-Za-z_\-~.%]/g, encodeOne));
	            } else {
	                uri.setAllParameters(query);
	            }
	        }
	        return uri;
	    }
	    function encodeIfExists(unescapedPart) {
	        if ('string' == typeof unescapedPart) {
	            return encodeURIComponent(unescapedPart);
	        }
	        return null;
	    };
	    /**
	     * if unescapedPart is non null, then escapes any characters in it that aren't
	     * valid characters in a url and also escapes any special characters that
	     * appear in extra.
	     *
	     * @param unescapedPart {string}
	     * @param extra {RegExp} a character set of characters in [\01-\177].
	     * @return {string|null} null iff unescapedPart == null.
	     */
	    function encodeIfExists2(unescapedPart, extra) {
	        if ('string' == typeof unescapedPart) {
	            return encodeURI(unescapedPart).replace(extra, encodeOne);
	        }
	        return null;
	    };
	    /** converts a character in [\01-\177] to its url encoded equivalent. */
	    function encodeOne(ch) {
	        var n = ch.charCodeAt(0);
	        return '%' + '0123456789ABCDEF'.charAt((n >> 4) & 0xf) +
	            '0123456789ABCDEF'.charAt(n & 0xf);
	    }
	
	    /**
	     * {@updoc
	     *  $ normPath('foo/./bar')
	     *  # 'foo/bar'
	     *  $ normPath('./foo')
	     *  # 'foo'
	     *  $ normPath('foo/.')
	     *  # 'foo'
	     *  $ normPath('foo//bar')
	     *  # 'foo/bar'
	     * }
	     */
	    function normPath(path) {
	        return path.replace(/(^|\/)\.(?:\/|$)/g, '$1').replace(/\/{2,}/g, '/');
	    }
	
	    var PARENT_DIRECTORY_HANDLER = new RegExp(
	        ''
	            // A path break
	            + '(/|^)'
	            // followed by a non .. path element
	            // (cannot be . because normPath is used prior to this RegExp)
	            + '(?:[^./][^/]*|\\.{2,}(?:[^./][^/]*)|\\.{3,}[^/]*)'
	            // followed by .. followed by a path break.
	            + '/\\.\\.(?:/|$)');
	
	    var PARENT_DIRECTORY_HANDLER_RE = new RegExp(PARENT_DIRECTORY_HANDLER);
	
	    var EXTRA_PARENT_PATHS_RE = /^(?:\.\.\/)*(?:\.\.$)?/;
	
	    /**
	     * Normalizes its input path and collapses all . and .. sequences except for
	     * .. sequences that would take it above the root of the current parent
	     * directory.
	     * {@updoc
	     *  $ collapse_dots('foo/../bar')
	     *  # 'bar'
	     *  $ collapse_dots('foo/./bar')
	     *  # 'foo/bar'
	     *  $ collapse_dots('foo/../bar/./../../baz')
	     *  # 'baz'
	     *  $ collapse_dots('../foo')
	     *  # '../foo'
	     *  $ collapse_dots('../foo').replace(EXTRA_PARENT_PATHS_RE, '')
	     *  # 'foo'
	     * }
	     */
	    function collapse_dots(path) {
	        if (path === null) { return null; }
	        var p = normPath(path);
	        // Only /../ left to flatten
	        var r = PARENT_DIRECTORY_HANDLER_RE;
	        // We replace with $1 which matches a / before the .. because this
	        // guarantees that:
	        // (1) we have at most 1 / between the adjacent place,
	        // (2) always have a slash if there is a preceding path section, and
	        // (3) we never turn a relative path into an absolute path.
	        for (var q; (q = p.replace(r, '$1')) != p; p = q) {};
	        return p;
	    }
	
	    /**
	     * resolves a relative url string to a base uri.
	     * @return {URI}
	     */
	    function resolve(baseUri, relativeUri) {
	        // there are several kinds of relative urls:
	        // 1. //foo - replaces everything from the domain on.  foo is a domain name
	        // 2. foo - replaces the last part of the path, the whole query and fragment
	        // 3. /foo - replaces the the path, the query and fragment
	        // 4. ?foo - replace the query and fragment
	        // 5. #foo - replace the fragment only
	
	        var absoluteUri = baseUri.clone();
	        // we satisfy these conditions by looking for the first part of relativeUri
	        // that is not blank and applying defaults to the rest
	
	        var overridden = relativeUri.hasScheme();
	
	        if (overridden) {
	            absoluteUri.setRawScheme(relativeUri.getRawScheme());
	        } else {
	            overridden = relativeUri.hasCredentials();
	        }
	
	        if (overridden) {
	            absoluteUri.setRawCredentials(relativeUri.getRawCredentials());
	        } else {
	            overridden = relativeUri.hasDomain();
	        }
	
	        if (overridden) {
	            absoluteUri.setRawDomain(relativeUri.getRawDomain());
	        } else {
	            overridden = relativeUri.hasPort();
	        }
	
	        var rawPath = relativeUri.getRawPath();
	        var simplifiedPath = collapse_dots(rawPath);
	        if (overridden) {
	            absoluteUri.setPort(relativeUri.getPort());
	            simplifiedPath = simplifiedPath
	                && simplifiedPath.replace(EXTRA_PARENT_PATHS_RE, '');
	        } else {
	            overridden = !!rawPath;
	            if (overridden) {
	                // resolve path properly
	                if (simplifiedPath.charCodeAt(0) !== 0x2f /* / */) {  // path is relative
	                    var absRawPath = collapse_dots(absoluteUri.getRawPath() || '')
	                        .replace(EXTRA_PARENT_PATHS_RE, '');
	                    var slash = absRawPath.lastIndexOf('/') + 1;
	                    simplifiedPath = collapse_dots(
	                        (slash ? absRawPath.substring(0, slash) : '')
	                            + collapse_dots(rawPath))
	                        .replace(EXTRA_PARENT_PATHS_RE, '');
	                }
	            } else {
	                simplifiedPath = simplifiedPath
	                    && simplifiedPath.replace(EXTRA_PARENT_PATHS_RE, '');
	                if (simplifiedPath !== rawPath) {
	                    absoluteUri.setRawPath(simplifiedPath);
	                }
	            }
	        }
	
	        if (overridden) {
	            absoluteUri.setRawPath(simplifiedPath);
	        } else {
	            overridden = relativeUri.hasQuery();
	        }
	
	        if (overridden) {
	            absoluteUri.setRawQuery(relativeUri.getRawQuery());
	        } else {
	            overridden = relativeUri.hasFragment();
	        }
	
	        if (overridden) {
	            absoluteUri.setRawFragment(relativeUri.getRawFragment());
	        }
	
	        return absoluteUri;
	    }
	
	    /**
	     * a mutable URI.
	     *
	     * This class contains setters and getters for the parts of the URI.
	     * The <tt>getXYZ</tt>/<tt>setXYZ</tt> methods return the decoded part -- so
	     * <code>uri.parse('/foo%20bar').getPath()</code> will return the decoded path,
	     * <tt>/foo bar</tt>.
	     *
	     * <p>The raw versions of fields are available too.
	     * <code>uri.parse('/foo%20bar').getRawPath()</code> will return the raw path,
	     * <tt>/foo%20bar</tt>.  Use the raw setters with care, since
	     * <code>URI::toString</code> is not guaranteed to return a valid url if a
	     * raw setter was used.
	     *
	     * <p>All setters return <tt>this</tt> and so may be chained, a la
	     * <code>uri.parse('/foo').setFragment('part').toString()</code>.
	     *
	     * <p>You should not use this constructor directly -- please prefer the factory
	     * functions {@link uri.parse}, {@link uri.create}, {@link uri.resolve}
	     * instead.</p>
	     *
	     * <p>The parameters are all raw (assumed to be properly escaped) parts, and
	     * any (but not all) may be null.  Undefined is not allowed.</p>
	     *
	     * @constructor
	     */
	    function URI(
	        rawScheme,
	        rawCredentials, rawDomain, port,
	        rawPath, rawQuery, rawFragment) {
	        this.scheme_ = rawScheme;
	        this.credentials_ = rawCredentials;
	        this.domain_ = rawDomain;
	        this.port_ = port;
	        this.path_ = rawPath;
	        this.query_ = rawQuery;
	        this.fragment_ = rawFragment;
	        /**
	         * @type {Array|null}
	         */
	        this.paramCache_ = null;
	    }
	
	    /** returns the string form of the url. */
	    URI.prototype.toString = function () {
	        var out = [];
	        if (null !== this.scheme_) { out.push(this.scheme_, ':'); }
	        if (null !== this.domain_) {
	            out.push('//');
	            if (null !== this.credentials_) { out.push(this.credentials_, '@'); }
	            out.push(this.domain_);
	            if (null !== this.port_) { out.push(':', this.port_.toString()); }
	        }
	        if (null !== this.path_) { out.push(this.path_); }
	        if (null !== this.query_) { out.push('?', this.query_); }
	        if (null !== this.fragment_) { out.push('#', this.fragment_); }
	        return out.join('');
	    };
	
	    URI.prototype.clone = function () {
	        return new URI(this.scheme_, this.credentials_, this.domain_, this.port_,
	            this.path_, this.query_, this.fragment_);
	    };
	
	    URI.prototype.getScheme = function () {
	        // HTML5 spec does not require the scheme to be lowercased but
	        // all common browsers except Safari lowercase the scheme.
	        return this.scheme_ && decodeURIComponent(this.scheme_).toLowerCase();
	    };
	    URI.prototype.getRawScheme = function () {
	        return this.scheme_;
	    };
	    URI.prototype.setScheme = function (newScheme) {
	        this.scheme_ = encodeIfExists2(
	            newScheme, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);
	        return this;
	    };
	    URI.prototype.setRawScheme = function (newScheme) {
	        this.scheme_ = newScheme ? newScheme : null;
	        return this;
	    };
	    URI.prototype.hasScheme = function () {
	        return null !== this.scheme_;
	    };
	
	
	    URI.prototype.getCredentials = function () {
	        return this.credentials_ && decodeURIComponent(this.credentials_);
	    };
	    URI.prototype.getRawCredentials = function () {
	        return this.credentials_;
	    };
	    URI.prototype.setCredentials = function (newCredentials) {
	        this.credentials_ = encodeIfExists2(
	            newCredentials, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);
	
	        return this;
	    };
	    URI.prototype.setRawCredentials = function (newCredentials) {
	        this.credentials_ = newCredentials ? newCredentials : null;
	        return this;
	    };
	    URI.prototype.hasCredentials = function () {
	        return null !== this.credentials_;
	    };
	
	
	    URI.prototype.getDomain = function () {
	        return this.domain_ && decodeURIComponent(this.domain_);
	    };
	    URI.prototype.getRawDomain = function () {
	        return this.domain_;
	    };
	    URI.prototype.setDomain = function (newDomain) {
	        return this.setRawDomain(newDomain && encodeURIComponent(newDomain));
	    };
	    URI.prototype.setRawDomain = function (newDomain) {
	        this.domain_ = newDomain ? newDomain : null;
	        // Maintain the invariant that paths must start with a slash when the URI
	        // is not path-relative.
	        return this.setRawPath(this.path_);
	    };
	    URI.prototype.hasDomain = function () {
	        return null !== this.domain_;
	    };
	
	
	    URI.prototype.getPort = function () {
	        return this.port_ && decodeURIComponent(this.port_);
	    };
	    URI.prototype.setPort = function (newPort) {
	        if (newPort) {
	            newPort = Number(newPort);
	            if (newPort !== (newPort & 0xffff)) {
	                throw new Error('Bad port number ' + newPort);
	            }
	            this.port_ = '' + newPort;
	        } else {
	            this.port_ = null;
	        }
	        return this;
	    };
	    URI.prototype.hasPort = function () {
	        return null !== this.port_;
	    };
	
	
	    URI.prototype.getPath = function () {
	        return this.path_ && decodeURIComponent(this.path_);
	    };
	    URI.prototype.getRawPath = function () {
	        return this.path_;
	    };
	    URI.prototype.setPath = function (newPath) {
	        return this.setRawPath(encodeIfExists2(newPath, URI_DISALLOWED_IN_PATH_));
	    };
	    URI.prototype.setRawPath = function (newPath) {
	        if (newPath) {
	            newPath = String(newPath);
	            this.path_ =
	                // Paths must start with '/' unless this is a path-relative URL.
	                (!this.domain_ || /^\//.test(newPath)) ? newPath : '/' + newPath;
	        } else {
	            this.path_ = null;
	        }
	        return this;
	    };
	    URI.prototype.hasPath = function () {
	        return null !== this.path_;
	    };
	
	
	    URI.prototype.getQuery = function () {
	        // From http://www.w3.org/Addressing/URL/4_URI_Recommentations.html
	        // Within the query string, the plus sign is reserved as shorthand notation
	        // for a space.
	        return this.query_ && decodeURIComponent(this.query_).replace(/\+/g, ' ');
	    };
	    URI.prototype.getRawQuery = function () {
	        return this.query_;
	    };
	    URI.prototype.setQuery = function (newQuery) {
	        this.paramCache_ = null;
	        this.query_ = encodeIfExists(newQuery);
	        return this;
	    };
	    URI.prototype.setRawQuery = function (newQuery) {
	        this.paramCache_ = null;
	        this.query_ = newQuery ? newQuery : null;
	        return this;
	    };
	    URI.prototype.hasQuery = function () {
	        return null !== this.query_;
	    };
	
	    /**
	     * sets the query given a list of strings of the form
	     * [ key0, value0, key1, value1, ... ].
	     *
	     * <p><code>uri.setAllParameters(['a', 'b', 'c', 'd']).getQuery()</code>
	     * will yield <code>'a=b&c=d'</code>.
	     */
	    URI.prototype.setAllParameters = function (params) {
	        if (typeof params === 'object') {
	            if (!(params instanceof Array)
	                && (params instanceof Object
	                || Object.prototype.toString.call(params) !== '[object Array]')) {
	                var newParams = [];
	                var i = -1;
	                for (var k in params) {
	                    var v = params[k];
	                    if ('string' === typeof v) {
	                        newParams[++i] = k;
	                        newParams[++i] = v;
	                    }
	                }
	                params = newParams;
	            }
	        }
	        this.paramCache_ = null;
	        var queryBuf = [];
	        var separator = '';
	        for (var j = 0; j < params.length;) {
	            var k = params[j++];
	            var v = params[j++];
	            queryBuf.push(separator, encodeURIComponent(k.toString()));
	            separator = '&';
	            if (v) {
	                queryBuf.push('=', encodeURIComponent(v.toString()));
	            }
	        }
	        this.query_ = queryBuf.join('');
	        return this;
	    };
	    URI.prototype.checkParameterCache_ = function () {
	        if (!this.paramCache_) {
	            var q = this.query_;
	            if (!q) {
	                this.paramCache_ = [];
	            } else {
	                var cgiParams = q.split(/[&\?]/);
	                var out = [];
	                var k = -1;
	                for (var i = 0; i < cgiParams.length; ++i) {
	                    var m = cgiParams[i].match(/^([^=]*)(?:=(.*))?$/);
	                    // From http://www.w3.org/Addressing/URL/4_URI_Recommentations.html
	                    // Within the query string, the plus sign is reserved as shorthand
	                    // notation for a space.
	                    out[++k] = decodeURIComponent(m[1]).replace(/\+/g, ' ');
	                    out[++k] = decodeURIComponent(m[2] || '').replace(/\+/g, ' ');
	                }
	                this.paramCache_ = out;
	            }
	        }
	    };
	    /**
	     * sets the values of the named cgi parameters.
	     *
	     * <p>So, <code>uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])
	     * </code> yields <tt>foo?a=b&c=new&e=f</tt>.</p>
	     *
	     * @param key {string}
	     * @param values {Array.<string>} the new values.  If values is a single string
	     *   then it will be treated as the sole value.
	     */
	    URI.prototype.setParameterValues = function (key, values) {
	        // be nice and avoid subtle bugs where [] operator on string performs charAt
	        // on some browsers and crashes on IE
	        if (typeof values === 'string') {
	            values = [ values ];
	        }
	
	        this.checkParameterCache_();
	        var newValueIndex = 0;
	        var pc = this.paramCache_;
	        var params = [];
	        for (var i = 0, k = 0; i < pc.length; i += 2) {
	            if (key === pc[i]) {
	                if (newValueIndex < values.length) {
	                    params.push(key, values[newValueIndex++]);
	                }
	            } else {
	                params.push(pc[i], pc[i + 1]);
	            }
	        }
	        while (newValueIndex < values.length) {
	            params.push(key, values[newValueIndex++]);
	        }
	        this.setAllParameters(params);
	        return this;
	    };
	    URI.prototype.removeParameter = function (key) {
	        return this.setParameterValues(key, []);
	    };
	    /**
	     * returns the parameters specified in the query part of the uri as a list of
	     * keys and values like [ key0, value0, key1, value1, ... ].
	     *
	     * @return {Array.<string>}
	     */
	    URI.prototype.getAllParameters = function () {
	        this.checkParameterCache_();
	        return this.paramCache_.slice(0, this.paramCache_.length);
	    };
	    /**
	     * returns the value<b>s</b> for a given cgi parameter as a list of decoded
	     * query parameter values.
	     * @return {Array.<string>}
	     */
	    URI.prototype.getParameterValues = function (paramNameUnescaped) {
	        this.checkParameterCache_();
	        var values = [];
	        for (var i = 0; i < this.paramCache_.length; i += 2) {
	            if (paramNameUnescaped === this.paramCache_[i]) {
	                values.push(this.paramCache_[i + 1]);
	            }
	        }
	        return values;
	    };
	    /**
	     * returns a map of cgi parameter names to (non-empty) lists of values.
	     * @return {Object.<string,Array.<string>>}
	     */
	    URI.prototype.getParameterMap = function (paramNameUnescaped) {
	        this.checkParameterCache_();
	        var paramMap = {};
	        for (var i = 0; i < this.paramCache_.length; i += 2) {
	            var key = this.paramCache_[i++],
	                value = this.paramCache_[i++];
	            if (!(key in paramMap)) {
	                paramMap[key] = [value];
	            } else {
	                paramMap[key].push(value);
	            }
	        }
	        return paramMap;
	    };
	    /**
	     * returns the first value for a given cgi parameter or null if the given
	     * parameter name does not appear in the query string.
	     * If the given parameter name does appear, but has no '<tt>=</tt>' following
	     * it, then the empty string will be returned.
	     * @return {string|null}
	     */
	    URI.prototype.getParameterValue = function (paramNameUnescaped) {
	        this.checkParameterCache_();
	        for (var i = 0; i < this.paramCache_.length; i += 2) {
	            if (paramNameUnescaped === this.paramCache_[i]) {
	                return this.paramCache_[i + 1];
	            }
	        }
	        return null;
	    };
	
	    URI.prototype.getFragment = function () {
	        return this.fragment_ && decodeURIComponent(this.fragment_);
	    };
	    URI.prototype.getRawFragment = function () {
	        return this.fragment_;
	    };
	    URI.prototype.setFragment = function (newFragment) {
	        this.fragment_ = newFragment ? encodeURIComponent(newFragment) : null;
	        return this;
	    };
	    URI.prototype.setRawFragment = function (newFragment) {
	        this.fragment_ = newFragment ? newFragment : null;
	        return this;
	    };
	    URI.prototype.hasFragment = function () {
	        return null !== this.fragment_;
	    };
	
	    function nullIfAbsent(matchPart) {
	        return ('string' == typeof matchPart) && (matchPart.length > 0)
	            ? matchPart
	            : null;
	    }
	
	
	
	
	    /**
	     * a regular expression for breaking a URI into its component parts.
	     *
	     * <p>http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234 says
	     * As the "first-match-wins" algorithm is identical to the "greedy"
	     * disambiguation method used by POSIX regular expressions, it is natural and
	     * commonplace to use a regular expression for parsing the potential five
	     * components of a URI reference.
	     *
	     * <p>The following line is the regular expression for breaking-down a
	     * well-formed URI reference into its components.
	     *
	     * <pre>
	     * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
	     *  12            3  4          5       6  7        8 9
	     * </pre>
	     *
	     * <p>The numbers in the second line above are only to assist readability; they
	     * indicate the reference points for each subexpression (i.e., each paired
	     * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
	     * For example, matching the above expression to
	     * <pre>
	     *     http://www.ics.uci.edu/pub/ietf/uri/#Related
	     * </pre>
	     * results in the following subexpression matches:
	     * <pre>
	     *    $1 = http:
	     *    $2 = http
	     *    $3 = //www.ics.uci.edu
	     *    $4 = www.ics.uci.edu
	     *    $5 = /pub/ietf/uri/
	     *    $6 = <undefined>
	     *    $7 = <undefined>
	     *    $8 = #Related
	     *    $9 = Related
	     * </pre>
	     * where <undefined> indicates that the component is not present, as is the
	     * case for the query component in the above example. Therefore, we can
	     * determine the value of the five components as
	     * <pre>
	     *    scheme    = $2
	     *    authority = $4
	     *    path      = $5
	     *    query     = $7
	     *    fragment  = $9
	     * </pre>
	     *
	     * <p>msamuel: I have modified the regular expression slightly to expose the
	     * credentials, domain, and port separately from the authority.
	     * The modified version yields
	     * <pre>
	     *    $1 = http              scheme
	     *    $2 = <undefined>       credentials -\
	     *    $3 = www.ics.uci.edu   domain       | authority
	     *    $4 = <undefined>       port        -/
	     *    $5 = /pub/ietf/uri/    path
	     *    $6 = <undefined>       query without ?
	     *    $7 = Related           fragment without #
	     * </pre>
	     */
	    var URI_RE_ = new RegExp(
	        "^" +
	            "(?:" +
	            "([^:/?#]+)" +         // scheme
	            ":)?" +
	            "(?://" +
	            "(?:([^/?#]*)@)?" +    // credentials
	            "([^/?#:@]*)" +        // domain
	            "(?::([0-9]+))?" +     // port
	            ")?" +
	            "([^?#]+)?" +            // path
	            "(?:\\?([^#]*))?" +      // query
	            "(?:#(.*))?" +           // fragment
	            "$"
	    );
	
	    var URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_ = /[#\/\?@]/g;
	    var URI_DISALLOWED_IN_PATH_ = /[\#\?]/g;
	
	    URI.parse = parse;
	    URI.create = create;
	    URI.resolve = resolve;
	    URI.collapse_dots = collapse_dots;  // Visible for testing.
	
	// lightweight string-based api for loadModuleMaker
	    URI.utils = {
	        mimeTypeOf: function (uri) {
	            var uriObj = parse(uri);
	            if (/\.html$/.test(uriObj.getPath())) {
	                return 'text/html';
	            } else {
	                return 'application/javascript';
	            }
	        },
	        resolve: function (base, uri) {
	            if (base) {
	                return resolve(parse(base), parse(uri)).toString();
	            } else {
	                return '' + uri;
	            }
	        }
	    };
	
	
	    return URI;
	})();
	
	if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	        exports = module.exports = URI;
	    }
	    exports.URI = URI;
	} else {
	
	    // Exports for closure compiler.
	    if (typeof window !== 'undefined') {
	        window['URI'] = URI;
	    }
	}


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DALCache = undefined;
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _for = __webpack_require__(145);
	
	var _for2 = _interopRequireDefault(_for);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _user = __webpack_require__(152);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _room = __webpack_require__(153);
	
	var _room2 = _interopRequireDefault(_room);
	
	var _emoticon = __webpack_require__(155);
	
	var _emoticon2 = _interopRequireDefault(_emoticon);
	
	var _browser_storage = __webpack_require__(156);
	
	var _browser_storage2 = _interopRequireDefault(_browser_storage);
	
	var _browser_storage_keys = __webpack_require__(158);
	
	var Keys = _interopRequireWildcard(_browser_storage_keys);
	
	var _config_actions = __webpack_require__(159);
	
	var _config_actions2 = _interopRequireDefault(_config_actions);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	var _compression = __webpack_require__(160);
	
	var _compression2 = _interopRequireDefault(_compression);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var STORE = (0, _for2.default)('DAL.Cache.BrowserStorage');
	
	/**
	 * @module DAL.Cache
	 */
	
	var DALCache = exports.DALCache = function () {
	  function DALCache() {
	    (0, _classCallCheck3.default)(this, DALCache);
	
	    this[STORE] = null;
	
	    /**
	     * @property {object} Keys - dictionary of storage keys
	     */
	    this.Keys = Keys;
	  }
	
	  /**
	   * Initializes the localStorage module. All reads/writes to storage
	   * are blocked until this is properly called
	   *
	   * @method configure
	   * @param {number} user_id
	   * @param {number} group_id
	   */
	
	
	  (0, _createClass3.default)(DALCache, [{
	    key: 'configure',
	    value: function configure(user_id, group_id) {
	      if (_.isNumber(user_id) && _.isNumber(group_id)) {
	        this[STORE] = new _browser_storage2.default(user_id, group_id);
	        _config_actions2.default.cacheConfigured();
	      }
	    }
	
	    /**
	     * Async pass-through to BrowserStorage.has
	     *
	     * @method has
	     * @param {string} key
	     * @param {object} [options = { location: 'localStorage' }]
	     * @returns {Promise<boolean,DALError>}
	     */
	
	  }, {
	    key: 'has',
	    value: function has(key) {
	      var _this = this;
	
	      var options = arguments.length <= 1 || arguments[1] === undefined ? { location: _browser_storage2.default.Locations.LOCAL } : arguments[1];
	
	      return new _promise2.default(function (resolve, reject) {
	        if (!_this[STORE]) {
	          return reject(_dalError2.default.ofType(_dalError2.default.Types.STORAGE_NOT_CONFIGURED));
	        }
	        resolve(_this[STORE].has(key, options));
	      });
	    }
	
	    /**
	     * Async pass-through to BrowserStorage.get
	     *
	     * @method get
	     * @param {string} key
	     * @param {object} [options = { location: 'localStorage' }]
	     * @returns {Promise<*,DALError>}
	     */
	
	  }, {
	    key: 'get',
	    value: function get(key) {
	      var _this2 = this;
	
	      var options = arguments.length <= 1 || arguments[1] === undefined ? { location: _browser_storage2.default.Locations.LOCAL } : arguments[1];
	
	      return new _promise2.default(function (resolve, reject) {
	        if (!_this2[STORE]) {
	          return reject(_dalError2.default.ofType(_dalError2.default.Types.STORAGE_NOT_CONFIGURED));
	        }
	        resolve(_compression2.default.rehydrate(key, _this2[STORE].get(key, options)));
	      });
	    }
	
	    /**
	     * Async pass-through to BrowserStorage.set
	     *
	     * @method set
	     * @param {string} key
	     * @param {*} val
	     * @param {object} [options = { location: 'localStorage' }]
	     * @returns {Promise<true,DALError>}
	     */
	
	  }, {
	    key: 'set',
	    value: function set(key, val) {
	      var _this3 = this;
	
	      var options = arguments.length <= 2 || arguments[2] === undefined ? { location: _browser_storage2.default.Locations.LOCAL } : arguments[2];
	
	      return new _promise2.default(function (resolve, reject) {
	        if (!_this3[STORE]) {
	          return reject(_dalError2.default.ofType(_dalError2.default.Types.STORAGE_NOT_CONFIGURED));
	        }
	        resolve(_this3[STORE].set(key, _compression2.default.dehydrate(key, val), options));
	      });
	    }
	
	    /**
	     * Async pass-through to BrowserStorage.unset
	     *
	     * @method unset
	     * @param {string} key
	     * @param {object} [options = { location: 'localStorage' }]
	     * @returns {Promise<true,DALError>}
	     */
	
	  }, {
	    key: 'unset',
	    value: function unset(key) {
	      var _this4 = this;
	
	      var options = arguments.length <= 1 || arguments[1] === undefined ? { location: _browser_storage2.default.Locations.LOCAL } : arguments[1];
	
	      return new _promise2.default(function (resolve, reject) {
	        if (!_this4[STORE]) {
	          return reject(_dalError2.default.ofType(_dalError2.default.Types.STORAGE_NOT_CONFIGURED));
	        }
	        resolve(_this4[STORE].unset(key, options));
	      });
	    }
	
	    /**
	     * Async pass-through to BrowserStorage.clear
	     *
	     * @method clear
	     * @returns {Promise<true,DALError>}
	     */
	
	  }, {
	    key: 'clear',
	    value: function clear() {
	      var _this5 = this;
	
	      return new _promise2.default(function (resolve, reject) {
	        if (!_this5[STORE]) {
	          return reject(_dalError2.default.ofType(_dalError2.default.Types.STORAGE_NOT_CONFIGURED));
	        }
	        resolve(_this5[STORE].clear());
	      });
	    }
	
	    /**
	     * Updates the room cache with the provided array of Room Models.
	     * Will either upsert or remove each provided room based on the
	     * Room's is_deleted flag;
	     *
	     * @param {Array<Room>} updates - list of Room models
	     * @returns {Promise<rooms,DALError>}
	     */
	
	  }, {
	    key: 'updateRooms',
	    value: function updateRooms(updates) {
	      var _this6 = this;
	
	      return this.get(Keys.ROOMS).then(function (cache) {
	        cache = cache || {};
	        updates.forEach(function (room) {
	          if (room.is_deleted || room.is_archived) {
	            if (!_.isNull(room.id)) {
	              delete cache[room.id];
	            } else {
	              cache = _.omitBy(cache, function (item) {
	                return item.jid === room.jid;
	              });
	            }
	          } else {
	            cache[room.id] = room;
	          }
	        });
	        return _this6.set(Keys.ROOMS, cache).then(function () {
	          return cache;
	        });
	      });
	    }
	
	    /**
	     * Updates the roster cache with the provided array of User Models.
	     * Will either upsert or remove each provided user based on the
	     * User's is_deleted flag. Resolves to the updated roster
	     *
	     * @param {Array<User>} updates - list of User models
	     * @returns {Promise<Roster, DALError>}
	     */
	
	  }, {
	    key: 'updateRoster',
	    value: function updateRoster(updates) {
	      var _this7 = this;
	
	      return this.get(Keys.ROSTER).then(function (cache) {
	        cache = cache || {};
	        updates.forEach(function (user) {
	          if (user.is_deleted) {
	            delete cache[user.id];
	          } else {
	            cache[user.id] = user;
	          }
	        });
	        return _this7.set(Keys.ROSTER, cache).then(function () {
	          return cache;
	        });
	      });
	    }
	  }, {
	    key: 'updateEmoticons',
	    value: function updateEmoticons(update) {
	      var _this8 = this;
	
	      return this.get(Keys.EMOTICONS).then(function (cached) {
	        var items = update.query.item,
	            cached_items = _.get(cached, 'query.item', null);
	
	        if (cached_items && update.type !== 'result') {
	          items = [].concat(cached_items, items);
	          update.query.path_prefix = cached.query.path_prefix;
	          update.query.ver = cached.query.ver;
	        }
	        update.query.item = _.uniqBy(items, 'id');
	        return _this8.set(Keys.EMOTICONS, update).then(function () {
	          return update;
	        });
	      });
	    }
	
	    /**
	     * Get the roster from the cache in the shape of an XMPP roster IQ query
	     * TEMPORARY convenience method until we can eliminate the IQ processors
	     * and allow the app to get the roster in it's cached state directly without
	     * breaking the startup flow :(
	     *
	     * @method getRosterAsXMPP
	     * @returns {Promise<XMPPRoster|null, DALError>}
	     */
	
	  }, {
	    key: 'getRosterAsXMPP',
	    value: function getRosterAsXMPP() {
	      return this.get(Keys.ROSTER).then(function (roster) {
	        if (roster) {
	          return {
	            iq: {
	              query: {
	                item: (0, _keys2.default)(roster).map(function (id) {
	                  return _user2.default.asX2JS(roster[id]);
	                }),
	                xmlns: NS.ROSTER
	              },
	              type: 'result',
	              xmlns: NS.JABBER
	            }
	          };
	        }
	        return null;
	      });
	    }
	
	    /**
	     * Get the rooms list from the cache in the shape of an XMPP roster IQ query
	     * TEMPORARY convenience method until we can eliminate the IQ processors
	     * and allow the app to get the room list in it's cached state directly without
	     * breaking the startup flow :(
	     *
	     * @method getRoomsAsXMPP
	     * @returns {Promise<XMPPRoomsList|null, DALError>}
	     */
	
	  }, {
	    key: 'getRoomsAsXMPP',
	    value: function getRoomsAsXMPP() {
	      return this.get(Keys.ROOMS).then(function (rooms) {
	        if (rooms) {
	          return {
	            iq: {
	              query: {
	                item: (0, _keys2.default)(rooms).map(function (id) {
	                  return _room2.default.asX2JS(rooms[id]);
	                }),
	                xmlns: NS.DISCO_ITEMS
	              },
	              type: 'result',
	              xmlns: NS.JABBER
	            }
	          };
	        }
	        return null;
	      });
	    }
	
	    /**
	     * Get the emoticons list from the cache in the shape of an XMPP emoticons IQ query
	     *
	     * @method getEmoticonsAsXMPP
	     * @returns {Promise<XMPPEmoticonsList|null, DALError>}
	     */
	
	  }, {
	    key: 'getEmoticonsAsXMPP',
	    value: function getEmoticonsAsXMPP() {
	      return this.get(Keys.EMOTICONS).then(function (iq) {
	        if (iq) {
	          return {
	            query: {
	              item: iq.query.item.map(_emoticon2.default.asX2JS),
	              path_prefix: iq.query.path_prefix,
	              xmlns: NS.HC_EMOTICONS
	            },
	            type: 'result',
	            xmlns: NS.JABBER
	          };
	        }
	        return null;
	      });
	    }
	  }]);
	  return DALCache;
	}();
	
	exports.default = new DALCache();

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(146), __esModule: true };

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(26);
	module.exports = __webpack_require__(18).Symbol['for'];

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ERRORS = undefined;
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _assign = __webpack_require__(148);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * NOTE:
	 * XMPP exceptions are declared in txhipchat/txhipchat/error.py
	 * which adds some extensions to twisted's jabber protocol StanzaError class:
	 * http://twistedmatrix.com/trac/browser/tags/releases/twisted-9.0.0/twisted/words/protocols/jabber/error.py
	 */
	var ERRORS = exports.ERRORS = (0, _freeze2.default)({
	  HTTP: 'HTTP',
	  XMPP: 'XMPP',
	  OFFLINE: 'OFFLINE',
	  TIMEOUT: 'TIMEOUT', // status: 0
	  STORAGE_JSON_SERIALIZATION: 'STORAGE_JSON_SERIALIZATION', // status: 422
	  STORAGE_INACCESSIBLE: 'STORAGE_INACCESSIBLE', // status: 423
	  STORAGE_DOM_QUOTA_EXCEEDED: 'STORAGE_DOM_QUOTA_EXCEEDED', // status: 507
	  STORAGE_NOT_CONFIGURED: 'STORAGE_NOT_CONFIGURED', // status: 503
	  EXCEPTION: 'EXCEPTION', // status: 520,
	  OUT_OF_SYNC: 'OUT_OF_SYNC', // status: 409
	  RATE_LIMITED: 'RATE_LIMITED' // status: 429
	});
	
	/**
	 * All errors from the DAL should look like this:
	 *
	 * @class DALError
	 *
	 * @property {string} name - "DALError"
	 * @property {string} stack - stack trace
	 * @property {number} status - status code if applicable
	 * @property {string} message - the error message, if could be parsed
	 * @property {string} type - One of DALError.Types
	 * @property {object} body - the original error body
	 * - In the case of an ajax request, will be the jqXHR object
	 * - In the case of xmpp, will be x2js'd error stanza
	 */
	
	/**
	 * @constructs
	 * @param {object|error} input
	 * @param {string} input.message
	 * @param {number} [input.status = 520]
	 * @param {string} [input.type = "EXCEPTION"]
	 * @param {*} [input.body = null]
	 */
	var DALError = function DALError() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? { message: '', status: 520, type: ERRORS.EXCEPTION, body: null } : arguments[0];
	
	  var err = new Error(input.message);
	  (0, _assign2.default)(this, err);
	
	  this.status = input.status;
	  this.message = input.message;
	  this.type = input.type;
	  this.body = input.body;
	  this.name = input.name ? 'DALError<' + input.name + '>' : 'DALError';
	  if (input.message === 'Invalid OAuth session') {
	    this.message = 'If this keeps happening, try logging in again.';
	    this.name = '';
	  }
	  this.stack = input.stack || err.stack || null;
	  if (this.stack) {
	    var stackRegex = new RegExp('^' + input.name + '|^Error');
	    this.stack = this.stack.replace(stackRegex, this.name);
	  }
	};
	
	DALError.prototype = (0, _create2.default)(Error.prototype);
	DALError.Types = ERRORS;
	
	/**
	 * Create a DAL Error from a jQuery XHR error object.
	 * Typical Coral error json:
	 *
	 * {
	 *   error: {
	 *     message: "some error message", // Invalid OAuth session
	 *     code: "same as http error code", // 401
	 *     type: "some error type" // HTTP or XMPP
	 *   }
	 * }
	 *
	 * @static
	 * @method fromJqXHR
	 * @param {Object} jqXHR - jquery xhr object
	 * @returns {DALError}
	 */
	DALError.fromJqXHR = function (jqXHR) {
	  var message = jqXHR.responseText,
	      status = jqXHR.status;
	
	  if (_.isString(message) && message !== '') {
	    try {
	      var json = JSON.parse(message);
	      message = _.get(json, 'error.message', message);
	      status = _.get(json, 'error.code', status);
	    } catch (e) {
	      // (nothingtoseehere)
	    }
	  }
	
	  return new DALError({
	    type: ERRORS.HTTP,
	    status: status,
	    message: message,
	    body: jqXHR
	  });
	};
	
	/**
	 * Create a DAL Error from an XMPP error stanza, such as:
	 *
	 * <presence xmlns="" type="error" from="" to="" id="">
	 *   <error code="404" type="cancel">
	 *     <item-not-found xmlns="" />
	 *     <text xmlns="">Some error text</text>
	 *   </error>
	 * </presence>
	 *
	 * <iq xmlns='jabber:client' type='error' from='jid' id='6:sendIQ' to='1_7@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222'>
	 *   <query xmlns='http://hipchat.com/protocol/links' limit='50'/>
	 *   <error code='500' type='wait'>
	 *     <internal-server-error xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
	 *   </error>
	 * </iq>
	 *
	 * <message xmlns='jabber:client' type='error' from='jid' to='1_7@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222'>
	 *   <body>some test</body>
	 *   <error code='403' type='auth'>
	 *     <forbidden xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
	 *     <text xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>You must be in this room to send a message.</text>
	 *   </error>
	 * </message>
	 *
	 * The text node is not always present, so if it doesn't exist,
	 * return the first childNode of error's nodeName, which is a
	 * generic message-status type
	 *
	 * @static
	 * @method fromXMPP
	 * @param xmpp - an error stanza
	 * @returns {DALError}
	 */
	DALError.fromXMPP = function (xmpp) {
	  var errNode = xmpp.querySelector('error'),
	      status = parseInt(errNode.getAttribute('code'), 10),
	      txtNode = errNode.querySelector('text'),
	
	  //TODO: Create generic error messages per status code?
	  message = txtNode ? txtNode.textContent : errNode.childNodes[0].nodeName;
	
	  return new DALError({
	    type: ERRORS.XMPP,
	    status: status,
	    message: message,
	    body: xmpp
	  });
	};
	
	/**
	 * Returns a DALError of a given type with appropriate status codes and
	 * messaging. All these status codes arbitrarily picked from:
	 * https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
	 *
	 * @static
	 * @method ofType
	 * @param {string} type - one of the DALError.Types enums
	 * @param {object|error} [thrownException]
	 * @returns {DALError}
	 */
	DALError.ofType = function () {
	  var type = arguments.length <= 0 || arguments[0] === undefined ? ERRORS.EXCEPTION : arguments[0];
	  var thrownException = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  var error = { type: type, body: null },
	      originalErrMessage = thrownException.message ? ': ' + thrownException.message : '';
	  switch (type) {
	    case ERRORS.OFFLINE:
	      error.status = 0;
	      error.message = 'Your connection was interrupted';
	      break;
	
	    case ERRORS.TIMEOUT:
	      error.status = 0;
	      error.message = 'DAL operation timed out' + originalErrMessage;
	      break;
	
	    case ERRORS.OUT_OF_SYNC:
	      error.status = 409;
	      error.message = 'Resource is out of sync' + originalErrMessage;
	      break;
	
	    case ERRORS.RATE_LIMITED:
	      error.status = 429;
	      error.message = 'Too many requests' + originalErrMessage;
	      break;
	
	    case ERRORS.STORAGE_DOM_QUOTA_EXCEEDED:
	      error.status = 507; // Insufficient Storage
	      error.message = 'DAL failed to write to storage due to quota exceeded error' + originalErrMessage;
	      break;
	
	    case ERRORS.STORAGE_JSON_SERIALIZATION:
	      error.status = 422; // Unprocessable Entity
	      error.message = 'DAL JSON serialization error' + originalErrMessage;
	      break;
	
	    case ERRORS.STORAGE_INACCESSIBLE:
	      error.status = 423; // Locked
	      error.message = 'DAL could not access browser storage' + originalErrMessage;
	      break;
	
	    case ERRORS.STORAGE_NOT_CONFIGURED:
	      error.status = 503; // Service Unavailable
	      error.message = 'DAL.Cache has not been configured! Access to storage is not yet available' + originalErrMessage;
	      break;
	
	    case ERRORS.EXCEPTION:
	    default:
	      error.status = 520; // Unknown Error
	      error.message = 'An unknown DALError occurred' + originalErrMessage;
	  }
	
	  return new DALError((0, _assign2.default)(thrownException, error));
	};
	
	exports.default = DALError;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(149), __esModule: true };

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(150);
	module.exports = __webpack_require__(18).Object.assign;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(16);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(151)});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.1 Object.assign(target, source, ...)
	var $        = __webpack_require__(8)
	  , toObject = __webpack_require__(13)
	  , IObject  = __webpack_require__(38);
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = __webpack_require__(21)(function(){
	  var a = Object.assign
	    , A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , $$    = arguments
	    , $$len = $$.length
	    , index = 1
	    , getKeys    = $.getKeys
	    , getSymbols = $.getSymbols
	    , isEnum     = $.isEnum;
	  while($$len > index){
	    var S      = IObject($$[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  }
	  return T;
	} : Object.assign;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class User
	 * @property {number|null} id
	 * @property {string|null} jid
	 * @property {string} name
	 * @property {string} mention_name
	 * @property {string} email
	 * @property {string} title
	 * @property {string} photo_url
	 * @property {string} version
	 * @property {boolean} is_guest
	 * @property {boolean} is_deleted
	 */
	
	var User = function () {
	
	  /**
	   * @constructs
	   * @param {object} input
	   * @param {number} [input.id = null]
	   * @param {string} [input.jid = null]
	   * @param {string} [input.name = '']
	   * @param {string} [input.mention_name = '']
	   * @param {string} [input.email = '']
	   * @param {string|null} [input.title = null]
	   * @param {string} [input.photo_url = '']
	   * @param {string} [input.version = '']
	   * @param {boolean} [input.is_guest = false]
	   * @param {boolean} [input.is_deleted = false]
	   */
	
	  function User() {
	    var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	    (0, _classCallCheck3.default)(this, User);
	
	    this.id = input.id ? input.id : null;
	    this.jid = input.jid ? input.jid : null;
	    this.name = input.name ? input.name : '';
	    this.mention_name = input.mention_name ? input.mention_name : '';
	    this.email = input.email ? input.email : '';
	    this.title = input.title ? input.title : null;
	    this.photo_url = input.photo_url ? input.photo_url : '';
	    this.version = input.version ? input.version : '';
	    this.is_guest = input.is_guest ? input.is_guest : false;
	    this.is_deleted = input.is_deleted ? input.is_deleted : false;
	  }
	
	  /**
	   * Create a User model from an individual item in a roster push. Roster pushes may
	   * contain 1 or more items (users), so the caller should be responsible for iterating
	   * over the list and calling this method to convert the item xml node into a user model
	   *
	   * <iq xmlns='jabber:client' to='1_4@chat.devvm.hipchat.com/web-15499||proxy|devvm.hipchat.com|5222' type='set'>
	   *   <query xmlns='jabber:iq:roster' ver='2016-04-27T20:16:36Z'>
	   *     <item jid='1_2520@chat.devvm.hipchat.com'
	   *       name='Art Cronin 61'
	   *       id='2520'
	   *       mention_name='ArtCronin61'
	   *       mobile="iphone" <!-- or android or this attribute does not exist -->
	   *       version='18EA5095'
	   *       subscription='both'
	   *       email='art.cronin61@atlassian.com'
	   *       photo_url='https://secure.gravatar.com/avatar/bcd6031e23dfb85bbf7c8aac0d3989df?s=125&amp;r=g&amp;d=https%3A%2F%2Fdevvm.hipchat.com%2Fimg%2Fsilhouette_125.png'/>
	   *   </query>
	   * </iq>
	   *
	   * @static
	   * @method fromXMPP
	   * @param item - the "item" node for a given roster update (not the whole iq)
	   * @returns {User}
	   */
	
	
	  (0, _createClass3.default)(User, null, [{
	    key: 'fromXMPP',
	    value: function fromXMPP(item) {
	
	      var id = item.hasAttribute('id') ? parseInt(item.getAttribute('id'), 10) : _utils2.default.jid.user_id(item.getAttribute('jid'));
	
	      return new User({
	        id: id,
	        jid: item.getAttribute('jid'),
	        name: item.getAttribute('name'),
	        mention_name: item.getAttribute('mention_name'),
	        email: item.getAttribute('email'),
	        photo_url: item.getAttribute('photo_url'),
	        version: item.getAttribute('version'),
	        is_deleted: item.getAttribute('subscription') === 'remove',
	        is_guest: false, // Guest users are not broadcast via roster pushes
	        title: null // We only get this value via xmpp from requesting the user's profile (sadplanet)
	      });
	    }
	
	    /*
	     * Example IQ from profile query. This gives us basically the same information, but
	     * does NOT include the version hash. It is, however, the only endpoint that give us
	     * the user's timezone offset value -- which we need to calculate their local time in
	     * the 1:1 chat headers. We currently store the parsed result of this IQ as a "profile"
	     * in several places in the app, and we should probably just merge it into the roster
	     * to fully flesh out the user item. Because of this, however, we have no single way
	     * to get ALL a user's information (feelsbadman)
	     *
	     * <iq xmlns='jabber:client' type='result' from='1_2530@chat.devvm.hipchat.com'
	     *   id='3b1b70d3-b4f8-48a2-a46e-a20b99ff373b:sendIQ' to='1_4@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222'>
	     *   <query xmlns='http://hipchat.com/protocol/profile'>
	     *     <email>mattye.veum69@atlassian.com</email>
	     *     <name>Mattye Veum</name>
	     *     <mention_name>MattyeVeum69</mention_name>
	     *     <photo_large>https://secure.gravatar.com/avatar/ea536d6e64288e112e736131589dc1f1?s=125&amp;r=g&amp;d=https%3A%2F%2Fdevvm.hipchat.com%2Fimg%2Fsilhouette_125.png</photo_large>
	     *     <photo_small>https://secure.gravatar.com/avatar/ea536d6e64288e112e736131589dc1f1?s=36&amp;r=g&amp;d=https%3A%2F%2Fdevvm.hipchat.com%2Fimg%2Fsilhouette_36.png</photo_small>
	     *     <timezone utc_offset='0.0'>UTC</timezone>
	     *     <title>Atlassian Member</title>
	     *   </query>
	     * </iq>
	     */
	
	    /*
	     * Guest users are not included when you sync or query the roster. You only know about them
	     * when you get a presence telling you they joined a room. We currently create a partial user
	     * object from this stanza and add them to our internal roster. They are never cached.
	     *
	     * <presence xmlns='jabber:client' to='1_4@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222'
	     *   from='1_coral-1@conf.devvm.hipchat.com/a guest'>
	     *   <x xmlns='http://jabber.org/protocol/muc#user'>
	     *     <item mention_name='aguestGuest'
	     *       affiliation='member'
	     *       jid='1_5656@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222'
	     *       role='visitor'/>
	     *   </x>
	     * </presence>
	     */
	
	    /**
	     * Returns a user model from the coral rest user representation pulled down
	     * in the sync api. Updated user looks like:
	     * {
	     *   "email": "extraneous@example.com",
	     *   "id": 5655,
	     *   "is_guest": false,
	     *   "links": {
	     *     "self": "https://devvm.hipchat.com/v2/user/5655"
	     *     },
	     *   "mention_name": "extraneous",
	     *   "name": "extraneous",
	     *   "photo_url": "https://secure.gravatar.com/avatar/13958a29d8b9f8361ce8d1dd8c277dc8?s=125&r=g&d=https%3A%2F%2Fdevvm.hipchat.com%2Fimg%2Fsilhouette_125.png",
	     *   "timezone": "UTC",
	     *   "title": "",
	     *   "version": "00000000",
	     *   "xmpp_jid": "1_5655@chat.devvm.hipchat.com"
	     * }
	     *
	     * Deleted user looks like:
	     * {
	     *   "id": 123,
	     *   "is_deleted": true
	     * }
	     *
	     * The timezone value received from Coral is a string-name (UTC, US/Central),
	     * which is pretty useless for us unless we maintain a dictionary of
	     * these strings -> utc offsets. txhipchat is using http://pythonhosted.org/pytz
	     * which contains a binary database of these mappings
	     *
	     * @static
	     * @method fromREST
	     * @param {object} json
	     * @returns {User}
	     */
	
	  }, {
	    key: 'fromREST',
	    value: function fromREST(json) {
	      return new User({
	        id: json.id,
	        jid: json.xmpp_jid,
	        name: json.name,
	        mention_name: json.mention_name,
	        email: json.email,
	        title: json.title,
	        photo_url: json.photo_url,
	        version: json.version,
	        is_guest: json.is_guest,
	        is_deleted: json.is_deleted
	      });
	    }
	
	    /**
	     * Converts user model back to the x2js version for
	     * backwards compatibility until we can model all
	     * the way thru the app
	     * @param {User} user
	     * @returns {object}
	     */
	
	  }, {
	    key: 'asX2JS',
	    value: function asX2JS(user) {
	      var x2js = {
	        id: user.id,
	        jid: user.jid,
	        name: user.name,
	        mention_name: user.mention_name,
	        email: user.email,
	        title: user.title,
	        photo_url: user.photo_url,
	        version: user.version
	      };
	
	      if (user.subscription) {
	        x2js.subscription = user.subscription;
	      } else if (user.is_deleted) {
	        x2js.subscription = 'remove';
	      } else if (!user.is_guest) {
	        x2js.subscription = '';
	      }
	
	      return x2js;
	    }
	  }]);
	  return User;
	}();

	exports.default = User;
	module.exports = exports['default'];

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PrivacyLevels = undefined;
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Valid room privacy values
	 */
	var PrivacyLevels = exports.PrivacyLevels = (0, _freeze2.default)({
	  PRIVATE: 'private',
	  PUBLIC: 'public'
	});
	
	/**
	 * Reasonable default values for the room object
	 */
	var Defaults = (0, _freeze2.default)({
	  NAME: "",
	  TOPIC: "",
	  PRIVACY: PrivacyLevels.PUBLIC,
	  AVATAR_URL: "",
	  ID: null,
	  JID: "",
	  GUEST_URL: "",
	  OWNER: null,
	  IS_ARCHIVED: false,
	  IS_DELETED: false,
	  VERSION: "00000000"
	});
	
	/**
	 * Returns the textContent value of the node that is found when querying the root node passed in for the element that
	 * returns from a querySelector search for the `name` value specified.
	 *
	 * @param {Document} root xml
	 * @param {string} name the name of the tag you're looking for
	 * @param defaultVal what to return if nothing is found
	 *
	 * @returns {string|null}
	 */
	var queryContent = function queryContent(root, name) {
	  var defaultVal = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var node = root.querySelector(name);
	  return _.get(node, 'textContent', defaultVal);
	};
	
	/**
	 * @class Room
	 *
	 * @property {string} name
	 * @property {string} privacy (public or private)
	 * @property {string} topic
	 * @property {string} jid
	 * @property {string} version
	 * @property {int} owner
	 * @property {int} id
	 * @property {boolean} is_archived
	 * @property {string} guest_url
	 * @property {string} avatar_url
	 */
	
	var Room = function () {
	
	  /**
	   * @constructs
	   * @param {object} input
	   * @param {string} input.name
	   * @param {string} [input.privacy="public"]
	   * @param {string} [input.topic=""]
	   * @param {string} input.version
	   * @param {string|null} input.avatar_url
	   * @param {string|number} input.id
	   * @param {string} input.jid
	   * @param {string|null} input.guest_url
	   * @param {string|number} input.owner
	   * @param {boolean} [input.is_archived]
	   * @param {boolean} [input.is_deleted]
	   */
	
	  function Room() {
	    var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	    (0, _classCallCheck3.default)(this, Room);
	
	    this.name = input.name || Defaults.NAME;
	    this.topic = input.topic || Defaults.TOPIC;
	    this.privacy = input.privacy || Defaults.PRIVACY;
	    this.version = input.version || Defaults.VERSION;
	    this.avatar_url = input.avatar_url || Defaults.AVATAR_URL;
	    this.id = input.id ? parseInt(input.id, 10) : Defaults.ID;
	    this.jid = input.jid || Defaults.JID;
	    this.guest_url = input.guest_url || Defaults.GUEST_URL;
	    this.owner = input.owner ? parseInt(input.owner, 10) : Defaults.OWNER;
	    this.is_archived = _utils2.default.coerceBoolean(input.is_archived, Defaults.IS_ARCHIVED);
	    this.is_deleted = _utils2.default.coerceBoolean(input.is_deleted, Defaults.IS_DELETED);
	  }
	
	  /**
	   * Takes an IQ result from a disco#info query for a room, and returns
	   * a Room model. IQ looks like:
	   *
	   * <iq xmlns="jabber:client" type="result" from="${room_jid}" id="" to="">
	   *   <query xmlns="http://jabber.org/protocol/disco#info">
	   *     <identity category="conference" type="text" name="${room_name}" />
	   *     <feature var="http://jabber.org/protocol/muc" />
	   *     <feature var="muc_membersonly" />
	   *     <x xmlns="http://hipchat.com/protocol/muc#room">
	   *       <id>${room_id}</id>
	   *       <topic>${room_topic}</topic>
	   *       <privacy>${room_privacy}</privacy>
	   *       <owner>${room_owner_jid}</owner>
	   *       <guest_url />
	   *       <is_archived /> // only present if true
	   *       <version>${room_version_hash}</version>
	   *       <num_participants>0</num_participants>
	   *     </x>
	   *   </query>
	   * </iq>
	   *
	   * @static
	   * @method fromXMPPDiscoInfo
	   * @param xmpp - xml result from a disco#info query for a room
	   * @returns {Room}
	   */
	
	
	  (0, _createClass3.default)(Room, null, [{
	    key: 'fromXMPPDiscoInfo',
	    value: function fromXMPPDiscoInfo(xmpp) {
	      var x = xmpp.getElementsByTagNameNS(NS.HC_MUC_ROOM, 'x')[0],
	          identity = xmpp.querySelector('identity'),
	          owner = queryContent(x, 'owner');
	
	      return new Room({
	        id: queryContent(x, 'id'),
	        jid: xmpp.getAttribute('from'),
	        owner: owner ? _utils2.default.jid.user_id(owner) : null,
	        name: identity.getAttribute('name'),
	        topic: queryContent(x, 'topic'),
	        privacy: queryContent(x, 'privacy'),
	        version: queryContent(x, 'version'),
	        avatar_url: queryContent(x, 'avatar_url'),
	        guest_url: queryContent(x, 'guest_url'),
	        is_archived: x.querySelectorAll('is_archived').length > 0,
	        is_deleted: false // if room was deleted, disco#info would return a 404
	      });
	    }
	
	    /**
	     * Takes an individual item from a disco_items entry (ie. when you download the
	     * entire rooms list) and returns a Room model. Entire IQ result looks like this.
	     * This parser is for an individual item node from this list. Caller is responsible
	     * for iteration.
	     *
	     * <iq xmlns='jabber:client' type='result' from='conf.hipchat.com' id='e09bd3e5-5238-4122-99ee-88a1e51dc654:sendIQ'
	     *  to='10804_220836@chat.hipchat.com/web||proxy|proxy-c303.hipchat.com|5262'>
	     *    <query xmlns='http://jabber.org/protocol/disco#items'>
	     *      <item jid='10804_bitbucket@conf.hipchat.com' name='room name'>
	     *        <x xmlns='http://hipchat.com/protocol/muc#room'>
	     *          <id>22087</id>
	     *          <name>room name</name>
	     *          <topic>room topic</topic>
	     *          <privacy>public</privacy>
	     *          <owner>10804_85346@chat.hipchat.com</owner>
	     *          <guest_url/>
	     *          <version>QX6A723G</version>
	     *          <num_participants>0</num_participants>
	     *        </x>
	     *      </item>
	     *    </query>
	     * </iq>
	     *
	     * @static
	     * @method from XMPPDiscoItem
	     * @param item - individual item node from disco_items iq result
	     * @returns {Room}
	     */
	
	  }, {
	    key: 'fromXMPPDiscoItem',
	    value: function fromXMPPDiscoItem(item) {
	      var x = item.getElementsByTagNameNS(NS.HC_MUC_ROOM, 'x')[0],
	          name = item.hasAttribute('name') ? item.getAttribute('name') : queryContent(x, 'name'),
	          owner = queryContent(x, 'owner');
	
	      return new Room({
	        id: queryContent(x, 'id'),
	        jid: item.getAttribute('jid'),
	        owner: owner ? _utils2.default.jid.user_id(owner) : null,
	        name: name,
	        topic: queryContent(x, 'topic'),
	        privacy: queryContent(x, 'privacy'),
	        version: queryContent(x, 'version'),
	        avatar_url: queryContent(x, 'avatar_url'),
	        guest_url: queryContent(x, 'guest_url'),
	        is_archived: false, // disco items does not return archived rooms
	        is_deleted: false // disco items does not return deleted rooms
	      });
	    }
	
	    /**
	     * Takes an IQ result from a muc#room query for a room, and returns
	     * a Room model. IQ looks like:
	     *
	     * <iq xmlns='jabber:client' to='1_1@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222' type='set'>
	     *   <query xmlns='http://hipchat.com/protocol/muc#room'>
	     *     <item jid='1_ii@conf.devvm.hipchat.com' name='Eye Eye'>
	     *       <id>693</id>
	     *       <name>Eye Eye</name>
	     *       <topic>This is room Eye Eye topic</topic>
	     *       <privacy>public</privacy>
	     *       <owner>1_2@chat.devvm.hipchat.com</owner>
	     *       <guest_url/>
	     *       <version>8WEKZB9B</version>
	     *       <num_participants>0</num_participants>
	     *     </item>
	     *   </query>
	     * </iq>
	     *
	     * @static
	     * @method fromXMPPMucRoom
	     * @param item - individual item from a muc#room push iq
	     * @returns {Room}
	     */
	
	  }, {
	    key: 'fromXMPPMucRoom',
	    value: function fromXMPPMucRoom(item) {
	      var owner = queryContent(item, 'owner'),
	          name = item.hasAttribute('name') ? item.getAttribute('name') : queryContent(item, 'name');
	
	      return new Room({
	        id: queryContent(item, 'id'),
	        jid: item.getAttribute('jid'),
	        owner: owner ? _utils2.default.jid.user_id(owner) : null,
	        name: name,
	        topic: queryContent(item, 'topic'),
	        privacy: queryContent(item, 'privacy'),
	        version: queryContent(item, 'version'),
	        avatar_url: queryContent(item, 'avatar_url'),
	        guest_url: queryContent(item, 'guest_url'),
	        is_archived: item.querySelectorAll('is_archived').length > 0,
	        is_deleted: item.getAttribute('status') === 'deleted'
	      });
	    }
	
	    /**
	     * Returns room model from the coral rest room representation:
	     * {
	     *     "avatar_url": null,
	     *     "created": "2015-12-29T19:50:02+00:00",
	     *     "delegate_admin_visibility": null,
	     *     "guest_access_url": null,
	     *     "id": 59,
	     *     "is_archived": false,
	     *     "is_guest_accessible": false,
	     *     "last_active": null,
	     *     "links": {
	     *         "participants": "https://devvm.hipchat.com/v2/room/59/participant",
	     *         "self": "https://devvm.hipchat.com/v2/room/59",
	     *         "webhooks": "https://devvm.hipchat.com/v2/room/59/webhook"
	     *     },
	     *     "name": "test room name",
	     *     "owner": {
	     *         "id": 4,
	     *         "links": {
	     *             "self": "https://devvm.hipchat.com/v2/user/4"
	     *         },
	     *         "mention_name": "Homer",
	     *         "name": "Homer Simpson",
	     *         "version": "VXAKO96E"
	     *     },
	     *     "participants": [],
	     *     "privacy": "public",
	     *     "statistics": {
	     *         "links": {
	     *             "self": "https://devvm.hipchat.com/v2/room/59/statistics"
	     *         }
	     *     },
	     *     "topic": "asdsd",
	     *     "version": "GDKMBGDZ",
	     *     "xmpp_jid": "1_test-room-name@conf.devvm.hipchat.com"
	     * }
	     *
	     * @static
	     * @method fromREST
	     * @param {object} json
	     * @returns {Room}
	     */
	
	  }, {
	    key: 'fromREST',
	    value: function fromREST(json) {
	      // let's convert properties that aren't in the format the constructor expects
	      var id = json.id ? parseInt(json.id, 10) : Defaults.ID,
	          jid = json.xmpp_jid,
	          guest_url = json.guest_access_url,
	          owner = json.owner || {};
	
	      return new Room(_.merge(json, { id: id, jid: jid, guest_url: guest_url }, { owner: owner.id }));
	    }
	
	    /**
	     * Converts room model back to the x2js version for
	     * backwards compatibility until we can model all
	     * the way thru the app
	     * @param {Room} room
	     * @returns {object}
	     */
	
	  }, {
	    key: 'asX2JS',
	    value: function asX2JS(room) {
	      return {
	        id: room.id,
	        jid: room.jid,
	        name: room.name,
	        version: room.version,
	        x: {
	          guest_url: room.guest_url,
	          id: room.id,
	          name: room.name,
	          owner: room.owner,
	          privacy: room.privacy,
	          version: room.version
	        }
	      };
	    }
	  }]);
	  return Room;
	}();

	exports.default = Room;

/***/ },
/* 154 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 * HipChat custom XMPP namespaces
	 */
	var HC = exports.HC = 'http://hipchat.com';
	var HC_PRESENCE = exports.HC_PRESENCE = 'http://hipchat.com/protocol/presence';
	var HC_PROFILE = exports.HC_PROFILE = 'http://hipchat.com/protocol/profile';
	var HC_MUC_ROOM = exports.HC_MUC_ROOM = 'http://hipchat.com/protocol/muc#room';
	var HC_MUC_PERMISSIONS = exports.HC_MUC_PERMISSIONS = 'http://hipchat.com/protocol/muc#permissions';
	var HC_HISTORY = exports.HC_HISTORY = 'http://hipchat.com/protocol/history';
	var HC_LINKS = exports.HC_LINKS = 'http://hipchat.com/protocol/links';
	var HC_FILES = exports.HC_FILES = 'http://hipchat.com/protocol/files';
	var HC_AUTHENTICATED_FILE = exports.HC_AUTHENTICATED_FILE = 'http://hipchat.com/protocol/file';
	var HC_EMOTICONS = exports.HC_EMOTICONS = 'http://hipchat.com/protocol/emoticons';
	var HC_ROSTER_HASH = exports.HC_ROSTER_HASH = 'http://hipchat.com/protocol/users#hash';
	var HC_ROOMS_HASH = exports.HC_ROOMS_HASH = 'http://hipchat.com/protocol/rooms#hash';
	
	/*
	 * Jabber common XMPP namespaces
	 */
	var JABBER = exports.JABBER = 'jabber:client';
	var MUC = exports.MUC = 'http://jabber.org/protocol/muc';
	var MUC_OWNER = exports.MUC_OWNER = 'http://jabber.org/protocol/muc#owner';
	var MUC_USER = exports.MUC_USER = 'http://jabber.org/protocol/muc#user';
	var DISCO_INFO = exports.DISCO_INFO = 'http://jabber.org/protocol/disco#info';
	var DISCO_ITEMS = exports.DISCO_ITEMS = 'http://jabber.org/protocol/disco#items';
	var CHAT_STATES = exports.CHAT_STATES = 'http://jabber.org/protocol/chatstates';
	var ENTITY_CAPABILITIES = exports.ENTITY_CAPABILITIES = 'http://jabber.org/protocol/caps';
	var ROSTER = exports.ROSTER = 'jabber:iq:roster';
	var LAST_ACTIVITY = exports.LAST_ACTIVITY = 'jabber:iq:last';

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.EmoticonTypes = undefined;
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Valid emoticon type values
	 */
	var EmoticonTypes = exports.EmoticonTypes = (0, _freeze2.default)({
	  GLOBAL: 'global',
	  GROUP: 'group'
	});
	
	/**
	 * Reasonable default values for the emoticon object
	 */
	var Defaults = (0, _freeze2.default)({
	  ID: null,
	  SHORTCUT: '',
	  PATH: '',
	  W: 30,
	  H: 30,
	  TYPE: EmoticonTypes.GROUP
	});
	
	/**
	 * Returns the textContent value of the node that is found when querying the root node passed in for the element that
	 * returns from a querySelector search for the `name` value specified.
	 *
	 * @param {Document} root xml
	 * @param {string} name the name of the tag you're looking for
	 * @param defaultVal what to return if nothing is found
	 *
	 * @returns {string|null}
	 */
	var queryContent = function queryContent(root, name) {
	  var defaultVal = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var node = root.querySelector(name);
	  return _.get(node, 'textContent', defaultVal);
	};
	
	/**
	 * @class Emoticon
	 *
	 * @property {number} id
	 * @property {string} shortcut
	 * @property {string} path
	 * @property {number} w
	 * @property {number} h
	 * @property {string} type
	 */
	
	var Emoticon = function () {
	
	  /**
	   * @constructs
	   * @param {object} input
	   * @param {string|number} input.id
	   * @param {string} input.shortcut
	   * @param {string} input.path
	   * @param {string|number} input.w
	   * @param {string|number} input.h
	   * @param {string} input.type
	   */
	
	  function Emoticon() {
	    var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	    (0, _classCallCheck3.default)(this, Emoticon);
	
	    this.id = input.id ? parseInt(input.id, 10) : Defaults.ID;
	    this.shortcut = input.shortcut || Defaults.SHORTCUT;
	    this.path = input.path || Defaults.PATH;
	    this.w = input.w ? parseInt(input.w, 10) : Defaults.W;
	    this.h = input.h ? parseInt(input.h, 10) : Defaults.H;
	    this.type = input.type || Defaults.TYPE;
	  }
	
	  /**
	   * Takes an IQ result from a iq query for emoticons, and returns
	   * a Emoticon model. IQ looks like:
	   *
	   * <iq xmlns="jabber:client" to="" type="{set|result}">
	   *  <query xmlns="http://hipchat.com/protocol/emoticons">
	   *    <path_prefix>https://dujrsrsgsd3nh.cloudfront.net/img/emoticons</path_prefix>
	   *    <item>
	   *      <id>560651</id>
	   *      <path>10804/troll-1467393875.png</path>
	   *      <shortcut>troll</shortcut>
	   *      <w>30</w>
	   *      <h>26</h>
	   *      <type>group</type>
	   *    </item>
	   *  </query>
	   * </iq>
	   *
	   * @static
	   * @method fromXMPP
	   * @param item - xml <item> element from a iq query for emoticons
	   * @returns {Emoticon}
	   */
	
	
	  (0, _createClass3.default)(Emoticon, null, [{
	    key: 'fromXMPP',
	    value: function fromXMPP(item) {
	      return new Emoticon({
	        id: queryContent(item, 'id'),
	        shortcut: queryContent(item, 'shortcut'),
	        path: queryContent(item, 'path'),
	        w: queryContent(item, 'w'),
	        h: queryContent(item, 'h'),
	        type: queryContent(item, 'type')
	      });
	    }
	
	    /**
	     * Converts emoticon model back to the x2js version for
	     * backwards compatibility until we can model all
	     * the way thru the app
	     * @param {Emoticon} emoticon
	     * @returns {object}
	     */
	
	  }, {
	    key: 'asX2JS',
	    value: function asX2JS(emoticon) {
	      return {
	        id: String(emoticon.id),
	        shortcut: emoticon.shortcut,
	        path: emoticon.path,
	        w: String(emoticon.w),
	        h: String(emoticon.h),
	        type: emoticon.type
	      };
	    }
	  }]);
	  return Emoticon;
	}();

	exports.default = Emoticon;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _for = __webpack_require__(145);
	
	var _for2 = _interopRequireDefault(_for);
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	var _Object$freeze2; /**
	                      * @IMPORTANT: DO NOT IMPORT THIS MODULE DIRECTLY!!!
	                      * IF YOU NEED TO ACCESS STORAGE, DO SO VIA THE DAL.CACHE MODULE.
	                      * IT SHOULD OWN THE ONLY INSTANCE OF THIS ADAPTER, AND ALL METHODS
	                      * WRITTEN TO INTERFACE WITH STORAGE SHOULD BE WRITTEN THERE
	                      */
	
	
	var _browser_storage_keys = __webpack_require__(158);
	
	var Keys = _interopRequireWildcard(_browser_storage_keys);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PREFIX = 'hc.';
	var LEGACY_PREFIX = 'hc-';
	
	/*
	 * Browser storage locations
	 */
	var LOCATIONS = (0, _freeze2.default)({
	  LOCAL: 'localStorage',
	  SESSION: 'sessionStorage'
	});
	
	/*
	 * Defines the current/expected storage schema. Used to invalidate
	 * the cache when we make changes to the shape of the data we store
	 */
	var SCHEMA = (0, _freeze2.default)((_Object$freeze2 = {}, (0, _defineProperty3.default)(_Object$freeze2, Keys.ROSTER, '3'), (0, _defineProperty3.default)(_Object$freeze2, Keys.ROOMS, '4'), (0, _defineProperty3.default)(_Object$freeze2, Keys.EMOTICONS, '1'), _Object$freeze2));
	
	/*
	 * Keys for data migration/cleanup
	 */
	var OBSOLETE_KEYS = [Keys.PER_ROOM_NOTIFICATION_DIALOG_SHOWN, 'hc._' + Keys.USER_ID, 'hc._' + Keys.GROUP_ID, 'hc._' + Keys.ROOMS, 'hc._' + Keys.ROSTER, 'hc._' + Keys.EMOTICONS];
	
	var LEGACY_KEYS = [Keys.NOTIF_BANNER_DISMISSAL_COUNT, Keys.NOTIF_BANNER_DISMISSED_FOREVER, Keys.INTEGRATIONS, Keys.CLIENT_PREFERENCES, Keys.READSTATE];
	
	/*
	 * Cross-browser check for localStorage quota exceeded error
	 * http://crocodillon.com/blog/always-catch-localstorage-security-and-quota-exceeded-errors
	 */
	function isQuotaExceededError(error) {
	  switch (error.code) {
	    case 22:
	      // Most browsers
	      return true;
	
	    case 1014:
	      // Firefox :-(
	      return error.name === 'NS_ERROR_DOM_QUOTA_REACHED';
	
	    default:
	      return false;
	  }
	}
	
	/**
	 * @class BrowserStorage
	 */
	
	var BrowserStorage = function () {
	
	  /**
	   * Instantiates the class. Checks user/group against provided params and
	   * throws away all stored data if they do not match. Clears out legacy
	   * localStorage data that we don't use anymore and migrates data stored
	   * in the prior localStorage adapter.
	   *
	   * @constructs
	   * @param {number} user_id
	   * @param {number} group_id
	   */
	
	  function BrowserStorage(user_id, group_id) {
	    (0, _classCallCheck3.default)(this, BrowserStorage);
	
	
	    // If the user/group doesn't match what was provided, throw everything away
	    if (this._shouldClearPriorUserData(user_id, group_id)) {
	      this.clear();
	
	      // Otherwise, migrate over data from legacy storage implementations
	    } else {
	        this._clearObsoleteData();
	        this._migrateLegacyKeys();
	      }
	
	    this.set(Keys.SCHEMA, SCHEMA);
	    this.set(Keys.USER_ID, user_id);
	    this.set(Keys.GROUP_ID, group_id);
	  }
	
	  /**
	   * @method has
	   * @param {string} key
	   * @param {object} [options = { location: 'localStorage' }]
	   * @returns {boolean}
	   */
	
	
	  (0, _createClass3.default)(BrowserStorage, [{
	    key: 'has',
	    value: function has(key) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? { location: LOCATIONS.LOCAL } : arguments[1];
	
	      return PREFIX + key in this._getAPI(options.location);
	    }
	
	    /**
	     * @method get
	     * @param {string} key
	     * @param {object} [options = { location: 'localStorage' }]
	     * @returns {*}
	     */
	
	  }, {
	    key: 'get',
	    value: function get(key) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? { location: LOCATIONS.LOCAL } : arguments[1];
	
	      var api = this._getAPI(options.location);
	      if (this.has(key, options)) {
	        return this._deserialize(api.getItem(PREFIX + key));
	      }
	      return null;
	    }
	
	    /**
	     * @method set
	     * @param {string} key
	     * @param {*} value
	     * @param {object} [options = { location: 'localStorage' }]
	     */
	
	  }, {
	    key: 'set',
	    value: function set(key, value) {
	      var options = arguments.length <= 2 || arguments[2] === undefined ? { location: LOCATIONS.LOCAL } : arguments[2];
	
	      var api = this._getAPI(options.location),
	          data = this._serialize(value);
	      try {
	        api.setItem(PREFIX + key, data);
	      } catch (e) {
	        this.unset(key, options); // erase partial writes
	        var error = isQuotaExceededError(e) ? _dalError2.default.ofType(_dalError2.default.Types.STORAGE_DOM_QUOTA_EXCEEDED, e) : _dalError2.default.ofType(_dalError2.default.Types.EXCEPTION, e);
	        if (window.Raven) {
	          window.Raven.captureException(error);
	        }
	        throw error;
	      }
	      return true;
	    }
	
	    /**
	     * @method unset
	     * @param {string} key
	     * @param {object} [options = { location: 'localStorage' }]
	     * @returns {boolean}
	     */
	
	  }, {
	    key: 'unset',
	    value: function unset(key) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? { location: LOCATIONS.LOCAL } : arguments[1];
	
	      var api = this._getAPI(options.location);
	      api.removeItem(PREFIX + key);
	      return true;
	    }
	
	    /**
	     * For both localStorage and sessionStorage, find all keys that contain either
	     * the new or legacy prefixes and remove the items completely
	     *
	     * @method clear
	     */
	
	  }, {
	    key: 'clear',
	    value: function clear() {
	      var _this = this;
	
	      var prefixMatch = new RegExp('^' + PREFIX + '|^' + LEGACY_PREFIX);
	      _.forOwn(LOCATIONS, function (location) {
	        var api = _this._getAPI(location);
	        (0, _keys2.default)(api).filter(function (key) {
	          return prefixMatch.test(key);
	        }).forEach(function (key) {
	          return api.removeItem(key);
	        });
	      });
	      return true;
	    }
	
	    /**
	     * Check provided user and group id against previously stored values (if they exist)
	     * Returns true if the prior values exist and they don't match the provided values
	     * @private
	     */
	
	  }, {
	    key: '_shouldClearPriorUserData',
	    value: function _shouldClearPriorUserData(user_id, group_id) {
	      if (this.has(Keys.USER_ID) && this.has(Keys.GROUP_ID)) {
	        var prevUser = this.get(Keys.USER_ID),
	            prevGroup = this.get(Keys.GROUP_ID);
	        return !(prevUser === user_id && prevGroup === group_id);
	      }
	      return false;
	    }
	
	    /**
	     * Directly accessing window.localStorage will throw if the user has
	     * disabled it in the browser (ohcrap)
	     * @private
	     */
	
	  }, {
	    key: '_getAPI',
	    value: function _getAPI(location) {
	      try {
	        switch (location) {
	          case LOCATIONS.SESSION:
	            return window.sessionStorage;
	          case LOCATIONS.LOCAL:
	          default:
	            return window.localStorage;
	        }
	      } catch (e) {
	        var error = _dalError2.default.ofType(_dalError2.default.Types.STORAGE_INACCESSIBLE, e);
	        if (window.Raven) {
	          window.Raven.captureException(error);
	        }
	        throw error;
	      }
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_serialize',
	    value: function _serialize(value) {
	      return (0, _stringify2.default)(value, function (k, v) {
	        if (v instanceof RegExp) {
	          return v.toString();
	        }
	        return v;
	      });
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_deserialize',
	    value: function _deserialize(value) {
	      if (_.includes(['null', 'undefined', ''], value)) {
	        return null;
	      }
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        var error = _dalError2.default.ofType(_dalError2.default.Types.STORAGE_JSON_SERIALIZATION, e);
	        if (window.Raven) {
	          window.Raven.captureException(error);
	        }
	        return null;
	      }
	    }
	
	    /**
	     * Clean out obsolete data
	     * @private
	     */
	
	  }, {
	    key: '_clearObsoleteData',
	    value: function _clearObsoleteData() {
	      var _this2 = this;
	
	      var oldSchema = this.get(Keys.SCHEMA),
	          api = this._getAPI();
	
	      // check expected schema against last stored schema
	      // and delete any data under keys where they don't match
	      (0, _keys2.default)(SCHEMA).forEach(function (key) {
	        if (!oldSchema || oldSchema[key] !== SCHEMA[key]) {
	          _this2.unset(key);
	        }
	      });
	
	      // delete data stored under old/unused keys
	      // these are not prefixed
	      OBSOLETE_KEYS.forEach(function (key) {
	        api.removeItem(key);
	      });
	    }
	
	    /**
	     * Migrate data stored under old "hc-" prefixed keys to
	     * use the new "hc." prefix for consistency
	     * @private
	     */
	
	  }, {
	    key: '_migrateLegacyKeys',
	    value: function _migrateLegacyKeys() {
	      var api = this._getAPI();
	      LEGACY_KEYS.forEach(function (key) {
	        var legacyKey = LEGACY_PREFIX + key,
	            newKey = PREFIX + key;
	        if (legacyKey in api) {
	          var data = api.getItem(legacyKey);
	          api.removeItem(legacyKey);
	          api.setItem(newKey, data);
	        }
	      });
	    }
	  }]);
	  return BrowserStorage;
	}();
	
	/*
	 * Expose constants above as static properties on the class
	 * Hide the schema in a symbol since that should never be directly
	 * accessed, other than in testing
	 */
	
	
	BrowserStorage[(0, _for2.default)('HJC.Storage.Schema')] = SCHEMA;
	BrowserStorage.Locations = LOCATIONS;
	
	exports.default = BrowserStorage;
	module.exports = exports['default'];

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(6);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	
	  return obj;
	};

/***/ },
/* 158 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var NOTIF_BANNER_DISMISSED_FOREVER = exports.NOTIF_BANNER_DISMISSED_FOREVER = 'notificationBannerDismissedForever';
	var NOTIF_BANNER_DISMISSAL_COUNT = exports.NOTIF_BANNER_DISMISSAL_COUNT = 'notificationBannerDismissalCount';
	var PER_ROOM_NOTIFICATION_DIALOG_SHOWN = exports.PER_ROOM_NOTIFICATION_DIALOG_SHOWN = 'perRoomNotificationsDialogShown';
	
	var ROSTER = exports.ROSTER = 'roster';
	var ROOMS = exports.ROOMS = 'rooms-wo-archived';
	var EMOTICONS = exports.EMOTICONS = 'emoticons';
	var GROUP_ID = exports.GROUP_ID = 'group_id';
	var USER_ID = exports.USER_ID = 'user_id';
	var SCHEMA = exports.SCHEMA = 'storage-schema';
	var INTEGRATIONS = exports.INTEGRATIONS = 'integrations';
	var CLIENT_PREFERENCES = exports.CLIENT_PREFERENCES = 'client-preferences';
	
	var ANALYTICS = exports.ANALYTICS = 'hc_web-herment-storage-key';
	var READSTATE = exports.READSTATE = 'pending-readstate';

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  /**
	   * Notifies native client that API V1 auth token has been updated.
	   * Native client updates the cookie.
	   */
	
	  updateAuthTokens: function updateAuthTokens(config) {
	    _app_dispatcher2.default.dispatch('auth-token-update', config);
	  },
	  updateFeatureFlags: function updateFeatureFlags(config) {
	    _app_dispatcher2.default.dispatch('feature-flags-update', config);
	  },
	  updateAppConfiguration: function updateAppConfiguration(config) {
	    _app_dispatcher2.default.dispatch('configuration-change', config);
	  },
	  serverUnsupportedError: function serverUnsupportedError(reason) {
	    _app_dispatcher2.default.dispatch('server-unsupported', reason);
	  },
	  updateSID: function updateSID(config) {
	    _app_dispatcher2.default.dispatch('update-sid', config);
	  },
	  cacheConfigured: function cacheConfigured() {
	    _app_dispatcher2.default.dispatch('DAL:cache-configured');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _Compressors;
	
	var _user = __webpack_require__(152);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _room = __webpack_require__(153);
	
	var _room2 = _interopRequireDefault(_room);
	
	var _emoticon = __webpack_require__(155);
	
	var _emoticon2 = _interopRequireDefault(_emoticon);
	
	var _browser_storage_keys = __webpack_require__(158);
	
	var Keys = _interopRequireWildcard(_browser_storage_keys);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * Compression algorithms for saving space in localStorage
	 * Keyed by the localStorage key
	 */
	var Compressors = (_Compressors = {}, (0, _defineProperty3.default)(_Compressors, Keys.ROSTER, {
	  dehydrate: function dehydrate(roster) {
	    if (_.isNull(roster)) {
	      return null;
	    }
	    return _.transform(roster, function (result, user, id) {
	      result['g'] = result['g'] || _utils2.default.jid.group_id(user.jid);
	      result['c'] = result['c'] || _utils2.default.jid.domain(user.jid);
	      result['u'] = result['u'] || {};
	      result['u'][id] = [user.name, user.mention_name, user.email, user.photo_url, user.version];
	      return result;
	    });
	  },
	  rehydrate: function rehydrate(roster) {
	    if (_.isNull(roster)) {
	      return null;
	    }
	    return _.transform(roster['u'], function (result, user, id) {
	      result[id] = new _user2.default({
	        id: parseInt(id, 10),
	        jid: roster['g'] + '_' + id + '@' + roster['c'],
	        name: user[0],
	        mention_name: user[1],
	        email: user[2],
	        photo_url: user[3],
	        version: user[4],
	        is_guest: false, // guest users are not saved to storage
	        is_deleted: false // deleted users are not saved to storage
	      });
	      return result;
	    });
	  }
	}), (0, _defineProperty3.default)(_Compressors, Keys.ROOMS, {
	  dehydrate: function dehydrate(rooms) {
	    if (_.isNull(rooms)) {
	      return null;
	    }
	    return _.transform(rooms, function (result, room, id) {
	      result['g'] = result['g'] || _utils2.default.jid.group_id(room.jid);
	      result['c'] = result['c'] || _utils2.default.jid.domain(room.jid);
	      result['u'] = result['u'] || {};
	      result['u'][id] = [room.name, _utils2.default.jid.room_name(room.jid), room.privacy === _room.PrivacyLevels.PUBLIC ? 1 : 0, room.owner, room.guest_url, room.avatar_url, room.version];
	      return result;
	    });
	  },
	  rehydrate: function rehydrate(rooms) {
	    if (_.isNull(rooms)) {
	      return null;
	    }
	    return _.transform(rooms['u'], function (result, room, id) {
	      result[id] = new _room2.default({
	        id: parseInt(id, 10),
	        name: room[0],
	        jid: rooms['g'] + '_' + room[1] + '@' + rooms['c'],
	        privacy: room[2] === 1 ? _room.PrivacyLevels.PUBLIC : _room.PrivacyLevels.PRIVATE,
	        owner: room[3],
	        guest_url: room[4],
	        avatar_url: room[5],
	        version: room[6],
	        topic: null,
	        is_archived: false,
	        is_deleted: false
	      });
	      return result;
	    });
	  }
	}), (0, _defineProperty3.default)(_Compressors, Keys.EMOTICONS, {
	  dehydrate: function dehydrate(iq) {
	    if (_.isNull(iq)) {
	      return null;
	    }
	    return {
	      p: iq.query.path_prefix,
	      v: iq.query.ver,
	      i: _.map(iq.query.item, function (emoticon, i) {
	        return [parseInt(emoticon.id, 10), emoticon.shortcut, emoticon.path, parseInt(emoticon.w, 10), parseInt(emoticon.h, 10), emoticon.type === _emoticon.EmoticonTypes.GROUP ? 1 : 0];
	      })
	    };
	  },
	  rehydrate: function rehydrate(emoticons) {
	    if (_.isNull(emoticons)) {
	      return null;
	    }
	    return {
	      type: 'result',
	      query: {
	        path_prefix: emoticons['p'],
	        ver: emoticons['v'],
	        item: emoticons['i'].map(function (emoticon, i) {
	          return new _emoticon2.default({
	            id: emoticon[0],
	            shortcut: emoticon[1],
	            path: emoticon[2],
	            w: emoticon[3],
	            h: emoticon[4],
	            type: emoticon[5] === 1 ? _emoticon.EmoticonTypes.GROUP : _emoticon.EmoticonTypes.GLOBAL
	          });
	        })
	      }
	    };
	  }
	}), _Compressors);
	
	/**
	 * @module Compressors
	 */
	exports.default = {
	
	  /**
	   * @method dehydrate
	   * @param {string} key - one of browser storage keys
	   * @param {*} val - the data to be compressed
	   * @returns {*} - the compressed version, if there is a compression algorithm for the given key
	   *  otherwise, returns the data it was passed
	   */
	
	  dehydrate: function dehydrate(key, val) {
	    if (Compressors[key]) {
	      return Compressors[key].dehydrate(val);
	    }
	    return val;
	  },
	
	
	  /**
	   * @method rehydrate
	   * @param {string} key - one of browser storage keys
	   * @param {*} val - the data to be decompressed
	   * @returns {*} - the decompressed version, if there is a compression algorithm for the given key
	   *  otherwise, returns the data it was passed
	   */
	  rehydrate: function rehydrate(key, val) {
	    if (Compressors[key]) {
	      return Compressors[key].rehydrate(val);
	    }
	    return val;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _model_store = __webpack_require__(162);
	
	var _model_store2 = _interopRequireDefault(_model_store);
	
	var _constants = __webpack_require__(163);
	
	var Constants = _interopRequireWildcard(_constants);
	
	var _dal = __webpack_require__(144);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _preferences_model = __webpack_require__(165);
	
	var _preferences_model2 = _interopRequireDefault(_preferences_model);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SERVER_KEYS = void 0,
	    CLIENT_KEYS = void 0;
	
	var PreferencesStore = function (_ModelStore) {
	  (0, _inherits3.default)(PreferencesStore, _ModelStore);
	
	
	  /**
	   * On construction of the store, pull in any saved localStorage preferences
	   */
	
	  function PreferencesStore() {
	    (0, _classCallCheck3.default)(this, PreferencesStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(PreferencesStore).call(this));
	
	    _this._initKeys();
	    _this._throttledSavePrefs = _.throttle(_this.savePrefs, _app_config2.default.save_preferences_throttle_interval, { leading: true, trailing: true });
	    _this.local = {
	      queued: {},
	      cache_configured: false
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(PreferencesStore, [{
	    key: '_initKeys',
	    value: function _initKeys() {
	      SERVER_KEYS = _.invert(_preferences_keys2.default);
	      CLIENT_KEYS = _.invert(_client_preferences_keys2.default);
	      CLIENT_KEYS = _.assign(CLIENT_KEYS, SERVER_KEYS);
	
	      // HW-1127 To prevent messing up order in OTO chats
	      CLIENT_KEYS = _.omit(CLIENT_KEYS, [_preferences_keys2.default.AUTO_JOIN]);
	    }
	  }, {
	    key: 'getModel',
	    value: function getModel() {
	      return _preferences_model2.default;
	    }
	  }, {
	    key: 'flush',
	    value: function flush() {
	      if (this.local.cache_configured) {
	        _dal2.default.set(_dal2.default.Keys.CLIENT_PREFERENCES, this.getClientPreferences());
	      }
	    }
	  }, {
	    key: 'getServerPreferences',
	    value: function getServerPreferences() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? this.getAll() : arguments[0];
	
	      return _.pickBy(from, function (val, key) {
	        return _.has(SERVER_KEYS, key);
	      });
	    }
	  }, {
	    key: 'getClientPreferences',
	    value: function getClientPreferences() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? this.getAll() : arguments[0];
	
	      return _.pickBy(from, function (val, key) {
	        return _.has(CLIENT_KEYS, key);
	      });
	    }
	  }, {
	    key: 'getDefaults',
	    value: function getDefaults() {
	      var _ref;
	
	      return _ref = {}, (0, _defineProperty3.default)(_ref, _preferences_keys2.default.NOTIFY_WHEN_DND, false), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.NOTIFY_FOR_VIDEO_WHEN_DND, false), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.THEME, _app_config2.default.default_theme), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.DENSITY, _app_config2.default.default_density), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.CHAT_VIEW, _app_config2.default.default_chat_view), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.NAME_DISPLAY, _app_config2.default.default_name_display), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.ENABLE_IDLE, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.IDLE_MINUTES, Constants.IDLE_DELAY_MINUTES), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.NOTIFY_FOR_ROOM, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.NOTIFY_FOR_TAG, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.NOTIFY_FOR_PRIVATE_ROOM, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.NOTIFY_FOR_PRIVATE, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.HIDE_PRESENCE_MESSAGES, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.SOUNDS_ENABLED, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.MESSAGE_SOUNDS, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.VIDEO_SOUNDS, true), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.GLOBAL_NOTIFICATION_SETTING, 'loud'), (0, _defineProperty3.default)(_ref, _preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE, ''), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.ANIMATED_AVATARS, _app_config2.default.default_animated_avatars), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.HIDE_GIFS_BY_DEFAULT, false), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.ENABLE_SPELL_CHECK, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.ENABLE_AUTOCORRECT, false), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.HIDE_ATTACHED_CARDS_BY_DEFAULT, false), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.REPLACE_TEXT_EMOTICONS, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.SHOW_UNREAD_DIVIDER, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.SHOW_CHAT_SIDEBAR, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.SHOW_GROUPCHAT_SIDEBAR, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.SHOW_NAVIGATION_SIDEBAR, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.CHAT_ACTIVE_PANEL, 'files'), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.GROUPCHAT_ACTIVE_PANEL, 'roster'), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.LEFT_COLUMN_WIDTH, _app_config2.default.column_width_limits['left'].default), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.RIGHT_COLUMN_WIDTH, _app_config2.default.column_width_limits['right'].default), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.KEEP_POPUPS_VISIBLE, false), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.BLINK_TASKBAR, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.BOUNCE_ICON, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.BOUNCE_ONCE, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.ENABLE_LOGGING, false), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.SHOW_QUICK_SWITCHER_HINT, true), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.ACTIVE_CHAT_INTEGRATION, null), (0, _defineProperty3.default)(_ref, _client_preferences_keys2.default.ACTIVE_GROUPCHAT_INTEGRATION, null), _ref;
	    }
	
	    /**
	     * This function ensures that we have valid values for our settings (especially in the scenario of a new user).
	     * The validity of these values is important when determining the default value of globalNotificationSetting.
	     *
	     * @param config the configuration object that we get when HC has initialized
	     */
	
	  }, {
	    key: 'getValidDefaults',
	    value: function getValidDefaults(config) {
	      var _overrides;
	
	      var serverSettings = _.pickBy(config.preferences, function (x) {
	        return !_.isNull(x) && !_.isUndefined(x) && x !== '';
	      }),
	          overrides = (_overrides = {}, (0, _defineProperty3.default)(_overrides, _preferences_keys2.default.NOTIFY_FOR_ROOM, _.get(serverSettings, _preferences_keys2.default.NOTIFY_FOR_ROOM, true)), (0, _defineProperty3.default)(_overrides, _preferences_keys2.default.NOTIFY_FOR_PRIVATE_ROOM, _.get(serverSettings, _preferences_keys2.default.NOTIFY_FOR_PRIVATE_ROOM, true)), _overrides);
	
	      // if they don't have a default for the global notification setting, set it based on the room settings above
	      if (_.get(config, "feature_flags.web_client_per_room_notifications")) {
	        var globalDefault = overrides[_preferences_keys2.default.NOTIFY_FOR_ROOM] || overrides[_preferences_keys2.default.NOTIFY_FOR_PRIVATE_ROOM] ? "loud" : "normal";
	        overrides[_preferences_keys2.default.GLOBAL_NOTIFICATION_SETTING] = _.get(serverSettings, _preferences_keys2.default.GLOBAL_NOTIFICATION_SETTING, globalDefault);
	      }
	
	      return _.extend(this.getAll(), serverSettings, overrides);
	    }
	  }, {
	    key: 'getNotificationTypes',
	    value: function getNotificationTypes() {
	      var _ref2;
	
	      return _ref2 = {}, (0, _defineProperty3.default)(_ref2, _preferences_keys2.default.SHOW_TOASTERS, this.getShowToasters()), (0, _defineProperty3.default)(_ref2, _client_preferences_keys2.default.BLINK_TASKBAR, this.shouldBlinkTaskBar()), (0, _defineProperty3.default)(_ref2, _client_preferences_keys2.default.BOUNCE_ICON, this.shouldBounceIcon()), (0, _defineProperty3.default)(_ref2, _client_preferences_keys2.default.BOUNCE_ONCE, this.shouldBounceOnce()), _ref2;
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'DAL:cache-configured': function DALCacheConfigured() {
	          _this2.local.cache_configured = true;
	          _dal2.default.get(_dal2.default.Keys.CLIENT_PREFERENCES).then(function (prefs) {
	            _this2.set(prefs);
	          });
	        }
	      });
	      _app_dispatcher2.default.register({
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.setChatToFocus(jid);
	        },
	        'updated:config': function updatedConfig(config) {
	          if (_.has(config, 'preferences')) {
	            if (_.has(config, 'preferences.properties') && !_.isObject(config.preferences.properties)) {
	              delete config.preferences.properties;
	            }
	            _this2.setIfNotEqual(_.omitBy(config.preferences, _.isUndefined));
	          }
	          if (_.has(config, 'feature_flags')) {
	            _this2.set({
	              web_client_integrations_enabled: _integration_helper2.default.isFeatureEnabled(config),
	              web_client_freeze_gifs: _.get(config, 'feature_flags.web_client_freeze_gifs', false)
	            });
	          }
	        },
	        'updated:ignoreAddIntegrationsGlance': function updatedIgnoreAddIntegrationsGlance(roomIdArray) {
	          _this2.set(_preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE, roomIdArray);
	        },
	        'save-preferences': function savePreferences(prefs) {
	          _this2.setIfNotEqual(prefs);
	        },
	        'add-room-integration-discovery-ignore-list': function addRoomIntegrationDiscoveryIgnoreList(roomId) {
	          _this2.addRoomToIgnoreIntegrationGlanceList(roomId);
	        },
	        'close-room': function closeRoom(data) {
	          _this2.removeRoom(data);
	        },
	        'toggle-sound-notifications': function toggleSoundNotifications() {
	          _this2.toggleSounds();
	        },
	        'set-first-login-date': function setFirstLoginDate() {
	          _this2.setFirstLoginDate();
	        },
	        'unload-app': function unloadApp() {
	          _this2.savePrefs();
	        }
	      });
	
	      this.on('change', this._onChange);
	    }
	  }, {
	    key: '_onChange',
	    value: function _onChange(changeset) {
	      var serverChanges = this.getServerPreferences(changeset);
	      var clientChanges = this.getClientPreferences(changeset);
	      if (!_.isEmpty(clientChanges)) {
	        this.flush();
	      }
	      if (!_.isEmpty(serverChanges)) {
	        _.assign(this.local.queued, serverChanges);
	        this._throttledSavePrefs();
	      }
	      _app_dispatcher2.default.dispatch('updated:preferences', this.getAll());
	    }
	  }, {
	    key: 'savePrefs',
	    value: function savePrefs() {
	      _app_dispatcher2.default.dispatch('sync-preferences', this.local.queued);
	      this.local.queued = {};
	    }
	  }, {
	    key: 'getAutoJoinRooms',
	    value: function getAutoJoinRooms() {
	      return this.get(_preferences_keys2.default.AUTO_JOIN);
	    }
	  }, {
	    key: 'setAutoJoinRooms',
	    value: function setAutoJoinRooms(autoJoinRooms) {
	      this.set((0, _defineProperty3.default)({}, _preferences_keys2.default.AUTO_JOIN, autoJoinRooms));
	    }
	  }, {
	    key: 'getChatToFocus',
	    value: function getChatToFocus() {
	      return this.get(_client_preferences_keys2.default.CHAT_TO_FOCUS);
	    }
	  }, {
	    key: 'getSoundsEnabled',
	    value: function getSoundsEnabled() {
	      return this.get(_preferences_keys2.default.SOUNDS_ENABLED);
	    }
	  }, {
	    key: 'getMessageSounds',
	    value: function getMessageSounds() {
	      return this.get(_preferences_keys2.default.MESSAGE_SOUNDS);
	    }
	  }, {
	    key: 'getVideoSounds',
	    value: function getVideoSounds() {
	      return this.get(_preferences_keys2.default.VIDEO_SOUNDS);
	    }
	  }, {
	    key: 'getShowToasters',
	    value: function getShowToasters() {
	      return this.get(_preferences_keys2.default.SHOW_TOASTERS);
	    }
	  }, {
	    key: 'getBlinkTaskBar',
	    value: function getBlinkTaskBar() {
	      return this.get(_client_preferences_keys2.default.BLINK_TASKBAR);
	    }
	  }, {
	    key: 'getBounceIcon',
	    value: function getBounceIcon() {
	      return this.get(_client_preferences_keys2.default.BOUNCE_ICON);
	    }
	  }, {
	    key: 'getBounceOnce',
	    value: function getBounceOnce() {
	      return this.get(_client_preferences_keys2.default.BOUNCE_ONCE);
	    }
	  }, {
	    key: 'toggleSounds',
	    value: function toggleSounds() {
	      this.set(_preferences_keys2.default.SOUNDS_ENABLED, !this.getSoundsEnabled());
	    }
	  }, {
	    key: 'getHidePresenceMessages',
	    value: function getHidePresenceMessages() {
	      return this.get(_preferences_keys2.default.HIDE_PRESENCE_MESSAGES);
	    }
	  }, {
	    key: 'shouldUse24HrTime',
	    value: function shouldUse24HrTime() {
	      return this.get(_preferences_keys2.default.USE_24_HR_FORMAT) || false;
	    }
	
	    /**
	     * Check if the notification should be shown
	     */
	
	  }, {
	    key: 'shouldIssueNotification',
	    value: function shouldIssueNotification() {
	      return this.getShowToasters() || this.shouldBlinkTaskBar() || this.shouldBounceIcon();
	    }
	  }, {
	    key: 'setChatToFocus',
	    value: function setChatToFocus(jid) {
	      if (!_utils2.default.jid.is_search(jid)) {
	        this.data.chatToFocus = jid ? jid.replace(/"/g, '') : '';
	        this._onChange((0, _defineProperty3.default)({}, _client_preferences_keys2.default.CHAT_TO_FOCUS, this.data.chatToFocus));
	      }
	    }
	  }, {
	    key: 'removeRoom',
	    value: function removeRoom(data) {
	      var autoJoinRooms = _.filter(this.getAutoJoinRooms(), function (room) {
	        return room.jid !== data.jid;
	      });
	      this.set((0, _defineProperty3.default)({}, _preferences_keys2.default.AUTO_JOIN, autoJoinRooms));
	    }
	  }, {
	    key: 'setFirstLoginDate',
	    value: function setFirstLoginDate() {
	      var properties = this.get(_preferences_keys2.default.PROPERTIES) || {};
	      properties[_preferences_keys2.default.PROPERTIES_FIRST_LOGIN_DATE] = new Date().getTime();
	      this.set(_preferences_keys2.default.PROPERTIES, properties);
	    }
	  }, {
	    key: 'getRoomNotificationOverrides',
	    value: function getRoomNotificationOverrides() {
	      var overrides = this.get(_preferences_keys2.default.ROOM_NOTIFICATION_OVERRIDES);
	      return _.isEmpty(overrides) ? {} : overrides;
	    }
	  }, {
	    key: 'overrideNotificationForRoom',
	    value: function overrideNotificationForRoom(room_jid, override_info) {
	      var overrides = _.cloneDeep(this.getRoomNotificationOverrides());
	      overrides[room_jid] = override_info;
	      this.set(_preferences_keys2.default.ROOM_NOTIFICATION_OVERRIDES, overrides);
	    }
	  }, {
	    key: 'removeRoomNotificationOverride',
	    value: function removeRoomNotificationOverride(room_jid) {
	      var overrides = _.omit(this.getRoomNotificationOverrides(), room_jid);
	      this.set(_preferences_keys2.default.ROOM_NOTIFICATION_OVERRIDES, overrides);
	    }
	  }, {
	    key: 'getGlobalNotificationSetting',
	    value: function getGlobalNotificationSetting() {
	      return this.get(_preferences_keys2.default.GLOBAL_NOTIFICATION_SETTING);
	    }
	  }, {
	    key: 'setGlobalNotificationSetting',
	    value: function setGlobalNotificationSetting(level) {
	      this.set(_preferences_keys2.default.GLOBAL_NOTIFICATION_SETTING, level);
	    }
	  }, {
	    key: 'getNotifyWhenDND',
	    value: function getNotifyWhenDND() {
	      return this.get(_preferences_keys2.default.NOTIFY_WHEN_DND);
	    }
	  }, {
	    key: 'getNotifyForVideoWhenDND',
	    value: function getNotifyForVideoWhenDND() {
	      return this.get(_preferences_keys2.default.NOTIFY_FOR_VIDEO_WHEN_DND);
	    }
	  }, {
	    key: 'shouldHideGifsByDefault',
	    value: function shouldHideGifsByDefault() {
	      return this.get(_client_preferences_keys2.default.HIDE_GIFS_BY_DEFAULT);
	    }
	  }, {
	    key: 'shouldHideAttachedCardsByDefault',
	    value: function shouldHideAttachedCardsByDefault() {
	      return this.get(_client_preferences_keys2.default.HIDE_ATTACHED_CARDS_BY_DEFAULT);
	    }
	  }, {
	    key: 'shouldReplaceTextEmoticons',
	    value: function shouldReplaceTextEmoticons() {
	      return this.get(_client_preferences_keys2.default.REPLACE_TEXT_EMOTICONS);
	    }
	  }, {
	    key: 'shouldShowUnreadMessageDivider',
	    value: function shouldShowUnreadMessageDivider() {
	      return this.get(_client_preferences_keys2.default.SHOW_UNREAD_DIVIDER);
	    }
	  }, {
	    key: 'shouldShowChatSidebar',
	    value: function shouldShowChatSidebar() {
	      return this.get(_client_preferences_keys2.default.SHOW_CHAT_SIDEBAR);
	    }
	  }, {
	    key: 'shouldShowGroupChatSidebar',
	    value: function shouldShowGroupChatSidebar() {
	      return this.get(_client_preferences_keys2.default.SHOW_GROUPCHAT_SIDEBAR);
	    }
	  }, {
	    key: 'shouldShowNavigationSidebar',
	    value: function shouldShowNavigationSidebar() {
	      return this.get(_client_preferences_keys2.default.SHOW_NAVIGATION_SIDEBAR);
	    }
	  }, {
	    key: 'getChatActivePanel',
	    value: function getChatActivePanel() {
	      var chatActivePanel = this.get(_client_preferences_keys2.default.CHAT_ACTIVE_PANEL);
	      if (this.get('web_client_integrations_enabled')) {
	        return 'integrations';
	      } else if (chatActivePanel === 'integrations') {
	        return 'files';
	      }
	      return chatActivePanel;
	    }
	  }, {
	    key: 'getGroupChatActivePanel',
	    value: function getGroupChatActivePanel() {
	      var activeGroupChatPanel = this.get(_client_preferences_keys2.default.GROUPCHAT_ACTIVE_PANEL);
	      if (this.get('web_client_integrations_enabled')) {
	        return 'integrations';
	      } else if (activeGroupChatPanel === 'integrations') {
	        return 'roster';
	      }
	      return activeGroupChatPanel;
	    }
	  }, {
	    key: 'getActiveGroupchatIntegration',
	    value: function getActiveGroupchatIntegration() {
	      return this.get(_client_preferences_keys2.default.ACTIVE_GROUPCHAT_INTEGRATION);
	    }
	  }, {
	    key: 'getActiveChatIntegration',
	    value: function getActiveChatIntegration() {
	      return this.get(_client_preferences_keys2.default.ACTIVE_CHAT_INTEGRATION);
	    }
	  }, {
	    key: 'getLeftColumnWidth',
	    value: function getLeftColumnWidth() {
	      return this.get(_client_preferences_keys2.default.LEFT_COLUMN_WIDTH);
	    }
	  }, {
	    key: 'getRightColumnWidth',
	    value: function getRightColumnWidth() {
	      return this.get(_client_preferences_keys2.default.RIGHT_COLUMN_WIDTH);
	    }
	  }, {
	    key: 'getChatView',
	    value: function getChatView() {
	      return this.get(_preferences_keys2.default.CHAT_VIEW);
	    }
	  }, {
	    key: 'getNameDisplay',
	    value: function getNameDisplay() {
	      return this.get(_preferences_keys2.default.NAME_DISPLAY);
	    }
	  }, {
	    key: 'getShowQuickSwitcherHint',
	    value: function getShowQuickSwitcherHint() {
	      return this.get(_client_preferences_keys2.default.SHOW_QUICK_SWITCHER_HINT);
	    }
	  }, {
	    key: 'getNameDisplayOptions',
	    value: function getNameDisplayOptions() {
	      return ['names', 'mentions'];
	    }
	  }, {
	    key: 'getIgnoreAddIntegrationGlanceRooms',
	    value: function getIgnoreAddIntegrationGlanceRooms() {
	      return this._convertStringToIntArray(this.get(_preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE));
	    }
	  }, {
	    key: '_convertStringToIntArray',
	    value: function _convertStringToIntArray(string) {
	      var intArray = [];
	      if (string) {
	        intArray = string.split(',').map(Number);
	      }
	      return intArray;
	    }
	  }, {
	    key: 'addRoomToIgnoreIntegrationGlanceList',
	    value: function addRoomToIgnoreIntegrationGlanceList(roomId) {
	      var roomsThatDismissedIntegrationsGlance = this._convertStringToIntArray(this.get(_preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE));
	      if (!_.includes(roomsThatDismissedIntegrationsGlance, roomId)) {
	        roomsThatDismissedIntegrationsGlance.push(roomId);
	        this.set(_preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE, roomsThatDismissedIntegrationsGlance.join());
	      }
	      _app_dispatcher2.default.dispatch('save-preferences', (0, _defineProperty3.default)({}, _preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE, roomsThatDismissedIntegrationsGlance.join()));
	    }
	  }, {
	    key: 'getTheme',
	    value: function getTheme() {
	      return this.get(_preferences_keys2.default.THEME);
	    }
	  }, {
	    key: 'isDarkTheme',
	    value: function isDarkTheme() {
	      return this.getTheme() === this.DARK_THEME;
	    }
	  }, {
	    key: 'getThemeOptions',
	    value: function getThemeOptions() {
	      return [this.LIGHT_THEME, this.DARK_THEME];
	    }
	  }, {
	    key: 'getChatViewOptions',
	    value: function getChatViewOptions() {
	      return ['classic_neue', 'classic'];
	    }
	  }, {
	    key: 'getDensity',
	    value: function getDensity() {
	      return this.get(_preferences_keys2.default.DENSITY);
	    }
	  }, {
	    key: 'getDensityOptions',
	    value: function getDensityOptions() {
	      return ['normal', 'tighter'];
	    }
	  }, {
	    key: 'getAnimatedAvatarsOptions',
	    value: function getAnimatedAvatarsOptions() {
	      return ['animated', 'static'];
	    }
	  }, {
	    key: 'shouldAnimateAvatars',
	    value: function shouldAnimateAvatars() {
	      return !this.data.web_client_freeze_gifs || this.get(_client_preferences_keys2.default.ANIMATED_AVATARS) === 'animated';
	    }
	  }, {
	    key: 'shouldLog',
	    value: function shouldLog() {
	      return this.get(_client_preferences_keys2.default.ENABLE_LOGGING);
	    }
	  }, {
	    key: 'shouldBlinkTaskBar',
	    value: function shouldBlinkTaskBar() {
	      var subtype = _configuration_store2.default.get('client_subtype'),
	          isValidSubType = _utils2.default.clientSubType.isWindows(subtype);
	
	      return isValidSubType && this.getBlinkTaskBar();
	    }
	  }, {
	    key: 'shouldBounceIcon',
	    value: function shouldBounceIcon() {
	      var subtype = _configuration_store2.default.get('client_subtype'),
	          isValidSubType = _utils2.default.clientSubType.isMac(subtype);
	
	      return isValidSubType && this.getBounceIcon();
	    }
	  }, {
	    key: 'shouldBounceOnce',
	    value: function shouldBounceOnce() {
	      var subtype = _configuration_store2.default.get('client_subtype'),
	          isValidSubType = _utils2.default.clientSubType.isMac(subtype);
	
	      return isValidSubType && this.getBounceOnce();
	    }
	  }, {
	    key: 'LIGHT_THEME',
	    get: function get() {
	      return 'light';
	    }
	  }, {
	    key: 'DARK_THEME',
	    get: function get() {
	      return 'dark';
	    }
	  }]);
	  return PreferencesStore;
	}(_model_store2.default);
	
	exports.default = new PreferencesStore();
	module.exports = exports['default'];

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _assign = __webpack_require__(148);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ExampleStoreModel = function ExampleStoreModel() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	  (0, _classCallCheck3.default)(this, ExampleStoreModel);
	
	  (0, _assign2.default)(this, input);
	};
	
	var ModelStore = function (_Store) {
	  (0, _inherits3.default)(ModelStore, _Store);
	
	  function ModelStore() {
	    (0, _classCallCheck3.default)(this, ModelStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ModelStore).call(this));
	
	    _this.data = _this._convertToModel(_this.data);
	    return _this;
	  }
	
	  /**
	   * Override this method to return the model the extending store should use
	   * @returns {Model}
	   */
	
	
	  (0, _createClass3.default)(ModelStore, [{
	    key: 'getModel',
	    value: function getModel() {
	      return ExampleStoreModel;
	    }
	
	    /**
	     * @override
	     * @param key
	     * @param value
	     */
	
	  }, {
	    key: 'setIfNotEqual',
	    value: function setIfNotEqual(key, value) {
	      this.set(key, value, true);
	    }
	
	    /**
	     * @override
	     * @param key
	     * @param value
	     * @param doEqualityCheck
	     */
	
	  }, {
	    key: 'set',
	    value: function set(key, value) {
	      var doEqualityCheck = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	      var data = this._getInputObject(key, value);
	      if (data && !_.isEmpty(data)) {
	        this.doSet(this._convertToModel(data), doEqualityCheck);
	      }
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_getInputObject',
	    value: function _getInputObject(key, value) {
	      if (_.isObject(key)) {
	        return key;
	      } else if (_.isString(key) && !_.isUndefined(value)) {
	        return (0, _defineProperty3.default)({}, key, value);
	      }
	      return null;
	    }
	
	    /**
	     * @param data
	     * @returns {Model}
	     */
	
	  }, {
	    key: '_convertToModel',
	    value: function _convertToModel(data) {
	      var Model = this.getModel();
	      return new Model(data);
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this.data = this._convertToModel(this.getDefaults());
	    }
	  }]);
	  return ModelStore;
	}(_store2.default);

	exports.default = ModelStore;
	module.exports = exports['default'];

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var HEARTBEAT_INTERVAL = exports.HEARTBEAT_INTERVAL = 60 * 1000;
	var XMPP_INACTIVITY_INTERVAL = exports.XMPP_INACTIVITY_INTERVAL = 60 * 1000;
	var BOSH_INACTIVITY_INTERVAL = exports.BOSH_INACTIVITY_INTERVAL = 60 * 1000;
	var XMPP_PONG_WAIT = exports.XMPP_PONG_WAIT = 30 * 1000;
	var NETWORK_LATENCY_GRACE_PERIOD = exports.NETWORK_LATENCY_GRACE_PERIOD = 5 * 1000;
	
	var RECONNECT_BACKOFF_FACTOR = exports.RECONNECT_BACKOFF_FACTOR = 3;
	var RECONNECT_DELAY_MS = exports.RECONNECT_DELAY_MS = 2 * 1000;
	var RECONNECT_MAX_DELAY = exports.RECONNECT_MAX_DELAY = 60 * 1000;
	var RECONNECT_SYNC_THRESHOLD = exports.RECONNECT_SYNC_THRESHOLD = 3 * 60 * 1000;
	var MAX_RECONNECT_TIME = exports.MAX_RECONNECT_TIME = 10 * 60 * 1000;
	var IDLE_DELAY_MINUTES = exports.IDLE_DELAY_MINUTES = 15;
	
	var OAUTH_TOKEN_REFRESH_DELAY_MS = exports.OAUTH_TOKEN_REFRESH_DELAY_MS = 5000;
	var OAUTH_TOKEN_REFRESH_BACKOFF_FACTOR = exports.OAUTH_TOKEN_REFRESH_BACKOFF_FACTOR = 3;
	var OAUTH_TOKEN_REFRESH_MAX_DELAY = exports.OAUTH_TOKEN_REFRESH_MAX_DELAY = 60 * 1000;
	
	var CACHE_TTL = exports.CACHE_TTL = 90 * 24 * 60 * 60 * 1000;
	var OAUTH_TTL = exports.OAUTH_TTL = 60 * 60 * 1000;
	var SLEEP_DELAY_MS = exports.SLEEP_DELAY_MS = 60 * 1000;
	
	var READSTATE_BACKOFF_FACTOR = exports.READSTATE_BACKOFF_FACTOR = 3;
	var READSTATE_DEFAULT_BACKOFF = exports.READSTATE_DEFAULT_BACKOFF = 5 * 1000;
	var READSTATE_MAX_BACKOFF = exports.READSTATE_MAX_BACKOFF = 5 * 60 * 1000;
	var READSTATE_UPDATE_DEBOUNCE = exports.READSTATE_UPDATE_DEBOUNCE = 0.5 * 1000;
	var READSTATE_NULL_MID = exports.READSTATE_NULL_MID = '';
	var READSTATE_NULL_TS = exports.READSTATE_NULL_TS = '0.0';
	
	var SYNC_REQUEST_GZIP_SIZE = exports.SYNC_REQUEST_GZIP_SIZE = 10 * 1024;
	
	var XMPP_LOG_MAX_CHARS = exports.XMPP_LOG_MAX_CHARS = 600;
	
	var XMPP_SEND_IQ_TIMEOUT = exports.XMPP_SEND_IQ_TIMEOUT = 30000;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @typedef {{name: string, key: string}} prefs
	 * @type {Object.<string, string>}
	 */
	var PrefKeys = (0, _freeze2.default)({
	  NOTIFY_FOR_ROOM: "notifyForRoom",
	  NOTIFY_FOR_PRIVATE_ROOM: "notifyForPrivateRoom",
	  NOTIFY_FOR_TAG: "notifyForTag",
	  NOTIFY_FOR_PRIVATE: "notifyForPrivate",
	  NOTIFY_WHEN_DND: "notifyWhenDND",
	  NOTIFY_FOR_VIDEO_WHEN_DND: "notifyForVideoWhenDND",
	  SOUNDS_ENABLED: "soundsEnabled",
	  MESSAGE_SOUNDS: "messageSounds",
	  VIDEO_SOUNDS: "videoSounds",
	  SHOW_TOASTERS: "showToasters",
	  HIDE_PRESENCE_MESSAGES: "hidePresenceMessages",
	  USE_24_HR_FORMAT: "timeFormat24Hour",
	  PROPERTIES: "properties",
	  PROPERTIES_FIRST_LOGIN_DATE: "firstLoginDate",
	  ROOM_NOTIFICATION_OVERRIDES: "roomNotificationOverrides",
	  GLOBAL_NOTIFICATION_SETTING: "globalNotificationSetting",
	  AUTO_JOIN: "autoJoin",
	  NOTIFICATIONS: 'notifications',
	  UPDATE_TIME: 'updateTime',
	  THEME: "theme",
	  DENSITY: "density",
	  CHAT_VIEW: 'chatView',
	  NAME_DISPLAY: 'nameDisplay',
	  ENABLE_IDLE: 'enableIdle',
	  IDLE_MINUTES: 'idleMinutes',
	  CHECK_MINOR_UPDATES: 'checkMinorUpdates',
	  IGNORE_ADD_INTEGRATIONS_GLANCE: 'ignoreAddIntegrationsGlance'
	});
	
	exports.default = PrefKeys;
	module.exports = exports['default'];

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(148);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class PreferencesModel
	 *
	 * Application State:
	 *
	 * @property {array} autoJoin
	 * @property {string} chatToFocus
	 *
	 * User State:
	 *
	 * @property {object} properties
	 * @property {number} properties.firstLoginDate
	 * @property {array} ignoreAddIntegrationsGlance
	 *
	 * Appearance Settings:
	 *
	 * @property {string} theme "light|dark"
	 * @property {string} density "normal|tighter"
	 * @property {string} chatView "classic|classic_neue"
	 * @property {string} nameDisplay "names|mentions"
	 * @property {string} animatedAvatars "animated|static"
	 * @property {boolean} timeFormat24Hour
	 * @property {boolean} showUnreadDivider
	 * @property {boolean} hidePresenceMessages
	 * @property {boolean} bounceIcon // Mac
	 *
	 * Notification Settings:
	 *
	 * @property {string} globalNotificationSetting "loud|quiet|normal"
	 * @property {boolean} notifyForRoom
	 * @property {boolean} notifyForPrivateRoom
	 * @property {boolean} notifyForTag
	 * @property {boolean} notifyForPrivate
	 * @property {boolean} notifyWhenDND
	 * @property {boolean} notifyForVideoWhenDND
	 * @property {boolean} showToasters
	 * @property {boolean} soundsEnabled
	 * @property {boolean} messageSounds
	 * @property {boolean} videoSounds
	 * @property {boolean} blinkTaskbar // Windows
	 *
	 * @property {object} notifications
	 * @property {array} notifications.room_invite
	 * @property {array} notifications.oto_call
	 * @property {array} notifications.group_invite_requested
	 * @property {array} notifications.oto_message
	 * @property {array} notifications.mention
	 * @property {array} notifications.newsletter
	 *
	 * @property {object} roomNotificationOverrides
	 * @property {object} roomNotificationOverrides[room_jid]
	 * @property {string} roomNotificationOverrides[room_jid].level "quiet|loud|normal"
	 *
	 * Native Prefs, unused in web client:
	 *
	 * @property {boolean} enableIdle
	 * @property {number} idleMinutes
	 * @property {number} updateTime
	 * @property {boolean} checkMinorUpdates
	 * @property {boolean} keepPopUsVisible
	 * @property {boolean} blinkTaskbar
	 *
	 * Client Preferences (persisted in localStorage):
	 *
	 * @property {boolean} hideGifsByDefault
	 * @property {boolean} replaceTextEmoticons
	 * @property {boolean} showUnreadDivider
	 * @property {boolean} showChatSidebar
	 * @property {boolean} showGroupChatSidebar
	 * @property {boolean} showNavigationSidebar
	 * @property {boolean} launchWithOSStartup
	 * @property {boolean} enableSpellCheck
	 * @property {boolean} bounceIcon
	 * @property {boolean} enableLogging
	 * @property {boolean} showQuickSwitcherHint
	 * @property {string} chatActivePanel
	 * @property {string} groupChatActivePanel
	 * @property {number} leftColumnWidth
	 * @property {number} rightColumnWidth
	 * @property {object} activeGroupchatIntegration
	 * @property {object} activeChatIntegration
	 */
	
	var ENUMS = {
	  theme: {
	    options: ['light', 'dark'],
	    default: _app_config2.default.default_theme
	  },
	  density: {
	    options: ['normal', 'tighter'],
	    default: _app_config2.default.default_density
	  },
	  chatView: {
	    options: ['classic', 'classic_neue'],
	    default: _app_config2.default.default_chat_view
	  },
	  nameDisplay: {
	    options: ['names', 'mentions'],
	    default: _app_config2.default.default_name_display
	  },
	  animatedAvatars: {
	    options: ['animated', 'static'],
	    default: _app_config2.default.default_animated_avatars
	  },
	  notificationLevels: {
	    options: ['loud', 'normal', 'quiet'],
	    default: _app_config2.default.default_notification_level
	  }
	};
	
	// Various string prefs sometimes come back with extraneous quotes around them
	function normalizeString(val) {
	  return _.isString(val) ? val.replace(/"/g, '') : val;
	}
	
	// Make sure appearance setting values are ONLY the expected enums above
	function normalizeAppearanceSettings(key, val) {
	  var str = normalizeString(val);
	  if (!_.includes(ENUMS[key].options, str)) {
	    return ENUMS[key].default;
	  }
	  return str;
	}
	
	// Ensure global notification setting is one of the expected enums above
	function normalizeGlobalNotificationSetting(val, obj) {
	  if (_.isString(val)) {
	    var str = normalizeString(val);
	    if (_.includes(ENUMS.notificationLevels.options, str)) {
	      return str;
	    }
	  }
	  return obj[_preferences_keys2.default.NOTIFY_FOR_ROOM] || obj[_preferences_keys2.default.NOTIFY_FOR_PRIVATE_ROOM] ? 'loud' : 'normal';
	}
	
	// Clean up autojoin -- mainly from raw x2js input
	function normalizeAutoJoin(autoJoin) {
	  var normalizedAutoJoin = [];
	
	  if (autoJoin.item) {
	    autoJoin = autoJoin.item;
	  }
	  if (!Array.isArray(autoJoin)) {
	    autoJoin = [autoJoin];
	  }
	
	  for (var room in autoJoin) {
	    var curRoom = autoJoin[room];
	    if (_.isPlainObject(curRoom) && !_.isEmpty(curRoom)) {
	      normalizedAutoJoin.push(_.pick(curRoom, 'jid', 'name'));
	    }
	  }
	  return normalizedAutoJoin;
	}
	
	// Returned as object with comma separated string values instead of array of values
	function normalizeNotifications(notifications) {
	  return _.transform(notifications, function (result, val, key) {
	    if (_.isString(val)) {
	      result[key] = _.compact(val.split(','));
	    } else {
	      result[key] = val;
	    }
	  });
	}
	
	// roomNotificationOverrides is sometimes an object,
	// sometimes a json string, sometimes an empty string
	function normalizeJSON(json) {
	  if (_.isObject(json)) {
	    return json;
	  } else if (_.isString(json)) {
	    try {
	      return JSON.parse(json);
	    } catch (e) {
	      return null;
	    }
	  }
	}
	
	// The Big Switch. Go through each key and fix/properly coerce the value
	function normalizePreferences(input) {
	  return _.transform(input, function (result, val, key, original) {
	    switch (key) {
	
	      case _preferences_keys2.default.USE_24_HR_FORMAT:
	      case _preferences_keys2.default.HIDE_PRESENCE_MESSAGES:
	      case _preferences_keys2.default.NOTIFY_FOR_TAG:
	      case _preferences_keys2.default.NOTIFY_FOR_PRIVATE:
	      case _preferences_keys2.default.NOTIFY_WHEN_DND:
	      case _preferences_keys2.default.NOTIFY_FOR_VIDEO_WHEN_DND:
	      case _preferences_keys2.default.SHOW_TOASTERS:
	      case _preferences_keys2.default.SOUNDS_ENABLED:
	      case _preferences_keys2.default.MESSAGE_SOUNDS:
	      case _preferences_keys2.default.VIDEO_SOUNDS:
	      case _preferences_keys2.default.ENABLE_IDLE:
	      case _preferences_keys2.default.CHECK_MINOR_UPDATES:
	      case _client_preferences_keys2.default.SHOW_UNREAD_DIVIDER:
	      case _client_preferences_keys2.default.REPLACE_TEXT_EMOTICONS:
	      case _client_preferences_keys2.default.BOUNCE_ICON:
	      case _client_preferences_keys2.default.BOUNCE_ONCE:
	      case _client_preferences_keys2.default.BLINK_TASKBAR:
	      case _client_preferences_keys2.default.HIDE_GIFS_BY_DEFAULT:
	      case _client_preferences_keys2.default.SHOW_CHAT_SIDEBAR:
	      case _client_preferences_keys2.default.SHOW_GROUPCHAT_SIDEBAR:
	      case _client_preferences_keys2.default.SHOW_NAVIGATION_SIDEBAR:
	      case _client_preferences_keys2.default.LAUNCH_WITH_OS_STARTUP:
	      case _client_preferences_keys2.default.ENABLE_SPELL_CHECK:
	      case _client_preferences_keys2.default.KEEP_POPUPS_VISIBLE:
	      case _client_preferences_keys2.default.ENABLE_LOGGING:
	      case _client_preferences_keys2.default.SHOW_QUICK_SWITCHER_HINT:
	        result[key] = _utils2.default.coerceBoolean(val);
	        break;
	
	      case _preferences_keys2.default.NOTIFY_FOR_ROOM:
	      case _preferences_keys2.default.NOTIFY_FOR_PRIVATE_ROOM:
	        result[key] = _.isBoolean(val) ? val : true;
	        break;
	
	      case _preferences_keys2.default.IDLE_MINUTES:
	      case _preferences_keys2.default.UPDATE_TIME:
	      case _client_preferences_keys2.default.LEFT_COLUMN_WIDTH:
	      case _client_preferences_keys2.default.RIGHT_COLUMN_WIDTH:
	        result[key] = parseFloat(val);
	        break;
	
	      case _preferences_keys2.default.CHAT_TO_FOCUS:
	      case _client_preferences_keys2.default.CHAT_ACTIVE_PANEL:
	      case _client_preferences_keys2.default.GROUPCHAT_ACTIVE_PANEL:
	      case _preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE:
	        result[key] = normalizeString(val);
	        break;
	
	      case _preferences_keys2.default.GLOBAL_NOTIFICATION_SETTING:
	        result[key] = normalizeGlobalNotificationSetting(val, original);
	        break;
	
	      case _preferences_keys2.default.THEME:
	      case _preferences_keys2.default.CHAT_VIEW:
	      case _preferences_keys2.default.DENSITY:
	      case _preferences_keys2.default.NAME_DISPLAY:
	      case _client_preferences_keys2.default.ANIMATED_AVATARS:
	        result[key] = normalizeAppearanceSettings(key, val);
	        break;
	
	      case _preferences_keys2.default.AUTO_JOIN:
	        result[key] = normalizeAutoJoin(val);
	        break;
	
	      case _preferences_keys2.default.NOTIFICATIONS:
	        result[key] = normalizeNotifications(val);
	        break;
	
	      case _preferences_keys2.default.PROPERTIES:
	        result[key] = normalizeJSON(val);
	        break;
	
	      case _preferences_keys2.default.ROOM_NOTIFICATION_OVERRIDES:
	        result[key] = normalizeJSON(val);
	        break;
	
	      // ignored keys
	      case 'secondsToIdle':
	      case 'isIdleTimeEnabled':
	      case 'enableEmoticons':
	      case 'dndWhenInCall':
	      case 'visualNotifications':
	      case 'exitWarn':
	        break;
	
	      default:
	        result[key] = val;
	    }
	  });
	}
	
	var PreferencesModel =
	
	/**
	 * @constructs
	 *
	 * @param {object} input
	 * @param {boolean} [serverPreferencesOnly]
	 */
	function PreferencesModel() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	  var serverPreferencesOnly = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	  (0, _classCallCheck3.default)(this, PreferencesModel);
	
	  if (serverPreferencesOnly) {
	    input = _.pick(input, _.values(_preferences_keys2.default));
	  }
	  (0, _assign2.default)(this, normalizePreferences(input));
	};
	
	exports.default = PreferencesModel;
	module.exports = exports['default'];

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @typedef {{name: string, key: string}} clientPrefs
	 * @type {Object.<string, string>}
	 */
	var ClientPrefKeys = (0, _freeze2.default)({
	  ANIMATED_AVATARS: 'animatedAvatars',
	  HIDE_GIFS_BY_DEFAULT: 'hideGifsByDefault',
	  HIDE_ATTACHED_CARDS_BY_DEFAULT: 'hideAttachedCardsByDefault',
	  CHAT_TO_FOCUS: 'chatToFocus',
	  REPLACE_TEXT_EMOTICONS: 'replaceTextEmoticons',
	  SHOW_UNREAD_DIVIDER: 'showUnreadDivider',
	  SHOW_CHAT_SIDEBAR: 'showChatSidebar',
	  SHOW_GROUPCHAT_SIDEBAR: 'showGroupChatSidebar',
	  SHOW_NAVIGATION_SIDEBAR: 'showNavigationSidebar',
	  CHAT_ACTIVE_PANEL: 'chatActivePanel',
	  GROUPCHAT_ACTIVE_PANEL: 'groupChatActivePanel',
	  LEFT_COLUMN_WIDTH: 'leftColumnWidth',
	  RIGHT_COLUMN_WIDTH: 'rightColumnWidth',
	  LAUNCH_WITH_OS_STARTUP: 'launchWithOSStartup',
	  ENABLE_SPELL_CHECK: 'enableSpellCheck',
	  ENABLE_AUTOCORRECT: 'enableAutoCorrect',
	  KEEP_POPUPS_VISIBLE: 'keepPopUsVisible',
	  BLINK_TASKBAR: 'blinkTaskbar',
	  BOUNCE_ICON: 'bounceIcon',
	  BOUNCE_ONCE: 'bounceOnce',
	  ENABLE_LOGGING: 'enableLogging',
	  SHOW_QUICK_SWITCHER_HINT: 'showQuickSwitcherHint',
	  ACTIVE_GROUPCHAT_INTEGRATION: 'activeGroupchatIntegration',
	  ACTIVE_CHAT_INTEGRATION: 'activeChatIntegration'
	});
	
	exports.default = ClientPrefKeys;
	module.exports = exports['default'];

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _client_info_helper = __webpack_require__(168);
	
	var _uri_template = __webpack_require__(170);
	
	var _uri_template2 = _interopRequireDefault(_uri_template);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  /*
	   * Source IDs as per https://extranet.atlassian.com/display/HC/Add-on+Management+Analytics
	   */
	  CONFIGURE_LINK_SOURCE_ID: 5,
	  DIALOG_LINK_SOURCE_ID: 6,
	  API_SOURCE_ID: 7,
	
	  to_full_key: function to_full_key(addon_key, module_key) {
	    return addon_key + ':' + module_key;
	  },
	
	  is_full_key: function is_full_key(key) {
	    return key.indexOf(":") !== -1;
	  },
	
	  split_full_key: function split_full_key(key) {
	    return key.split(":");
	  },
	
	  isFeatureEnabled: function isFeatureEnabled(initData) {
	    var isGuest = initData && initData.is_guest;
	    return !isGuest && (_.get(initData, 'feature_flags.web_client_integrations') || _.get(initData, "perms.hipconnect") === "all");
	  },
	
	  /**
	   * Check if an integration key is the same as an internal integration
	   *
	   * It is currently possible to fake this key, so it should not be used for anything requiring security
	   *
	   * @param key
	   * @returns {boolean}
	   */
	  isInternalIntegrationKey: function isInternalIntegrationKey(key) {
	    return _.includes([_app_config2.default.links_glance.full_key, _app_config2.default.files_glance.full_key, _app_config2.default.people_glance.full_key], key);
	  },
	
	  /**
	   * This routine returns a URL to the integrations management page.
	   * @param baseUrl the base URL where the connected instance of HipChat is running.
	   * @param roomId the ID of the room that the integration manager should use for its context.
	   * @param userId the ID of the current user.
	   * @param sourceId an ID representing the 'source' by which the user arrives at the integration
	   * management page. See https://extranet.atlassian.com/display/HC/Add-on+Management+Analytics.
	   * @returns {string} a URL to the integration manager.
	   */
	  getIntegrationsUrl: function getIntegrationsUrl(baseUrl, roomId, userId, sourceId) {
	    var fromLocationId = (0, _client_info_helper.getClientLocationId)();
	    if (!sourceId) {
	      sourceId = 0;
	    }
	    var str_formats = {
	      'base_url': baseUrl,
	      'room_id': roomId,
	      'user_id': encodeURIComponent(userId),
	      'from_location_id': fromLocationId,
	      'source_id': sourceId
	    };
	
	    var template = new _uri_template2.default(_app_config2.default.integrations_url);
	    return template.replaceVariables(str_formats);
	  },
	
	  getIntegrationsBaseUrl: function getIntegrationsBaseUrl(baseUrl) {
	    var str_formats = {
	      'base_url': baseUrl
	    };
	
	    var template = new _uri_template2.default(_app_config2.default.integrations_base_url);
	    return template.replaceVariables(str_formats);
	  },
	
	  getIntegrationsConfigUrl: function getIntegrationsConfigUrl(baseUrl, roomId, addon_key) {
	    var str_formats = {
	      'base_url': baseUrl,
	      'room_id': roomId,
	      'addon_key': addon_key
	    };
	
	    var template = new _uri_template2.default(_app_config2.default.integrations_config_url);
	    return template.replaceVariables(str_formats);
	  },
	
	  getIntegrationsUpdateUrl: function getIntegrationsUpdateUrl(baseUrl, roomId, addon_key) {
	    var str_formats = {
	      'base_url': baseUrl,
	      'room_id': roomId,
	      'addon_key': addon_key
	    };
	
	    var template = new _uri_template2.default(_app_config2.default.integrations_update_url);
	    return template.replaceVariables(str_formats);
	  },
	
	  extractIntegrationParametersFromMessage: function extractIntegrationParametersFromMessage(msg) {
	    var parameters = {};
	    if (msg) {
	      parameters = {
	        body: msg.body,
	        sender: {
	          id: msg.sender_id,
	          name: msg.sender,
	          mention: msg.sender_mention
	        },
	        mid: msg.mid,
	        type: msg.type,
	        metadata: _.get(msg, 'metadata', {})
	      };
	
	      if (msg.card) {
	        parameters.card = _.pick(msg.card, ['title', 'description', 'url']);
	      }
	
	      if (msg.file_data) {
	        parameters.media = {
	          type: _.get(msg.file_data, 'file_type', 'unknown').replace('img', 'image'),
	          name: _.get(msg.file_data, 'name', ''),
	          size: msg.file_data.size,
	          url: msg.file_data.url
	        };
	        if (msg.file_data.thumb_url) {
	          parameters.media.thumb_url = msg.file_data.thumb_url;
	        }
	      }
	
	      if (msg.link_details) {
	        parameters.media = {
	          type: msg.link_details.type,
	          url: msg.link_details.url
	        };
	      }
	    }
	    return parameters;
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ANDROID_CLIENT_LOCATION_ID = exports.IOS_CLIENT_LOCATION_ID = exports.LINUX_CLIENT_LOCATION_ID = exports.WINDOWS_CLIENT_LOCATION_ID = exports.MAC_CLIENT_LOCATION_ID = exports.WEB_CLIENT_LOCATION_ID = exports.INTERNET_LINK_LOCATION_ID = exports.UNKNOWN_LOCATION_ID = undefined;
	exports.getClientLocationId = getClientLocationId;
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var UNKNOWN_LOCATION_ID = exports.UNKNOWN_LOCATION_ID = 0;
	var INTERNET_LINK_LOCATION_ID = exports.INTERNET_LINK_LOCATION_ID = 1;
	var WEB_CLIENT_LOCATION_ID = exports.WEB_CLIENT_LOCATION_ID = 2;
	var MAC_CLIENT_LOCATION_ID = exports.MAC_CLIENT_LOCATION_ID = 3;
	var WINDOWS_CLIENT_LOCATION_ID = exports.WINDOWS_CLIENT_LOCATION_ID = 4;
	var LINUX_CLIENT_LOCATION_ID = exports.LINUX_CLIENT_LOCATION_ID = 5;
	var IOS_CLIENT_LOCATION_ID = exports.IOS_CLIENT_LOCATION_ID = 6;
	var ANDROID_CLIENT_LOCATION_ID = exports.ANDROID_CLIENT_LOCATION_ID = 7;
	
	function getClientLocationId() {
	  var clientType = _configuration_store2.default.get('client_type');
	  var clientSubtype = _configuration_store2.default.get('client_subtype');
	  if (clientType === 'qt' && clientSubtype === 'windows') {
	    return WINDOWS_CLIENT_LOCATION_ID;
	  } else if (clientType === 'qt' && clientSubtype === 'linux') {
	    return LINUX_CLIENT_LOCATION_ID;
	  } else if (clientType === 'mac') {
	    return MAC_CLIENT_LOCATION_ID;
	  } else if (clientType === 'web') {
	    return WEB_CLIENT_LOCATION_ID;
	  }
	  return UNKNOWN_LOCATION_ID;
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(47);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ConfigurationStore = function (_Store) {
	  (0, _inherits3.default)(ConfigurationStore, _Store);
	
	  function ConfigurationStore() {
	    (0, _classCallCheck3.default)(this, ConfigurationStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ConfigurationStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(ConfigurationStore, [{
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register('updated:config', function (data) {
	        _this2.set(data);
	      });
	    }
	  }, {
	    key: 'get',
	    value: function get(key) {
	      switch (key) {
	        case 'auth_method':
	          return this._getAuthMethod();
	
	        case 'client_node':
	          return this._getClientNode();
	
	        case 'bind_url':
	          return this._getBindUrl();
	
	        default:
	          return (0, _get3.default)((0, _getPrototypeOf2.default)(ConfigurationStore.prototype), 'get', this).call(this, key);
	      }
	    }
	  }, {
	    key: '_getBindUrl',
	    value: function _getBindUrl() {
	      if (_.isString(this.data.bind_url) && _.isString(this.data.web_server) && this.data.bind_url.indexOf('https://') === -1) {
	        this.data.bind_url = 'https://' + this.data.web_server + this.data.bind_url;
	      }
	      return this.data.bind_url;
	    }
	  }, {
	    key: '_getAuthMethod',
	    value: function _getAuthMethod() {
	      if (_.isNull(this.data.auth_method) && _.isString(this.data.oauth_token)) {
	        this.data.auth_method = 'oauth2';
	      }
	      return this.data.auth_method;
	    }
	  }, {
	    key: '_getClientNode',
	    value: function _getClientNode() {
	      if (_.isString(this.data.client_type) && _.isNull(this.data.client_node)) {
	        var node = 'http://hipchat.com/client/' + this.data.client_type;
	        if (this.data.client_subtype) {
	          node += '/' + this.data.client_subtype;
	        }
	        this.data.client_node = node;
	      }
	      return this.data.client_node;
	    }
	  }, {
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        auth_method: null,
	        auth_nonce: null,
	        oauth_token: null,
	        oauth_token_expires_in: null,
	        apiv1_token: null,
	        apiv1_token_expires_in: null,
	        base_url: '',
	        video_base_url: '',
	        bind_url: null,
	        api_host: 'api.hipchat.com',
	        conference_server: null,
	        chat_server: null,
	        display_name: "",
	        web_server: null,
	        route: null,
	        invite_url: null,
	        video_chat_uri: null,
	        client_type: null,
	        client_subtype: null,
	        client_version_id: null,
	        client_os_version_id: null,
	        client_node: null,
	        asset_base_uri: null,
	        video_chat_enabled: null,
	        private_rooms_enabled: null,
	        guest_access_enabled: null,
	        html5_routing_enabled: null,
	        ui: null,
	        app_config_overrides: null,
	        feature_flags: {},
	        native_feature_flags: {},
	        log_to_file: false,
	        jid: null,
	        sid: null,
	        user_id: null,
	        user_name: null,
	        group_id: null,
	        group_name: null,
	        mention: null,
	        is_admin: null,
	        is_guest: null,
	        guest_key: null,
	        email: null,
	        title: null,
	        photo_small: null,
	        photo_large: null,
	        group_avatar_url: null,
	        addlive_app_id: null
	      };
	    }
	
	    /**
	     * @method isOAuth
	     * @returns {boolean} is the config in oauth2 mode
	     */
	
	  }, {
	    key: 'isOAuth',
	    value: function isOAuth() {
	      return this._getAuthMethod() === 'oauth2';
	    }
	
	    /**
	     * @method isNonce
	     * @returns {boolean} is the config in nonce mode
	     */
	
	  }, {
	    key: 'isNonce',
	    value: function isNonce() {
	      return this._getAuthMethod() === 'nonce';
	    }
	
	    /**
	     * @method getNonceToken
	     * @returns {string} the nonce session token used for authenticating xmpp in nonce mode
	     */
	
	  }, {
	    key: 'getNonceToken',
	    value: function getNonceToken() {
	      return this.data.auth_nonce;
	    }
	
	    /**
	     * @method getOAuthToken
	     * @returns {string} the oauth token for authenticating with v2 (coral) apis
	     */
	
	  }, {
	    key: 'getOAuthToken',
	    value: function getOAuthToken() {
	      return this.data.oauth_token;
	    }
	
	    /**
	     * @method getOAuthTokenExpiry
	     * @returns {number} in ms
	     */
	
	  }, {
	    key: 'getOAuthTokenExpiry',
	    value: function getOAuthTokenExpiry() {
	      return this.data.oauth_token_expires_in;
	    }
	
	    /**
	     * @method getApiV1TokenExpiry
	     * @returns {number} in ms
	     */
	
	  }, {
	    key: 'getApiV1TokenExpiry',
	    value: function getApiV1TokenExpiry() {
	      return this.data.apiv1_token_expires_in;
	    }
	
	    /**
	     * Get session token used for authenticating to PHP/v1 api -- such as
	     * for saving preferences and authenticating in-app search
	     *
	     * @method getApiV1Token
	     * @returns {object} the session token object
	     */
	
	  }, {
	    key: 'getApiV1Token',
	    value: function getApiV1Token() {
	      return this.data.apiv1_token;
	    }
	
	    /**
	     * Get BOSH session id
	     *
	     * @method getSID
	     * @returns {string} the BOSH session id
	     */
	
	  }, {
	    key: 'getSID',
	    value: function getSID() {
	      return this.data.sid || "Unknown";
	    }
	
	    /**
	     * @method isAdmin
	     * @returns {boolean} is the current user an admin
	     */
	
	  }, {
	    key: 'isAdmin',
	    value: function isAdmin() {
	      return this.data.is_admin === true;
	    }
	
	    /**
	     * @method isGuest
	     * @returns {boolean} is the current user a guest
	     */
	
	  }, {
	    key: 'isGuest',
	    value: function isGuest() {
	      return this.data.is_guest === true;
	    }
	
	    /**
	     * @method shouldLogToFile
	     * @returns {boolean} should the app send logs through the SPI
	     */
	
	  }, {
	    key: 'shouldLogToFile',
	    value: function shouldLogToFile() {
	      return this.data.log_to_file === true;
	    }
	  }]);
	  return ConfigurationStore;
	}(_store2.default);
	
	exports.default = new ConfigurationStore();
	module.exports = exports['default'];

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var URL_TEMPLATE_RE = new RegExp("{[^}]*}", "g");
	
	function getReplacement(parameters, variable) {
	  var value = _.get(parameters, variable, "");
	  if (_.isObject(value)) {
	    value = (0, _stringify2.default)(value);
	  } else {
	    value = String(value);
	  }
	  return value;
	}
	
	var URITemplate = function () {
	  function URITemplate(template) {
	    (0, _classCallCheck3.default)(this, URITemplate);
	
	    this.template = template;
	  }
	
	  (0, _createClass3.default)(URITemplate, [{
	    key: "getTemplateVariables",
	    value: function getTemplateVariables() {
	      var matches = this.template.match(URL_TEMPLATE_RE);
	      return _.uniq(_.map(matches, function (match) {
	        return match.slice(1, -1);
	      }));
	    }
	  }, {
	    key: "replaceVariables",
	    value: function replaceVariables(parameters) {
	      var uri = this.template;
	      var variables = this.getTemplateVariables();
	      _.each(variables, function (variable) {
	        uri = uri.replace("{" + variable + "}", encodeURIComponent(getReplacement(parameters, variable)));
	      });
	      return uri;
	    }
	  }, {
	    key: "getTemplateValuesFromParameters",
	    value: function getTemplateValuesFromParameters(parameters) {
	      var variables = this.getTemplateVariables();
	      return _.reduce(variables, function (accumulator, variable) {
	        accumulator[variable] = getReplacement(parameters, variable);
	        return accumulator;
	      }, {});
	    }
	  }]);
	  return URITemplate;
	}();
	
	exports.default = URITemplate;
	module.exports = exports['default'];

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _video_actions = __webpack_require__(172);
	
	var _video_actions2 = _interopRequireDefault(_video_actions);
	
	var _postis = __webpack_require__(175);
	
	var _postis2 = _interopRequireDefault(_postis);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/** class representing an instance of a video window */
	
	var VideoWindow = function () {
	
	  /**
	   * Create the video window
	   *
	   * @param {string} url - the url to point the external window to
	   * @param {string} name - the name of the external window
	   * @param {string} props - the properties of the external window,
	   *                         such as 'resizable=yes,width=${width},height=${height},top=${pos.top},left=${pos.left}'
	   * @param {string} passedWindow - optional, a prepared window already opened
	   */
	
	  function VideoWindow(url, name, props, passedWindow) {
	    (0, _classCallCheck3.default)(this, VideoWindow);
	
	    if (passedWindow) {
	      this.window = passedWindow;
	      this.window.location = url;
	    } else {
	      this.window = window.open(url, name, props);
	    }
	    this._initializeXDM();
	    this._startClosedInterval();
	  }
	
	  /**
	   * Focus the window
	   * @method focus
	   */
	
	
	  (0, _createClass3.default)(VideoWindow, [{
	    key: 'focus',
	    value: function focus() {
	      this.window.focus();
	    }
	
	    /**
	     * Close the window
	     * @method close
	     */
	
	  }, {
	    key: 'close',
	    value: function close() {
	      clearInterval(this._closedInterval);
	      this.window.close();
	      this._xdmChannel.destroy();
	      _video_actions2.default.destroyVideoSession();
	    }
	
	    /**
	     * Initialize the cross-domain message bridge
	     * @method _initializeXDM
	     * @private
	     */
	
	  }, {
	    key: '_initializeXDM',
	    value: function _initializeXDM() {
	      var _this = this;
	
	      this._xdmChannel = (0, _postis2.default)({
	        window: this.window
	      });
	
	      this._xdmChannel.ready(function () {
	        _this._xdmChannel.listen('video-conference-joined', function () {
	          _video_actions2.default.videoConferenceJoined();
	        });
	        _this._xdmChannel.listen('video-conference-left', function () {
	          _video_actions2.default.videoConferenceLeft();
	        });
	        _this._xdmChannel.listen('video-ready-to-close', function () {
	          _this.close();
	        });
	      });
	    }
	
	    /**
	     * Start the interval to check if the external window has been closed
	     * @method _startClosedInterval
	     * @private
	     */
	
	  }, {
	    key: '_startClosedInterval',
	    value: function _startClosedInterval() {
	      this._closedInterval = setInterval(function (videowindow) {
	        if (!videowindow.window) {
	          clearInterval(videowindow._closedInterval);
	        } else if (_.get(videowindow, 'window.closed')) {
	          videowindow.close();
	          clearInterval(videowindow._closedInterval);
	        }
	      }, 1000, this);
	    }
	  }]);
	  return VideoWindow;
	}();

	exports.default = VideoWindow;
	module.exports = exports['default'];

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _video_service_keys = __webpack_require__(174);
	
	var _video_service_keys2 = _interopRequireDefault(_video_service_keys);
	
	var _jid_utils = __webpack_require__(109);
	
	var _jid_utils2 = _interopRequireDefault(_jid_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  startScreenShare: function startScreenShare(jid) {
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ENSO + '.start-screen-share', { jid: jid });
	  },
	
	  showInviteFlag: function showInviteFlag(data) {
	    _app_dispatcher2.default.dispatch('show-flag', {
	      id: data.id,
	      type: 'video',
	      sender: data.sender,
	      photo: data.photo_url,
	      message: data.message,
	      service: _video_service_keys2.default.ENSO
	    });
	  },
	  showPopupsDisabledFlag: function showPopupsDisabledFlag(data) {
	    _app_dispatcher2.default.dispatch('show-flag', {
	      id: data.flag_id,
	      type: 'video_popup_blocked',
	      body: data.message,
	      promise: data.promise
	    });
	  },
	  removeInviteFlag: function removeInviteFlag(data) {
	    _app_dispatcher2.default.dispatch('remove-flag', data.index);
	  },
	  sendVideoInviteDeclineMessage: function sendVideoInviteDeclineMessage(data) {
	    _app_dispatcher2.default.dispatch('send-video-message', {
	      jid: data.jid,
	      type: 'decline',
	      reason: data.reason,
	      service: _video_service_keys2.default.ENSO
	    });
	  },
	  handleRemoteDeclinedMessage: function handleRemoteDeclinedMessage(data) {
	    _app_dispatcher2.default.dispatch('call-declined', data.message);
	  },
	  sendVideoInviteAcceptMessage: function sendVideoInviteAcceptMessage(data) {
	    _app_dispatcher2.default.dispatch('send-video-message', {
	      jid: data.jid,
	      type: 'accept',
	      service: _video_service_keys2.default.ENSO
	    });
	  },
	  sendVideoInviteMessage: function sendVideoInviteMessage(data) {
	    _app_dispatcher2.default.dispatch('send-video-message', {
	      jid: data.jid,
	      url: data.url,
	      type: 'call',
	      service: _video_service_keys2.default.ENSO,
	      callback: data.callback
	    });
	  },
	  sendHangupMessage: function sendHangupMessage(data) {
	    var type = _jid_utils2.default.is_room(data.jid) ? 'room' : 'oto';
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.user.' + type + '.video.hangup',
	      properties: {
	        room: data.room_id,
	        service: _video_service_keys2.default.ENSO
	      }
	    });
	    _app_dispatcher2.default.dispatch('send-video-message', {
	      jid: data.jid,
	      type: 'hangup',
	      service: _video_service_keys2.default.ENSO
	    });
	  },
	  generateMissedCallMessage: function generateMissedCallMessage(data) {
	    _app_dispatcher2.default.dispatch('missed-call', data.message);
	  },
	  videoConferenceJoined: function videoConferenceJoined() {
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ENSO + '.video-conference-joined');
	  },
	  videoConferenceLeft: function videoConferenceLeft() {
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ENSO + '.video-conference-left');
	  },
	  destroyVideoSession: function destroyVideoSession() {
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ENSO + '.video-session-destroyed');
	  },
	  videoCallConnected: function videoCallConnected(_ref) {
	    var jid = _ref.jid;
	    var _ref$start = _ref.start;
	    var start = _ref$start === undefined ? 0 : _ref$start;
	    var _ref$done = _ref.done;
	    var done = _ref$done === undefined ? 0 : _ref$done;
	
	    var type = _jid_utils2.default.is_room(jid) ? 'room' : 'oto';
	    var time = done - start;
	
	    if (time <= 0) {
	      return;
	    }
	
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.user.' + type + '.video.connected',
	      properties: {
	        time: time,
	        service: _video_service_keys2.default.ENSO
	      }
	    });
	  },
	  joinRoomVideoCall: function joinRoomVideoCall(data) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.user.room.video.join',
	      properties: {
	        room: data.room_id,
	        service: _video_service_keys2.default.ENSO
	      }
	    });
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ENSO + '.join-room-video', data);
	  },
	  joinAddLiveCall: function joinAddLiveCall(data) {
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ADDLIVE + '.start-video-call', {
	      service: _video_service_keys2.default.ADDLIVE,
	      type: 'call',
	      jid: data.jid,
	      audio_only: data.audio_only
	    });
	  },
	  leaveAddLiveCall: function leaveAddLiveCall(jid) {
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ADDLIVE + '.audio-video-call-hung-up', {
	      sender: {
	        jid: jid
	      }
	    });
	  },
	  endAddLiveVideoSession: function endAddLiveVideoSession(jid) {
	    _app_dispatcher2.default.dispatch(_video_service_keys2.default.ADDLIVE + '.video-window-event', {
	      type: 'video_session_ended',
	      data: {
	        jid: jid,
	        reloading: false
	      }
	    });
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _dispatcher = __webpack_require__(58);
	
	var _dispatcher2 = _interopRequireDefault(_dispatcher);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AnalyticsDispatcher = function (_Dispatcher) {
	  (0, _inherits3.default)(AnalyticsDispatcher, _Dispatcher);
	
	  function AnalyticsDispatcher() {
	    (0, _classCallCheck3.default)(this, AnalyticsDispatcher);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AnalyticsDispatcher).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(AnalyticsDispatcher, [{
	    key: 'dispatch',
	    value: function dispatch(action) {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // most of these are fine to log in verbose mode, but logging every single keystroke is a bit much
	      // Test if Logger.log is defined before trying to log (because of circular dependencies)
	      if (_logger2.default.log) {
	        if (action !== 'analytics-set-message-value') {
	          var _Logger$type;
	
	          _logger2.default.debug.apply(_logger2.default, ['[AnalyticsDispatcher: ' + action + ']'].concat(args));
	          (_Logger$type = _logger2.default.type('analytics-dispatcher:' + action)).log.apply(_Logger$type, args);
	        }
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(AnalyticsDispatcher.prototype), 'dispatch', this)).call.apply(_get2, [this, action].concat(args));
	    }
	  }]);
	  return AnalyticsDispatcher;
	}(_dispatcher2.default);
	
	exports.default = new AnalyticsDispatcher();
	module.exports = exports['default'];

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @typedef {{name: string, key: string}} videoServiceKeys
	 * @type {Object.<string, string>}
	 */
	var VideoServiceKeys = (0, _freeze2.default)({
	  ENSO: 'enso',
	  ADDLIVE: 'addlive'
	});
	exports.default = VideoServiceKeys;
	module.exports = exports['default'];

/***/ },
/* 175 */
/***/ function(module, exports) {

	function Postis(options) {
	  var scope = options.scope;
	  var targetWindow = options.window;
	  var windowForEventListening = options.windowForEventListening || window;
	  var listeners = {};
	  var sendBuffer = [];
	  var listenBuffer = {};
	  var ready = false;
	  var readyMethod = "__ready__";
	  var readynessCheck;
	
	  var listener = function(event) {
	    var data;
	    try {
	      data = JSON.parse(event.data);
	    } catch (e) {
	      return;
	    }
	
	    if (data.postis && data.scope === scope) {
	      var listenersForMethod = listeners[data.method];
	      if (listenersForMethod) {
	        for (var i = 0; i < listenersForMethod.length; i++) {
	          listenersForMethod[i].call(null, data.params);
	        }
	      } else {
	        listenBuffer[data.method] = listenBuffer[data.method] || [];
	        listenBuffer[data.method].push(data.params);
	      }
	    }
	  };
	
	  windowForEventListening.addEventListener("message", listener, false);
	
	  var postis = {
	    listen: function (method, callback) {
	      listeners[method] = listeners[method] || [];
	      listeners[method].push(callback);
	
	      var listenBufferForMethod = listenBuffer[method];
	      if (listenBufferForMethod) {
	        var listenersForMethod = listeners[method];
	        for (var i = 0; i < listenersForMethod.length; i++) {
	          for (var j = 0; j < listenBufferForMethod.length; j++) {
	            listenersForMethod[i].call(null, listenBufferForMethod[j]);
	          }
	        }
	      }
	      delete listenBuffer[method];
	    },
	
	    send: function (opts) {
	      var method = opts.method;
	
	      if ((ready || opts.method === readyMethod) && (targetWindow && typeof targetWindow.postMessage === "function")) {
	        targetWindow.postMessage(JSON.stringify({
	          postis: true,
	          scope: scope,
	          method: method,
	          params: opts.params
	        }), "*");
	      } else {
	        sendBuffer.push(opts);
	      }
	    },
	
	    ready: function (callback) {
	      if (ready) {
	        callback();
	      } else {
	        setTimeout(function () { postis.ready(callback); }, 50);
	      }
	    },
	
	    destroy: function (callback) {
	      clearInterval(readynessCheck);
	      ready = false;
	      if (windowForEventListening && typeof windowForEventListening.removeEventListener === "function") {
	        windowForEventListening.removeEventListener("message", listener);
	      }
	      callback && callback();
	    }
	  };
	
	  var readyCheckID = +new Date() + Math.random() + "";
	
	  readynessCheck = setInterval(function () {
	    postis.send({
	      method: readyMethod,
	      params: readyCheckID
	    });
	  }, 50);
	
	  postis.listen(readyMethod, function (id) {
	    if (id === readyCheckID) {
	      clearInterval(readynessCheck);
	      ready = true;
	
	      for (var i = 0; i < sendBuffer.length; i++) {
	        postis.send(sendBuffer[i]);
	      }
	      sendBuffer = [];
	    } else {
	      postis.send({
	        method: readyMethod,
	        params: id
	      });
	    }
	  });
	
	  return postis;
	}
	
	module.exports = Postis;


/***/ },
/* 176 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  incoming_call_notification: function incoming_call_notification(name) {
	    return "Incoming call from " + name;
	  },
	  missed_call_message: function missed_call_message(name) {
	    return "Missed call from " + name;
	  },
	  join_video_call_message: "Join me in a video call",
	  confirm_leave: "Leave your current video call?",
	  call_status: "On a call",
	  connecting: "Connecting to video call",
	  popups_blocked: "Please enable popups and try again",
	  answer: "Answer",
	  ignore: "Ignore",
	  enso_to_addlive: function enso_to_addlive(url) {
	    return "I'm calling you using the new HipChat video experience, but you need to update your HipChat app to see it. You can still join the meeting in your browser: " + url;
	  },
	  call_declined: {
	    offline: function offline(name) {
	      return "It looks like " + name + " isn't available to accept video calls at the moment.";
	    },
	    on_a_call: function on_a_call(name) {
	      return name + " is currently in another video call";
	    },
	    decline: function decline(name) {
	      return name + " declined to join the video call";
	    },
	    unsupported: function unsupported(name) {
	      return name + " is using a HipChat client that doesn't support video calls";
	    }
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _fileviewer_strings = __webpack_require__(179);
	
	var _fileviewer_strings2 = _interopRequireDefault(_fileviewer_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FileHelper = function () {
	  function FileHelper() {
	    (0, _classCallCheck3.default)(this, FileHelper);
	
	    var timeout = _app_config2.default.fetch_thumbnails_timeout;
	    var boundFunction = this.fetchSignedThumbnailCollection.bind(this);
	
	    this.thumbnailMap = {};
	    this._debouncedFetchSignedThumbnailCollection = _.debounce(boundFunction, timeout, {
	      leading: false,
	      trailing: true
	    });
	  }
	
	  /**
	   * Returns true if the click event was triggered by a left click
	   * @param  {event} event
	   * @return {bool}
	   */
	
	
	  (0, _createClass3.default)(FileHelper, [{
	    key: 'shouldOpenFileViewer',
	    value: function shouldOpenFileViewer() {
	      var event = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      return event.button === 0;
	    }
	
	    /**
	     * Returns the filename from a path.
	     * @param {string} path
	     * @returns {string} filename
	     */
	
	  }, {
	    key: 'basename',
	    value: function basename() {
	      var path = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	
	      return path.split('/').pop();
	    }
	
	    /**
	     * Returns the suffix from a path.
	     * @param {string} path
	     * @returns {string} filename
	     */
	
	  }, {
	    key: 'filesuffix',
	    value: function filesuffix() {
	      var path = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	
	      var basename = this.basename(path);
	      var suffix = basename.split('.').pop();
	      return basename !== suffix ? suffix : '';
	    }
	
	    /**
	     * Check if FileViewer supports previewing the given file.
	     * @param {object} file
	     * @returns {boolean} is file supported
	     */
	
	  }, {
	    key: 'fileViewerSupports',
	    value: function fileViewerSupports() {
	      var file = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var normalized = this._normalizeFile(file);
	      return this._guessMimeType(normalized) !== 'unknown';
	    }
	
	    /**
	     * Transform a file to the format used by fileviewer.
	     * @param {object} file
	     * @returns {boolean} FileViewer file
	     */
	
	  }, {
	    key: 'transformForFileViewer',
	    value: function transformForFileViewer() {
	      var file = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var normalized = this._normalizeFile(file);
	      var item = {
	        is_authenticated: normalized.is_authenticated,
	        src: normalized.signed_url || normalized.url,
	        srcDownload: normalized.url,
	        title: normalized.name,
	
	        // if we return 'not/supported' as the mime type for signed files, the file viewer will resolve the signed url before previewing the file
	        type: normalized.is_authenticated ? 'not/supported' : this._guessMimeType(normalized),
	
	        downloadable: this._isDownloadable(normalized),
	        date: normalized.date,
	        meta: normalized.meta
	      };
	
	      if (item.type === 'video/youtube') {
	        item.title = file.title || 'Youtube Video';
	      }
	
	      return item;
	    }
	  }, {
	    key: '_formatDateTime',
	    value: function _formatDateTime(time, format) {
	      if (/^-?\d*\.?\d*$/.test(time)) {
	        time = _moment2.default.unix(time);
	      } else {
	        time = (0, _moment2.default)(time);
	      }
	
	      return time.format(format);
	    }
	
	    /**
	     * A file can either be an uploaded file or a link to a file.
	     * @param {object} file
	     * @returns {object} normalized file
	     */
	
	  }, {
	    key: '_normalizeFile',
	    value: function _normalizeFile(file) {
	      var dateFormatString = 'MMM D YYYY';
	      var timeFormatString = _preferences_store2.default.shouldUse24HrTime() ? 'HH:mm' : 'h:mm A';
	
	      return {
	        url: file.image || file.file_url || file.url,
	        name: this.basename(file.name || file.title || file.url),
	        date: file.date || '',
	        is_authenticated: !!file.is_authenticated,
	        meta: {
	          avatarSrc: file.sender_avatar,
	          author: file.user_name || file.sender,
	          authorPrefix: _fileviewer_strings2.default.default_metabar_author_prefix,
	          date: this._formatDateTime(file.date, dateFormatString),
	          time: this._formatDateTime(file.date, timeFormatString),
	          fileSize: _utils2.default.file.get_size_string(file.size),
	          fileType: this.filesuffix(file.image || file.file_url || file.name || file.url)
	        }
	      };
	    }
	
	    /**
	     * Guesses the mimetype for a given file based on the path.
	     * @param {object} normalized file
	     * @returns {string} mimetype
	     */
	
	  }, {
	    key: '_guessMimeType',
	    value: function _guessMimeType(file) {
	      var name = (file.url || '').split('?')[0].toLowerCase() || (file.name || '').toLowerCase();
	      var fileType = file.meta && file.meta.fileType ? file.meta.fileType : '';
	
	      var isImage = name.match(/\.(png|jpg|jpeg|gif|svg)$/i) || fileType.match(/(png|jpg|jpeg|gif|svg)$/i);
	      var isDoc = name.match(/\.pdf$/i) || fileType.match(/pdf$/i);
	      var isAudio = name.match(/\.mp3$/i) || fileType.match(/mp3$/i);
	      var isVideo = name.match(/\.mp4$/i) || fileType.match(/mp4$/i);
	      var isYoutube = name.match(/(youtu(?:be\.com|\.be))/i);
	
	      if (isImage) {
	        return 'image/' + isImage[1].replace('jpg', 'jpeg').replace('svg', 'svg+xml');
	      }
	      if (isDoc) {
	        return 'application/pdf';
	      }
	      if (isYoutube) {
	        return 'video/youtube';
	      }
	      if (isVideo) {
	        return 'video/mp4';
	      }
	      if (isAudio) {
	        return 'audio/mp3';
	      }
	
	      return 'unknown';
	    }
	
	    /**
	     * Check if a file is downloadable.
	     * @param {object} file
	     * @returns {boolean} is downloadable
	     */
	
	  }, {
	    key: '_isDownloadable',
	    value: function _isDownloadable(file) {
	      return this._guessMimeType(file) !== 'video/youtube';
	    }
	
	    /**
	     * Download a file at a URL directly
	     * @param {string} url of the file
	     * @returns {boolean}
	     */
	
	  }, {
	    key: 'downloadFileAtUrl',
	    value: function downloadFileAtUrl(url) {
	      /*
	       This is the only method available that works cross-browser,
	       regardless of popup/privacy settings.
	       */
	      _analytics_dispatcher2.default.dispatch('analytics-secure-file-download');
	      var frame = document.createElement('iframe'),
	          remove = function remove() {
	        frame.parentNode.removeChild(frame);
	        _app_dispatcher2.default.dispatch('file-download-stop');
	      };
	      document.body.appendChild(frame);
	
	      // this delay is necessary to initiate download
	      _.delay(remove, _app_config2.default.file_download_timeout);
	      frame.src = url;
	    }
	
	    /**
	     * Fetches signed thumbnail collection from thumbnail map
	     */
	
	  }, {
	    key: 'fetchSignedThumbnailCollection',
	    value: function fetchSignedThumbnailCollection() {
	      _chat_window_actions2.default.fetchSignedThumbnailCollection(this.thumbnailMap);
	      this.thumbnailMap = {};
	    }
	
	    /**
	     * Fetch signed thumbnail method
	     * @param {File} file
	     * @param {Function} cb
	     * @param {Function} errCb
	     */
	
	  }, {
	    key: 'fetchSignedThumbnail',
	    value: function fetchSignedThumbnail(_ref) {
	      var id = _ref.id;
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	      var errCb = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	      var item = { cb: cb, errCb: errCb };
	
	      this.thumbnailMap[id] = item;
	      this._debouncedFetchSignedThumbnailCollection();
	    }
	  }]);
	  return FileHelper;
	}();
	
	module.exports = new FileHelper();

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * ChatWindowActions
	 */
	
	exports.default = {
	
	  /**
	   * Request ancient history for a chat
	   * @param data
	   * @param data.jid JID of the chat
	   */
	  requestAncientHistory: function requestAncientHistory(data) {
	    _app_dispatcher2.default.dispatch('requesting-ancient-history', data);
	  },
	
	  setScrollValue: function setScrollValue(data) {
	    _app_dispatcher2.default.dispatch('set-scroll-value', data);
	  },
	
	  preserveScrollValue: function preserveScrollValue() {
	    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    _app_dispatcher2.default.dispatch('preserve-scroll-value', opts);
	  },
	
	  displayMessageAction: function displayMessageAction(data) {
	    _analytics_dispatcher2.default.dispatch('analytics-events', {
	      name: 'hipchat.client.integrations.message.action.open'
	    });
	
	    _app_dispatcher2.default.dispatch('display-message-action', data);
	  },
	
	  hideMessageAction: function hideMessageAction(data) {
	    _analytics_dispatcher2.default.dispatch('analytics-events', {
	      name: 'hipchat.client.integrations.message.action.close'
	    });
	
	    _app_dispatcher2.default.dispatch('hide-message-action', data);
	  },
	
	  chatStartedScroll: function chatStartedScroll(jid) {
	    _app_dispatcher2.default.dispatch('chat-is-scrolling', { scrolling: true, jid: jid });
	  },
	
	  updateScrollPosition: function updateScrollPosition(data) {
	    _app_dispatcher2.default.dispatch('update-scroll-position', data);
	  },
	
	  chatStoppedScroll: function chatStoppedScroll(jid) {
	    _app_dispatcher2.default.dispatch('chat-is-scrolling', { scrolling: false, jid: jid });
	  },
	
	  toggleImage: function toggleImage(data) {
	    _app_dispatcher2.default.dispatch('toggle-image', {
	      jid: data.jid,
	      mid: data.mid
	    });
	  },
	
	  senderClick: function senderClick(data) {
	    _app_dispatcher2.default.dispatch('sender-clicked', data);
	  },
	
	  chatPanelMounted: function chatPanelMounted(data) {
	    _analytics_dispatcher2.default.dispatch('analytics-chat-mount', data);
	  },
	
	  onFailedCancel: function onFailedCancel(msg) {
	    _app_dispatcher2.default.dispatch('cancel-failed-message', msg);
	  },
	
	  onFailedRetry: function onFailedRetry(msg) {
	    _app_dispatcher2.default.dispatch('retry-failed-message', msg);
	  },
	
	  /**
	   * Opens a 1-1 chat by mention name
	   * @param {string} mention name
	   */
	  openChatByMentionName: function openChatByMentionName(data) {
	    _app_dispatcher2.default.dispatch('open-chat-by-mention-name', data.mentionName);
	  },
	
	  dismissActionsDropDown: function dismissActionsDropDown() {
	    _app_dispatcher2.default.dispatch('dismiss-active-actions-dropdown');
	  },
	
	  messageMediaLoaded: function messageMediaLoaded(data) {
	    _app_dispatcher2.default.dispatch('message-media-loaded', data);
	  },
	  messageMediaSizeFound: function messageMediaSizeFound(data) {
	    _app_dispatcher2.default.dispatch('message-media-size-found', data);
	  },
	
	
	  toggleAttachedCards: function toggleAttachedCards(mid) {
	    _app_dispatcher2.default.dispatch('toggle-attached-cards', mid);
	  },
	
	  fetchSignedThumbnail: function fetchSignedThumbnail(data, cb, errCb) {
	    _app_dispatcher2.default.dispatch('API:fetch-signed-thumbnail', data, cb, errCb);
	  },
	  fetchSignedThumbnailCollection: function fetchSignedThumbnailCollection(fileObj) {
	    _app_dispatcher2.default.dispatch('API:fetch-signed-thumbnail-collection', fileObj);
	  },
	  thumbnailIsLoading: function thumbnailIsLoading(instance) {
	    _app_dispatcher2.default.dispatch('thumbnail-is-loading', instance);
	  },
	  thumbnailLoadedSuccess: function thumbnailLoadedSuccess(instance) {
	    _app_dispatcher2.default.dispatch('thumbnail-loaded-success', instance);
	  },
	  thumbnailLoadedError: function thumbnailLoadedError(data) {
	    _app_dispatcher2.default.dispatch('thumbnail-loaded-error', data);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 179 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  default_metabar_author_prefix: 'Shared by'
	};
	module.exports = exports['default'];

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _favicon_counter = __webpack_require__(181);
	
	var _favicon_counter2 = _interopRequireDefault(_favicon_counter);
	
	var _title_counter = __webpack_require__(182);
	
	var _title_counter2 = _interopRequireDefault(_title_counter);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Notifier = function () {
	  function Notifier() {
	    (0, _classCallCheck3.default)(this, Notifier);
	
	    this.isSupported = typeof Notification !== 'undefined';
	    this.totalUnreadCount = 0;
	    this.totalUnreadHasMention = false;
	    this.titleNotifications = [];
	    this.audioDuration = {};
	    this.canPlay = {};
	    this.autoclose_timeout = _app_config2.default.notification_close_timeout;
	    this.maxNotifications = _app_config2.default.notification_limit;
	    this.notificationCount = 0;
	    this.group_name = '';
	    this.feature_flags = {};
	    this.current_user_presence = _presence2.default.AVAILABLE;
	
	    this.titleCounter = new _title_counter2.default({
	      group_name: this.group_name,
	      feature_flags: this.feature_flags
	    });
	
	    try {
	      this.favicon = new _favicon_counter2.default({
	        bgColor: _app_config2.default.favicon_bg_color,
	        maxCount: _app_config2.default.max_unread_count
	      });
	    } catch (e) {
	      _logger2.default.warn(e);
	    }
	  }
	
	  (0, _createClass3.default)(Notifier, [{
	    key: 'initialize',
	    value: function initialize(asset_base_uri) {
	      var _this = this;
	
	      var sound_asset_overrides = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	      function addSrc(audio, mediaType, path) {
	        var src = document.createElement('source');
	        src.type = mediaType;
	        src.src = path;
	        audio.appendChild(src);
	      }
	
	      if (typeof Audio !== "undefined") {
	        (function () {
	          var supportCanPlay = 'oncanplay' in Audio.prototype;
	
	          _this.audio = {
	            notification: asset_base_uri + (sound_asset_overrides.notify_sound_asset || _app_config2.default.notify_sound_asset),
	            incoming_call: asset_base_uri + (sound_asset_overrides.incoming_sound_asset || _app_config2.default.incoming_sound_asset),
	            outgoing_call: asset_base_uri + (sound_asset_overrides.outgoing_sound_asset || _app_config2.default.outgoing_sound_asset)
	          };
	          _.forOwn(_this.audio, function (path, key) {
	            _this.audio[key] = new Audio();
	            _this.audio[key].addEventListener("loadedmetadata", function () {
	              _this.audioDuration[key] = _this.audio[key].duration;
	            });
	
	            var canPlayHandler = function canPlayHandler() {
	              _this.canPlay[key] = true;
	            };
	
	            var checkIfCanPlay = _this.checkIfCanPlay.bind(_this, _this.audio[key]);
	
	            if (supportCanPlay) {
	              _this.audio[key].oncanplay = canPlayHandler;
	            } else if (checkIfCanPlay('audio/ogg') || checkIfCanPlay('audio/mpeg')) {
	              canPlayHandler();
	            }
	
	            addSrc(_this.audio[key], 'audio/ogg', path + '.ogg');
	            addSrc(_this.audio[key], 'audio/mpeg', path + '.mp3');
	          });
	        })();
	      }
	    }
	  }, {
	    key: 'checkIfCanPlay',
	    value: function checkIfCanPlay(element, type) {
	      if (!element.canPlayType) {
	        return false;
	      }
	
	      var result = element.canPlayType(type);
	
	      if (result === 'probably' || result === 'maybe') {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'update',
	    value: function update(data) {
	      this.group_name = data.group_name || this.group_name;
	      this.feature_flags = data.feature_flags || this.feature_flags;
	      this.current_user_presence = data.current_user_presence || this.current_user_presence;
	
	      if (this.titleCounter) {
	        this.titleCounter.update({
	          group_name: this.group_name,
	          feature_flags: this.feature_flags
	        });
	      }
	    }
	  }, {
	    key: 'notify',
	    value: function notify(data) {
	      this._increaseCount();
	
	      if (this._shouldNotify(data.type)) {
	        var title = data.title;
	        if (_.get(this.feature_flags, "web_client_subdomain_scoped_session")) {
	          title = this._formatNewMessageNotificationTitle(data);
	        }
	        var notification = new Notification(title, this._getOptions(data));
	        this._bindNotification(notification, data.jid);
	      }
	    }
	  }, {
	    key: '_shouldNotify',
	    value: function _shouldNotify(type) {
	      return this.isSupported && (this.current_user_presence !== _presence2.default.DND || _preferences_store2.default.getNotifyWhenDND() || _preferences_store2.default.getNotifyForVideoWhenDND() && type === 'incoming_call');
	    }
	  }, {
	    key: '_formatNewMessageNotificationTitle',
	    value: function _formatNewMessageNotificationTitle(data) {
	      var title = _chat_panel_strings2.default.notification_title_with_group(data.title, data.group_name);
	      return _utils2.default.strings.ellipsis(title, _app_config2.default.notification_title_max_character_length);
	    }
	  }, {
	    key: '_shouldPlaySound',
	    value: function _shouldPlaySound(type) {
	      if (!_preferences_store2.default.getSoundsEnabled()) {
	        return false;
	      }
	
	      var message_sounds = _preferences_store2.default.getMessageSounds(),
	          video_sounds = _preferences_store2.default.getVideoSounds(),
	          is_dnd = this.current_user_presence === _presence2.default.DND,
	          notify_when_dnd = _preferences_store2.default.getNotifyWhenDND(),
	          notify_for_video_when_dnd = _preferences_store2.default.getNotifyForVideoWhenDND();
	
	      if (type === 'outgoing_call' && video_sounds) {
	        return true;
	      } else if (type === 'notification' && message_sounds && (!is_dnd || notify_when_dnd)) {
	        return true;
	      } else if (type === 'incoming_call' && video_sounds && (!is_dnd || notify_when_dnd || notify_for_video_when_dnd)) {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'playSound',
	    value: function playSound(type, loop) {
	      if (!this._shouldPlaySound(type)) {
	        return;
	      }
	
	      if (this.audio[type] && this.canPlay[type]) {
	        var audio = this.audio[type],
	            duration = this.audioDuration[type],
	            reset = function reset() {
	          this.currentTime = 0;
	          this.play();
	        };
	        if (duration && audio.currentTime < duration) {
	          try {
	            audio.pause();
	            audio.currentTime = 0;
	          } catch (e) {
	            _logger2.default.warn('HC-Client', e);
	          }
	        }
	        if (loop) {
	          audio.addEventListener('ended', reset);
	        } else {
	          audio.removeEventListener('ended', reset);
	        }
	        audio.play();
	      }
	    }
	  }, {
	    key: 'stopSounds',
	    value: function stopSounds(type) {
	      function stop(audio) {
	        try {
	          audio.pause();
	          audio.currentTime = 0;
	        } catch (e) {
	          _logger2.default.warn('HC-Client', e);
	        }
	      }
	      if (type && this.audio[type] && this.canPlay[type]) {
	        stop(this.audio[type]);
	      } else {
	        _.forEach(this.audio, function (audio) {
	          stop(audio);
	        });
	      }
	    }
	  }, {
	    key: 'updateTotalUnreadCount',
	    value: function updateTotalUnreadCount(count, hasMention) {
	      if (count !== this.totalUnreadCount || hasMention !== this.totalUnreadHasMention) {
	        this._updateFavicon(count, hasMention);
	        this._updateTitleBadge(count);
	        this.totalUnreadCount = count;
	        this.totalUnreadHasMention = hasMention;
	      }
	    }
	  }, {
	    key: 'setTitleNotification',
	    value: function setTitleNotification(notification) {
	      this.titleNotifications.push(notification);
	      this._updateTitleNotification();
	    }
	  }, {
	    key: 'unsetTitleNotification',
	    value: function unsetTitleNotification(id) {
	      _.remove(this.titleNotifications, { id: id });
	      this._updateTitleNotification();
	    }
	  }, {
	    key: '_getOptions',
	    value: function _getOptions(data) {
	      var notificationData = {
	        icon: data.icon,
	        body: data.body
	      };
	      if (this.notificationCount >= this.maxNotifications) {
	        notificationData.tag = true;
	      }
	      return notificationData;
	    }
	  }, {
	    key: '_bindNotification',
	    value: function _bindNotification(notification, jid) {
	      var _this2 = this;
	
	      notification.onclick = function () {
	        window.focus();
	        _app_dispatcher2.default.dispatch('set-route', { jid: jid });
	        _app_dispatcher2.default.dispatch('focus-video-window', { jid: jid });
	        _analytics_dispatcher2.default.dispatch('analytics-select-room', { jid: jid });
	        this.close();
	      };
	      notification.onshow = function () {
	        setTimeout(function () {
	          notification.close();
	        }, _this2.autoclose_timeout);
	      };
	      notification.onclose = function () {
	        _this2._decreaseCount(notification);
	      };
	    }
	  }, {
	    key: '_increaseCount',
	    value: function _increaseCount() {
	      this.notificationCount++;
	    }
	  }, {
	    key: '_decreaseCount',
	    value: function _decreaseCount(notification) {
	      if (notification.tag) {
	        this.notificationCount = 0;
	      } else {
	        this.notificationCount--;
	      }
	    }
	  }, {
	    key: '_updateFavicon',
	    value: function _updateFavicon(unreadTotal, hasMention) {
	      if (this.favicon) {
	        if (unreadTotal > 0) {
	          var opts = {
	            bgColor: _app_config2.default.favicon_bg_color,
	            maxCount: _app_config2.default.max_unread_count
	          };
	          if (hasMention) {
	            opts.bgColor = _app_config2.default.favicon_bg_color_with_mention;
	          }
	          this.favicon.badge(unreadTotal, opts);
	        } else {
	          this.favicon.reset();
	        }
	      }
	    }
	  }, {
	    key: '_updateTitleBadge',
	    value: function _updateTitleBadge(unreadTotal) {
	      if (!this._browserNeedsBadge()) {
	        return;
	      }
	
	      var unread_count = unreadTotal > 0 ? unreadTotal : 0,
	          notification = this._getCurrentTitleNotification();
	      this.titleCounter.set(unread_count, notification);
	    }
	  }, {
	    key: '_updateTitleNotification',
	    value: function _updateTitleNotification() {
	      var notification = this._getCurrentTitleNotification(),
	          unread_count = this._browserNeedsBadge() ? this.totalUnreadCount : 0;
	      this.titleCounter.set(unread_count, notification);
	    }
	  }, {
	    key: '_getCurrentTitleNotification',
	    value: function _getCurrentTitleNotification() {
	      var currentNotification = _.last(this.titleNotifications);
	      return _.get(currentNotification, 'text', null);
	    }
	  }, {
	    key: '_browserNeedsBadge',
	    value: function _browserNeedsBadge() {
	      return _utils2.default.browser.is.ie() || _utils2.default.browser.is.ie_edge() || _utils2.default.browser.is.safari();
	    }
	  }]);
	  return Notifier;
	}();
	
	module.exports = new Notifier();

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FaviconCounter = function () {
	  function FaviconCounter(opt) {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, FaviconCounter);
	
	    this.def = {
	      bgColor: '#d00',
	      textColor: '#fff',
	      fontFamily: 'sans-serif', //Arial,Verdana,Times New Roman,serif,sans-serif,...
	      fontStyle: 'lighter', //normal,italic,oblique,bold,bolder,lighter,100,200,300,400,500,600,700,800,900
	      elementId: false
	    };
	
	    this.browser = {};
	    this.browser.ff = typeof InstallTrigger !== 'undefined';
	    this.browser.opera = !!window.opera || navigator.userAgent.indexOf('Opera') >= 0;
	
	    this.readyCb = function () {};
	    this.ready = false;
	
	    this.opt = _.merge(this.def, opt);
	    this.opt.textColor = this.hexToRgb(this.opt.textColor);
	
	    try {
	      this.orig = this.getIcon();
	      this.canvas = document.createElement('canvas');
	      this.img = document.createElement('img');
	      if (this.orig.hasAttribute('href')) {
	        this.img.onload = function () {
	          _this.h = _this.img.height > 0 ? _this.img.height : 32;
	          _this.w = _this.img.width > 0 ? _this.img.width : 32;
	          _this.canvas.height = _this.h;
	          _this.canvas.width = _this.w;
	          _this.context = _this.canvas.getContext('2d');
	          _this.setReady();
	        };
	        this.img.setAttribute('src', this.orig.getAttribute('href'));
	      } else {
	        this.img.setAttribute('src', '');
	        this.h = 32;
	        this.w = 32;
	        this.img.height = this.h;
	        this.img.width = this.w;
	        this.canvas.height = this.h;
	        this.canvas.width = this.w;
	        this.context = this.canvas.getContext('2d');
	        this.setReady();
	      }
	    } catch (e) {
	      throw 'Error initializing favico. Message: ' + e.message;
	    }
	  }
	
	  (0, _createClass3.default)(FaviconCounter, [{
	    key: 'setReady',
	    value: function setReady() {
	      this.ready = true;
	      this.reset();
	      this.readyCb();
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      if (!this.ready || !this.context) {
	        return;
	      }
	      this.context.clearRect(0, 0, this.w, this.h);
	      this.context.drawImage(this.img, 0, 0, this.w, this.h);
	      this.setIcon(this.canvas);
	    }
	  }, {
	    key: 'draw',
	    value: function draw(opt) {
	      var _this2 = this;
	
	      if (_utils2.default.browser.is.ie() || _utils2.default.browser.is.ie_edge()) {
	        return;
	      }
	
	      this.ready = false;
	      var img = new Image();
	      img.onload = function () {
	        if (!_this2.context) {
	          return;
	        }
	        opt.n = typeof opt.n === 'number' ? Math.abs(opt.n | 0) : opt.n;
	        opt.w = _this2.w;
	        opt.h = _this2.h;
	        opt.len = ("" + opt.n).length;
	        _this2.context.clearRect(0, 0, _this2.w, _this2.h);
	        _this2.context.drawImage(img, 0, 0);
	        _this2.context.beginPath();
	        _this2.context.font = _this2.opt.fontStyle + " " + Math.floor(opt.n > 99 ? opt.h * 1.2 : opt.h * 0.55) + "px " + _this2.opt.fontFamily;
	        _this2.context.textAlign = 'center';
	        _this2.context.fillStyle = 'rgb(' + _this2.opt.textColor.r + ',' + _this2.opt.textColor.g + ',' + _this2.opt.textColor.b + ')';
	        if (typeof opt.n === 'number' && opt.n > _this2.opt.maxCount) {
	          _this2.context.font = "bold " + Math.floor(opt.h * 0.5) + "px " + _this2.opt.fontFamily;
	          _this2.context.fillText('', Math.floor(opt.w / 2), Math.floor(opt.h * 0.67));
	        } else {
	          _this2.context.fillText(opt.n, Math.floor(opt.w / 2), Math.floor(opt.h - opt.h * 0.34));
	        }
	        _this2.context.closePath();
	        _this2.setIcon(_this2.canvas);
	      };
	      var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + this.w + '" height="' + this.h + '"><g><path fill="' + opt.bgColor + '" d="M29.1,28.9c-1.1-0.6-2.2-1.7-2.6-3.2c-0.1-0.3,0-0.5,0.2-0.7c3.2-2.5,5.2-6.1,5.2-10.2c0-7.5-7-13.6-15.8-13.6c-8.7,0-15.7,6.1-15.7,13.6c0,7.5,7,13.6,15.7,13.6c1.1,0,2.2-0.1,3.3-0.3c0.3-0.1,0.5,0,0.7,0.1c2.2,1.3,5.4,2.4,8.2,2.4c0.9,0,1.3-0.6,1.3-1.1C28.6,29.3-209.8,29.1,28.9z"/></g></svg>';
	      img.src = 'data:image/svg+xml,' + encodeURIComponent(svg);
	    }
	  }, {
	    key: 'badge',
	    value: function badge(number, opts) {
	      var _this3 = this;
	
	      try {
	        if (typeof number === 'number' ? number > 0 : number !== '') {
	          var q = {
	            type: 'badge',
	            options: {
	              n: number,
	              bgColor: opts.bgColor || this.opt.bgColor
	            }
	          };
	          ['textColor'].forEach(function (o) {
	            if (o in opts) {
	              q.options[o] = _this3.hexToRgb(opts[o]);
	            }
	          });
	          ['fontStyle', 'fontFamily'].forEach(function (o) {
	            if (o in opts) {
	              q.options[o] = opts[o];
	            }
	          });
	          this.draw(q.options);
	        } else {
	          this.reset();
	        }
	      } catch (e) {
	        throw 'Error setting badge. Message: ' + e.message;
	      }
	    }
	  }, {
	    key: 'getIcon',
	    value: function getIcon() {
	      var elm = false;
	      var url = '';
	      var getLink = function getLink() {
	        var link = document.getElementsByTagName('head')[0].getElementsByTagName('link');
	        for (var l = link.length, i = l - 1; i >= 0; i--) {
	          if (/(^|\s)icon(\s|$)/i.test(link[i].getAttribute('rel'))) {
	            return link[i];
	          }
	        }
	        return false;
	      };
	      if (this.opt.elementId) {
	        elm = document.getElementById(this.opt.elementId);
	        elm.setAttribute('href', elm.getAttribute('src'));
	      } else {
	        elm = getLink();
	        if (elm === false) {
	          elm = document.createElement('link');
	          elm.setAttribute('rel', 'icon');
	          document.getElementsByTagName('head')[0].appendChild(elm);
	        }
	      }
	      url = this.opt.elementId ? elm.src : elm.href;
	      if (url.substr(0, 5) !== 'data:' && url.indexOf(document.location.hostname) === -1) {
	        throw new Error('Error setting favicon. Favicon image is on different domain (Icon: ' + url + ', Domain: ' + document.location.hostname + ')');
	      }
	      elm.setAttribute('type', 'image/png');
	      return elm;
	    }
	  }, {
	    key: 'setIcon',
	    value: function setIcon(canvas) {
	      var _this4 = this;
	
	      var url = canvas.toDataURL('image/png');
	      if (this.opt.elementId) {
	        document.getElementById(this.opt.elementId).setAttribute('src', url);
	      } else {
	        if (this.browser.ff || this.browser.opera) {
	          var old = this.orig;
	          this.orig = document.createElement('link');
	          if (this.browser.opera) {
	            this.orig.setAttribute('rel', 'icon');
	          }
	          this.orig.setAttribute('rel', 'icon');
	          this.orig.setAttribute('type', 'image/png');
	          document.getElementsByTagName('head')[0].appendChild(this.orig);
	          this.orig.setAttribute('href', url);
	          if (old.parentNode) {
	            old.parentNode.removeChild(old);
	          }
	        } else {
	          //This is because of a Chrome bug where batched repaints prevent the favicon from changing
	          _.defer(function () {
	            _this4.orig.setAttribute('href', url);
	          });
	        }
	      }
	      this.ready = true;
	    }
	
	    //http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-5624139
	    //HEX to RGB convertor
	
	  }, {
	    key: 'hexToRgb',
	    value: function hexToRgb(hex) {
	      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
	        return r + r + g + g + b + b;
	      });
	      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	      return result ? {
	        r: parseInt(result[1], 16),
	        g: parseInt(result[2], 16),
	        b: parseInt(result[3], 16)
	      } : false;
	    }
	  }]);
	  return FaviconCounter;
	}();
	
	module.exports = FaviconCounter;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TitleCounter = function () {
	  function TitleCounter(data) {
	    (0, _classCallCheck3.default)(this, TitleCounter);
	
	    this.group_name = null;
	    this.feature_flags = {};
	    this.update(data);
	  }
	
	  (0, _createClass3.default)(TitleCounter, [{
	    key: 'update',
	    value: function update(data) {
	      var group_name = _.get(data, 'group_name', ''),
	          feature_flags = _.get(data, 'feature_flags', {});
	
	      if (group_name !== this.group_name || !_.isEqual(feature_flags, this.feature_flags)) {
	        this.group_name = group_name;
	        this.feature_flags = feature_flags;
	        this.set();
	      }
	    }
	  }, {
	    key: 'set',
	    value: function set() {
	      var unread_count = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	      var notification = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      var title = [];
	
	      if (unread_count > _app_config2.default.max_unread_count) {
	        title.push('(' + _app_config2.default.max_unread_count + '+)');
	      } else if (unread_count) {
	        title.push('(' + unread_count + ')');
	      }
	
	      if (notification) {
	        title.push(notification, '-');
	      } else if (this.feature_flags.web_client_subdomain_scoped_session) {
	        title.push(this.group_name, '-');
	      }
	
	      title.push(_common_strings2.default.app_name);
	
	      this.setTitle(title.join(' '));
	    }
	  }, {
	    key: 'setTitle',
	    value: function setTitle(title) {
	      document.title = title;
	    }
	  }]);
	  return TitleCounter;
	}();

	exports.default = TitleCounter;
	module.exports = exports['default'];

/***/ },
/* 183 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  app_name: 'HipChat',
	  filter_label: 'Filter rooms and people',
	  filter: 'Filter',
	  all: 'All',
	  rooms: 'Rooms',
	  people: 'People',
	  sign_in: 'Sign in',
	  lobby: 'Lobby',
	  youre_welcome: 'you\'re welcome here',
	  search_results: 'Search results',
	  buttons: {
	    create_room: 'Create a room',
	    invite_team: 'Invite your team',
	    invite_team_in_lobby: 'Invite someone to join!',
	    invite_team_in_qs: 'Invite them to join!',
	    invite_team_in_invite_users_dialog: 'Invite them to join!'
	  },
	  no_one_found: 'No one found',
	  loud: 'Loud',
	  normal: 'Normal',
	  quiet: 'Quiet',
	  room_not_found: 'We couldn\'t find that room. It may have been deleted or you may have the wrong ID.',
	  user_not_found: 'We couldn\'t find that person.'
	};
	module.exports = exports['default'];

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _freeze2.default)({
	  AVAILABLE: 'chat',
	  IDLE: 'away',
	  AWAY: 'xa',
	  MOBILE: 'mobile',
	  DND: 'dnd',
	  UNAVAILABLE: 'unavailable'
	});
	module.exports = exports['default'];

/***/ },
/* 185 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  show_more: "Show more",
	  show_less: "Show less",
	  failed_message: "Couldn't send",
	  failed_message_retry: "Retry",
	  failed_message_cancel: "Cancel",
	  unconfirmed_message_group: "Sending...",
	  room_doesnt_exist: "This room doesn't exist; it may have been archived or deleted.",
	  integration_does_not_exist: "This addon does not exist; it may have been uninstalled from this room.",
	  user_leave: function user_leave(name) {
	    return name + " left the room";
	  },
	  user_join: function user_join(name) {
	    return name + " joined the room";
	  },
	  user_removed: function user_removed(name) {
	    return name + " was removed from the room";
	  },
	  user_added: function user_added(name) {
	    return name + " was added to the room";
	  },
	  user_leave_reason: function user_leave_reason(name, reason) {
	    return name + " left the room (" + reason + ")";
	  },
	  user_changed_guest_access: function user_changed_guest_access(name, action) {
	    return name + " " + action + " guest access";
	  },
	  user_changed_archive_status: function user_changed_archive_status(name, action) {
	    return name + " " + action + " the room";
	  },
	  generic_message: function generic_message(name) {
	    return "Message from " + name;
	  },
	  generic_file_message: function generic_file_message(name) {
	    return name + " uploaded a file";
	  },
	  generic_file_uploaded_message: function generic_file_uploaded_message(name, file) {
	    return name + " uploaded " + file;
	  },
	  topic_message: function topic_message(name, topic) {
	    return name + " changed the topic to: " + topic;
	  },
	  clear_topic_message: function clear_topic_message(name) {
	    return name + " cleared the topic.";
	  },
	  room_notification_title: function room_notification_title(sender, room_name) {
	    return sender + " - " + room_name;
	  },
	  oto_notification_title: function oto_notification_title(sender) {
	    return "" + sender;
	  },
	  notification_title_with_group: function notification_title_with_group(title, group_name) {
	    return title + " (" + group_name + ")";
	  },
	  you_have_been_removed: "You have been removed from the room",
	  archived: "archived",
	  unarchived: "unarchived",
	  not_allowed: "guest access unavailable",
	  turned_on: "turned on",
	  turned_off: "turned off",
	  loading_thumbnail: "Loading thumbnail",
	  loading_image: "Loading image",
	  image_error: "Failed to load the image",
	  thumbnail_error: "Failed to load thumbnail",
	  image_hidden: "Image hidden",
	  edited: "Edited",
	  message_deleted: "Message deleted"
	};
	module.exports = exports['default'];

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _namespaces = __webpack_require__(154);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SANITIZE_TOKEN_KEYS = ["token", "auth_nonce", "oauth_token", "oauth2_token", "access_token", "apiv1_token", "nonce"];
	var SANITIZE_MESSAGE_KEYS = ["message", "text"];
	var REMOVE_TEXT_NODE_TAGS = ['body', 'desc'];
	var REDACT_TEXT_NODE_TAGS = ['name', 'thumb', 'thumbnail', 'thumb_url', 'file_url'];
	var FUNC_STRING = "[function call]";
	
	function cleanTag(tag) {
	  tag.textContent = 'REDACTED';
	}
	function redactTag(tag) {
	  var textContent = tag.textContent;
	
	  tag.textContent = textContent.replace(/([\s\S]+\/)[\S]+(\.[\w]+)$/, "$1REDACTED$2");
	}
	function cleanTags(tags) {
	  var tagName = void 0;
	
	  (0, _from2.default)(tags).forEach(function (tag) {
	    tagName = tag.nodeName;
	    if (REMOVE_TEXT_NODE_TAGS.indexOf(tagName) >= 0) {
	      cleanTag(tag);
	    } else if (REDACT_TEXT_NODE_TAGS.indexOf(tagName) >= 0) {
	      redactTag(tag);
	    }
	  });
	}
	
	exports.default = {
	  sanitize: function sanitize(val) {
	    if (_.isFunction(val)) {
	      return this.sanitizeFunc(val);
	    }
	    var returnVal = _.cloneDeep(val);
	    if (_.isObject(returnVal)) {
	      return this.iterateObj(returnVal);
	    }
	    return returnVal;
	  },
	  sanitizeXML: function sanitizeXML(el) {
	    var localName = _.get(el, "localName");
	
	    if (!_.isString(localName)) {
	      return el;
	    }
	    switch (localName.toLowerCase()) {
	      case "auth":
	        return this.cleanStanza(el);
	      case "success":
	        return this.cleanStanza(el);
	      case "message":
	        return this.cleanMessageStanza(el);
	      case "iq":
	        return this.cleanIqStanza(el);
	    }
	
	    return el;
	  },
	  cleanStanza: function cleanStanza(node) {
	    var cloneNode = this.cloneXMLNode(node);
	
	    if (!cloneNode) {
	      return node;
	    }
	
	    cloneNode = this.cleanNodeContent(cloneNode);
	    cloneNode = this.cleanNodeAttrs(cloneNode);
	
	    return cloneNode;
	  },
	  cleanMessageStanza: function cleanMessageStanza(node) {
	    var cloneNode = this.cloneXMLNode(node);
	    var allNodes = void 0;
	
	    if (!cloneNode) {
	      return node;
	    }
	    allNodes = cloneNode.getElementsByTagName('*');
	    if (allNodes.length) {
	      cleanTags(allNodes);
	    }
	
	    return cloneNode;
	  },
	  cleanIqStanza: function cleanIqStanza(node) {
	    var cloneNode = this.cloneXMLNode(node);
	    var query = cloneNode.getElementsByTagName('query');
	    var attribute = void 0;
	
	    if (query.length) {
	      attribute = query[0].getAttribute('xmlns');
	      if (attribute === _namespaces.HC_FILES || attribute === _namespaces.HC_AUTHENTICATED_FILE) {
	        this.cleanFilesStanza(cloneNode);
	      }
	    }
	
	    return cloneNode;
	  },
	  cleanFilesStanza: function cleanFilesStanza(node) {
	    var allNodes = node.getElementsByTagName('*');
	
	    if (allNodes.length) {
	      cleanTags(allNodes);
	    }
	  },
	  cloneXMLNode: function cloneXMLNode(node) {
	    return node.cloneNode(true);
	  },
	  cleanNodeContent: function cleanNodeContent(node) {
	    node.textContent = this.cleanToken(node.textContent);
	    return node;
	  },
	  cleanNodeAttrs: function cleanNodeAttrs(node) {
	    var _this = this;
	
	    var attrKeys = arguments.length <= 1 || arguments[1] === undefined ? SANITIZE_TOKEN_KEYS : arguments[1];
	
	    _.each(attrKeys, function (attr) {
	      var val = node.getAttribute(attr);
	      if (node && val) {
	        node.setAttribute(attr, _this.cleanToken(val));
	      }
	    });
	    return node;
	  },
	  cleanToken: function cleanToken(val) {
	    var string = val.toString();
	    return string.slice(0, 8) + "...";
	  },
	  cleanMessage: function cleanMessage(val) {
	    return 'REDACTED';
	  },
	  iterateObj: function iterateObj(val) {
	    for (var prop in val) {
	      if (val.hasOwnProperty(prop)) {
	        var curVal = val[prop];
	        if (_.isObject(curVal) && !_.isFunction(curVal)) {
	          this.iterateObj(curVal);
	        } else {
	          val[prop] = this.sanitizeVal(prop, curVal);
	        }
	      }
	    }
	    return val;
	  },
	  sanitizeVal: function sanitizeVal(key, val) {
	    if (!val) {
	      return val;
	    }
	
	    if (_.isFunction(val)) {
	      return this.sanitizeFunc(val);
	    }
	    if (SANITIZE_TOKEN_KEYS.indexOf(key) !== -1) {
	      return this.cleanToken(val);
	    }
	    if (SANITIZE_MESSAGE_KEYS.indexOf(key) !== -1) {
	      return this.cleanMessage(val);
	    }
	    return val;
	  },
	  sanitizeFunc: function sanitizeFunc(val) {
	    return FUNC_STRING;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _symbol = __webpack_require__(24);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var X = (0, _symbol2.default)('X');
	var Y = (0, _symbol2.default)('Y');
	var REAL_X = (0, _symbol2.default)('realX');
	var REAL_Y = (0, _symbol2.default)('realY');
	
	exports.default = {
	  track: function track() {
	    var debouncedSave = _.debounce(this._save.bind(this), 20, { leading: true, trailing: true });
	    document.addEventListener("mouseover", debouncedSave);
	    document.addEventListener("mousemove", debouncedSave);
	  },
	  _save: function _save(_ref) {
	    var pageX = _ref.pageX;
	    var pageY = _ref.pageY;
	
	    this[REAL_X] = pageX;
	    this[REAL_Y] = pageY;
	    _logger2.default.type('mouse-position').withFilter().info('Real mouse position has changed:', pageX, pageY);
	  },
	  useLatest: function useLatest() {
	    this[X] = this[REAL_X];
	    this[Y] = this[REAL_Y];
	  },
	  hasChanged: function hasChanged(_ref2) {
	    var pageX = _ref2.pageX;
	    var pageY = _ref2.pageY;
	
	    if (this[X] !== pageX || this[Y] !== pageY) {
	      this[X] = pageX;
	      this[Y] = pageY;
	      _logger2.default.type('mouse-position').withFilter().info('Mouse position has changed:', pageX, pageY);
	      return true;
	    }
	    return false;
	  },
	
	
	  get x() {
	    return this[X];
	  },
	
	  get y() {
	    return this[Y];
	  },
	
	  get realX() {
	    return this[REAL_X];
	  },
	
	  get realY() {
	    return this[REAL_Y];
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _analytics_events = __webpack_require__(189);
	
	var _analytics_events2 = _interopRequireDefault(_analytics_events);
	
	var _analytics_event_keys = __webpack_require__(205);
	
	var _analytics_event_keys2 = _interopRequireDefault(_analytics_event_keys);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	__webpack_require__(254); /*global ENV*/
	
	
	var Analytics = function () {
	  function Analytics(initState, clientIdentifier) {
	    var herment = arguments.length <= 2 || arguments[2] === undefined ? window['herment-gas-client'] : arguments[2];
	    var metrics = arguments.length <= 3 || arguments[3] === undefined ? window['app-metrics'] : arguments[3];
	    var performance = arguments.length <= 4 || arguments[4] === undefined ? window['performance'] : arguments[4];
	    (0, _classCallCheck3.default)(this, Analytics);
	
	    this.setupVariables(initState, clientIdentifier, performance);
	    this.bindCustomAnalyticEvents();
	    this.startHerment(initState, clientIdentifier, herment);
	    this.setupMetrics(metrics);
	    // now that we have the ability to push events onto the queue, let's fire off any queued analytics
	    this.handlePreloaderAnalytics();
	    this.handleAnalyticsLaunched();
	    this.registerListeners();
	  }
	
	  (0, _createClass3.default)(Analytics, [{
	    key: "registerListeners",
	    value: function registerListeners() {
	      var _this = this;
	
	      // AppDispatcher Events
	      _app_dispatcher2.default.registerOnce({
	        'app-state-ready': function appStateReady() {
	          _this.handleAppStateReady();
	        },
	        'DAL:cache-configured': function DALCacheConfigured() {
	          // If we starting in the lobby, we should not send the 'launch-to-chat' event
	          _dal2.default.Cache.get(_dal2.default.Cache.Keys.CLIENT_PREFERENCES).then(function (prefs) {
	            _this.shouldSendLaunchToChat = _this.shouldSendLaunchToChatComplete = _utils2.default.jid.is_chat(_.get(prefs, 'chatToFocus'));
	          });
	        }
	      });
	
	      // AnalyticsDispatcher Events
	      _analytics_dispatcher2.default.registerOnce({
	        'analytics-client-ready': function analyticsClientReady() {
	          _this.handleAnalyticsClientReady();
	        },
	        'analytics-rooms-loaded': function analyticsRoomsLoaded() {
	          _this.handleAnalyticsRoomLoaded();
	        },
	        'analytics-roster-loaded': function analyticsRosterLoaded() {
	          _this.handleAnalyticsRosterLoaded();
	        },
	        'analytics-emoticons-loaded': function analyticsEmoticonsLoaded() {
	          _this.handleAnalyticsEmoticonLoaded();
	        }
	      });
	      _analytics_dispatcher2.default.register({
	        'analytics-hc-client-start': function analyticsHcClientStart() {
	          _this.handleClientStart();
	        },
	        'analytics-hc-client-initial-connection': function analyticsHcClientInitialConnection() {
	          _this.handleInitialConnection();
	        },
	        'analytics-hc-client-reconnection-start': function analyticsHcClientReconnectionStart() {
	          _this.handleReconnectionStart();
	        },
	        'analytics-hc-client-reconnection-success': function analyticsHcClientReconnectionSuccess() {
	          _this.handleReconnectionSuccess();
	        },
	        'analytics-initial-presence-response-received': function analyticsInitialPresenceResponseReceived() {
	          _this.handlePresenceResponse();
	        },
	        'analytics-start-iq-response-received': function analyticsStartIqResponseReceived() {
	          _this.handleStartupIqResponse();
	        },
	        'analytics-initial-auth-start': function analyticsInitialAuthStart() {
	          _this.handleAuthStart();
	        },
	        'analytics-initial-auth-done': function analyticsInitialAuthDone() {
	          _this.handleAuthDone();
	        },
	        'analytics-on-dom-ready': function analyticsOnDomReady() {
	          _this.handleDomReady();
	        },
	        'analytics-hc-init': function analyticsHcInit() {
	          _this.handleAppInit();
	        },
	        'analytics-chat-mount': function analyticsChatMount(data) {
	          _this.handleChatMountEvent(data);
	        },
	        'analytics-open-room': function analyticsOpenRoom(data) {
	          _this.handleOpenedRoom(data);
	        },
	        'analytics-request-history': function analyticsRequestHistory(data) {
	          _this.handleHistoryRequest(data);
	        },
	        'analytics-history-loaded': function analyticsHistoryLoaded(data) {
	          _this.handleHistoryResponse(data);
	        },
	        'analytics-roster-mount': function analyticsRosterMount(data) {
	          _this.handleRosterMount(data);
	        },
	        'analytics-files-mount': function analyticsFilesMount(data) {
	          _this.handleFilesMount(data);
	        },
	        'analytics-select-room': function analyticsSelectRoom(data) {
	          _this.handleLobbyOpen(data);
	        },
	        'analytics-lobby-mount': function analyticsLobbyMount(data) {
	          _this.handleLobbyMount(data);
	        },
	        'analytics-new-active-chat': function analyticsNewActiveChat(data) {
	          if (_utils2.default.jid.is_chat(data.jid)) {
	            _this.spawnCompositeEvent(_analytics_event_keys2.default.CHAT_SENDABLE, data);
	            _this.spawnCompositeEvent(_analytics_event_keys2.default.CHAT_IS_COMPLETE, data);
	          }
	        },
	        'performance-timing:analytics-launch-to-chat': function performanceTimingAnalyticsLaunchToChat(data) {
	          _this.handleLaunchToChat(data);
	        },
	        'performance-timing:analytics-launch-to-chat-complete': function performanceTimingAnalyticsLaunchToChatComplete(data) {
	          _this.handleLaunchToChatComplete(data);
	        }
	      });
	    }
	  }, {
	    key: "registerAppStateReadyAnalytics",
	    value: function registerAppStateReadyAnalytics() {
	      var _this2 = this;
	
	      _analytics_dispatcher2.default.registerOnce({
	        'performance-timing:analytics-launch-to-active-chat-list': function performanceTimingAnalyticsLaunchToActiveChatList(data) {
	          _this2.handleLaunchToActiveChatList(data);
	        }
	      });
	    }
	  }, {
	    key: "setupVariables",
	    value: function setupVariables(initState, clientIdentifier, performance) {
	      this.eventQueue = [];
	      this.userAgent = _utils2.default.browser.userAgent();
	      this.performance = performance;
	      this.slug = this.getSlug(clientIdentifier); // client identifier sent with events
	      this.baseEvent = this.getBaseEvent(initState.group_id, initState.user_id, this.slug, initState.is_admin, clientIdentifier.client_version_id); // setup base event for analytics
	      this.isGuest = this.getIsGuest(); // need to account for guest access for some of our analytics
	      this.appLaunchTime = window.hc_client_launch_time; // global variable set in HTML - earliest time in the app launch sequence
	      this.browserMetricsBaseEvent = this.getBrowserMetricsBaseEvent(initState.is_admin, this.slug);
	      this.requiredClientUpToDateFetchTimes = this.getRequiredClientFetchTimesObject(this.isGuest); // stores the times for each expected action that's necessary to get the client "up-to-date" on a load
	      // this will hold the composite event objects that have a longer lifespan than the fire-and-forget events.
	      // Examples include "navigate start --> able to send message" and "navigate start --> chat is fully initialized"
	      this.compositeEventQueue = {};
	      // Will override these with proper values in DAL:cache-configured handler above
	      this.shouldSendLaunchToChat = this.shouldSendLaunchToChatComplete = true;
	      this.deleteWindowLaunchTime();
	    }
	  }, {
	    key: "bindCustomAnalyticEvents",
	    value: function bindCustomAnalyticEvents() {
	      var _this3 = this;
	
	      var events = arguments.length <= 0 || arguments[0] === undefined ? _analytics_events2.default.events : arguments[0];
	
	      _.forOwn(events, function (handler, hcWebEvent) {
	        if (_.isString(handler)) {
	          (function () {
	            var eventName = handler;
	            handler = function handler() {
	              return {
	                name: eventName
	              };
	            };
	          })();
	        }
	        _analytics_dispatcher2.default.register(hcWebEvent, function () {
	          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }
	
	          return _this3.sendEvents(handler.apply(_this3, args));
	        });
	      });
	    }
	
	    /**
	     * Pushes the events onto the Herment stack.
	     * @param result
	     */
	
	  }, {
	    key: "sendEvents",
	    value: function sendEvents(result) {
	      var _this4 = this;
	
	      if (result) {
	        var events = _utils2.default.toArray(result);
	        _.each(events, function (event) {
	          _this4.addToEventQueue(_this4.makeEvent(event));
	        });
	      }
	    }
	  }, {
	    key: "startHerment",
	    value: function startHerment(initState, clientIdentifier) {
	      var herment = arguments.length <= 2 || arguments[2] === undefined ? window['herment-gas-client'] : arguments[2];
	
	      var options = this.getHermentOptions(initState.group_id, initState.user_id, clientIdentifier.client_version_id);
	      herment(options).start();
	      _logger2.default.type('analytics').withFilter().alwaysExpanded().log('Herment started with options: ', options);
	    }
	  }, {
	    key: "setupMetrics",
	    value: function setupMetrics() {
	      var metrics = arguments.length <= 0 || arguments[0] === undefined ? window['app-metrics'] : arguments[0];
	
	      // App metrics configuration specifics which is in line with the custom implementation of herment here
	      this.metrics = metrics({ publish: this.customPublish.bind(this), unfold: true });
	    }
	  }, {
	    key: "customPublish",
	    value: function customPublish(key, data) {
	      var event = this.makeEvent({ name: key, properties: data });
	      this.addToEventQueue(event);
	    }
	  }, {
	    key: "customBrowserMetricsEvent",
	    value: function customBrowserMetricsEvent(properties) {
	
	      if ('probes' in properties && properties.probes <= 0) {
	        _logger2.default.type('analytics').withFilter().alwaysExpanded().log('Probes property is invalid. Event was skipped: ', properties);
	        return;
	      }
	
	      var props = _.assign(properties, {
	        "sid": _configuration_store2.default.getSID()
	      }),
	          fullEvent = _.assign(_.clone(this.browserMetricsBaseEvent), {
	        "properties": props
	      }),
	          event = this.makeEvent(fullEvent);
	      this.addToEventQueue(event);
	    }
	  }, {
	    key: "handleRequiredClientUpToDateFetchTime",
	    value: function handleRequiredClientUpToDateFetchTime(name) {
	      var timeSinceLaunch = this.getTimeSinceAppLaunch();
	      this.requiredClientUpToDateFetchTimes[name] = timeSinceLaunch;
	      if (_.every(this.requiredClientUpToDateFetchTimes)) {
	        var eventData = {
	          name: _analytics_event_keys2.default.CLIENT_CURRENT,
	          properties: {
	            time_since_launch: timeSinceLaunch,
	            is_guest: this.isGuest
	          }
	        },
	            event = this.makeEvent(eventData);
	        this.addToEventQueue(event);
	        this.handleInitialDataFetched();
	      }
	    }
	  }, {
	    key: "handlePreloaderAnalytics",
	    value: function handlePreloaderAnalytics() {
	      var _this5 = this;
	
	      if (window.preloaderEvents) {
	        // Register to be notified when the preloader completes
	        window.preloaderEvents.onComplete(function (eventQueue) {
	          // For any that exist - pull them in, make them full events
	          _.each(eventQueue, function (event) {
	            _this5.addToEventQueue(_this5.makeEvent(event));
	          });
	        });
	      }
	    }
	  }, {
	    key: "handleAnalyticsLaunched",
	    value: function handleAnalyticsLaunched() {
	      var event = this.makeEvent({ name: _analytics_event_keys2.default.CLIENT_LAUNCH });
	      this.addToEventQueue(event);
	    }
	  }, {
	    key: "handleAnalyticsRoomLoaded",
	    value: function handleAnalyticsRoomLoaded() {
	      this.handleRequiredClientUpToDateFetchTime("rooms");
	      this.metrics.stop({ key: _analytics_event_keys2.default.INITIAL_ROOMS, id: 'app', size: 0, props: { method: "bosh" } });
	    }
	  }, {
	    key: "handleAnalyticsRosterLoaded",
	    value: function handleAnalyticsRosterLoaded() {
	      this.handleRequiredClientUpToDateFetchTime("roster");
	      this.metrics.stop({ key: _analytics_event_keys2.default.INITIAL_ROSTER, id: 'app', size: 0, props: { method: "bosh" } });
	    }
	  }, {
	    key: "handleAnalyticsEmoticonLoaded",
	    value: function handleAnalyticsEmoticonLoaded() {
	      this.handleRequiredClientUpToDateFetchTime("emoticons");
	      this.metrics.stop({ key: _analytics_event_keys2.default.INITIAL_EMOTICONS, id: 'app', size: 0, props: { method: "bosh" } });
	    }
	  }, {
	    key: "handleAnalyticsClientReady",
	    value: function handleAnalyticsClientReady() {
	      var event = this.makeEvent({
	        name: _analytics_event_keys2.default.CLIENT_READY,
	        properties: {
	          time_since_launch: this.getTimeSinceAppLaunch()
	        }
	      });
	      this.addToEventQueue(event);
	    }
	
	    // Called from `handleInitialDataFetched` instead of from its own event.
	
	  }, {
	    key: "handleInitialDataFetched",
	    value: function handleInitialDataFetched() {
	      this.metrics.stop({ key: _analytics_event_keys2.default.INITIAL_FETCH, id: "app", size: 0 });
	    }
	
	    // hc_web.app.load
	
	  }, {
	    key: "handleAppInit",
	    value: function handleAppInit() {
	      var performance = arguments.length <= 0 || arguments[0] === undefined ? this.performance : arguments[0];
	
	      if (performance && performance.now) {
	        var readyForUser = Math.floor(performance.now());
	        this.metrics.store({
	          key: _analytics_event_keys2.default.CLIENT_READY_FOR_USER,
	          probes: readyForUser,
	          size: 0,
	          props: {
	            readyForUser: readyForUser
	          }
	        });
	      }
	    }
	  }, {
	    key: "handleClientStart",
	    value: function handleClientStart() {
	      this.metrics.start({ key: _analytics_event_keys2.default.CONNECTION_ESTABLISHED, id: 'app', size: 0 });
	      this.metrics.start({ key: _analytics_event_keys2.default.INITIAL_FETCH, id: 'app', size: 0 });
	    }
	  }, {
	    key: "handleInitialConnection",
	    value: function handleInitialConnection() {
	      this.metrics.stop({ key: _analytics_event_keys2.default.CONNECTION_ESTABLISHED, id: "app", size: 0 });
	      this.metrics.start({ key: _analytics_event_keys2.default.INITIAL_PRESENCE, id: "app", size: 0 });
	      this.metrics.start({ key: _analytics_event_keys2.default.INITIAL_IQ, id: "app", size: 0 });
	      this.metrics.start({ key: _analytics_event_keys2.default.INITIAL_ROOMS, id: "app", size: 0 });
	      this.metrics.start({ key: _analytics_event_keys2.default.INITIAL_ROSTER, id: "app", size: 0 });
	      this.metrics.start({ key: _analytics_event_keys2.default.INITIAL_EMOTICONS, id: "app", size: 0 });
	    }
	
	    // This is an addition to the onOpenRoom callback in analytics-events
	    // hc_web.room.open
	    // hc_web.room.files.load
	    // hc_web.room.members.load
	
	  }, {
	    key: "handleOpenedRoom",
	    value: function handleOpenedRoom(properties) {
	      this.metrics.start({ key: _analytics_event_keys2.default.ROOM_RENDER, id: properties.jid });
	      this.metrics.start({ key: _analytics_event_keys2.default.ROOM_FILES_LOAD, id: properties.jid });
	      this.metrics.start({ key: _analytics_event_keys2.default.ROOM_MEMBERS_LOAD, id: properties.jid });
	    }
	
	    // hc_web.room.open
	
	  }, {
	    key: "handleChatMountEvent",
	    value: function handleChatMountEvent(properties) {
	      this.metrics.stop({ key: _analytics_event_keys2.default.ROOM_RENDER, id: properties.id, size: properties.size });
	    }
	
	    // hc_web.room.history.load
	
	  }, {
	    key: "handleHistoryRequest",
	    value: function handleHistoryRequest(properties) {
	      this.metrics.start({ key: _analytics_event_keys2.default.ROOM_HISTORY_LOAD, id: properties.jid });
	    }
	
	    // hc_web.room.history.load
	
	  }, {
	    key: "handleHistoryResponse",
	    value: function handleHistoryResponse(properties) {
	      this.metrics.stop({ key: _analytics_event_keys2.default.ROOM_HISTORY_LOAD, id: properties.jid, size: properties.size });
	    }
	
	    // hc_web.room.members.load
	
	  }, {
	    key: "handleRosterMount",
	    value: function handleRosterMount(properties) {
	      this.metrics.stop({ key: _analytics_event_keys2.default.ROOM_MEMBERS_LOAD, id: properties.id, size: properties.size });
	    }
	
	    // hc_web.room.files.load
	
	  }, {
	    key: "handleFilesMount",
	    value: function handleFilesMount(properties) {
	      this.metrics.stop({ key: _analytics_event_keys2.default.ROOM_FILES_LOAD, id: properties.id, size: properties.size });
	    }
	
	    // hc_web.lobby.panel.open
	
	  }, {
	    key: "handleLobbyOpen",
	    value: function handleLobbyOpen(properties) {
	      if (_utils2.default.jid.is_lobby(properties.jid)) {
	        this.metrics.start({ key: _analytics_event_keys2.default.LOBBY_RENDER, id: properties.jid, size: 0 });
	      }
	    }
	
	    // hc_web.lobby.panel.open
	
	  }, {
	    key: "handleLobbyMount",
	    value: function handleLobbyMount(properties) {
	      this.metrics.stop({ key: _analytics_event_keys2.default.LOBBY_RENDER, id: properties.id, size: 0 });
	    }
	  }, {
	    key: "handleReconnectionStart",
	    value: function handleReconnectionStart() {
	      this.metrics.start({ key: _analytics_event_keys2.default.RECONNECTION, id: 'app', size: 0 });
	    }
	  }, {
	    key: "handleReconnectionSuccess",
	    value: function handleReconnectionSuccess() {
	      this.metrics.stop({ key: _analytics_event_keys2.default.RECONNECTION, id: 'app', size: 0 });
	    }
	  }, {
	    key: "handlePresenceResponse",
	    value: function handlePresenceResponse() {
	      this.metrics.stop({ key: _analytics_event_keys2.default.INITIAL_PRESENCE, id: 'app', size: 0, props: { method: "bosh" } });
	    }
	  }, {
	    key: "handleStartupIqResponse",
	    value: function handleStartupIqResponse() {
	      this.metrics.stop({ key: _analytics_event_keys2.default.INITIAL_IQ, id: 'app', size: 0, props: { method: "bosh" } });
	    }
	  }, {
	    key: "handleAuthStart",
	    value: function handleAuthStart() {
	      this.metrics.start({ key: _analytics_event_keys2.default.AUTH, id: 'app', size: 0 });
	    }
	  }, {
	    key: "handleAuthDone",
	    value: function handleAuthDone() {
	      this.metrics.stop({ key: _analytics_event_keys2.default.AUTH, id: 'app', size: 0, props: { method: "bosh" } });
	    }
	  }, {
	    key: "handleDomReady",
	    value: function handleDomReady() {
	      var timings = _utils2.default.timings.getPerfTiming();
	      this.metrics.store({ key: _analytics_event_keys2.default.DOM_READY, id: 'app', size: 0, props: timings });
	    }
	  }, {
	    key: "handleLaunchToActiveChatList",
	    value: function handleLaunchToActiveChatList(data) {
	      var probes = this.getTimeSinceAppLaunch();
	      this.customBrowserMetricsEvent({
	        key: _analytics_event_keys2.default.LAUNCH_TO_ACTIVE_CHAT_LIST,
	        size: _.get(data, "size"),
	        probes: probes,
	        method: "bosh"
	      });
	    }
	
	    // Register one time performance events dependent upon app-state-ready
	
	  }, {
	    key: "handleAppStateReady",
	    value: function handleAppStateReady() {
	      if (!this.isGuest) {
	        // Guests do not have an active chat list
	        this.registerAppStateReadyAnalytics();
	      }
	    }
	  }, {
	    key: "handleLaunchToChat",
	    value: function handleLaunchToChat(data) {
	      if (!this.shouldSendLaunchToChat) {
	        return;
	      }
	
	      var probes = this.getTimeSinceAppLaunch();
	
	      // Remember that we've sent it so that we don't let it through more than once
	      this.shouldSendLaunchToChat = false;
	
	      this.customBrowserMetricsEvent({
	        key: _analytics_event_keys2.default.LAUNCH_TO_CHAT,
	        size: _.get(data, "size"),
	        probes: probes,
	        method: "bosh"
	      });
	    }
	  }, {
	    key: "handleLaunchToChatComplete",
	    value: function handleLaunchToChatComplete(data) {
	      if (!this.shouldSendLaunchToChatComplete) {
	        return;
	      }
	
	      // Remember that we've sent it so that we don't let it through more than once
	      this.shouldSendLaunchToChatComplete = false;
	
	      var probes = this.getTimeSinceAppLaunch(),
	          isRoom = _utils2.default.jid.is_room(data.jid),
	          chatTypeIndicator = isRoom ? 0 : 1,
	          chatId = "" + (isRoom ? 'r' : 'p') + data.id;
	
	      this.customBrowserMetricsEvent({
	        key: _analytics_event_keys2.default.LAUNCH_TO_CHAT_COMPLETE,
	        size: chatTypeIndicator,
	        chat: chatId,
	        probes: probes,
	        method: "bosh"
	      });
	    }
	
	    /**
	     * Decorates an event with the current server time and other required properties.
	     *
	     * @param event
	     * @return {*}
	     */
	
	  }, {
	    key: "makeEvent",
	    value: function makeEvent(event) {
	      this.processRoomType(event);
	      event.serverTime = _utils2.default.now();
	      return _.merge({}, this.baseEvent, event);
	    }
	  }, {
	    key: "addToEventQueue",
	    value: function addToEventQueue() {
	      var event = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      if (!_.get(event, 'properties')) {
	        event = this.makeEvent(event);
	      }
	      this.eventQueue.push(event);
	      _logger2.default.type('analytics').withFilter().alwaysExpanded().log('Event was added to queue:', event.name, event.properties, event);
	    }
	  }, {
	    key: "getTimeSinceAppLaunch",
	    value: function getTimeSinceAppLaunch() {
	      return _utils2.default.now() - this.appLaunchTime;
	    }
	  }, {
	    key: "getIsGuest",
	    value: function getIsGuest() {
	      return window.HC && window.HC.is_guest ? window.HC.is_guest : false;
	    }
	  }, {
	    key: "getSlug",
	    value: function getSlug(clientIdentifier) {
	      return clientIdentifier.client_subtype ? clientIdentifier.client_type + "_" + clientIdentifier.client_subtype : clientIdentifier.client_type;
	    }
	  }, {
	    key: "getBaseEvent",
	    value: function getBaseEvent(groupId, userId, slug, isAdmin, versionId) {
	      return {
	        "server": "gid-" + groupId,
	        "product": _analytics_event_keys2.default.PRODUCT,
	        "subproduct": "hc_" + slug,
	        "version": versionId,
	        "user": "uid-" + userId,
	        "properties": {
	          client: slug,
	          isAdmin: isAdmin,
	          environment: ("production"),
	          type: slug,
	          ver: versionId,
	          os_ver: this.userAgent.os.name + " " + (this.userAgent.os.version || ""),
	          browser: this.userAgent.browser.name + " " + this.userAgent.browser.version
	        }
	      };
	    }
	  }, {
	    key: "getHermentOptions",
	    value: function getHermentOptions(groupId, userId, versionId) {
	      return {
	        queue: this.eventQueue,
	        storage_key: _dal2.default.Cache.Keys.ANALYTICS,
	        server: "gid-" + groupId,
	        product: _analytics_event_keys2.default.PRODUCT,
	        subproduct: "hc_" + this.slug,
	        version: versionId,
	        user: "uid-" + userId,
	        unfold: true,
	        publish_interval: _app_config2.default.analytics_publish_interval,
	        save_interval: _app_config2.default.analytics_save_interval
	      };
	    }
	  }, {
	    key: "getBrowserMetricsBaseEvent",
	    value: function getBrowserMetricsBaseEvent(isAdmin, slug) {
	      return {
	        "name": _analytics_event_keys2.default.BROWSER_METRICS,
	        "properties": {
	          "client": slug,
	          "isAdmin": isAdmin,
	          "environment": ("production")
	        }
	      };
	    }
	  }, {
	    key: "getRequiredClientFetchTimesObject",
	    value: function getRequiredClientFetchTimesObject(isGuest) {
	      // Guests only fetch emoticons
	      if (isGuest) {
	        return {
	          emoticons: null
	        };
	      }
	
	      return {
	        roster: null,
	        rooms: null,
	        emoticons: null
	      };
	    }
	
	    /**
	     * Ensures we have a valid room type.
	     *
	     * We sometimes get an event type. This makes sure this doesn't get through to GAS.
	     *
	     * @param event The event.
	     * @return {*}
	     */
	
	  }, {
	    key: "processRoomType",
	    value: function processRoomType(event) {
	      if (event && event.properties && event.properties.type && !_.isString(event.properties.type)) {
	        delete event.properties.type;
	      }
	    }
	  }, {
	    key: "deleteWindowLaunchTime",
	    value: function deleteWindowLaunchTime() {
	      delete window.hc_client_launch_time;
	    }
	
	    /**
	     * Takes care of unregistering handlers for a given composite event and removing the association of those
	     * handlers to this composite event.  If handlers are found for the event name specified, this will remove
	     * them.  Otherwise it's essentially a noop.
	     *
	     * @param {String} name the name of the composite event you want to unstage
	     */
	
	  }, {
	    key: "__unstageCompositeEvent",
	    value: function __unstageCompositeEvent(name) {
	      // if we have a composite event with this name in the queue already, unregister its handlers
	      var existingHandlers = _.get(this.compositeEventQueue, name);
	      if (existingHandlers) {
	        _.each(existingHandlers, function (handler) {
	          handler.dispatcher.unregister(handler.name, handler.func);
	        });
	
	        // remove this composite event entry so that we know it has executed its handler
	        delete this.compositeEventQueue[name];
	      }
	    }
	
	    /**
	     * Takes care of registering handlers for a given composite event and associating those
	     * handlers to this composite event
	     *
	     * @param {String} name the name of the composite event
	     * @param {Array} handlers
	     */
	
	  }, {
	    key: "__stageCompositeEvent",
	    value: function __stageCompositeEvent(name, handlers) {
	      // now let's register the new handlers
	      _.each(handlers, function (handler) {
	        handler.dispatcher.register(handler.name, handler.func);
	      });
	
	      // and associate the handler map with the event name so that future register calls can clean them up if need be
	      this.compositeEventQueue[name] = handlers;
	    }
	
	    /**
	     * Handles the creation, spawning, and respawning logic for events that can't be fired until a set of
	     * events has successfully fired.  This acts as sort of a debounce for composite events,
	     *
	     * @param {String} name the name of the composite event you intend to fire.
	     * @param {*} starterData any data you have when you're spawning the composite event sequence
	     */
	
	  }, {
	    key: "spawnCompositeEvent",
	    value: function spawnCompositeEvent(name, starterData) {
	      var _this6 = this,
	          _handlerCreationFunct;
	
	      // Functions that generate the handler(s) associated with a given composite event.
	      // These should all return an array of handler entry objects containing:
	      // - dispatcher: The dispatcher to use when registering the function
	      // - name: The name of the event to register the function for
	      // - func: The function you need registered to that event
	      var handlerCreationFunctions = (_handlerCreationFunct = {}, (0, _defineProperty3.default)(_handlerCreationFunct, _analytics_event_keys2.default.CHAT_SENDABLE, function () {
	        var beginTime = new Date().getTime();
	        // create a handler that will fire when we get the notification that a user is able to send text in a new chat
	        var chatSendableHandler = function chatSendableHandler(data) {
	          // if the jid matches the one we had when we spawned this composite event, let's fire the event
	          if (starterData.jid === data.jid) {
	            _this6.customBrowserMetricsEvent({
	              key: _analytics_event_keys2.default.CHAT_SENDABLE,
	              size: _utils2.default.jid.is_room(data.jid) ? 0 : 1,
	              probes: _utils2.default.now() - beginTime,
	              method: "bosh"
	            });
	
	            // now let's remove any handlers that are tied to this composite event
	            _this6.__unstageCompositeEvent(_analytics_event_keys2.default.CHAT_SENDABLE);
	          }
	        };
	
	        return [{ dispatcher: _analytics_dispatcher2.default, name: "analytics-active-chat-changed", func: chatSendableHandler }];
	      }), (0, _defineProperty3.default)(_handlerCreationFunct, _analytics_event_keys2.default.CHAT_IS_COMPLETE, function () {
	        var beginTime = new Date().getTime();
	        // create a handler that will fire when we get the notification that the chat loaded has received
	        var chatIsCompleteHandler = function chatIsCompleteHandler(data) {
	          // if the jid matches the one we had when we spawned this composite event, let's fire the event
	          if (starterData.jid === data.jid) {
	            var isRoom = _utils2.default.jid.is_room(data.jid),
	                chatTypeIndicator = isRoom ? 0 : 1,
	                chatId = "" + (isRoom ? 'r' : 'p') + data.id;
	            _this6.customBrowserMetricsEvent({
	              key: _analytics_event_keys2.default.CHAT_IS_COMPLETE,
	              size: chatTypeIndicator,
	              chat: chatId,
	              probes: _utils2.default.now() - beginTime,
	              method: "bosh"
	            });
	
	            // now let's remove any handlers that are tied to this composite event
	            _this6.__unstageCompositeEvent(_analytics_event_keys2.default.CHAT_IS_COMPLETE);
	          }
	        };
	
	        return [{ dispatcher: _analytics_dispatcher2.default, name: "analytics-history-loaded", func: chatIsCompleteHandler }];
	      }), _handlerCreationFunct);
	
	      // lookup the handler creation function for the composite event specified
	      var handlerCreator = handlerCreationFunctions[name];
	      if (handlerCreator) {
	        // first, remove any existing handlers that might be waiting to fire for this composite event
	        this.__unstageCompositeEvent(name);
	        // now, stage our new handlers
	        this.__stageCompositeEvent(name, handlerCreator());
	      }
	    }
	
	    /**
	     * Reset variables
	     * FOR TESTING ONLY
	     * @method reset
	     */
	
	  }, {
	    key: "__reset",
	    value: function __reset() {
	      this.eventQueue = [];
	      this.compositeEventQueue = {};
	      this.isGuest = false;
	      this.appLaunchTime = null;
	      this.slug = null;
	      this.browserMetricsBaseEvent = {};
	      this.requiredClientUpToDateFetchTimes = null;
	      this.requiredClientUpToDateFetchTimes = {};
	    }
	  }]);
	  return Analytics;
	}();
	
	exports.default = Analytics;
	module.exports = exports['default'];

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _emoticons = __webpack_require__(110);
	
	var _emoticons2 = _interopRequireDefault(_emoticons);
	
	var _regex_helpers = __webpack_require__(106);
	
	var _regex_helpers2 = _interopRequireDefault(_regex_helpers);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasEnteredText = false;
	var ALL_MENTION_REGEX = /(?=[^\\w>]|^)@all(?=[^\\w<]|$)/gi;
	var HERE_MENTION_REGEX = /(?=[^\\w>]|^)@here(?=[^\\w<]|$)/gi;
	var USER_MENTION_REGEX = /(?=[^\\w]|^)@[a-z0-9\-]+(?=[^\\w]|$)/gi;
	var URL_MENTION_REGEX = new RegExp(_regex_helpers2.default.url, "gi");
	
	var SLASH_COMMAND_REGEX = /\/(join|part|topic|available|away|dnd|code|quote|pre|monospace|clear|me)\s/;
	
	/**
	 * Adds an input abandoned event if there is current text in the input field.
	 * @param events
	 */
	function checkChatAbandoned(events) {
	  if (hasEnteredText) {
	    events.push({
	      name: "hipchat.client.message.input.abandoned"
	    });
	  }
	}
	
	/**
	 * Can be called when a room is closed and a new one is subsequently selected.
	 * So please don't remove the isClosed below. :)
	 *
	 * @param properties
	 * @return {*}
	 */
	function onSelectRoom(_ref) {
	  var isClosed = _ref.isClosed;
	  var jid = _ref.jid;
	  var type = _ref.type;
	
	
	  var isLobby = _utils2.default.jid.is_lobby(jid);
	  var event = {
	    name: isLobby ? "hipchat.client.lobby.viewed" : "hipchat.client.chat.viewed"
	  };
	
	  var finalProps = {};
	
	  if (isClosed) {
	    finalProps.isClosed = true;
	  }
	
	  if (!isLobby) {
	    finalProps.type = type;
	    if (_utils2.default.jid.is_room(jid)) {
	      var room = _application_store2.default.get('allRooms')[jid];
	      if (room) {
	
	        var roster = _application_store2.default.get('roster');
	
	        var participants = _.get(room, 'participants.members', []).concat(_.get(room, 'participants.guests', []));
	
	        finalProps.room = room.id;
	        finalProps.room_name = room.name;
	        finalProps.private = _utils2.default.jid.is_private_room(room.privacy) ? 'yes' : 'no';
	
	        finalProps.here_size = _.values(_.pick(roster, participants)).filter(function (user) {
	          return _.get(user, 'presence.show') === _presence2.default.AVAILABLE;
	        }).length;
	
	        finalProps.all_size = participants.length;
	      }
	    }
	  }
	
	  if (!_.isEmpty(finalProps)) {
	    event.properties = finalProps;
	  }
	
	  var events = [event];
	
	  checkChatAbandoned(events);
	
	  return events;
	}
	
	/**
	 * Called when a room is newly opened.
	 *
	 * @param properties
	 * @return {*}
	 */
	function onOpenRoom(properties) {
	  var props = {
	    isNew: true,
	    type: properties.type,
	    source: properties.source
	  };
	
	  var type = _utils2.default.jid.is_room(properties.jid) ? 'room' : 'oto';
	  var source = props.source || "lobby";
	  var event = source === 'switcher' ? "hipchat.client.switcher.open." + type : "hipchat.client.lobby.open." + type;
	
	  if (source === "lobby" || source === 'switcher') {
	    props.filter_text_length = properties.query ? properties.query.length : 0;
	  }
	
	  return {
	    name: event,
	    properties: props
	  };
	}
	
	function onChatInputChanged(text) {
	  hasEnteredText = !_.isEmpty(text);
	}
	
	function messageContainsGroupMention(message) {
	  message = message.trim();
	  return ALL_MENTION_REGEX.test(message) || HERE_MENTION_REGEX.test(message);
	}
	
	/**
	 * TODO make this use the roster.
	 * @param message
	 * @returns {boolean}
	 */
	function messageContainsUserMention(message) {
	  message = message.trim();
	  return USER_MENTION_REGEX.test(message);
	}
	
	function onChatSent(data) {
	  var events = [];
	  if (hasEnteredText) {
	    var emoticons = _emoticons2.default.getEmoticonsInfo(data.text);
	    emoticons.forEach(function (emoticon) {
	      events.push({
	        name: "hipchat.client.emoticon.used",
	        properties: {
	          room: data.chat_type === 'groupchat' ? data.active_chat_id : null,
	          emoticonUsed: emoticon.shortcut,
	          emoticonType: emoticon.type
	        }
	      });
	    });
	
	    if (messageContainsGroupMention(data.text)) {
	      events.push({
	        name: "hipchat.client.message.group.mentioned"
	      });
	    } else if (messageContainsUserMention(data.text)) {
	      events.push({
	        name: "hipchat.client.message.user.mentioned"
	      });
	    }
	
	    if (URL_MENTION_REGEX.test(data.text)) {
	      events.push({
	        name: "hipchat.client.message.url.sent"
	      });
	    }
	
	    var slashCommand = SLASH_COMMAND_REGEX.exec(data.text);
	    if (slashCommand) {
	      events.push({
	        name: "hipchat.client.slash.command.used",
	        properties: {
	          command: slashCommand[1]
	        }
	      });
	    }
	
	    if (_app_config2.default.slash_replacement_regex.test(data.text)) {
	      events.push({
	        name: "hipchat.client.slash.command.used",
	        properties: {
	          command: 'replacement'
	        }
	      });
	    }
	
	    hasEnteredText = false;
	  }
	
	  return events;
	}
	
	function onCreateRoom(submit_data) {
	  return [{ name: "hipchat.client.room.created" }, { name: "hipchat.client.room." + submit_data.privacy + ".created" }];
	}
	
	function onUpdatePresence(presence) {
	  var eventType;
	  switch (presence.show) {
	    case "xa":
	      eventType = "away";
	      break;
	    case "dnd":
	      eventType = "donotdisturb";
	      break;
	    case "chat":
	      eventType = "available";
	  }
	
	  if (eventType) {
	    return {
	      name: "hipchat.client.top.navigation.profile.status.clicked." + eventType
	    };
	  }
	}
	
	function onUpdateStatusMessage(presence) {
	  return {
	    name: "hipchat.client.top.navigation.profile.status.statusmessage",
	    properties: {
	      custom: presence.status === "" ? false : true
	    }
	  };
	}
	
	function handleAnalyticsEvent(event) {
	  return event;
	}
	
	function onFilterLobby(data) {
	  var type;
	
	  if (data && data.scope) {
	    switch (data.scope) {
	      case "all":
	        type = "search";
	        break;
	      default:
	        type = data.scope;
	    }
	    return {
	      name: "hipchat.client.lobby.filter." + type
	    };
	  }
	}
	
	function getAddonKey(data) {
	  var addonKey = 'unknown-addon';
	  if (data && data.addon_key) {
	    addonKey = data.addon_key;
	  }
	  return { addonKey: addonKey };
	}
	
	function onConnectDialogClose(data) {
	  return {
	    name: "hipchat.client.connect.dialog.close",
	    properties: getAddonKey(data)
	  };
	}
	
	function onConnectDialogLinkClick(data) {
	  return {
	    name: "hipchat.client.connect.dialog.link.click",
	    properties: getAddonKey(data)
	  };
	}
	
	function onConnectAnalyticsEvent(data) {
	  return {
	    name: data.name,
	    properties: data.data
	  };
	}
	
	function onHideGifsClick(props) {
	  return {
	    name: "hipchat.client.settings.general.hidegifs",
	    properties: props
	  };
	}
	
	function onRoomNotificationSettingClick(data) {
	  return {
	    name: data.name,
	    properties: data.props
	  };
	}
	
	function onKeyboardShortcutUsed(data) {
	  return {
	    name: "hipchat.client.keyboard.shortcut.used",
	    properties: data
	  };
	}
	
	function onSecureFileDownload() {
	  return {
	    name: "hipchat.client.secure.file.download"
	  };
	}
	
	exports.default = {
	  events: {
	    "analytics-select-room": onSelectRoom,
	    "analytics-open-room": onOpenRoom,
	    "analytics-set-message-value": onChatInputChanged,
	    "analytics-send-message": onChatSent,
	    "analytics-create-room": onCreateRoom,
	    "analytics-event": handleAnalyticsEvent,
	    "analytics-update-presence": onUpdatePresence,
	    "analytics-update-status-message": onUpdateStatusMessage,
	    "analytics-filter-lobby": onFilterLobby,
	    "analytics-connect-dialog-click": onConnectDialogLinkClick,
	    "analytics-connect-dialog-close": onConnectDialogClose,
	    "analytics-connect-event": onConnectAnalyticsEvent,
	    "analytics-hide-gifs": onHideGifsClick,
	    "analytics-room-notification-setting": onRoomNotificationSettingClick,
	    "analytics-keyboard-shortcut-used": onKeyboardShortcutUsed,
	    "analytics-secure-file-download": onSecureFileDownload
	  },
	
	  /**
	   * Exposed for testing
	   * @private
	   */
	  __reset: function __reset() {
	    hasEnteredText = false;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _toConsumableArray2 = __webpack_require__(117);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _slicedToArray2 = __webpack_require__(127);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getIterator2 = __webpack_require__(114);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _message_processor = __webpack_require__(192);
	
	var _message_processor2 = _interopRequireDefault(_message_processor);
	
	var _iq_processor = __webpack_require__(199);
	
	var _iq_processor2 = _interopRequireDefault(_iq_processor);
	
	var _presence_processor = __webpack_require__(202);
	
	var _presence_processor2 = _interopRequireDefault(_presence_processor);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _notifier = __webpack_require__(180);
	
	var _notifier2 = _interopRequireDefault(_notifier);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AppStore = function (_Store) {
	  (0, _inherits3.default)(AppStore, _Store);
	
	  function AppStore() {
	    (0, _classCallCheck3.default)(this, AppStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AppStore).call(this));
	
	    _this.local = {
	      initialized: false,
	      user_state: 'active',
	      active_type: '',
	      profile_jids: [],
	      sent_msg_ids: [],
	      participants: [],
	      closedChats: [],
	      deletedRooms: [],
	      history_fetch_id: 0,
	      chat_states: ['active', 'inactive', 'composing', 'gone'],
	      emoticons_initialized: false,
	      windowFocused: true,
	      clearUnreadCounts: false,
	      shouldReconcileAutoJoin: false,
	      lastSavedAutoJoin: [],
	      presence_updates_timers: {}
	    };
	
	    _this.presenceProcessor = new _presence_processor2.default({
	      is_guest: _.get(window.HC, "is_guest", false)
	    });
	    _this.iqProcessor = new _iq_processor2.default({
	      is_guest: _.get(window.HC, "is_guest", false)
	    });
	
	    _this.server_data_callbacks = {
	      'message': _this.handleIncomingMessages,
	      'iq': _this.handleIQ,
	      'presence': _this.handlePresence,
	      'success': _this.handleConnectionSuccess
	    };
	
	    _this.messageProcessor = new _message_processor2.default(_this);
	
	    _this.debouncedSetActiveRooms = _.debounce(_this.setActiveRooms, _app_config2.default.set_active_rooms_timeout, {
	      leading: true,
	      trailing: true
	    });
	
	    _this.debouncedFetchRoomParticipantsFromAPI = _.debounce(_this.fetchRoomParticipantsFromAPI, _app_config2.default.fetch_room_participants_timeout, {
	      leading: false,
	      trailing: true
	    });
	
	    _this.refetchReadStateHandler = _this.refetchReadState.bind(_this);
	
	    _this.registerCallbacks();
	    _this.addChangeHandlers();
	    return _this;
	  }
	
	  (0, _createClass3.default)(AppStore, [{
	    key: 'getRoomDefaults',
	    value: function getRoomDefaults() {
	      return {
	        topic: null,
	        admins: [],
	        participants: {
	          members: [],
	          guests: []
	        },
	        files: [],
	        links: [],
	        is_archived: '0',
	        history_fetch_ids: [],
	        show_join_leave_messages: false,
	        guest_mention_regex: null,
	        most_recent_message: null,
	        last_read_message: null,
	        avatar_url: '',
	        roster_size: 0,
	        participants_fully_initialized: false,
	        presence: {
	          show: '',
	          status: '',
	          seconds: '',
	          idleTime: ''
	        },
	        unreadCount: 0,
	        unreadCountTemp: 0,
	        unreadMentionCount: 0,
	        unreadMentionJustMeCount: 0,
	        isUpdatingUnreadCount: false,
	        hasMention: false,
	        files_fetched: false,
	        links_fetched: false
	      };
	    }
	  }, {
	    key: 'getRosterDefaults',
	    value: function getRosterDefaults() {
	      return {
	        presence: {
	          show: 'unknown',
	          status: '',
	          seconds: '',
	          idleTime: ''
	        },
	        closed_at: _utils2.default.getMoment()
	      };
	    }
	  }, {
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        config: {},
	        active_chat: '',
	        asset_base_uri: '',
	        client_type: '',
	        client_subtype: '',
	        client_version_id: '',
	        video_chat_uri: '',
	        current_user: {},
	        activeRooms: {},
	        allRooms: {},
	        newMessages: {},
	        roster: {},
	        profiles: {},
	        smileys: {},
	        emoticons: {
	          path_prefix: '',
	          icons: {}
	        },
	        mentionRegexUser: null,
	        mentionRegexMe: null,
	        mentionRegexJustMe: null,
	        group_name: '',
	        group_id: null,
	        conference_server: null,
	        chat_server: null,
	        api_host: 'api.hipchat.com',
	        web_server: null,
	        features: {},
	        permissions: {},
	        release_dialog_content: {},
	        ui_available: false,
	        is_in_welcome_range: false
	      };
	    }
	  }, {
	    key: 'registerCallbacks',
	    value: function registerCallbacks() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(data) {
	          _this2.handleHCInit(data);
	        },
	        'app-state-ready': function appStateReady() {
	          _this2.fetchReadState();
	        },
	        'after:app-state-ready': function afterAppStateReady() {
	          // The first moment after the preloader has been hidden
	          _this2.set("ui_available", true);
	        },
	        'signout': function signout() {
	          var opts = {
	            is_guest: _.get(_this2.data.current_user, "is_guest", false),
	            guest_key: _.get(_this2.data.current_user, "guest_key", false),
	            type: '',
	            jid: _this2.data.active_chat,
	            preferences: _preferences_store2.default.getAll()
	          };
	          _app_dispatcher2.default.dispatch('exit-app', opts);
	        }
	      });
	      _app_dispatcher2.default.register({
	        'configuration-change': function configurationChange(data) {
	          _this2.handleConfigChange(data);
	        },
	        'feature-flags-update': function featureFlagsUpdate(feature_flags) {
	          _this2.updateFeatureFlags(feature_flags);
	          $(document).trigger('app-feature-flags', feature_flags);
	        },
	        'auth-token-update': function authTokenUpdate(data) {
	          _this2.updateConfig(data);
	        },
	        'update-sid': function updateSid(data) {
	          _this2.updateConfig(data);
	          _logger2.default.info('SID was updated: ', data.sid);
	          _logger2.default.type('sid').info('SID was updated: ', data.sid);
	        },
	        'server-data': function serverData(data) {
	          _this2.handleServerData(data);
	        },
	        'app-state-ready': function appStateReady() {
	          _this2.handleAppStateReady();
	        },
	        'open-room': function openRoom(data) {
	          _this2.handleOpenRoom(data);
	        },
	        'join-room': function joinRoom(data) {
	          _this2.handleJoinRoom(data);
	        },
	        'close-room': function closeRoom(data) {
	          _this2.handleCloseRoom(data.jid);
	        },
	        'delete-room': function deleteRoom(data) {
	          _this2.local.deletedRooms.push(data.jid);
	        },
	        'send-message': function sendMessage(data) {
	          _this2.handleSendMessage(data);
	        },
	        'fetch-attachment-image': function fetchAttachmentImage(messageObj) {
	          messageObj = _.groupBy(messageObj, 'room');
	          _this2.set({
	            newMessages: messageObj
	          });
	          _this2._handleNewMessageUpdate(messageObj);
	        },
	        'update-presence': function updatePresence(presence) {
	          _this2.updatePresence(presence);
	          if (presence.show === 'away') {
	            _app_dispatcher2.default.registerOnce('update-presence', _this2.refetchReadStateHandler);
	          }
	        },
	        'DAL:handle-joined-rooms': function DALHandleJoinedRooms(rooms) {
	          _this2.handleJoinedRooms(rooms);
	        },
	        'hide-join-messages': function hideJoinMessages() {
	          _.forOwn(_this2.data.activeRooms, function (room) {
	            room.show_join_leave_messages = false;
	          });
	        },
	        'guest-access-changed': function guestAccessChanged(data) {
	          var chat = _this2.data.allRooms[data.jid];
	          if (chat) {
	            _.assign(chat, { guest_url: data.url });
	          }
	          _this2.handleRoomUpdate(chat);
	        },
	        'new-active-chat': function newActiveChat(data) {
	          _this2._updateReadStateForActiveChat();
	          _this2._clearUnreadCountForChat(_this2.data.active_chat);
	
	          _this2.local.active_type = /@chat/.test(data.jid) ? 'chat' : 'groupchat';
	          _this2.set('active_chat', data.jid);
	
	          _this2.setActiveGuestUserRegex();
	          _this2._updateReadStateForActiveChat();
	          _this2._clearUnreadCountForChat(data.jid);
	
	          if (_utils2.default.jid.is_room(data.jid) && _.get(_this2.data.activeRooms, [data.jid, 'roster_size'], false)) {
	            _this2.initializeRoomParticipants(data.jid);
	          }
	        },
	        'request-ancient-history': function requestAncientHistory(data, cb) {
	          _this2.local.history_fetch_id++;
	          data.id = 'history:' + _this2.local.history_fetch_id;
	          if (_this2.data.activeRooms[data.jid]) {
	            _this2.data.activeRooms[data.jid].history_fetch_ids.push(data.id);
	          }
	          _app_dispatcher2.default.dispatch('fetch-previous', data, cb);
	        },
	        'remove-room-participant': function removeRoomParticipant(data) {
	          _this2.removeRoomParticipant(data);
	        },
	        'add-room-visitor': function addRoomVisitor(data) {
	          _this2.addVisitor(data);
	        },
	        'add-room-participant': function addRoomParticipant(data) {
	          _this2.addRoomParticipant(data);
	        },
	        'room-presence-received': function roomPresenceReceived(data) {
	          _this2.handleRoomPresence(data);
	        },
	        'user-removed': function userRemoved(data) {
	          _this2.handleUserRemoved(data);
	        },
	        'handle-cached-room': function handleCachedRoom(room) {
	          _this2.handleRooms(room);
	        },
	        'DAL:handle-new-room': function DALHandleNewRoom(room) {
	          _this2.handleRooms(room);
	        },
	        'DAL:handle-created-room': function DALHandleCreatedRoom(room) {
	          _this2.handleNewRoom(room);
	        },
	        'DAL:handle-fetched-links': function DALHandleFetchedLinks(chatLinksResponse) {
	          _this2.handleLinkQueryResponse(chatLinksResponse);
	        },
	        'DAL:handle-fetched-files': function DALHandleFetchedFiles(chatFilesResponse) {
	          _this2.handleFileQueryResponse(chatFilesResponse);
	        },
	        'add-link-from-message': function addLinkFromMessage(data) {
	          _this2.addLinkFromMessageToRoom(data.room, data.link);
	        },
	        'add-file-from-message': function addFileFromMessage(data) {
	          _this2.addFileFromMessageToRoom(data.room, data.file);
	        },
	        'global-presence-received': function globalPresenceReceived(data) {
	          _this2.handleGlobalPresence(data);
	        },
	        'groupchat-invite-received': function groupchatInviteReceived(message) {
	          _this2.handleInviteMessage(message);
	        },
	        'groupchat-invite-accepted': function groupchatInviteAccepted(data) {
	          _this2.handleRoomInviteAccepted(data.jid);
	        },
	        'private-chat-invite-received': function privateChatInviteReceived(message) {
	          _this2.handlePrivateChatInvite(message);
	        },
	        'enso.invite-to-audio-video-call': function ensoInviteToAudioVideoCall(data) {
	          _this2.handlePrivateChatInvite(data.message);
	        },
	        'set-user-state': function setUserState(data) {
	          if (_this2.local.user_state !== data.state) {
	            _this2.local.user_state = data.state;
	            _app_dispatcher2.default.dispatch('send-user-state-message', data);
	          } else if (data.state === 'composing') {
	            _app_dispatcher2.default.dispatch('send-user-state-message', data);
	          }
	        },
	        'status-message-received': function statusMessageReceived(data) {
	          _this2.handleChatStateMessage(data);
	        },
	        'mark-chats-as-read': function markChatsAsRead() {
	          var chats = _.values(_this2.data.activeRooms);
	          _this2.resetReadStateCounts(chats);
	        },
	        'mark-rooms-as-read': function markRoomsAsRead() {
	          var rooms = _.filter(_this2.data.activeRooms, function (chat) {
	            return _utils2.default.jid.is_room(chat.jid);
	          });
	          _this2.resetReadStateCounts(rooms);
	        },
	        'mark-people-as-read': function markPeopleAsRead() {
	          var people = _.filter(_this2.data.activeRooms, function (chat) {
	            return _utils2.default.jid.is_private_chat(chat.jid);
	          });
	          _this2.resetReadStateCounts(people);
	        },
	        'archive-room': function archiveRoom(data, cb) {
	          _this2.handleArchiveRoom(data, true, cb);
	        },
	        'unarchive-room': function unarchiveRoom(data, cb) {
	          _this2.handleArchiveRoom(data, false, cb);
	        },
	        'room-archived': function roomArchived(data) {
	          _this2.handleArchivedRoom(data, '1');
	        },
	        'room-unarchived': function roomUnarchived(data) {
	          _this2.handleArchivedRoom(data, '0');
	        },
	        'DAL:handle-topic-updated': function DALHandleTopicUpdated(data) {
	          _this2.handleTopicUpdated(data.topic, data.jid);
	        },
	        'enable-dark-feature': function enableDarkFeature(feature) {
	          _this2.handleEnableDarkFeature(feature);
	        },
	        'open-chat-by-mention-name': function openChatByMentionName(mentionName) {
	          _this2.openChatByMentionName(mentionName);
	        },
	        'missed-call': function missedCall(data) {
	          _this2.handleMissedCall(data);
	        },
	        'call-declined': function callDeclined(data) {
	          _this2.handleCallDeclined(data);
	        },
	        'application-focused': function applicationFocused() {
	          _this2.local.windowFocused = true;
	          _this2._updateReadStateForActiveChat();
	          _this2._clearUnreadCountForChat(_this2.data.active_chat);
	        },
	        'application-blurred': function applicationBlurred() {
	          _this2.local.windowFocused = false;
	        },
	        'strophe-disconnecting': function stropheDisconnecting() {
	          _app_dispatcher2.default.unregister('update-presence', _this2.refetchReadStateHandler);
	        },
	        'strophe-reconnecting': function stropheReconnecting() {
	          _this2.local.shouldReconcileAutoJoin = true;
	          _this2.resetRoomParticipantsListInitializedFlag();
	        },
	        'before:app-state-reconnected': function beforeAppStateReconnected() {
	          _this2.resetFilesAndLinksFetching();
	        },
	        'app-state-reconnected': function appStateReconnected() {
	          _this2.refetchReadState();
	        },
	        'fetch-files': function fetchFiles(_ref) {
	          var room = _ref.room;
	
	          if (_.get(_this2.data.activeRooms, room)) {
	            _this2.data.activeRooms[room].files_fetching = true;
	            _this2.set('activeRooms', _this2.data.activeRooms);
	          }
	        },
	        'fetch-links': function fetchLinks(_ref2) {
	          var room = _ref2.room;
	
	          if (_.get(_this2.data.activeRooms, room)) {
	            _this2.data.activeRooms[room].links_fetching = true;
	            _this2.set('activeRooms', _this2.data.activeRooms);
	          }
	        },
	        'preferences-saved': function preferencesSaved(data) {
	          if (data.autoJoin) {
	            _this2.local.lastSavedAutoJoin = data.autoJoin;
	          }
	        },
	        'updated:preferences': function updatedPreferences(newPreferences) {
	          var config = _.get(_this2.data, 'config', {}),
	              preferences = _.get(config, 'preferences', {});
	
	          config.preferences = _.merge(preferences, newPreferences);
	          // Write directly to `data`. We don't want to call this.set() here, because we're responding to
	          // a change in the prefs store and we don't want to trigger another with the same data.
	          _this2.data.config = config;
	
	          _this2._updateTotalUnreadCount();
	        },
	        'set-room-participants-fully-initialized': function setRoomParticipantsFullyInitialized(roomJid) {
	          var room = _.get(_this2.data.activeRooms, roomJid);
	          if (room) {
	            _this2.setRoomParticipantsFullyInitialized(room);
	          }
	        },
	        'API:fetched-recent-history': function APIFetchedRecentHistory(data) {
	          _this2.handleIncomingMessages(data, _this2);
	        },
	        'DAL:guest-fetched-room-participants': function DALGuestFetchedRoomParticipants(data) {
	          _this2.handleGuestRoomParticipants(data.items);
	        },
	        'DAL:fetched-room-participants': function DALFetchedRoomParticipants(data) {
	          _this2.handleRoomParticipantsFromAPI(data);
	        },
	        'DAL:readstate-fetched': function DALReadstateFetched(err, data) {
	          _this2.handleReadState(err, data);
	        }
	      });
	    }
	  }, {
	    key: 'updateConfig',
	    value: function updateConfig(data) {
	      var config = _.merge(this.data.config, data);
	      this.set({ config: config });
	    }
	  }, {
	    key: 'handleAppStateReady',
	    value: function handleAppStateReady() {
	      _analytics_dispatcher2.default.dispatch('analytics-client-ready', { name: 'hipchat.client.ready' });
	
	      while (this.local.profile_jids.length) {
	        var jid = this.local.profile_jids.shift();
	        _app_dispatcher2.default.dispatch('request-profile', jid);
	      }
	
	      var activeSize = _.size(this.data.activeRooms);
	      var isFounder = _.size(this.data.roster) === 1;
	      if (this._isFirstLogin() && !this.data.current_user.is_guest) {
	
	        // if there's no firstLoginDate then set one in prefs
	        _app_dispatcher2.default.dispatch('set-first-login-date');
	
	        this._showWelcomeDialog();
	
	        // invited users have no rooms in their autoJoin so we open a room for them, if it exists
	        if (activeSize === 0 && isFounder) {
	          this.onBoardNewUser(activeSize);
	        }
	      }
	
	      this.verifyOTOChats();
	    }
	  }, {
	    key: '_showWelcomeDialog',
	    value: function _showWelcomeDialog() {
	      var isWelcomeDialogEnabled = _.get(this.data.config, 'feature_flags.web_client_is_welcome_dialog_enabled', false);
	
	      if (isWelcomeDialogEnabled && this.data.is_in_welcome_range) {
	        _app_dispatcher2.default.dispatch('show-modal-dialog', {
	          dialog_type: 'welcome-dialog',
	          dialog_data: {}
	        });
	      }
	    }
	  }, {
	    key: '_isFirstLogin',
	    value: function _isFirstLogin() {
	      var preferences = arguments.length <= 0 || arguments[0] === undefined ? _preferences_store2.default.getAll() : arguments[0];
	
	      var firstLoginDate = _.get(preferences, "properties.firstLoginDate");
	      firstLoginDate = parseInt(firstLoginDate, 10);
	      return _.isNaN(firstLoginDate);
	    }
	  }, {
	    key: '_handleWelcomeRange',
	    value: function _handleWelcomeRange(peopleAmount) {
	      var peopleAmountMax = _app_config2.default.welcome_dialog.max_size_of_group_to_display;
	
	      var isFirst = peopleAmount === 1 ? true : false,
	          isLessThanMax = peopleAmount <= peopleAmountMax ? true : false;
	
	      if (!isFirst && isLessThanMax && !this.data.is_in_welcome_range) {
	        this.set({
	          is_in_welcome_range: true
	        });
	      } else if ((isFirst || !isLessThanMax) && this.data.is_in_welcome_range) {
	        this.set({
	          is_in_welcome_range: false
	        });
	      }
	    }
	  }, {
	    key: 'verifyOTOChats',
	    value: function verifyOTOChats() {
	      var _this3 = this;
	
	      if (_.size(this.data.activeRooms) > 0) {
	        _.forOwn(this.data.activeRooms, function (room, jid) {
	          if (_utils2.default.jid.is_private_chat(jid)) {
	            // Close OTO chats when user is not in the roster
	            if (!_this3.data.roster[jid]) {
	              _app_dispatcher2.default.dispatch('close-room', {
	                jid: jid
	              });
	            }
	          }
	        });
	      }
	    }
	  }, {
	    key: 'handleConfigChange',
	    value: function handleConfigChange(data) {
	      var config = _.mergeWith(this.data.config, data, function (item1, item2, key) {
	        if (key === _preferences_keys2.default.AUTO_JOIN) {
	          return item2;
	        }
	      });
	      this.set({ config: config });
	
	      // TEMP -------
	      this.handleHCInit(config, true);
	      // END TEMP ---
	    }
	  }, {
	    key: 'resetFilesAndLinksFetching',
	    value: function resetFilesAndLinksFetching() {
	      for (var jid in this.data.activeRooms) {
	        if (this.data.activeRooms[jid]) {
	          this.data.activeRooms[jid].files_fetching = false;
	          this.data.activeRooms[jid].links_fetching = false;
	        }
	      }
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = (0, _getIterator3.default)(this.local.closedChats), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var _jid = _step.value;
	
	          if (this.data.allRooms[_jid]) {
	            this.data.allRooms[_jid].files_fetching = false;
	            this.data.allRooms[_jid].links_fetching = false;
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'fetchReadState',
	    value: function fetchReadState() {
	      _logger2.default.log('[ReadState] Fetching readstate data.');
	      _app_dispatcher2.default.dispatch('DAL:fetch-readstate');
	    }
	  }, {
	    key: 'refetchReadState',
	    value: function refetchReadState() {
	      if (this.local.clearUnreadCounts) {
	        this._clearPendingReadstateData();
	      }
	      this.fetchReadState();
	    }
	  }, {
	    key: 'handleReadState',
	    value: function handleReadState(err, data) {
	      var _this4 = this;
	
	      var activeRooms = this.data.activeRooms;
	
	      if (err || !Array.isArray(data)) {
	        _logger2.default.warn('[ReadState] Error fetching readstate. Reason:', err, data);
	        this._resetPendingReadstateData();
	        return;
	      }
	
	      _logger2.default.log('[ReadState] Received readstate data for ' + data.length + ' rooms:', _.map(data, 'xmppJid'));
	      _.forEach(data, function (chat) {
	        var jid = chat.xmppJid;
	
	        // Only remove rooms from readstate if the activeRooms object is populated
	        // and the room is not present in it.
	        if (!_.isEmpty(activeRooms) && !activeRooms[jid]) {
	          _logger2.default.debug('[ReadState] Removing inactive room:', jid);
	          _this4._removeReadState(jid);
	          return;
	        }
	
	        var roomDefaults = _.pick(_this4.getRoomDefaults(), 'unreadCount', 'unreadMentionCount', 'unreadMentionJustMeCount', 'unreadCountTemp', 'hasMention'),
	            roomData = _.pick(activeRooms[jid], 'unreadCount', 'unreadMentionCount', 'unreadMentionJustMeCount', 'unreadCountTemp', 'hasMention'),
	            update = {
	          isUpdatingUnreadCount: false,
	          last_read_message: {
	            mid: chat.mid,
	            timestamp: Number(chat.timestamp)
	          }
	        };
	
	        _.assign(update, roomDefaults, roomData);
	
	        if ('unreadCount' in chat) {
	          var unreadCount = chat.unreadCount.count || 0,
	              mentionCount = chat.unreadCount.mentions || 0,
	              hasMention = chat.unreadCount.includesMention;
	
	          update.unreadCount = unreadCount + update.unreadCountTemp;
	          update.unreadCountTemp = update.unreadCount;
	
	          if (update.unreadCount && _utils2.default.jid.is_room(jid)) {
	            update.hasMention = hasMention || update.hasMention;
	
	            if (update.hasMention) {
	              update.unreadMentionCount = mentionCount;
	
	              // Readstate doesn't provide a breakdown by mention type. We know the the total number
	              // of unread mentions but not how many of those are of the  @all or @here variety vs a
	              // direct mention. Here we are setting the unreadMentionJustMeCount property to one to
	              // indicate that there might be a notification-worthy unread message. Which is better
	              // than leaving it set to zero.
	              update.unreadMentionJustMeCount = 1;
	            }
	          }
	
	          _this4.local.clearUnreadCounts = true;
	        }
	
	        _.assign(activeRooms[jid], update);
	      });
	
	      this._resetPendingReadstateData();
	      this.handleChatsAbsentFromReadState(data.map(function (room) {
	        return room.xmppJid;
	      }));
	      this.set('activeRooms', activeRooms);
	
	      _app_dispatcher2.default.dispatch('readstate-received');
	    }
	  }, {
	    key: '_clearPendingReadstateData',
	    value: function _clearPendingReadstateData() {
	
	      _.forEach(this.data.activeRooms, function (room) {
	        room.unreadCountTemp = 0;
	        room.isUpdatingUnreadCount = true;
	      });
	      this.set('activeRooms', this.data.activeRooms);
	    }
	  }, {
	    key: '_resetPendingReadstateData',
	    value: function _resetPendingReadstateData() {
	
	      _.forEach(this.data.activeRooms, function (room) {
	        room.unreadCountTemp = room.unreadCount;
	        room.isUpdatingUnreadCount = false;
	      });
	      this.set('activeRooms', this.data.activeRooms);
	    }
	  }, {
	    key: 'handleChatsAbsentFromReadState',
	    value: function handleChatsAbsentFromReadState(rooms) {
	      for (var jid in this.data.activeRooms) {
	        var chat = this.data.activeRooms[jid];
	
	        if (chat && _utils2.default.jid.is_chat(jid) && rooms.indexOf(jid) === -1) {
	          _logger2.default.debug('[ReadState] Adding active room:', jid);
	          this.getLastMessageForChat(chat);
	        }
	      }
	    }
	  }, {
	    key: 'getLastMessageForChat',
	    value: function getLastMessageForChat(chat) {
	      var jid = chat.jid,
	          type = _utils2.default.jid.is_private_chat(jid) ? 'user' : 'room',
	          id = _utils2.default.jid.is_private_chat(jid) ? _utils2.default.jid.user_id(jid) : chat.id,
	          data = {
	        jid: jid,
	        path: {
	          type: type,
	          identifier: id
	        }
	      };
	
	      if (id) {
	        _app_dispatcher2.default.dispatch('API:fetch-last-message', data, this.addChatToReadState.bind(this));
	      } else {
	        this._updateReadState({ jid: data.jid });
	      }
	    }
	  }, {
	    key: 'getLastClosedChat',
	    value: function getLastClosedChat() {
	      var _this5 = this;
	
	      this.local.closedChats = _.filter(this.local.closedChats, function (jid) {
	        return _utils2.default.jid.is_room(jid) ? jid in _this5.data.allRooms : jid in _this5.data.roster;
	      });
	      return this.local.closedChats.shift();
	    }
	  }, {
	    key: 'addChatToReadState',
	    value: function addChatToReadState(data) {
	      var msg = _.get(data, 'items[0]', {}),
	          ts = _utils2.default.getTimestampFromIsoDate(msg.date),
	          chat = this.data.activeRooms[data.jid];
	
	      chat.most_recent_message = {
	        mid: msg.id,
	        timestamp: ts
	      };
	      chat.last_read_message = (0, _extends3.default)({}, chat.most_recent_message);
	      this.set('activeRooms', this.data.activeRooms);
	
	      this._updateReadState({
	        jid: data.jid,
	        mid: msg.id,
	        timestamp: ts
	      });
	    }
	  }, {
	    key: 'resetReadStateCounts',
	    value: function resetReadStateCounts(chats) {
	      var _this6 = this;
	
	      _logger2.default.log('[ReadState] Marking chats as read', chats.map(function (chat) {
	        return chat.jid;
	      }));
	
	      _.forEach(chats, function (chat) {
	        if (chat.unreadCount) {
	          _this6._clearUnreadCountForChat(chat.jid);
	          _this6.getLastMessageForChat(chat);
	        }
	      });
	    }
	
	    /**
	     * Gets the info for the room that is named after this group instance
	     *
	     * @returns {Object} roomInfo the room info object
	     * @returns {String} roomInfo.jid the jid of the room
	     * @returns {Object} roomInfo.room the room object if this room exists, or undefined if not
	     */
	
	  }, {
	    key: 'getGroupInstanceRoomInfo',
	    value: function getGroupInstanceRoomInfo() {
	      var conf = this.data.conference_server,
	          groupName = this.data.group_name,
	          groupId = this.data.group_id,
	          jid = _utils2.default.jid.build_group_jid(groupName, groupId, conf);
	
	      return {
	        jid: jid,
	        room: this.data.allRooms[jid]
	      };
	    }
	  }, {
	    key: 'onBoardNewUser',
	    value: function onBoardNewUser(activeSize) {
	      // Fixes a bug for GROW-1687
	      // we may consider removing when that experiment is complete
	      var groupInstanceRoomInfo = this.getGroupInstanceRoomInfo(),
	          room = groupInstanceRoomInfo.room;
	
	      if (room && room.privacy === "public") {
	        if (activeSize === 0) {
	          _app_dispatcher2.default.dispatch("set-route", {
	            jid: groupInstanceRoomInfo.jid
	          });
	        }
	      } else {
	        _app_dispatcher2.default.dispatch("set-route", {
	          jid: 'lobby'
	        });
	      }
	    }
	  }, {
	    key: 'addChangeHandlers',
	    value: function addChangeHandlers() {
	      var _this7 = this;
	
	      _.map(this.data, function (obj, key) {
	        _this7.on('change:' + key, function (changeset) {
	          _app_dispatcher2.default.dispatch('updated:' + key, changeset);
	        });
	      });
	    }
	  }, {
	    key: 'handleOpenRoom',
	    value: function handleOpenRoom(data) {
	      var jid = _utils2.default.jid.bare_jid(data.jid || data.from);
	
	      if (_utils2.default.jid.is_private_chat(jid)) {
	        this.joinPrivateChat(jid, _utils2.default.jid.user_id(jid));
	        return;
	      }
	
	      var room = _utils2.default.fetch(this.data.allRooms[jid], {}),
	          dontSelectRoom = _.get(data, "dontSelectRoom", false);
	
	      room = _.assign({}, this.getRoomDefaults(), room, {
	        presence: _.cloneDeep(this.getRoomDefaults().presence),
	        type: 'groupchat',
	        jid: jid
	      });
	      this.data.activeRooms[jid] = room;
	
	      // If the room is opening as the result of an invite, fetch the
	      // latest message from the API in order to start tracking readstate
	      if (dontSelectRoom || room.jid !== this.data.active_chat) {
	        this.getLastMessageForChat(room);
	      }
	
	      this.set({
	        activeRooms: this.data.activeRooms,
	        active_chat: dontSelectRoom ? this.data.active_chat : jid
	      });
	
	      this._clearUnreadCountForChat(jid);
	    }
	  }, {
	    key: 'handleJoinRoom',
	    value: function handleJoinRoom(_ref3) {
	      var _this8 = this;
	
	      var roomName = _ref3.room;
	
	
	      var canBeUser = !roomName.indexOf('@');
	
	      if (!roomName || roomName === "@") {
	        return;
	      }
	
	      var chats = void 0;
	
	      if (canBeUser) {
	        (function () {
	          var mention = roomName.substr(1);
	          chats = _.filter(_this8.data.roster, function (user) {
	            return user.mention_name && user.mention_name === mention;
	          });
	        })();
	      }
	
	      if (_.isEmpty(chats)) {
	        (function () {
	          var roomNameLowerCase = roomName.toLowerCase();
	          chats = _.filter(_this8.data.allRooms, function (room) {
	            return room.name && room.name.toLowerCase() === roomNameLowerCase;
	          });
	          if (chats.length > 1) {
	            chats = _.filter(chats, function (room) {
	              return room.name && room.name === roomName;
	            });
	          }
	        })();
	      }
	
	      var chat = _.head(chats);
	
	      if (chat) {
	        if (chat.jid !== this.data.active_chat) {
	          _app_dispatcher2.default.dispatch('set-route', { jid: chat.jid });
	        }
	      } else {
	        _app_dispatcher2.default.dispatch('show-flag', {
	          type: "warning",
	          close: "auto",
	
	          body: (canBeUser ? "User" : "Room") + ' "' + roomName + '" not found.'
	        });
	      }
	    }
	
	    /**
	     * We limit room presences to a minimal number initally and only consider the
	     * participants list "fully initialized" in one of these cases:
	     *
	     * - All participants have been received.
	     * - The HC server doesn't support participant limiting.
	     * - Current user is a guest.
	     * - Chat type is a 1-1
	     *
	     * This is for the purpose of mitigating a flood of room presences on initial
	     * join of a room with many occupants.
	     */
	
	  }, {
	    key: 'initializeRoomParticipants',
	    value: function initializeRoomParticipants(roomJid) {
	      var room = this.data.activeRooms[roomJid];
	      var includeOffline = _utils2.default.jid.is_private_room(room.privacy);
	
	      if (room.participants_fully_initialized) {
	        return;
	      }
	
	      if (!room.roster_size || room.roster_size <= _app_config2.default.initial_room_participants_limit) {
	        this.setRoomParticipantsFullyInitialized(room);
	      } else {
	        if (this.data.active_chat === roomJid) {
	          this.debouncedFetchRoomParticipantsFromAPI(room, includeOffline);
	        }
	      }
	    }
	  }, {
	    key: 'handleJoinedRooms',
	    value: function handleJoinedRooms(rooms) {
	      var _this9 = this;
	
	      _utils2.default.toArray(rooms).forEach(function (room) {
	        var activeRoom = _this9.data.activeRooms[room.jid];
	
	        if (activeRoom) {
	          activeRoom.show_join_leave_messages = true;
	          activeRoom.roster_size = room.roster_size || 0;
	          activeRoom.topic = room.topic;
	          _this9.initializeRoomParticipants(room.jid);
	        }
	      });
	    }
	  }, {
	    key: 'handleOfflineChatsChanges',
	    value: function handleOfflineChatsChanges(newJids, activeJids, lastSavedJids, activeChat) {
	      var modifiedOnOtherDevices = _.xor(lastSavedJids, newJids);
	
	      var _$partition = _.partition(modifiedOnOtherDevices, function (jid) {
	        return _.includes(lastSavedJids, jid);
	      });
	
	      var _$partition2 = (0, _slicedToArray3.default)(_$partition, 2);
	
	      var closedOnOtherDevices = _$partition2[0];
	      var openedOnOtherDevices = _$partition2[1];
	
	
	      var modifiedOffline = _.xor(lastSavedJids, activeJids);
	
	      var _$partition3 = _.partition(modifiedOffline, function (jid) {
	        return _.includes(lastSavedJids, jid);
	      });
	
	      var _$partition4 = (0, _slicedToArray3.default)(_$partition3, 2);
	
	      var closedOffline = _$partition4[0];
	      var openedOffline = _$partition4[1];
	
	
	      var opened = _.union(openedOnOtherDevices, openedOffline);
	      var closed = _.union(closedOnOtherDevices, closedOffline);
	
	      _logger2.default.type('application-store:handle-offline-chats-changes').log({ opened: opened, closed: closed });
	
	      // There is no need to close rooms of guest user because he/she has only one active room
	      if (!_configuration_store2.default.isGuest()) {
	        this._closeRooms(closed);
	      }
	
	      this._openRooms(opened, activeChat);
	    }
	
	    /**
	     * Dispatches closing room event for all rooms defined in collection sent via parameter
	     * @param closed
	     * @private
	     */
	
	  }, {
	    key: '_closeRooms',
	    value: function _closeRooms(rooms) {
	      _.each(rooms, function (jid) {
	        _app_dispatcher2.default.dispatch('close-room', {
	          jid: jid,
	          type: _utils2.default.room.detect_chat_type(jid)
	        });
	      });
	    }
	
	    /**
	     * Dispatches opening room event for all rooms defined in collection sent via parameter
	     * @param opened
	     * @private
	     */
	
	  }, {
	    key: '_openRooms',
	    value: function _openRooms(rooms, activeChat) {
	      _.each(rooms, function (jid) {
	        _app_dispatcher2.default.dispatch('open-room', {
	          jid: jid,
	          dontSelectRoom: true
	        });
	        _app_actions2.default.restoreRoomOrder(jid);
	        if (jid === activeChat) {
	          _app_actions2.default.navigateToChat(jid);
	        }
	        if (_utils2.default.jid.is_private_chat(jid)) {
	          _app_dispatcher2.default.dispatch('request-profile', jid);
	        }
	      });
	    }
	  }, {
	    key: 'handleHCInit',
	    value: function handleHCInit(data) {
	      var _this10 = this;
	
	      var isReconnect = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      var uid,
	          roomsArr = _utils2.default.toArray(_.uniq(_.cloneDeep(_preferences_store2.default.getAutoJoinRooms()))),
	          rooms = {},
	          roster = {};
	
	      var autoJoin = _.get(data, ['preferences', 'autoJoin'], false),
	          isFirstLogin = autoJoin && autoJoin.length < 2 && this._isFirstLogin(data.preferences),
	          chatToFocus = isFirstLogin ? _.get(data, 'preferences.chatToFocus') : _preferences_store2.default.getChatToFocus(),
	          newJids = _.map(roomsArr, 'jid'),
	          activeJids = _.keys(this.data.activeRooms),
	          newAndActiveJids = newJids.concat(activeJids),
	          oldActiveChat = this.data.active_chat;
	
	      _logger2.default.type('application-store:handle-hc-init').log('isFirstLogin:', isFirstLogin);
	      _logger2.default.type('application-store:handle-hc-init').log('chatToFocus:', chatToFocus);
	
	      if (!isFirstLogin || data.is_guest) {
	        if (this.local.shouldReconcileAutoJoin) {
	          (function () {
	            _this10.local.shouldReconcileAutoJoin = false;
	            _logger2.default.type('application-store:handle-hc-init').log('autoJoin reconciling started.');
	            var lastSavedJids = _.map(_this10.local.lastSavedAutoJoin, 'jid');
	            if (_this10.data.config.auth_method !== 'nonce') {
	              _app_dispatcher2.default.registerOnce('after:configuration-change', function () {
	                _this10.handleOfflineChatsChanges(newJids, activeJids, lastSavedJids, oldActiveChat);
	              });
	            } else {
	              _app_dispatcher2.default.registerOnce('strophe-reconnected', function () {
	                _this10.handleOfflineChatsChanges(newJids, activeJids, lastSavedJids, oldActiveChat);
	              });
	            }
	          })();
	        } else {
	          _logger2.default.type('application-store:handle-hc-init').log('autoJoin reconciling skipped.');
	        }
	
	        _.forEach(roomsArr, function (room) {
	          room.type = _utils2.default.jid.is_room(room.jid) ? 'groupchat' : 'chat';
	          if (room.type === 'chat') {
	            room.participants_fully_initialized = true;
	            uid = _utils2.default.jid.user_id(room.jid);
	            room.id = uid;
	            if (!_.includes(_this10.local.participants, uid)) {
	              _this10.local.participants.push(uid);
	            }
	            if (!_.includes(_this10.local.profile_jids, room.jid)) {
	              _this10.local.profile_jids.push(room.jid);
	            }
	          }
	          if (data.is_guest) {
	            room.participants_fully_initialized = true;
	          }
	
	          var local_active_room = _.get(_this10.data, 'activeRooms[\'' + room.jid + '\']', {});
	          var local_room = _.get(_this10.data, 'allRooms[\'' + room.jid + '\']', {});
	
	          // not all clients save autoJoin list with names
	          if (!room.name) {
	            room.name = local_active_room.name || local_room.name;
	            _logger2.default.warn('Room name isn\'t defined in the autoJoin list. Room jid: ' + room.jid);
	          }
	
	          rooms[room.jid] = _.merge(_this10.getRoomDefaults(), _.omit(local_active_room, ['name']), room);
	        });
	      }
	
	      var current_user = _.pick(data, ['user_jid', 'jid', 'user_id', 'user_name', 'mention', 'title', 'photo_large', 'photo_small', 'email', 'is_admin', 'is_guest', 'guest_key', 'presence', 'user_created_utc']);
	      current_user.user_jid = current_user.user_jid || current_user.jid;
	      current_user.is_guest = current_user.is_guest ? true : false;
	
	      if (_preferences_store2.default.getAutoJoinRooms() !== undefined) {
	        if (current_user.is_guest) {
	          this.data.active_chat = data.room_jid;
	          this.local.active_type = 'groupchat';
	        } else if (isFirstLogin || !chatToFocus || newAndActiveJids.length && newAndActiveJids.indexOf(chatToFocus) === -1) {
	          this.data.active_chat = 'lobby';
	        } else {
	          this.data.active_chat = chatToFocus;
	          this.local.active_type = /@chat/.test(chatToFocus) ? 'chat' : 'groupchat';
	        }
	      }
	
	      if (_utils2.default.jid.is_private_chat(this.data.active_chat)) {
	        _app_dispatcher2.default.dispatch('request-profile', this.data.active_chat);
	      }
	
	      if (_utils2.default.jid.is_chat(this.data.active_chat) && _.isEmpty(rooms)) {
	        rooms[this.data.active_chat] = _.merge(this.getRoomDefaults(), {
	          jid: this.data.active_chat,
	          type: _utils2.default.jid.is_room(this.data.active_chat) ? 'groupchat' : 'chat'
	        }, this.data.allRooms[this.data.active_chat]);
	        _preferences_store2.default.setAutoJoinRooms([{
	          jid: rooms[this.data.active_chat].jid,
	          name: rooms[this.data.active_chat].name
	        }]);
	      }
	
	      this.set('ignoreAddIntegrationsGlance', _.get(data, 'preferences.ignoreAddIntegrationsGlance'));
	
	      if (!isReconnect) {
	        roster[current_user.user_jid] = _.assign(this.getRosterDefaults(), { presence: { show: 'chat', status: '' } });
	        if (current_user.is_guest) {
	          roster[data.user_jid]['mention_name'] = current_user.mention;
	        }
	        if (rooms[current_user.user_jid]) {
	          rooms[current_user.user_jid].presence = current_user.presence = {
	            show: 'chat',
	            status: ''
	          };
	        }
	      }
	
	      var meDefaultMentions = _.reduce(_app_config2.default.core_mentions, function (acc, core_mention) {
	        if (!core_mention.isUser) {
	          acc = [].concat(acc, core_mention.mention_name);
	        }
	        return acc;
	      }, []);
	
	      var meDefaultMentionsRegex = meDefaultMentions ? '|' + meDefaultMentions.join('|') + '|' : '';
	      this.data.mentionRegexMe = new RegExp('(?=[^\\w]|^)@(' + _utils2.default.escapeRegEx(data.mention) + meDefaultMentionsRegex + '"' + _utils2.default.escapeRegEx(data.user_name) + '")(?=[^\\w]|$)', "ig");
	      this.data.mentionRegexJustMe = new RegExp('(?=[^\\w]|^)@(' + _utils2.default.escapeRegEx(data.mention) + "|" + '"' + _utils2.default.escapeRegEx(data.user_name) + '")(?=[^\\w]|$)', "ig");
	
	      this.data.activeRooms = rooms;
	      _.merge(this.data, {
	        current_user: current_user,
	        roster: roster,
	        smileys: _utils2.default.emoticons.addSmileys(data.emoticons || [])
	      });
	
	      var features = data.features || this.data.features;
	
	      this.setActiveGuestUserRegex();
	
	      var dataForUpdate = {
	        current_user: this.data.current_user,
	        activeRooms: this.data.activeRooms,
	        roster: this.data.roster,
	        smileys: this.data.smileys,
	        chat_server: data.chat_server,
	        conference_server: data.conference_server,
	        api_host: data.api_host,
	        web_server: data.web_server,
	        group_name: data.group_name,
	        group_id: data.group_id,
	        features: features,
	        permissions: data.perms || {}
	      };
	
	      if (this.data.active_chat) {
	        if (!this.data.activeRooms[this.data.active_chat]) {
	          this.data.active_chat = 'lobby';
	        }
	        dataForUpdate.active_chat = this.data.active_chat;
	      }
	
	      this.set(dataForUpdate);
	      if (!this.local.initialized) {
	        this.local.lastSavedAutoJoin = roomsArr;
	      }
	      this.local.initialized = true;
	      this.updatePresenceProcessor();
	    }
	
	    /*
	     * Populate what we know about the autoJoin rooms from the startup IQ
	     * into the allRooms & activeRooms lists. This way, everything on screen
	     * is sufficiently populated when the preloader drops. See HC-29452
	     */
	
	  }, {
	    key: 'handleStartupIQAutoJoin',
	    value: function handleStartupIQAutoJoin(autoJoin) {
	      var _this11 = this;
	
	      autoJoin.forEach(function (item) {
	        if (_utils2.default.jid.is_room(item.jid)) {
	
	          var owner = _utils2.default.jid.user_id(_.get(item, 'x.owner', null));
	          var room = _.merge(_this11.getRoomDefaults(), _this11.data.allRooms[item.jid], _this11.data.activeRooms[item.jid], item.x, {
	            jid: item.jid,
	            type: 'groupchat',
	            owner: owner
	          });
	
	          if (!_.includes(room.admins, owner)) {
	            room.admins.push(owner);
	          }
	
	          _this11.data.allRooms[item.jid] = _.cloneDeep(room);
	          _this11.data.activeRooms[item.jid] = _.cloneDeep(room);
	        }
	      });
	    }
	  }, {
	    key: 'handleServerData',
	    value: function handleServerData(data) {
	      var _this12 = this;
	
	      _.map(this.server_data_callbacks, function (cb, evt) {
	        var thisData = data[evt];
	        if (thisData) {
	          cb(thisData, _this12, data.cached);
	        }
	      });
	    }
	  }, {
	    key: 'unsubscribeFromStanzas',
	    value: function unsubscribeFromStanzas(type) {
	      var _this13 = this;
	
	      _utils2.default.toArray(type).forEach(function (stanza) {
	        _this13.server_data_callbacks[stanza] = function (stz) {
	          _.noop(stz);
	        };
	      });
	    }
	  }, {
	    key: 'handleIQ',
	    value: function handleIQ(iq, store, fromCache) {
	      store.iqProcessor.handleIQ.apply(store.iqProcessor, arguments);
	    }
	  }, {
	    key: 'handleInviteMessage',
	    value: function handleInviteMessage(message) {
	      var fromRoom = _utils2.default.jid.bare_jid(message.from),
	          invite = _.get(message, 'x[0].invite', {}),
	          reason = invite.reason || '',
	          fromUser = invite.from || '',
	          user_jid = _utils2.default.jid.bare_jid(fromUser),
	          room = _.omit(_.get(message, 'x[1]'), 'xmlns'),
	          roomName = room.name || '';
	
	      if (!this.data.allRooms[fromRoom]) {
	        this.data.allRooms[fromRoom] = _.assign(this.getRoomDefaults(), { jid: fromRoom }, room);
	      }
	
	      var inviteFromName = _.get(this.data, 'roster["' + user_jid + '"].name', '');
	      if (_utils2.default.jid.is_room(fromUser)) {
	        inviteFromName = _utils2.default.jid.resource(fromUser);
	      }
	
	      _app_dispatcher2.default.dispatch('open-room', {
	        jid: fromRoom,
	        dontSelectRoom: true
	      });
	
	      _app_dispatcher2.default.dispatch('show-modal-dialog', {
	        dialog_type: 'room-invite-dialog',
	        dialog_data: {
	          bgDismiss: false,
	          room_name: roomName,
	          room_jid: fromRoom,
	          from_user: inviteFromName,
	          should_queue: true,
	          reason: reason
	        }
	      });
	
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: "hipchat.client.invite.room",
	        properties: {
	          isFromDory: inviteFromName === 'HipChat'
	        }
	      });
	    }
	  }, {
	    key: 'handleRoomInviteAccepted',
	    value: function handleRoomInviteAccepted(jid) {
	      if (this.data.allRooms[jid]) {
	        this.handleNewRoom(this.data.allRooms[jid]);
	        _app_dispatcher2.default.dispatch('set-route', { jid: jid });
	      }
	    }
	  }, {
	    key: 'handlePrivateChatInvite',
	    value: function handlePrivateChatInvite(message) {
	      var jid, uid;
	      if (message.from === this.data.current_user.user_jid) {
	        jid = _utils2.default.jid.bare_jid(message.to);
	      } else {
	        jid = _utils2.default.jid.bare_jid(message.from);
	      }
	      uid = _utils2.default.jid.user_id(jid);
	      this.joinPrivateChat(jid, uid);
	    }
	  }, {
	    key: 'handlePresence',
	    value: function handlePresence(presences, store) {
	      store.presenceProcessor.handlePresence(presences);
	    }
	  }, {
	    key: 'handleMissedCall',
	    value: function handleMissedCall(msg) {
	      this.handleIncomingMessages(msg, this);
	    }
	  }, {
	    key: 'handleCallDeclined',
	    value: function handleCallDeclined(msg) {
	      this.handleIncomingMessages(msg, this);
	    }
	  }, {
	    key: 'handleIncomingMessages',
	    value: function handleIncomingMessages(messages, store) {
	      store.set({
	        rawMessages: messages
	      });
	      var messagesObj = store.messageProcessor.processMessages(messages);
	      messagesObj = _.groupBy(messagesObj, 'room');
	      store.set({
	        newMessages: messagesObj
	      });
	      store._handleNewMessageUpdate(messagesObj);
	    }
	  }, {
	    key: 'handleSendMessage',
	    value: function handleSendMessage(data) {
	      var activeChat = _utils2.default.jid.is_chat(data.jid) ? this.data.activeRooms[data.jid] : null,
	          currentTime = Date.now() / 1000;
	      if (activeChat) {
	        // user's local time is incorrect
	        if (_.get(activeChat, 'most_recent_message.timestamp', 0) > currentTime) {
	          data.time = activeChat.most_recent_message.timestamp + 1;
	        } else {
	          data.time = currentTime;
	        }
	        var msg = this.messageProcessor.processSentMessage(data);
	        this.local.user_state = 'active';
	        this.local.sent_msg_ids.push(data.id.toString());
	        this.set({
	          newMessages: _.groupBy(msg, 'room')
	        });
	      }
	    }
	  }, {
	    key: '_handleNewMessageUpdate',
	    value: function _handleNewMessageUpdate(messageData) {
	      var _this14 = this;
	
	      var activeChat = _utils2.default.jid.is_chat(this.data.active_chat) ? this.data.activeRooms[this.data.active_chat] : null,
	          hasChanges = false;
	
	      _.forEach(messageData, function (messages, jid) {
	        _.forEach(_this14.data.activeRooms, function (chat) {
	          if (chat.jid !== jid) {
	            return;
	          }
	
	          _.forEach(messages, function (msg) {
	            _this14._updateMostRecentMessage(chat, msg);
	            if (msg.is_echo) {
	              _this14._updateReadStateForChat(chat);
	            } else if (_this14._msgIsTopicChange(msg)) {
	              return;
	            }
	            hasChanges = true;
	
	            if (_this14._msgShouldNotUpdateBadge(msg)) {
	              return;
	            }
	
	            if (chat && !msg.is_history_message && msg.type !== 'user_state') {
	              ++chat.unreadCount;
	              ++chat.unreadCountTemp;
	
	              if (_utils2.default.isFormattedMessage(msg)) {
	                return;
	              }
	
	              if (_this14._shouldUpdateMentionFromCard(_this14.data.mentionRegexMe, msg) || msg.body && msg.body.search(_this14.data.mentionRegexMe) !== -1 || _utils2.default.jid.is_private_chat(chat.jid)) {
	                chat.hasMention = true;
	                ++chat.unreadMentionCount;
	                if (_this14._shouldUpdateMentionFromCard(_this14.data.mentionRegexJustMe, msg) || msg.body && msg.body.search(_this14.data.mentionRegexJustMe) !== -1) {
	                  ++chat.unreadMentionJustMeCount;
	                }
	                return;
	              }
	            }
	          });
	        });
	      });
	
	      if (activeChat && this._msgShouldUpdateReadState(activeChat.most_recent_message)) {
	        this._updateReadStateForActiveChat();
	        hasChanges = true;
	      }
	
	      if (hasChanges) {
	        this.set('activeRooms', this.data.activeRooms);
	        this._updateTotalUnreadCount();
	      }
	    }
	  }, {
	    key: '_shouldUpdateMentionFromCard',
	    value: function _shouldUpdateMentionFromCard(regex, msg) {
	      return _.has(msg, 'card.activity.html') && msg.card.activity.html.indexOf("hc-mention-user") !== -1 && regex.test(msg.card.activity.html);
	    }
	  }, {
	    key: '_updateMostRecentMessage',
	    value: function _updateMostRecentMessage(chat, msg) {
	      var most_recent = chat.most_recent_message || {};
	
	      if (msg.is_presence_message || !_utils2.default.validateMID(msg.mid)) {
	        return;
	      }
	
	      if (!most_recent.timestamp || msg.time > most_recent.timestamp) {
	        chat.most_recent_message = {
	          mid: msg.mid,
	          timestamp: msg.time
	        };
	      }
	    }
	  }, {
	    key: '_msgShouldUpdateReadState',
	    value: function _msgShouldUpdateReadState(msg) {
	      var user_jid = this.data.current_user.user_jid,
	          user = this.data.roster[user_jid],
	          user_presence = user ? user.presence : null;
	
	      var isAppFocused = this.local.windowFocused,
	          isChat = _utils2.default.jid.is_chat(this.data.active_chat),
	          isSender = msg ? user_jid === msg.sender : false,
	          isAvailable = user_presence && user_presence.show !== _presence2.default.IDLE;
	
	      return isAppFocused && isChat && (isSender || isAvailable);
	    }
	  }, {
	    key: '_msgIsTopicChange',
	    value: function _msgIsTopicChange(msg) {
	      // if subject prop exists this is a room topic change
	      return !!msg.subject;
	    }
	  }, {
	    key: '_updateReadStateForActiveChat',
	    value: function _updateReadStateForActiveChat() {
	      var ac = this.data.active_chat;
	      if (ac && _utils2.default.jid.is_chat(ac) && this.data.activeRooms[ac]) {
	        this._updateReadStateForChat(this.data.activeRooms[ac]);
	      }
	    }
	  }, {
	    key: '_updateReadStateForChat',
	    value: function _updateReadStateForChat(chat) {
	      var most_recent = chat.most_recent_message,
	          last_read = chat.last_read_message,
	          data = {
	        jid: chat.jid
	      };
	
	      // if we have both a most_recent_message and a last_read_message, and the timestamp
	      //   of the last_read_message is newer, there's nothing to do.
	      if (most_recent && last_read && most_recent.timestamp <= last_read.timestamp) {
	        return;
	      }
	
	      // if we don't have a most_recent_message and a last_read_message, the chat is empty
	      //   but we need to inform the readstate endpoint to start tracking unread messages.
	      if (!most_recent && !last_read) {
	        chat.last_read_message = {};
	        this._updateReadState(data);
	        return;
	      }
	
	      // if we don't have a most_recent_message but the last_read_message is truthy, we've
	      //   already opened this chat before, so there's nothing to do.
	      if (!most_recent && last_read) {
	        return;
	      }
	
	      // if we have a newer most_recent_message, we need to update readstate
	      //   with the newer message
	      chat.last_read_message = (0, _extends3.default)({}, most_recent);
	      data.mid = most_recent.mid;
	      data.timestamp = most_recent.timestamp;
	
	      this._updateReadState(data);
	    }
	  }, {
	    key: '_updateReadState',
	    value: function _updateReadState(data) {
	      if (data && _utils2.default.jid.is_chat(data.jid)) {
	        _app_dispatcher2.default.dispatch('DAL:update-readstate', data);
	      }
	    }
	  }, {
	    key: '_removeReadState',
	    value: function _removeReadState(jid) {
	      if (_utils2.default.jid.is_chat(jid)) {
	        _app_dispatcher2.default.dispatch('DAL:remove-readstate', { jid: jid });
	      }
	    }
	  }, {
	    key: '_clearUnreadCountForChat',
	    value: function _clearUnreadCountForChat(jid) {
	      var result = this._clearUnreadCount(jid);
	
	      if (result) {
	        this.set('activeRooms', this.data.activeRooms);
	        this._updateTotalUnreadCount();
	      }
	    }
	  }, {
	    key: '_clearUnreadCount',
	    value: function _clearUnreadCount(jid) {
	      if (!_utils2.default.jid.is_chat(jid)) {
	        return false;
	      }
	
	      var chat = this.data.activeRooms[jid],
	          room = this.data.allRooms[jid];
	
	      if (chat) {
	        var defaults = _.pick(this.getRoomDefaults(), 'unreadCount', 'unreadCountTemp', 'unreadMentionCount', 'unreadMentionJustMeCount', 'hasMention'),
	            exists = _.pick(chat, 'unreadCount', 'unreadCountTemp', 'unreadMentionCount', 'unreadMentionJustMeCount', 'hasMention');
	
	        if (!_.isEqual(exists, defaults)) {
	          this.data.activeRooms[jid] = _.assign({}, chat, defaults);
	          if (room && _utils2.default.jid.is_room(jid)) {
	            this.data.allRooms[jid] = _.assign({}, room, defaults);
	          }
	          return true;
	        }
	      }
	
	      return false;
	    }
	  }, {
	    key: '_updateTotalUnreadCount',
	    value: function _updateTotalUnreadCount() {
	      var _PreferencesStore$get = _preferences_store2.default.getAll();
	
	      var notifyForRoom = _PreferencesStore$get.notifyForRoom;
	      var notifyForPrivateRoom = _PreferencesStore$get.notifyForPrivateRoom;
	      var notifyForPrivate = _PreferencesStore$get.notifyForPrivate;
	      var notifyForTag = _PreferencesStore$get.notifyForTag;
	      var _PreferencesStore$get2 = _PreferencesStore$get.roomNotificationOverrides;
	      var roomNotificationOverrides = _PreferencesStore$get2 === undefined ? {} : _PreferencesStore$get2;
	
	
	      var perRoomNotificationsEnabled = _.get(this.data.config, 'feature_flags.web_client_per_room_notifications', false);
	      var globalNotificationLevel = _preferences_store2.default.getGlobalNotificationSetting();
	
	      var hasMention = false;
	      var unreadTotal = _.reduce(this.data.activeRooms, function (sum, chat) {
	        var isPrivateChat = _utils2.default.jid.is_private_chat(chat.jid);
	
	        if (isPrivateChat) {
	          if (chat.unreadCount) {
	            hasMention = true;
	          }
	
	          if (notifyForPrivate) {
	            return sum + chat.unreadCount;
	          }
	        } else {
	          //it's groupchat
	          if (chat.hasMention) {
	            hasMention = true;
	          }
	
	          // check using new per-room notification settings
	          if (perRoomNotificationsEnabled) {
	            // check if there is notification level for room or use global level as default
	            var notificationLevel = _.get(roomNotificationOverrides[chat.jid], 'level', globalNotificationLevel);
	
	            switch (notificationLevel) {
	              case "quiet":
	                return sum + chat.unreadMentionJustMeCount;
	              case "normal":
	                return sum + chat.unreadMentionCount;
	              case "loud":
	              default:
	                return sum + chat.unreadCount;
	            }
	          }
	
	          // check using old notification settings
	          if (_utils2.default.jid.is_public_room(chat.privacy)) {
	            if (notifyForRoom) {
	              return sum + chat.unreadCount;
	            } else if (notifyForTag) {
	              return sum + chat.unreadMentionCount;
	            }
	          } else if (_utils2.default.jid.is_private_room(chat.privacy)) {
	            if (notifyForPrivateRoom) {
	              return sum + chat.unreadCount;
	            } else if (notifyForTag) {
	              return sum + chat.unreadMentionCount;
	            }
	          }
	        }
	
	        return sum;
	      }, 0);
	
	      _app_actions2.default.updateTotalUnreadCount(unreadTotal, hasMention);
	    }
	  }, {
	    key: '_msgShouldNotUpdateBadge',
	    value: function _msgShouldNotUpdateBadge(msg) {
	      var xData = _.isArray(msg.x) && msg.x.length ? msg.x[0] : false,
	          doNotNotify = _.get(xData, "notify") === "0";
	
	      return doNotNotify || msg.delay || msg.room === this.data.active_chat && this.local.windowFocused || msg.sender === this.data.current_user.user_name;
	    }
	
	    /*
	     * Only react to chatstate messages when they are sent from ourself.
	     * This happens when:
	     * 1. We're opening/closing a private chat with ourself
	     *   (message.from will be our jid)
	     * 2. We've joined/left a private chat in another open client
	     *   (message.delay.from_jid will exist, and be our jid)
	     */
	
	  }, {
	    key: 'handleChatStateMessage',
	    value: function handleChatStateMessage(data) {
	      var jid = _utils2.default.jid.bare_jid(_.get(data, 'message.from')),
	          chat = this.data.activeRooms[jid],
	          sender = _utils2.default.jid.bare_jid(_.get(data, 'message.delay.from_jid', jid)),
	          uid = _utils2.default.jid.user_id(jid);
	      if (this.data.current_user.user_jid === sender && _utils2.default.jid.is_private_chat(jid)) {
	        if (!chat && data.type === 'active') {
	          this.joinPrivateChat(jid, uid);
	        } else if (chat && data.type === 'gone') {
	          this.handleCloseRoom(jid);
	        }
	      }
	    }
	  }, {
	    key: 'handleConnectionSuccess',
	    value: function handleConnectionSuccess(connection, store) {}
	  }, {
	    key: 'handleEmoticons',
	    value: function handleEmoticons(query, type) {
	      var items = query.item ? _utils2.default.toArray(query.item) : [],
	          emoticons = type === 'result' ? {} : _.cloneDeep(this.data.emoticons.icons);
	
	      emoticons = _utils2.default.emoticons.addBulk(items, emoticons);
	
	      if (query.path_prefix && _utils2.default.emoticons.path_prefix !== query.path_prefix) {
	        _utils2.default.emoticons.path_prefix = query.path_prefix;
	      }
	
	      var oldEmoticons = _.keys(this.data.emoticons.icons).sort(),
	          newEmoticons = _.keys(emoticons).sort(),
	          hasChanges = !_.isEqual(oldEmoticons, newEmoticons);
	
	      if (hasChanges) {
	        this.set({
	          emoticons: {
	            path_prefix: query.path_prefix,
	            icons: emoticons
	          }
	        });
	      }
	
	      if (this.local.emoticons_initialized) {
	        if (hasChanges) {
	          this._replaceEmoticonsIfRequired();
	        }
	      } else {
	        this.local.emoticons_initialized = true;
	      }
	    }
	  }, {
	    key: '_replaceEmoticonsIfRequired',
	    value: function _replaceEmoticonsIfRequired() {
	      if (_preferences_store2.default.shouldReplaceTextEmoticons() && this.data.rawMessages) {
	        this.handleIncomingMessages(this.data.rawMessages, this);
	      }
	    }
	  }, {
	    key: 'handleRoster',
	    value: function handleRoster(roster) {
	      var _this15 = this;
	
	      // roster being object means that this event is that user joined to group and now roster is it's object
	      var newUser = null;
	      if (_.isPlainObject(roster)) {
	        newUser = roster;
	      }
	      var updatedRoster = [],
	          verifyOTOChats = false;
	      _utils2.default.toArray(roster).filter(function (val) {
	        return !!val;
	      }).forEach(function (user) {
	        var id = _.get(user, "id"),
	            jid = _.get(user, "jid");
	        if (_.get(user, "subscription") === "remove" && (jid || id)) {
	          // Handle Deleted User
	          var deleted_user = _.get(_this15.data, 'roster[\'' + jid + '\']') || _.find(_this15.data.roster, { id: id });
	          if (deleted_user) {
	            deleted_user.deleted = true;
	          }
	          jid = jid || deleted_user.jid;
	          _app_dispatcher2.default.dispatch('room-deleted', {
	            jid: jid
	          });
	          verifyOTOChats = true;
	        } else {
	          user.display_name = user.name;
	          user.id = user.id ? user.id : _utils2.default.jid.user_id(user.jid);
	          updatedRoster.push(user);
	        }
	      });
	      this.data.roster = _.omitBy(this.data.roster, function (item) {
	        return item.deleted;
	      });
	      var rosterObj = _.keyBy(updatedRoster, function (user) {
	        if (!_this15.data.roster[user.jid]) {
	          _.assign(user, user.jid === _this15.data.current_user.user_jid ? { presence: { show: 'chat', status: '' } } : _this15.getRosterDefaults());
	        }
	        return user.jid;
	      });
	
	      var oldRosterSize = _.size(this.data.roster),
	          newRosterData = _.merge(this.data.roster, rosterObj),
	          newRosterDataSize = _.size(newRosterData);
	
	      this.set('roster', newRosterData);
	
	      var userJoinedNotificationEnabled = _.get(this.data.config, 'feature_flags.web_client_user_joined_notification', false);
	
	      if (userJoinedNotificationEnabled && newUser && newRosterDataSize > oldRosterSize && newRosterDataSize <= _app_config2.default.max_users_in_group_join_notification) {
	
	        var flagId = 'user-joined-flag-' + _utils2.default.now();
	        _flag_actions2.default.showFlag({
	          id: flagId,
	          type: "success",
	          body: this._flagBodyForUserJoinedEvent(newUser.jid, newUser.display_name, flagId),
	          close: "manual"
	        });
	      }
	
	      this.updateMentionNames();
	      this.updateRosterNames();
	      if (verifyOTOChats) {
	        this.verifyOTOChats();
	      }
	
	      this._handleWelcomeRange(_.toArray(newRosterData).length);
	    }
	  }, {
	    key: '_setRouteToUser',
	    value: function _setRouteToUser(jid, flagId) {
	      return function (e) {
	        e.preventDefault();
	        _app_dispatcher2.default.dispatch("set-route", { jid: jid });
	        _flag_actions2.default.removeFlag(flagId);
	      };
	    }
	  }, {
	    key: '_flagBodyForUserJoinedEvent',
	    value: function _flagBodyForUserJoinedEvent(jid, displayName, flagId) {
	      var _this16 = this;
	
	      return function () {
	        return React.createElement(
	          'div',
	          null,
	          React.createElement('b', { dangerouslySetInnerHTML: { __html: _dialog_strings2.default.user_joined(displayName) } }),
	          React.createElement(
	            'span',
	            null,
	            ' '
	          ),
	          React.createElement(
	            'a',
	            { href: '#', onClick: _this16._setRouteToUser(jid, flagId) },
	            _dialog_strings2.default.user_joined_link
	          )
	        );
	      };
	    }
	  }, {
	    key: 'updateMentionNames',
	    value: function updateMentionNames() {
	      var isGuest = this.data.current_user.is_guest;
	      var mentionNames = _.map(this.data.roster, function (user) {
	        // Skip Guest Users (they do not have a subscription)
	        if ('subscription' in user && !isGuest ||
	        // highlight users mentions in the guest mode
	        !/Guest$/.test(user.mention_name) && isGuest) {
	          return user.mention_name;
	        }
	      });
	
	      mentionNames = _.reject(mentionNames, _.isEmpty);
	
	      var index = mentionNames.indexOf(this.data.current_user.mention);
	      if (index !== -1) {
	        mentionNames.splice(index, 1);
	      }
	      var userMentions = _.filter(_app_config2.default.core_mentions, { isUser: true });
	      var userDefaultMentions = _.map(userMentions, 'mention_name');
	
	      var userDefaultMentionsRegex = userDefaultMentions ? userDefaultMentions.join('|') : '';
	      this.set({
	        mentionRegexUser: new RegExp('(?=[^\\w]|^)@(' + (mentionNames.length ? mentionNames.join('|') + '|' + userDefaultMentionsRegex : userDefaultMentionsRegex) + ')(?=[^\\w]|$)', 'gi')
	      });
	    }
	  }, {
	    key: 'updateGuestMentions',
	    value: function updateGuestMentions(jid) {
	      var _this17 = this;
	
	      var room = this.data.activeRooms[jid],
	          guestMentionNames,
	          guestRegex;
	      if (room && _.get(room, "participants.guests")) {
	        guestMentionNames = _.map(room.participants.guests, function (guest_jid) {
	          if (_this17.data.roster[guest_jid]) {
	            return _this17.data.roster[guest_jid].mention_name;
	          }
	        });
	        guestRegex = new RegExp('(?=[^\\w]|^)@(' + (guestMentionNames && guestMentionNames.length ? guestMentionNames.join('|') : '') + ')(?=[^\\w]|$)', 'gi');
	        room.guest_mention_regex = guestRegex;
	        this.set({
	          activeRooms: this.data.activeRooms
	        });
	        this.setActiveGuestUserRegex();
	      }
	    }
	  }, {
	    key: 'updateRosterNames',
	    value: function updateRosterNames() {
	      var name_map = _.transform(this.data.roster, function (result, user) {
	        result[user.mention_name] = user.name;
	      });
	      var mentionNames = {};
	      _.forEach(_app_config2.default.core_mentions, function (val) {
	        mentionNames[val.mention_name] = val.name;
	      });
	      _utils2.default.roster_names = _.merge(name_map, mentionNames);
	    }
	  }, {
	    key: 'handleProfile',
	    value: function handleProfile(iq) {
	      var jid = _utils2.default.jid.bare_jid(iq.from);
	      this.data.profiles[jid] = iq.query;
	      var rosterItem = _.get(this.data, ['roster', jid]);
	      if (rosterItem) {
	        rosterItem.name = _.get(iq, ['query', 'name']);
	      }
	      this.set('profiles', this.data.profiles);
	    }
	
	    /**
	     * @param {ChatFilesResponse} response
	     */
	
	  }, {
	    key: 'handleFileQueryResponse',
	    value: function handleFileQueryResponse(response) {
	      var _this18 = this;
	
	      var jid = response.jid;
	      if (this.data.activeRooms[jid]) {
	        var current = this.data.activeRooms[jid].files || [];
	        var files = _.orderBy(current.concat(response.files), 'date', 'desc');
	        var uniqFiles = _.uniqBy(files, 'url');
	        this.data.activeRooms[jid].files = _.map(uniqFiles, function (file) {
	          file.user_name = file.user_name || _utils2.default.user.get_user_name(_this18.data.roster, file.group_id, file.user_id);
	          file.icon_class = file.icon_class || _utils2.default.file.get_icon_class(file.name);
	          return file;
	        });
	
	        this.data.activeRooms[jid].all_files_fetched = response.end;
	        this.data.activeRooms[jid].files_fetched = true;
	        this.data.activeRooms[jid].files_fetching = false;
	        this.set('activeRooms', this.data.activeRooms);
	        _app_dispatcher2.default.dispatch('files-fetched', { jid: jid });
	      }
	    }
	
	    /**
	     * Fired by the message processor when parsing a file out of a received
	     * message. The message could be new or from history, so need to re-sort
	     * the list after adding the link to ensure proper sent order
	     */
	
	  }, {
	    key: 'addFileFromMessageToRoom',
	    value: function addFileFromMessageToRoom(jid, file) {
	      if (this.data.activeRooms[jid]) {
	        var files = this.data.activeRooms[jid].files || [];
	        files = [file].concat((0, _toConsumableArray3.default)(files));
	        files = _.orderBy(files, 'date', 'desc');
	        files = _.uniqBy(files, 'url');
	        this.data.activeRooms[jid].files = files;
	        this.debouncedSetActiveRooms();
	      }
	    }
	
	    /**
	     * @param {ChatLinksResponse} response
	     */
	
	  }, {
	    key: 'handleLinkQueryResponse',
	    value: function handleLinkQueryResponse(response) {
	      var _this19 = this;
	
	      var jid = response.jid;
	      if (this.data.activeRooms[jid]) {
	        var current = this.data.activeRooms[jid].links || [];
	        var links = current.concat(response.links);
	        var sortedLinks = _.orderBy(links, 'date', 'desc');
	        var uniqLinks = _.uniqBy(sortedLinks, 'url');
	
	        this.data.activeRooms[jid].links = _.map(uniqLinks, function (link) {
	          link.user_name = link.user_name || _utils2.default.user.get_user_name(_this19.data.roster, link.group_id, link.user_id);
	          link.display_url = link.display_url || link.url.replace(/.*?:\/\//g, "");
	          return link;
	        });
	
	        this.data.activeRooms[jid].all_links_fetched = response.end;
	        this.data.activeRooms[jid].links_fetched = true;
	        this.data.activeRooms[jid].links_fetching = false;
	        this.set('activeRooms', this.data.activeRooms);
	        _app_dispatcher2.default.dispatch('links-fetched', { jid: jid });
	      }
	    }
	
	    /**
	     * Fired by the message processor when scraping a link out of a received
	     * message. The message could be new or from history, so need to re-sort
	     * the list after adding the link to ensure proper sent order
	     */
	
	  }, {
	    key: 'addLinkFromMessageToRoom',
	    value: function addLinkFromMessageToRoom(jid, link) {
	      if (this.data.activeRooms[jid]) {
	        var links = this.data.activeRooms[jid].links || [];
	        var sortedLinks = _.orderBy([].concat(link, links), 'date', 'desc');
	        this.data.activeRooms[jid].links = _.uniqBy(sortedLinks, 'url');
	        this.debouncedSetActiveRooms();
	      }
	    }
	  }, {
	    key: 'joinPrivateChat',
	    value: function joinPrivateChat(jid, uid) {
	      this.data.activeRooms[jid] = {
	        jid: jid,
	        id: uid,
	        name: _.get(this.data.roster, [jid, 'name'], 'Unknown'),
	        type: 'chat',
	        presence: _.get(this.data.roster, [jid, 'presence']) || {
	          show: '',
	          status: ''
	        },
	        files: [],
	        links: [],
	        history_fetch_ids: [],
	        unreadCount: 0,
	        unreadMentionCount: 0,
	        unreadMentionJustMeCount: 0,
	        hasMention: false
	      };
	      if (this.local.participants.indexOf(uid) === -1) {
	        this.local.participants.push(uid);
	      }
	      _app_dispatcher2.default.dispatch('request-profile', jid);
	      this.set('activeRooms', this.data.activeRooms);
	    }
	  }, {
	    key: 'handleRooms',
	    value: function handleRooms(rooms) {
	      var _this20 = this;
	
	      var cachedCall = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      rooms = _utils2.default.toArray(rooms);
	      var deletedRoomJids = [];
	
	      var allRoomsArray = _.reduce(rooms, function (roomsAccumulatedArr, room) {
	        var roomInfo = {};
	
	        if (room) {
	          if (room.is_deleted) {
	            deletedRoomJids.push(room.jid);
	          } else if (room.id && !room.jid) {
	            var inActiveRooms = _.find(_.values(_this20.data.activeRooms), { id: room.id }),
	                inAllRooms = _.find(_.values(_this20.data.allRooms), { id: room.id }),
	                filtered = inActiveRooms || inAllRooms;
	            if (filtered) {
	              var jid = filtered.jid;
	              var name = filtered.name;
	
	              _app_dispatcher2.default.dispatch('close-room', { jid: jid });
	              deletedRoomJids.push(jid);
	              if (inActiveRooms) {
	                _app_dispatcher2.default.dispatch('show-flag', {
	                  type: "info",
	                  body: _chat_panel_strings2.default.you_have_been_removed + ' "' + name + '"',
	                  close: "auto"
	                });
	              }
	              _logger2.default.type('application-store:handle-rooms').log('Active room was closed because user was removed from that room. jid: ' + jid);
	            }
	          } else {
	            var activeRoom = _this20.data.activeRooms[room.jid] || {};
	
	            // construct room properties from room defaults, data we have
	            // already and room stanza data (which gets flattened)
	            roomInfo = _.assign({}, _this20.getRoomDefaults(), activeRoom, room.x, {
	              jid: room.jid,
	              name: room.name
	            });
	
	            // update room object in activeRooms collection
	            if (_this20.data.activeRooms[room.jid]) {
	              _this20.data.activeRooms[room.jid] = roomInfo;
	
	              if (_utils2.default.jid.is_room(room.jid) && !_.includes(roomInfo.admins, roomInfo.owner)) {
	                _this20.addRoomAdmin(room.jid, roomInfo.owner);
	              }
	            }
	
	            roomsAccumulatedArr.push(roomInfo);
	          }
	          return roomsAccumulatedArr;
	        }
	      }, []),
	          allRoomsObj = _.keyBy(allRoomsArray, 'jid');
	
	      // remove the deleted rooms from both of our rooms lists
	      var allRooms = _.omit(this.data.allRooms, deletedRoomJids),
	          activeRooms = _.omit(this.data.activeRooms, deletedRoomJids);
	
	      this.set({
	        allRooms: _.assign(allRooms, allRoomsObj),
	        activeRooms: activeRooms
	      });
	    }
	  }, {
	    key: 'determineRoomUpdate',
	    value: function determineRoomUpdate(room) {
	      if (room.status === 'deleted') {
	        this.handleRoomDelete(room);
	        return;
	      }
	      var is_new_room = !this.data.allRooms[room.jid];
	      if (is_new_room) {
	        this.handleNewRoom(room);
	      }
	      this.handleRoomUpdate(room);
	    }
	
	    /**
	     * Handles what to do when a new room push is received
	     *
	     * @param {object} room the room to join
	     */
	
	  }, {
	    key: 'handleNewRoom',
	    value: function handleNewRoom(room) {
	      var room_data = this.getRoomDefaults();
	      room_data.type = _utils2.default.room.detect_chat_type(room.jid);
	      this.data.allRooms[room.jid] = _.assign(room_data, room);
	      if (!room_data.admins) {
	        room_data.admins = [];
	      }
	      room_data.admins.push(room.owner);
	      this.set({
	        allRooms: this.data.allRooms
	      });
	    }
	  }, {
	    key: 'handleRoomUpdate',
	    value: function handleRoomUpdate(room) {
	      this.data.allRooms[room.jid] = _.merge(this.data.allRooms[room.jid], room);
	      if (this.data.activeRooms[room.jid]) {
	        this.data.activeRooms[room.jid] = _.merge(this.data.activeRooms[room.jid], room);
	      }
	      this.set({
	        allRooms: this.data.allRooms,
	        activeRooms: this.data.activeRooms
	      });
	      this._updateTotalUnreadCount();
	    }
	  }, {
	    key: 'handleRoomDelete',
	    value: function handleRoomDelete(room) {
	      var deleted_room_id = this.data.allRooms[room.jid] ? this.data.allRooms[room.jid].id : room.id;
	      delete this.data.allRooms[room.jid];
	      if (this.data.activeRooms[room.jid]) {
	
	        /*
	         * If I took the action to delete the room, it's jid will exist in the local deletedRooms list
	         * (see registered handler for 'delete-room' up above). Therefore, don't show me the generic
	         * "admin deleted the room" flag since I'll already be looking at the confirmation flag.
	         */
	        if (room.jid === this.data.active_chat && !_.includes(this.local.deletedRooms, room.jid)) {
	          _app_dispatcher2.default.dispatch('show-flag', {
	            type: "info",
	            close: "auto",
	            body: '"' + this.data.activeRooms[room.jid].name + '" was deleted by the admin.'
	          });
	        }
	
	        _app_dispatcher2.default.dispatch('close-room', {
	          jid: room.jid,
	          doNotNotifyHC: true,
	          id: deleted_room_id
	        });
	      }
	      _app_dispatcher2.default.dispatch('room-deleted', {
	        jid: room.jid,
	        id: deleted_room_id
	      });
	      this.set({
	        allRooms: this.data.allRooms,
	        activeRooms: this.data.activeRooms
	      });
	      this._updateTotalUnreadCount();
	      _.pull(this.local.deletedRooms, room.jid);
	    }
	  }, {
	    key: 'handleCloseRoom',
	    value: function handleCloseRoom(jid) {
	      _app_dispatcher2.default.dispatch('room-closed', {
	        jid: jid
	      });
	      delete this.data.activeRooms[jid];
	      delete this.data.newMessages[jid];
	
	      this._resetFiles(jid);
	      this._resetLinks(jid);
	
	      if (_utils2.default.jid.is_private_chat(jid) && this.data.roster[jid]) {
	        this.data.roster[jid].closed_at = _utils2.default.getMoment();
	      }
	      this.set({
	        activeRooms: this.data.activeRooms,
	        roster: this.data.roster
	      });
	      this.local.closedChats = [].concat(jid, _.pull(this.local.closedChats, jid));
	      this._updateTotalUnreadCount();
	      this._removeReadState(jid);
	    }
	  }, {
	    key: '_resetFiles',
	    value: function _resetFiles(jid) {
	      if (this.data.allRooms[jid]) {
	        this.data.allRooms[jid].files = [];
	        this.data.allRooms[jid].all_files_fetched = false;
	        this.data.allRooms[jid].files_fetched = false;
	        this.data.allRooms[jid].files_fetching = false;
	      }
	    }
	  }, {
	    key: '_resetLinks',
	    value: function _resetLinks(jid) {
	      if (this.data.allRooms[jid]) {
	        this.data.allRooms[jid].links = [];
	        this.data.allRooms[jid].all_links_fetched = false;
	        this.data.allRooms[jid].links_fetched = false;
	        this.data.allRooms[jid].links_fetching = false;
	      }
	    }
	  }, {
	    key: 'addVisitor',
	    value: function addVisitor(data) {
	      var participantExistsInRoster = !!this.data.roster[data.participant];
	      var participantExistsInRoom = !!this.data.activeRooms[data.participant];
	
	      if (!participantExistsInRoster || !participantExistsInRoom) {
	        this.data.roster[data.participant] = {
	          mention_name: data.user_mention || _.get(this.data.roster[data.participant], 'mention_name'),
	          name: data.user_name,
	          jid: data.participant
	        };
	        this.addRoomParticipant({
	          room: data.room,
	          user_jid: data.participant,
	          user_id: _utils2.default.jid.user_id(data.participant),
	          role: 'visitor',
	          affiliation: ''
	        });
	
	        this.updateParticipantStatusInRoster(data);
	        this.updateGuestMentions(data.room);
	      }
	
	      this.data.roster[data.participant].presence = {
	        show: data.presence.show || 'chat',
	        status: data.presence.status
	      };
	
	      this.set('roster', this.data.roster);
	    }
	  }, {
	    key: 'updateParticipantStatusInRoster',
	    value: function updateParticipantStatusInRoster(data) {
	      var currentRoom = this.data.activeRooms[data.room];
	
	      if (currentRoom) {
	        var guests = _.get(currentRoom, 'participants.guests', []);
	
	        if (guests.some(function (el) {
	          return el === data.participant;
	        })) {
	          this.data.roster[data.participant].is_guest = true;
	        }
	      }
	    }
	  }, {
	    key: 'removeVisitor',
	    value: function removeVisitor(data) {
	      if (this.data.roster[data.participant]) {
	        delete this.data.roster[data.participant];
	        this.set("roster", this.data.roster);
	        this.updateGuestMentions(data.room);
	      }
	    }
	  }, {
	    key: 'handleRoomPresence',
	    value: function handleRoomPresence(data) {
	      if (this.data.activeRooms[data.room]) {
	        this.addRoomParticipant(data);
	        this.updateMessagesIfGuestsConnected(data.room);
	      }
	    }
	  }, {
	    key: 'updateMessagesIfGuestsConnected',
	    value: function updateMessagesIfGuestsConnected(room_jid) {
	      if (!room_jid) {
	        return;
	      } else if (!_.isEmpty(_.get(this.data.activeRooms[room_jid], 'participants.guests', []))) {
	        this.messageProcessor.updateMessagesIfGuestsConnected(this.data.newMessages[room_jid]);
	        this.set('newMessages', this.data.newMessages);
	      }
	    }
	  }, {
	    key: 'handleGlobalPresence',
	    value: function handleGlobalPresence(data) {
	      var _this21 = this;
	
	      var person, chat;
	      _.forOwn(data, function (pres, jid) {
	        person = _this21.data.roster[jid];
	        chat = _this21.data.activeRooms[jid];
	        if (person) {
	          if (jid !== _this21.data.current_user.user_jid || jid === _this21.data.current_user.user_jid && _.includes(["away", "chat", "dnd", "xa"], pres.show)) {
	            _.assign(person.presence, pres);
	          }
	        }
	        if (chat) {
	          _.assign(chat.presence, pres);
	        }
	      });
	      this.set({
	        activeRooms: this.data.activeRooms,
	        roster: this.data.roster
	      });
	    }
	  }, {
	    key: 'addRoomParticipantFromAPI',
	    value: function addRoomParticipantFromAPI(room, participant) {
	
	      if (_utils2.default.jid.is_public_room(room.privacy) && !participant.is_present_in_room) {
	        // The API appears to be returning users in public rooms marked as not present
	        // this should never happen for a public room.
	        return;
	      }
	
	      if (_utils2.default.room.is_guest(participant)) {
	
	        if (!this.data.roster[participant.jid]) {
	          // if guest not in the roster add them
	          this.data.roster[participant.jid] = participant;
	          this.set('roster', this.data.roster);
	        }
	
	        if (!_.includes(room.participants.guests, participant.jid)) {
	          room.participants.guests.push(participant.jid);
	          this.updateGuestMentions(room.jid);
	        }
	      } else {
	
	        if (!_.includes(room.participants.members, participant.jid)) {
	          // member
	          room.participants.members.push(participant.jid);
	        }
	      }
	
	      if (_utils2.default.room.is_admin(participant) && !_.includes(room.admins, participant.id)) {
	        room.admins.push(participant.id);
	      }
	
	      if (!_.includes(this.local.participants, participant.id)) {
	        this.local.participants.push(participant.id);
	      }
	    }
	  }, {
	    key: 'addRoomParticipant',
	    value: function addRoomParticipant(data) {
	      var _this22 = this;
	
	      var room = this.data.activeRooms[data.room];
	      var arr = data.role === 'visitor' ? room.participants.guests : room.participants.members;
	      var isNotInParticipantList = arr.indexOf(data.user_jid) === -1;
	      if (isNotInParticipantList) {
	        arr.push(data.user_jid);
	
	        if (data.type === "unavailable" && _utils2.default.user.is_admin(room.admins, room.owner, this.data.current_user)) {
	          this.roomParticipantNotification(data, "add");
	        } else {
	          this.roomParticipantNotificationTimer(room, data, "join");
	        }
	      }
	
	      if (room.privacy === 'private') {
	        _app_dispatcher2.default.dispatch('unmark-participant', {
	          room: data.room,
	          user: data.user_jid
	        });
	      }
	
	      if ((data.affiliation === "owner" || data.affiliation === "admin") && !_.includes(room.admins, data.user_id)) {
	        this.addRoomAdmin(data.room, data.user_id);
	      }
	      if (this.data.current_user.is_guest && !this.data.roster[data.user_jid]) {
	        //The following block is to add a roster item from a room presence. Guests don't have the full roster,
	        //and need to add users to it piecemeal as room presences come in
	        _app_dispatcher2.default.dispatch('request-profile', data.user_jid, function (resp) {
	          if (resp.query) {
	            _this22.handleGuestRoomParticipants(_.merge(data, resp.query));
	            _this22.debouncedSetActiveRooms();
	          }
	        });
	      }
	      this.debouncedSetActiveRooms();
	      if (this.local.participants.indexOf(data.user_id) === -1) {
	        this.local.participants.push(data.user_id);
	      }
	    }
	  }, {
	    key: 'removeRoomParticipant',
	    value: function removeRoomParticipant(data) {
	      var _this23 = this;
	
	      var room = this.data.activeRooms[data.room];
	      if (room) {
	        if (room.participants[data.role]) {
	
	          if (data.role === "guests") {
	            this.roomParticipantNotification(data, "leave");
	            this.removeVisitor(data);
	          } else {
	            this.roomParticipantNotificationTimer(room, data, "leave");
	          }
	
	          if (room.privacy === 'private' && data.role !== 'guests') {
	            _app_dispatcher2.default.dispatch('mark-participant-unknown', {
	              room: data.room,
	              user: data.participant,
	              role: data.role
	            });
	          } else {
	            _.remove(room.participants[data.role], function (i) {
	              return i === data.participant;
	            });
	          }
	        } else if (data.role === "none") {
	          if (_utils2.default.user.is_admin(room.admins, room.owner, this.data.current_user)) {
	            this.roomParticipantNotification(data, "remove");
	          }
	
	          // Remove Members
	          _.remove(room.participants.members, function (user_jid) {
	            return user_jid === data.participant;
	          });
	
	          // Remove Guests
	          _.forEach(room.participants.guests, function (user_jid) {
	            if (user_jid === data.participant) {
	              _this23.removeVisitor(data);
	            }
	          });
	        }
	        this.debouncedSetActiveRooms();
	      }
	    }
	  }, {
	    key: 'handleUserRemoved',
	    value: function handleUserRemoved(data) {
	      // User Being removed from a room
	      this.removeRoomParticipant({
	        room: data.room,
	        participant: data.user_jid,
	        role: data.role
	      });
	
	      var user_id = Number(_.get(this.data.current_user, 'user_id') || _.get(this.data.current_user, 'id'));
	
	      if (this.data.allRooms[data.room] && this.data.activeRooms[data.room].owner !== user_id && data.user_jid === this.data.current_user.user_jid) {
	        if (this.data.activeRooms[data.room]) {
	          _app_dispatcher2.default.dispatch('show-flag', {
	            type: "info",
	            body: _chat_panel_strings2.default.you_have_been_removed + ' "' + this.data.activeRooms[data.room].name + '"',
	            close: "auto"
	          });
	          _app_dispatcher2.default.dispatch('close-room', {
	            jid: data.room
	          });
	        }
	        _app_dispatcher2.default.dispatch('room-deleted', {
	          jid: data.room
	        });
	        delete this.data.allRooms[data.room];
	        this.set({
	          allRooms: this.data.allRooms
	        });
	      }
	    }
	  }, {
	    key: 'roomParticipantNotificationTimer',
	    value: function roomParticipantNotificationTimer(room, data, type) {
	      var _this24 = this;
	
	      if (!room.show_join_leave_messages) {
	        return;
	      }
	
	      var user = data.participant || data.user_jid,
	          key = room.jid + user;
	
	      if (type === 'join') {
	        if (this.local.presence_updates_timers[key]) {
	          clearTimeout(this.local.presence_updates_timers[key]);
	        } else {
	          this.roomParticipantNotification(data, type);
	        }
	      } else {
	        clearTimeout(this.local.presence_updates_timers[key]);
	        this.local.presence_updates_timers[key] = setTimeout(function () {
	          delete _this24.local.presence_updates_timers[key];
	          _this24.roomParticipantNotification(data, type);
	        }, _app_config2.default.leave_room_message_confirmation_timeout);
	      }
	    }
	  }, {
	    key: 'roomParticipantNotification',
	    value: function roomParticipantNotification(data, notificationType) {
	      var user_jid = data.participant || data.user_jid || data.jid,
	          user = this.data.roster[user_jid];
	
	      if (_preferences_store2.default.getHidePresenceMessages() || !user) {
	        return;
	      }
	
	      var statusMessage = void 0,
	          messages = [],
	          room = this.data.activeRooms[data.room];
	
	      if (_utils2.default.user.is_admin(room.admins, room.owner, this.data.current_user) && data.is_present_in_room) {
	        notificationType = "join";
	      }
	
	      if (notificationType === "leave") {
	        if (data.status === 'hc-not-allowed') {
	          statusMessage = _chat_panel_strings2.default.user_leave_reason(user.name, _chat_panel_strings2.default.not_allowed);
	        } else {
	          statusMessage = _chat_panel_strings2.default.user_leave(user.name);
	        }
	      } else if (notificationType === "join") {
	        statusMessage = _chat_panel_strings2.default.user_join(user.name);
	      } else if (notificationType === "remove") {
	        statusMessage = _chat_panel_strings2.default.user_removed(user.name);
	      } else if (notificationType === "add") {
	        statusMessage = _chat_panel_strings2.default.user_added(user.name);
	      }
	
	      messages.push({
	        body: statusMessage,
	        type: 'room-presence',
	        from: data.room,
	        delay: true,
	        sender: ' ',
	        user_jid: user_jid
	      });
	
	      this.handleIncomingMessages(messages, this);
	    }
	  }, {
	    key: 'addRoomAdmin',
	    value: function addRoomAdmin(roomJid, userId) {
	      this.data.activeRooms[roomJid].admins.push(userId);
	    }
	  }, {
	    key: 'updatePresence',
	    value: function updatePresence(pres) {
	      _notifier2.default.update({ current_user_presence: pres.show });
	      this.data.roster[this.data.current_user.user_jid].presence = pres;
	      this.set({
	        roster: this.data.roster
	      });
	    }
	  }, {
	    key: 'resetRoomParticipantsListInitializedFlag',
	    value: function resetRoomParticipantsListInitializedFlag() {
	      _.forOwn(this.data.activeRooms, function (room) {
	        room.participants_fully_initialized = false;
	      });
	    }
	  }, {
	    key: 'fetchRoomParticipantsFromAPI',
	    value: function fetchRoomParticipantsFromAPI(room, includeOffline) {
	      _app_actions2.default.fetchRoomParticipants(room, includeOffline);
	    }
	  }, {
	    key: 'handleRoomParticipantsFromAPI',
	    value: function handleRoomParticipantsFromAPI(data) {
	      var _this25 = this;
	
	      var room = _.find(this.data.activeRooms, function (activeRoom) {
	        return activeRoom.id.toString() === data.roomId.toString();
	      });
	
	      if (room) {
	        var participants = _utils2.default.toArray(data.participants);
	
	        this.setRoomParticipantsFullyInitialized(room);
	
	        participants.forEach(function (participant) {
	          participant.jid = participant.xmpp_jid;
	          participant.presence = {
	            show: 'chat',
	            status: ''
	          };
	          _this25.addRoomParticipantFromAPI(room, participant);
	        });
	
	        this.updateMessagesIfGuestsConnected(room.jid);
	      }
	    }
	  }, {
	    key: 'setRoomParticipantsFullyInitialized',
	    value: function setRoomParticipantsFullyInitialized(room) {
	      room.participants_fully_initialized = true;
	    }
	  }, {
	    key: 'setActiveRooms',
	    value: function setActiveRooms() {
	      this.set('activeRooms', this.data.activeRooms);
	      this._updateTotalUnreadCount();
	    }
	  }, {
	    key: 'setActiveGuestUserRegex',
	    value: function setActiveGuestUserRegex() {
	      var guestRegexUser;
	      if (this.data.activeRooms[this.data.active_chat]) {
	        guestRegexUser = this.data.activeRooms[this.data.active_chat].guest_mention_regex;
	      }
	      this.set({
	        guestRegexUser: guestRegexUser
	      });
	    }
	  }, {
	    key: 'updatePresenceProcessor',
	    value: function updatePresenceProcessor() {
	      this.presenceProcessor.update({
	        is_guest: this.data.current_user.is_guest,
	        current_user_jid: this.data.current_user.user_jid
	      });
	    }
	  }, {
	    key: 'handleArchiveRoom',
	    value: function handleArchiveRoom(data, archive, cb) {
	      var room = this.data.activeRooms[data.jid];
	      _app_dispatcher2.default.dispatch('API:update-room', {
	        params: {
	          name: room.name,
	          privacy: room.privacy,
	          is_archived: archive,
	          is_guest_accessible: !!room.guest_url,
	          topic: room.topic,
	          owner: {
	            id: room.owner
	          },
	          id: room.id
	        },
	        path: {
	          'identifier': room.id,
	          'type': 'room'
	        },
	        jid: data.jid
	      }, cb);
	    }
	  }, {
	    key: 'handleArchivedRoom',
	    value: function handleArchivedRoom(data, archived) {
	      var chatInAllRooms = this.data.allRooms[data.jid] || {};
	      var chatInActiveRooms = this.data.activeRooms[data.jid] || {};
	
	      chatInAllRooms.is_archived = archived;
	      chatInActiveRooms.is_archived = archived;
	
	      this.set({
	        allRooms: this.data.allRooms,
	        activeRooms: this.data.activeRooms
	      });
	    }
	  }, {
	    key: 'handleTopicUpdated',
	    value: function handleTopicUpdated(topic, jid) {
	      if (jid) {
	        if (this.data.allRooms[jid]) {
	          this.data.allRooms[jid].topic = topic;
	        }
	        if (this.data.activeRooms[jid]) {
	          this.data.activeRooms[jid].topic = topic;
	        }
	        this.set({
	          allRooms: this.data.allRooms,
	          activeRooms: this.data.activeRooms
	        });
	      }
	    }
	  }, {
	    key: 'openChatByMentionName',
	    value: function openChatByMentionName(mentionName) {
	      var user = _.find(this.data.roster, function (u) {
	        return u.mention_name.toLowerCase() === mentionName.toLowerCase();
	      });
	
	      var currentUser = this.get('current_user');
	      if (user && !currentUser.is_guest) {
	        var data = {
	          jid: user.jid,
	          name: user.name
	        };
	        _app_dispatcher2.default.dispatch('set-route', data);
	      }
	    }
	
	    /**
	     * Generates a roster from the room participants that a guest has requested via coral
	     */
	
	  }, {
	    key: 'handleGuestRoomParticipants',
	    value: function handleGuestRoomParticipants(users) {
	      var _this26 = this;
	
	      var fake_roster = _.forEach(_utils2.default.toArray(users), function (user) {
	        user.jid = user.user_jid || _utils2.default.jid.build_group_jid(user.id, _this26.data.group_id, _this26.data.chat_server);
	        user.presence = {
	          show: 'chat',
	          status: ''
	        };
	      });
	      this.set('roster', _.merge(this.data.roster, _.keyBy(fake_roster, 'jid')));
	      this.updateMentionNames();
	      this.updateRosterNames();
	    }
	  }, {
	    key: 'updateFeatureFlags',
	    value: function updateFeatureFlags(data) {
	      if (_.isObject(data) && _.has(data, "feature_flags")) {
	        var config = _.merge(this.data.config, data);
	        this.set("config", config);
	      }
	    }
	
	    /**
	     * Enables a feature flag
	     *
	     * @param {Object} feature the feature to enable_guest_classes
	     * @param {String} feature.name the name of the feature to enable
	     */
	
	  }, {
	    key: 'handleEnableDarkFeature',
	    value: function handleEnableDarkFeature(feature) {
	      var featureFlags = _.get(this.data.config, "feature_flags", {});
	      if (featureFlags && feature.name) {
	        featureFlags[feature.name] = true;
	        this.updateFeatureFlags({
	          feature_flags: featureFlags
	        });
	      }
	    }
	  }, {
	    key: 'configure',
	    value: function configure(data) {
	      this.messageProcessor.configure(data.asset_base_uri);
	      if (data.config.auth_method !== 'nonce') {
	        this.iqProcessor.addRequiredStartupStanza();
	      }
	      this.set(data);
	    }
	  }]);
	  return AppStore;
	}(_store2.default);
	
	exports.default = new AppStore();
	module.exports = exports['default'];

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Object$assign = __webpack_require__(148)["default"];
	
	exports["default"] = _Object$assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};
	
	exports.__esModule = true;

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _toArray2 = __webpack_require__(193);
	
	var _toArray3 = _interopRequireDefault(_toArray2);
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _link_utils = __webpack_require__(108);
	
	var _link_utils2 = _interopRequireDefault(_link_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _notifier = __webpack_require__(180);
	
	var _notifier2 = _interopRequireDefault(_notifier);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _file = __webpack_require__(194);
	
	var _file2 = _interopRequireDefault(_file);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _api_integration_events = __webpack_require__(198);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MessageProcessor = function () {
	  function MessageProcessor(store) {
	    (0, _classCallCheck3.default)(this, MessageProcessor);
	
	    this.store = store;
	    this.update();
	    this.registerEventCallbacks();
	    this.ready = false;
	    this.queued = [];
	    this.imagesQueue = [];
	    this._debouncedFetchQueue = _.debounce(this._fetchQueue.bind(this), 500, {
	      leading: true,
	      trailing: true
	    });
	  }
	
	  (0, _createClass3.default)(MessageProcessor, [{
	    key: 'update',
	    value: function update() {
	      this.setPredicates();
	      this.updateNotifier();
	    }
	  }, {
	    key: 'setPredicates',
	    value: function setPredicates() {
	      this.outgoing_message_predicate = _utils2.default.createSafePredicate(_app_config2.default.outgoing_message_filter_predicate, _app_config2.default);
	      _utils2.default.formatMessageBody = this.formatMessageBody.bind(this);
	    }
	  }, {
	    key: 'configure',
	    value: function configure(asset_base_uri) {
	      this.asset_base_uri = asset_base_uri;
	    }
	  }, {
	    key: 'updateNotifier',
	    value: function updateNotifier() {
	      _notifier2.default.update({
	        group_name: this.store.get("group_name"),
	        feature_flags: _.get(this.store.get("config"), "feature_flags", {})
	      });
	    }
	  }, {
	    key: 'registerEventCallbacks',
	    value: function registerEventCallbacks() {
	      var _this = this;
	
	      _app_dispatcher2.default.registerOnce('app-state-ready', function () {
	        _this.ready = true;
	        _this.processMessages(_this.queued);
	        _this.queued = [];
	      });
	      _app_dispatcher2.default.register({
	        'application-blurred': function applicationBlurred() {
	          _this.appBlurred = true;
	        },
	        'application-focused': function applicationFocused() {
	          _this.appBlurred = false;
	        }
	      });
	    }
	  }, {
	    key: 'getMentionArguments',
	    value: function getMentionArguments() {
	      var mentionRegexMe = this.convertRegex(this.store.get("mentionRegexMe"), "mentionRegexMe");
	      var mentionRegexUser = this.convertRegex(this.store.get("mentionRegexUser"), "mentionRegexUser");
	      return {
	        name_tag_regex: mentionRegexMe,
	        mention_regex: mentionRegexUser,
	        matches: [],
	        do_escape: false,
	        do_linkify: false,
	        do_mentions: true
	      };
	    }
	  }, {
	    key: 'convertRegex',
	    value: function convertRegex(regex, key) {
	      var flag = key === "mentionRegexUser" ? "ig" : "g";
	      if (typeof regex === 'string') {
	        return new RegExp(regex.substring(1, regex.lastIndexOf(')') + 1), flag);
	      }
	      return regex;
	    }
	  }, {
	    key: 'processMessages',
	    value: function processMessages(messages) {
	      var msgArray = _utils2.default.toArray(messages);
	      if (!this.ready && !messages.results) {
	        this.queued = this.queued.concat(msgArray);
	      } else {
	        var messagesObj = {};
	        if (messages.jid && messages.results) {
	          messagesObj = this.formatAPIMessages(messages);
	        } else {
	          messagesObj = this.formatXMPPMessages(messages);
	        }
	        return messagesObj;
	      }
	    }
	  }, {
	    key: 'formatXMPPMessages',
	    value: function formatXMPPMessages(messages) {
	      var _this2 = this;
	
	      var messagesObj = {},
	          jid,
	          sender;
	
	      // Filter messages
	      messages = this.filterMessages(_utils2.default.toArray(messages));
	
	      _.forEach(messages, function (message) {
	        jid = _utils2.default.jid.bare_jid(message.from);
	
	        if (_this2.checkMessageForAction(message, jid)) {
	          return;
	        }
	        _this2.setMessageTypeAndFormat(message);
	
	        if (typeof message.mid === 'undefined') {
	          message.mid = _.uniqueId();
	        }
	        if (typeof message.ts === 'undefined') {
	          message.ts = _utils2.default.getMoment();
	        }
	
	        if (typeof message.subject !== 'undefined') {
	          if (message.delay) {
	            //We don't want previous topic change messages to change the room topic
	            return;
	          }
	          sender = _this2.getMessageSender(message);
	          if (!sender) {
	            return;
	          }
	
	          var topicChangeMsg = _this2.handleTopicChange(message, sender, jid);
	
	          _.assign(message, topicChangeMsg);
	        }
	
	        var sender_id = _this2.getMessageSenderId(message),
	            sender_name = _this2.getMessageSender(message),
	            current_user = _this2.store.get("current_user");
	
	        _.assign(message, {
	          room: jid,
	          sender: message.sender || sender_name,
	          sender_id: sender_id,
	          sender_is_current_user: sender_id === current_user.user_id,
	          date: _moment2.default.unix(message.ts).toISOString(),
	          sender_mention: message.sender_mention || _this2.getMessageSenderMention(message),
	          sender_avatar: message.sender_avatar || _this2.getAvatar(sender_id),
	          display_time: _this2.formatDate(message.ts),
	          time: parseFloat(message.ts),
	          is_history_message: _utils2.default.isHistoryMessage(message),
	          status: 'confirmed'
	        });
	
	        _this2.setMessageColor(message);
	        message.card = _this2.processCard(_.get(message, "x.card.raw", false));
	        _this2.setMessageSenderAndAvatar(message, _.get(message, 'x.notification_sender', false));
	        _this2.processMessageMetadata(message);
	
	        message = _this2.formatMessageBody(message);
	
	        if (message.body && !_utils2.default.isHistoryMessage(message) && _this2.shouldNotify(message)) {
	          sender = message.sender || _this2.getMessageSender(message);
	          _this2.updateNotifier();
	          _app_actions2.default.showNotification({
	            jid: jid,
	            group_id: _this2.store.get("group_id"),
	            group_name: _this2.store.get("group_name"),
	            title: _this2.getNotificationTitle(message.room, sender),
	            body: _this2.getNotificationBody(message, sender),
	            icon: _this2.asset_base_uri + _app_config2.default.notification_icon,
	            html_body: message.format === 'html' ? message.xhtml_im_body : message.rendered_body
	          });
	          _notifier2.default.playSound('notification');
	        }
	
	        messagesObj[message.mid] = message;
	
	        var escapeAndLinkifyOptions = {
	          do_emoticons: _preferences_store2.default.shouldReplaceTextEmoticons()
	        };
	
	        if (_.filter(message.x, 'metadata').length) {
	          var meta = _.compact(_.map(message.x, 'metadata'))[0];
	          if (meta.type === "info") {
	            _.assign(message, {
	              sender: _utils2.default.getSenderFromMeta(meta.type),
	              sender_id: sender_id,
	              sender_mention: "",
	              color: 'gray'
	            });
	          } else {
	            var mid = message.mid || '',
	                msg = {},
	                time = parseFloat(message.ts);
	
	            _.assign(msg, {
	              room: jid,
	              mid: mid + '-link-1',
	              sender: _utils2.default.getSenderFromMeta(meta.type),
	              sender_id: sender_id,
	              sender_mention: message.sender_mention || _this2.getMessageSenderMention(message),
	              sender_avatar: _this2.getAvatar(sender_id),
	              date: _moment2.default.unix(time).toISOString(),
	              display_time: _this2.formatDate(time + 1),
	              time: time,
	              format: 'html',
	              body: meta.text ? _utils2.default.escapeAndLinkify(meta.text, escapeAndLinkifyOptions) : '',
	              type: meta.type,
	              link_details: meta,
	              color: 'gray',
	              is_history_message: _utils2.default.isHistoryMessage(message)
	            });
	            msg.link_details = _.transform(msg.link_details, function (result, val, key) {
	              result[_utils2.default.camelToSnake(key)] = val;
	            });
	
	            if (meta.type === 'image' && !meta.mp4) {
	              _this2._processImageMessage(meta, msg);
	            } else {
	              messagesObj[msg.mid] = _.clone(msg);
	            }
	          }
	        }
	      });
	      return messagesObj;
	    }
	
	    /**
	     * Method for preparing image for image link message
	     * @param meta
	     * @param msg
	     * @private
	     */
	
	  }, {
	    key: '_processImageMessage',
	    value: function _processImageMessage(meta, msg) {
	      this.imagesQueue.push({ url: meta.image, msg: msg });
	      this._debouncedFetchQueue(function (imgMsg, image) {
	        _app_dispatcher2.default.dispatch('fetch-attachment-image', (0, _defineProperty3.default)({}, imgMsg.mid, imgMsg));
	      });
	    }
	
	    /**
	     * Fetching queue of images
	     * @param {Func<Object,Image>} iteratee - callback
	     * @param {Array<Object>} queue - url queue to be fetched
	     * @private
	     */
	
	  }, {
	    key: '_fetchQueue',
	    value: function _fetchQueue() {
	      var iteratee = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	      var queue = arguments.length <= 1 || arguments[1] === undefined ? _.clone(this.imagesQueue).reverse() : arguments[1];
	
	      this.imagesQueue = [];
	      this._recurQueue(queue, iteratee);
	    }
	
	    /**
	     * Applying promisified fetchImage recursively against the queue
	     * @param {Array} queue
	     * @param {Func<Object,Image} iteratee - callback
	     * @private
	     */
	
	  }, {
	    key: '_recurQueue',
	    value: function _recurQueue(queue, iteratee) {
	      var _this3 = this;
	
	      var _queue = (0, _toArray3.default)(queue);
	
	      var head = _queue[0];
	
	      var rest = _queue.slice(1);
	
	      var promise = this._fetchImage(head.url);
	
	      promise.then(function (image) {
	        iteratee(head.msg, image);
	
	        if (rest.length !== 0) {
	          _this3._recurQueue(rest, iteratee);
	        }
	      }, function (err) {
	        _logger2.default.error(err.message, err);
	
	        if (rest.length !== 0) {
	          _this3._recurQueue(rest, iteratee);
	        }
	      });
	    }
	
	    /**
	     * Fetching image
	     * @param url
	     * @returns {Promise{Image}
	     * @private
	     */
	
	  }, {
	    key: '_fetchImage',
	    value: function _fetchImage(url) {
	      return new _promise2.default(function (resolve, reject) {
	        var image = new Image();
	        var timeoutId = void 0;
	
	        image.onload = function () {
	          clearTimeout(timeoutId);
	
	          if (image.naturalWidth > _app_config2.default.message_image_max_size || image.naturalHeight > _app_config2.default.message_image_max_size) {
	            reject(new Error('Image is too large'));
	          }
	
	          resolve(image);
	        };
	
	        image.onerror = function (err) {
	          clearTimeout(timeoutId);
	        };
	
	        timeoutId = setTimeout(function () {
	          image.src = '';
	          clearTimeout(timeoutId);
	          reject(new Error('Fetching timeout'));
	        }, _app_config2.default.message_image_loading_timeout);
	
	        image.src = url;
	      });
	    }
	  }, {
	    key: 'filterMessages',
	    value: function filterMessages(msgs) {
	      var predicate = _utils2.default.createSafePredicate(_app_config2.default.message_filter_predicate, _app_config2.default);
	
	      msgs = _.filter(msgs, function (msg) {
	        return _.has(msg, 'body') ? !_.isEmpty(msg.body) || !!msg.replace : true;
	      });
	      return _.filter(msgs, predicate);
	    }
	  }, {
	    key: 'formatDate',
	    value: function formatDate(date) {
	      return _utils2.default.format_time(date, _preferences_store2.default.shouldUse24HrTime());
	    }
	  }, {
	    key: 'formatAPIMessages',
	    value: function formatAPIMessages(messages) {
	      var _this4 = this;
	
	      var temp = {},
	          transformed_messages;
	
	      transformed_messages = _.transform(messages.results, function (result, msg) {
	        if (msg.type === 'topic') {
	          return;
	        }
	        if (_this4.isEnsoVideoHistoryMessage(msg)) {
	          return;
	        }
	        // HC-31099: Deleted messages come back from Coral with null message bodies (ohcrap)
	        if (_.isNull(msg.message)) {
	          return;
	        }
	
	        var sender_name = msg.from.name || msg.from;
	
	        temp = {
	          body: msg.message,
	          room: messages.jid,
	          mid: msg.id,
	          time: _utils2.default.getMoment(msg.date),
	          display_time: _this4.formatDate(msg.date),
	          date: (0, _moment2.default)(msg.date).toISOString(),
	          from: messages.jid,
	          sender: sender_name,
	          sender_mention: msg.from.mention_name,
	          sender_id: msg.from.id,
	          sender_avatar: _this4.getAvatar(msg.from.id),
	          type: msg.type === 'unknown' || !msg.type ? 'message' : msg.type,
	          color: msg.color,
	          format: msg.message_format,
	          card: _this4.processCard(_.get(msg, "card", false)),
	          is_history_message: true,
	          status: 'confirmed'
	        };
	
	        if (msg.message_format === 'html') {
	          temp.xhtml_im_body = msg.message;
	        }
	
	        if (msg.authenticated_file) {
	          _.assign(temp, {
	            type: 'file',
	            authenticated_file: msg.authenticated_file
	          });
	        } else if (msg.file) {
	          _.assign(temp, {
	            type: 'file',
	            file: msg.file
	          });
	        }
	
	        if (_app_config2.default.slash_replacement_regex.test(msg.message)) {
	          var arr = msg.message.split('/');
	          _app_dispatcher2.default.dispatch('replacement-message-received', {
	            jid: messages.jid,
	            sender_id: msg.from.id,
	            text_to_replace: arr[1],
	            replacement_text: arr[2],
	            time: _utils2.default.getMoment(msg.date),
	            mid: msg.id
	          });
	        }
	
	        _this4.setMessageTypeAndFormat(temp);
	        _this4.setMessageColor(temp);
	        _this4.setMessageSenderAndAvatar(temp, _.get(msg, 'notification_sender', false));
	        _this4.processMessageMetadata(temp);
	        result.push(_this4.formatMessageBody(temp));
	
	        if (msg.message_links && msg.message_links.length) {
	          var linkMsg = {},
	              index = 0;
	          _.map(msg.message_links, function (link) {
	            index++;
	            linkMsg = {
	              room: messages.jid,
	              mid: link.id || msg.id + '-link-' + index,
	              body: link[link.type].text || msg.message,
	              time: _utils2.default.getMoment(msg.date) + index,
	              date: (0, _moment2.default)(msg.date).toISOString(),
	              display_time: _this4.formatDate(msg.date),
	              from: messages.jid,
	              sender: _utils2.default.getSenderFromMeta(link.type),
	              sender_mention: msg.from.mention_name,
	              sender_id: msg.from.id,
	              format: 'html',
	              color: 'gray',
	              type: link.type,
	              link_details: link[link.type],
	              is_history_message: true,
	              status: 'confirmed'
	            };
	            linkMsg.link_details['url'] = link.url;
	            linkMsg.link_details = _.transform(linkMsg.link_details, function (transform_result, val, key) {
	              transform_result[_utils2.default.camelToSnake(key)] = val;
	            });
	            result.push(linkMsg);
	          });
	        }
	      });
	
	      transformed_messages = _.reject(transformed_messages, function (msg) {
	        return msg.mid.split('-link-')[0] === messages.mid || _.has(msg, 'message') && _.isNull(msg.message);
	      });
	
	      if (transformed_messages.length) {
	        return _.keyBy(transformed_messages, 'mid');
	      }
	    }
	  }, {
	    key: 'processSentMessage',
	    value: function processSentMessage(data) {
	      var msgObj = {},
	          currentUser = this.store.get("current_user"),
	          sender_id = _utils2.default.jid.user_id(currentUser.user_jid),
	          msg = {
	        jid: data.jid,
	        room: data.jid,
	        from: currentUser.user_jid,
	        sender: currentUser.user_name,
	        sender_id: sender_id,
	        sender_avatar: this.getAvatar(sender_id),
	        display_time: this.formatDate(),
	        color: 'blue',
	        time: data.time,
	        body: data.text,
	        type: 'message',
	        mid: data.id.toString(),
	        status: this.outgoing_message_predicate(data) ? 'unconfirmed' : 'confirmed',
	        is_user_sent: true
	      };
	      if (this.checkMessageForAction(msg, data.jid)) {
	        return undefined;
	      }
	      this.setMessageTypeAndFormat(msg);
	      msg = this.formatMessageBody(msg);
	      msg['sender_mention'] = this.getMessageSenderMention(msg);
	      msgObj[msg.mid] = msg;
	      return msgObj;
	    }
	  }, {
	    key: 'handleTopicChange',
	    value: function handleTopicChange(message, sender, jid) {
	      var subject = message.subject.substring(0, _app_config2.default.max_topic_text_length),
	          // Truncate topics that come from server
	      currentUser = this.store.get("current_user"),
	          msg = {
	        sender: ' ',
	        type: "info",
	        color: sender === currentUser.user_name ? "blue" : "nocolor",
	        body: subject.length ? _chat_panel_strings2.default.topic_message(sender, subject) : _chat_panel_strings2.default.clear_topic_message(sender)
	      };
	
	      _app_dispatcher2.default.dispatch("DAL:handle-topic-updated", {
	        topic: subject,
	        jid: jid
	      });
	
	      return msg;
	    }
	  }, {
	    key: 'formatMessageBody',
	    value: function formatMessageBody(message) {
	      var type = /message$/.test(message.type) ? 'message' : message.type,
	          text = message.body,
	          do_escape = true;
	
	      if (typeof text === 'string') {
	        do_escape = ['html', 'code', 'quotation', 'monospace'].indexOf(message.format) === -1;
	        if (message.x) {
	          message.x = _utils2.default.toArray(message.x);
	        }
	
	        if (type === 'message' && text.match(_app_config2.default.emote_regex)) {
	          message.type = 'info';
	          message.isEmote = true;
	          text = _utils2.default.replaceEmoteMessage(text, message.sender);
	        }
	
	        if (message.type === 'file') {
	          var file = _file2.default.fromMessageObject(message);
	          message.file_data = file;
	          text = file.desc;
	        }
	
	        // Check for monospace formatting (remove excess whitespace)
	        if (message.format === 'quotation') {
	          text = _utils2.default.formatMultilineBlock(text);
	        }
	
	        // Escape html and linkify
	        var matches = [];
	        var isFormatted = this.isQuoteMessage(message) || this.isCodeMessage(message) || this.isMonospaceMessage(message);
	
	        // Don't linkify if we're going to truncate a pasted block by # of characters
	        // (links are fine if we're truncating by line)
	        var do_linkify = do_escape && !isFormatted;
	        var do_emoticons = do_escape && !isFormatted && _preferences_store2.default.shouldReplaceTextEmoticons();
	        var do_mentions = do_escape && !isFormatted && _utils2.default.jid.is_room(message.room);
	        var do_hex_colors = do_escape && !isFormatted;
	        var do_word_breaks = do_escape;
	        var mentionRegexMe = this.convertRegex(this.store.get("mentionRegexMe"), "mentionRegexMe");
	        var mentionRegexUser = this.convertRegex(this.store.get("mentionRegexUser"), "mentionRegexUser");
	        var guestRegexUser = this.convertRegex(this.store.get("guestRegexUser"), "guestRegexUser");
	        var emoticons = this.store.get("emoticons");
	
	        text = _utils2.default.escapeAndLinkify(text, {
	          escape_whitespace: do_escape,
	          name_tag_regex: mentionRegexMe,
	          mention_regex: mentionRegexUser,
	          guest_regex: guestRegexUser,
	          matches: matches,
	          emoticon_path: emoticons.path_prefix,
	          do_escape: do_escape,
	          do_linkify: do_linkify,
	          do_emoticons: do_emoticons,
	          do_word_breaks: do_word_breaks,
	          do_mentions: do_mentions,
	          do_hex_colors: do_hex_colors
	        });
	
	        message.rendered_body = text;
	        message.message_type = type;
	        if (message.format === 'html' && message.xhtml_im_body) {
	          message.xhtml_im_body = this.substituteMentionTagsForHtml(message.xhtml_im_body);
	        }
	      }
	      return message;
	    }
	  }, {
	    key: 'getNotificationBody',
	    value: function getNotificationBody(message, sender) {
	      var body;
	
	      if (message.type === "message") {
	        body = message.body ? message.body : _chat_panel_strings2.default.generic_message(sender);
	      } else if (message.type === "file") {
	        if (message.body) {
	          body = message.body;
	        } else if (_.get(message, "file_data.name")) {
	          var file_name = _utils2.default.file.get_file_name(message.file_data.name);
	          body = _chat_panel_strings2.default.generic_file_uploaded_message(sender, file_name);
	        } else {
	          body = _chat_panel_strings2.default.generic_file_message(sender);
	        }
	      }
	      return body || _chat_panel_strings2.default.generic_message(sender);
	    }
	  }, {
	    key: 'getNotificationTitle',
	    value: function getNotificationTitle(room_jid, sender) {
	      var room = this.store.get("activeRooms")[room_jid] || this.store.get("allRooms")[room_jid],
	          room_name = _.get(room, 'name'),
	          is_from_room = _utils2.default.jid.is_room(room_jid),
	          title = void 0;
	
	      if (is_from_room) {
	        title = this.getRoomNotificationTitle(room_name, sender);
	      } else {
	        title = this.getOTONotificationTitle(sender);
	      }
	      return title;
	    }
	  }, {
	    key: 'getRoomNotificationTitle',
	    value: function getRoomNotificationTitle(room_name, sender) {
	      return _chat_panel_strings2.default.room_notification_title(sender, room_name);
	    }
	  }, {
	    key: 'getOTONotificationTitle',
	    value: function getOTONotificationTitle(sender) {
	      return _chat_panel_strings2.default.oto_notification_title(sender);
	    }
	  }, {
	    key: 'shouldNotify',
	    value: function shouldNotify(message) {
	      var preferences = _preferences_store2.default.getAll(),
	          current_user = this.store.get("current_user"),
	          roster = this.store.get("roster"),
	          current_user_roster_entry = roster[current_user.user_jid],
	          overrides,
	          roomOverrides,
	          notification_level;
	
	      // Do not notify if current user is DND
	      if (!preferences.notifyWhenDND && current_user_roster_entry && _.get(current_user_roster_entry, "presence.show") === "dnd") {
	        return false;
	      }
	
	      // Do not notify for info messages
	      if (message.type && message.type === "info") {
	        return false;
	      }
	
	      // Do not notify for s/ messages
	      if (_app_config2.default.slash_replacement_regex.test(message.body)) {
	        return false;
	      }
	
	      // Do not notify if message is from the current user
	      if (this.getMessageSenderId(message) === current_user.user_id) {
	        return false;
	      }
	
	      // Do not notify if app is focused and message is for the active chat
	      if (!this.appBlurred && this.store.get("active_chat") === message.room) {
	        return false;
	      }
	
	      // Private chats are the only ones that have a setting that take precedence over the globalNotificationSetting
	      if (_utils2.default.jid.is_private_chat(message.room)) {
	        return preferences.notifyForPrivate;
	      }
	
	      // See if this room has an override, else use the global setting
	      overrides = preferences.roomNotificationOverrides || {};
	      roomOverrides = overrides[message.room] || {};
	      notification_level = _.get(roomOverrides, "level", _preferences_store2.default.getGlobalNotificationSetting());
	
	      if (message.x) {
	        var x = _.head(_utils2.default.toArray(message.x));
	        var notify = _.get(x, 'notify');
	        var type = _.get(x, 'type');
	        var hasMention = message.body.search(this.store.get('mentionRegexMe')) !== -1;
	
	        if (notify === '0' && (type !== 'system' || !hasMention)) {
	          return false;
	        }
	      }
	
	      return this.shouldNotifyForLevel(notification_level, message);
	    }
	  }, {
	    key: 'shouldNotifyForLevel',
	    value: function shouldNotifyForLevel(level, message) {
	      var isFormatted = _utils2.default.isFormattedMessage(message);
	
	      var hasJustMeMention = message.body.search(this.store.get('mentionRegexJustMe')) !== -1;
	      var hasMention = message.body.search(this.store.get('mentionRegexMe')) !== -1;
	
	      switch (level) {
	        case "quiet":
	          return !isFormatted && hasJustMeMention;
	        case "normal":
	          return !isFormatted && hasMention;
	        case "loud":
	          return true;
	        default:
	          return false;
	      }
	    }
	  }, {
	    key: 'getMessageSenderObject',
	    value: function getMessageSenderObject(message) {
	      var jid = void 0,
	          name = void 0,
	          sender = {},
	          roster = this.store.get('roster');
	
	      // If history message, use from_jid in delay node as it is first source of truth
	      if (message.delay && message.delay.from_jid) {
	        jid = _utils2.default.jid.bare_jid(message.delay.from_jid);
	
	        // Fallback if the sender name is not defined
	        sender = roster[jid] || {
	          id: _utils2.default.jid.user_id(jid),
	          name: _utils2.default.jid.resource(message.from)
	        };
	
	        // If message.from is a user's jid, use it
	      } else if (_utils2.default.jid.is_private_chat(message.from)) {
	          jid = _utils2.default.jid.bare_jid(message.from);
	          sender = roster[jid] || { id: _utils2.default.jid.user_id(jid) };
	
	          // That leaves room messages. First, prefer from_jid if available (will not exist
	          // in older BTF servers
	        } else if (message.from_jid) {
	            jid = _utils2.default.jid.bare_jid(message.from_jid);
	            sender = roster[jid] || { id: _utils2.default.jid.user_id(jid) };
	
	            // Finally, fallback to using the resource part of the from property
	            // This is prone to a security hole in which a user can impersonate another
	            // by using the same full name -- but should only be applicable for BTF instances
	            // where from_jid is not yet supported
	          } else if (message.from) {
	              name = _utils2.default.jid.resource(message.from);
	              sender = _.find(roster, { name: name }) || { name: name };
	            }
	      return {
	        name: sender.name ? sender.name : '',
	        mention_name: sender.mention_name ? sender.mention_name : '',
	        id: sender.id ? parseInt(sender.id, 10) : null
	      };
	    }
	  }, {
	    key: 'getMessageSender',
	    value: function getMessageSender(message) {
	      if (message.type === 'link') {
	        return 'Link';
	      }
	      return this.getMessageSenderObject(message).name;
	    }
	  }, {
	    key: 'getMessageSenderId',
	    value: function getMessageSenderId(message) {
	      return this.getMessageSenderObject(message).id;
	    }
	  }, {
	    key: 'getMessageSenderMention',
	    value: function getMessageSenderMention(message) {
	      return this.getMessageSenderObject(message).mention_name;
	    }
	  }, {
	    key: 'updateMessagesIfGuestsConnected',
	    value: function updateMessagesIfGuestsConnected(messages) {
	      var _this5 = this;
	
	      _.forEach(messages, function (message) {
	        if (!message.sender_mention) {
	          message.sender_mention = _this5.getMessageSenderMention(message);
	        }
	        _this5.formatMessageBody(message);
	      });
	    }
	  }, {
	    key: 'checkMessageForAction',
	    value: function checkMessageForAction(message, jid) {
	      var extra,
	          status = _.intersection(_.keys(message), this.store.local.chat_states),
	          active_rooms = this.store.get("activeRooms"),
	          current_user = this.store.get("current_user");
	
	      extra = message.x ? _utils2.default.toArray(message.x) : [{}];
	
	      var is_video_message = _.includes(['http://hipchat.com/protocol/enso', 'http://hipchat.com/protocol/addlive'], extra[0].xmlns) && !_utils2.default.isHistoryMessage(message);
	
	      if (is_video_message) {
	        return this.handleCallMessage(message, extra[0], extra[0].xmlns.split('/').pop());
	      } else if (message.type === 'error') {
	        _logger2.default.warn(message);
	        _app_dispatcher2.default.dispatch('error-message-received', message);
	        return true;
	      } else if (message.html && message.xhtml_im_body && !message.authenticated_file) {
	        var $markup = $('<div/>').append(_utils2.default.getFixedHtml(message.xhtml_im_body)),
	            $link = $('a[data-target-options="enso_invite"]', $markup);
	        if ($link.length) {
	          return true;
	        }
	      } else if (message.authenticated_file || message.file || extra[0].file) {
	
	        // Open OTO chat if chat is not open
	        if (this.isOneToOneChatClosed(message, jid, active_rooms)) {
	          _app_dispatcher2.default.dispatch('private-chat-invite-received', message);
	        }
	
	        this.addFile(jid, message);
	        return false;
	      } else if (message.replace) {
	        _app_dispatcher2.default.dispatch('replacement-message-received', {
	          jid: jid,
	          edited_message: message.body,
	          mid: message.mid,
	          replace: message.replace,
	          is_deleted: message.replace && message.body === ""
	        });
	      } else if (message.x && message.x.is_archived && !message.body && !_utils2.default.isHistoryMessage(message)) {
	        if (parseInt(message.x.is_archived)) {
	          _app_dispatcher2.default.dispatch('room-archived', { jid: jid });
	        } else if (!parseInt(message.x.is_archived)) {
	          _app_dispatcher2.default.dispatch('room-unarchived', { jid: jid });
	        }
	        return false;
	      } else if (this.isCodeMessage(message) || this.isQuoteMessage(message) || this.isMonospaceMessage(message)) {
	
	        if (this.isOneToOneChatClosed(message, jid, active_rooms)) {
	          _app_dispatcher2.default.dispatch('private-chat-invite-received', message);
	        }
	        return false;
	      } else if (!extra[0].file && extra[0].type !== "system" && active_rooms[jid] && message.body && message.body.length && _link_utils2.default.get_urls_from_string(message.body)) {
	
	        this.addLinks(jid, message);
	        return false;
	      } else if (status.length && (!message.body || message.body.length === 0)) {
	        status = _.head(status);
	        _app_dispatcher2.default.dispatch('status-message-received', {
	          type: status,
	          message: message
	        });
	        return true;
	      } else if (_app_config2.default.slash_replacement_regex.test(message.body)) {
	        var arr = message.body.split('/');
	        _app_dispatcher2.default.dispatch('replacement-message-received', {
	          jid: jid,
	          sender_id: this.getMessageSenderId(message),
	          text_to_replace: arr[1],
	          replacement_text: arr[2],
	          time: message.time || parseFloat(message.ts),
	          mid: message.mid
	        });
	        return false;
	      } else if (extra[0].invite) {
	        var from = _.get(extra[0], 'invite.from', false);
	        if (from && _utils2.default.jid.bare_jid(from) === current_user.user_jid) {
	          var fromRoom = _utils2.default.jid.bare_jid(message.from);
	          _app_dispatcher2.default.dispatch('open-room', {
	            jid: fromRoom,
	            dontSelectRoom: true
	          });
	        } else {
	          var cb = function cb(err, room) {
	            if (room) {
	              _app_dispatcher2.default.dispatch('handle-cached-room', {
	                jid: room.jid,
	                name: room.name,
	                x: room
	              });
	            } else {
	              _logger2.default.error(['fetch-room'], err.message);
	            }
	            _app_dispatcher2.default.dispatch('groupchat-invite-received', message);
	          };
	          _app_dispatcher2.default.dispatch('fetch-room', message.from, cb);
	        }
	        return true;
	      } else if (this.isOneToOneChatClosed(message, jid, active_rooms) && message.body && message.body.length > 0) {
	        _app_dispatcher2.default.dispatch('private-chat-invite-received', message);
	        return false;
	      } else if (typeof extra[0].guest_url !== 'undefined' && !_utils2.default.isHistoryMessage(message)) {
	        _app_dispatcher2.default.dispatch('guest-access-changed', {
	          jid: jid,
	          url: extra[0].guest_url
	        });
	        return false;
	      }
	    }
	  }, {
	    key: 'handleCallMessage',
	    value: function handleCallMessage(message, extra, service) {
	      var evt_map = {
	        call: 'invite-to-audio-video-call',
	        accept: 'audio-video-call-accepted',
	        decline: 'audio-video-call-declined',
	        hangup: 'audio-video-call-hung-up'
	      },
	          sender = {
	        jid: message.from,
	        id: this.getMessageSenderId(message),
	        name: this.getMessageSender(message)
	      },
	          current_user = this.store.get("current_user"),
	          commonKeys = _.intersection(_.keys(extra), _.keys(evt_map)),
	          type = _.head(commonKeys),
	          evt = evt_map[type];
	      if (message.type === 'error' && service === _video_call_strings2.default.ENSO) {
	        _.assign(message, {
	          body: _.get(message, 'error.text', '').toString(),
	          from: 'HipChat',
	          sender: _utils2.default.getSenderFromMeta(),
	          type: 'system',
	          color: 'gray'
	        });
	        return !message.body;
	      } else if (evt && message.from !== current_user.user_jid || evt === 'audio-video-hangup') {
	        _app_dispatcher2.default.dispatch(service + '.' + evt, {
	          message: message,
	          sender: sender
	        });
	      }
	      return true;
	    }
	  }, {
	    key: 'setMessageColor',
	    value: function setMessageColor(message) {
	      var current_user = this.store.get("current_user");
	
	      if (message.color || message.x && message.x.color) {
	        message.color = message.color || message.x.color;
	      } else if (message.sender_id === current_user.user_id || message.delay && message.delay.from_jid === current_user.user_jid || current_user.is_guest && message.sender_mention === current_user.mention) {
	        message.color = 'blue';
	      } else if (message.type === 'notification') {
	        message.color = 'gray';
	      } else {
	        message.color = 'nocolor';
	      }
	    }
	  }, {
	    key: 'isQuoteMessage',
	    value: function isQuoteMessage(message) {
	      if (_.get(message, 'format') === 'quotation') {
	        return true;
	      }
	
	      var formatIsText = false,
	          messageFormat = _.get(message, 'x.message_format'),
	          matchesRegex = _app_config2.default.quote_regex.test(message.body);
	
	      if (_.isUndefined(messageFormat) || messageFormat === 'text') {
	        formatIsText = true;
	      }
	
	      return formatIsText && matchesRegex;
	    }
	  }, {
	    key: 'isCodeMessage',
	    value: function isCodeMessage(message) {
	      if (_.get(message, 'format') === 'code') {
	        return true;
	      }
	
	      var formatIsText = false,
	          messageFormat = _.get(message, 'x.message_format'),
	          matchesRegex = _app_config2.default.code_regex.test(message.body);
	
	      if (_.isUndefined(messageFormat) || messageFormat === 'text') {
	        formatIsText = true;
	      }
	
	      return formatIsText && matchesRegex;
	    }
	  }, {
	    key: 'isMonospaceMessage',
	    value: function isMonospaceMessage(message) {
	      if (_.get(message, 'format') === 'monospace') {
	        return true;
	      }
	
	      var formatIsText = false,
	          messageFormat = _.get(message, 'x.message_format'),
	          matchesRegex = _app_config2.default.pre_regex.test(message.body);
	
	      if (_.isUndefined(messageFormat) || messageFormat === 'text') {
	        formatIsText = true;
	      }
	
	      return formatIsText && matchesRegex;
	    }
	  }, {
	    key: 'formatQuoteMessage',
	    value: function formatQuoteMessage(message) {
	      _.assign(message, {
	        original_body: message.body,
	        body: message.body.replace(_app_config2.default.quote_regex, ''),
	        format: 'quotation'
	      });
	    }
	  }, {
	    key: 'formatCodeMessage',
	    value: function formatCodeMessage(message) {
	      _.assign(message, {
	        original_body: message.body,
	        body: message.body.replace(_app_config2.default.code_regex, ''),
	        format: 'code'
	      });
	    }
	  }, {
	    key: 'formatMonospaceMessage',
	    value: function formatMonospaceMessage(message) {
	      _.assign(message, {
	        original_body: message.body,
	        body: message.body.replace(_app_config2.default.pre_regex, ''),
	        format: 'monospace'
	      });
	    }
	  }, {
	    key: 'setMessageTypeAndFormat',
	    value: function setMessageTypeAndFormat(message) {
	      var type = message.x ? _.compact(_.map(_utils2.default.toArray(message.x), 'type'))[0] : message.type,
	          format = message.x ? _.compact(_.map(_utils2.default.toArray(message.x), 'message_format'))[0] : message.format;
	
	      if (message.subject || type === 'topic') {
	        message.type = 'info';
	      } else if (this.handleInfoMessage(message)) {
	        _.assign(message, {
	          type: 'info',
	          sender: ' ',
	          color: 'nocolor'
	        });
	      } else if (type === 'system' || type === 'notification') {
	        message.type = 'notification';
	        if (this.isQuoteMessage(message)) {
	          return this.formatQuoteMessage(message);
	        } else if (this.isCodeMessage(message)) {
	          return this.formatCodeMessage(message);
	        } else if (this.isMonospaceMessage(message)) {
	          return this.formatMonospaceMessage(message);
	        }
	      } else if (type === 'room-presence') {
	        message.type = 'info';
	        message.is_presence_message = true;
	      } else if (type === 'missed-call') {
	        message.type = 'info';
	        message.is_missed_call_message = true;
	      } else if (message.authenticated_file || message.file) {
	        var file = message.authenticated_file || message.file;
	        message.type = 'file';
	        message.body = file.desc || message.body || '';
	        format = 'text';
	      } else if (message.x && typeof message.x.file !== 'undefined') {
	        message.type = 'file';
	        message.body = _.get(message, 'x.file.desc') || message.body || '';
	      } else if (type === 'user_state') {
	        message.format = 'html';
	      } else if (message.xhtml_im_body) {
	        message.format = 'html';
	        message.type = 'notification';
	      } else if (!_.isUndefined(message.body)) {
	        message.type = 'message';
	        message.body = message.body.toString();
	        if (this.isQuoteMessage(message)) {
	          return this.formatQuoteMessage(message);
	        } else if (this.isCodeMessage(message)) {
	          return this.formatCodeMessage(message);
	        } else if (this.isMonospaceMessage(message)) {
	          return this.formatMonospaceMessage(message);
	        }
	      }
	      message.format = format || 'text';
	
	      if (message.format === 'html') {
	        if (message.xhtml_im_body) {
	          message.xhtml_im_body = _utils2.default.getFixedHtml(message.xhtml_im_body);
	        } else {
	          message.body = _utils2.default.getFixedHtml(message.body);
	        }
	      }
	    }
	  }, {
	    key: 'setMessageSenderAndAvatar',
	    value: function setMessageSenderAndAvatar(message, sender) {
	      if (sender) {
	        var avatar = this.getNotificationAvatar(sender);
	        if (avatar) {
	          message.sender_avatar = avatar;
	        }
	        message.notification_sender = sender;
	      }
	    }
	  }, {
	    key: 'processMessageMetadata',
	    value: function processMessageMetadata(message) {
	      var messageMetadata = _.get(message.card, 'metadata', {});
	
	      if (message.notification_sender && message.notification_sender.type === "addon") {
	        messageMetadata.sender_addon_key = message.notification_sender.id;
	      }
	
	      message.metadata = messageMetadata;
	
	      if (message.metadata.sender_addon_key) {
	        var payload = _integration_helper2.default.extractIntegrationParametersFromMessage(message);
	        var spec = { addon_key: message.notification_sender.id };
	
	        _app_dispatcher2.default.dispatch("integration-iframe-event", _api_integration_events.MESSAGE_RECEIVED, spec, payload);
	      }
	    }
	  }, {
	    key: 'handleInfoMessage',
	    value: function handleInfoMessage(message) {
	      if (message.x && !message.body) {
	        if (message.x.is_archived) {
	          message.body = _chat_panel_strings2.default.user_changed_archive_status(this.getMessageSender(message), parseInt(message.x.is_archived) ? _chat_panel_strings2.default.archived : _chat_panel_strings2.default.unarchived);
	          return true;
	        } else if (typeof message.x.guest_url !== 'undefined') {
	          message.body = _chat_panel_strings2.default.user_changed_guest_access(this.getMessageSender(message), message.x.guest_url ? _chat_panel_strings2.default.turned_on : _chat_panel_strings2.default.turned_off);
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'addLinks',
	    value: function addLinks(jid, message) {
	      var _this6 = this;
	
	      if (message.ts && !this.isCodeMessage(message) && !this.isMonospaceMessage(message)) {
	        (function () {
	          var sender = _this6.getMessageSender(message);
	          var urls = _link_utils2.default.get_urls_from_string(message.body);
	          urls.forEach(function (url) {
	            url = _link_utils2.default.wrapped_url_fix(message.body, url);
	            if (_link_utils2.default.url_should_be_replaced(message.body, url)) {
	              var link = _link_utils2.default.create_link_object(jid, message.ts, url, sender);
	              _app_dispatcher2.default.dispatch("add-link-from-message", {
	                room: jid,
	                link: link
	              });
	            }
	          });
	        })();
	      }
	    }
	  }, {
	    key: 'addFile',
	    value: function addFile(jid, message) {
	      if (message.ts) {
	        var sender = this.getMessageSender(message),
	            fileModel = _file2.default.fromMessageObject(message),
	            fileObject = _utils2.default.file.create_file_object(jid, fileModel, message.ts, sender);
	
	        if (fileObject) {
	          _app_dispatcher2.default.dispatch("add-file-from-message", {
	            room: jid,
	            file: fileObject
	          });
	        }
	      }
	    }
	
	    /*
	     addXHTML(message) {
	     var xhtml,
	     $xhtml = $(this.mdParser.render(message.text));
	     $xhtml.is('p') ? xhtml = $xhtml.prop('innerHTML') : xhtml = $('<div/>').append($xhtml).html();
	     if ($xhtml.children().length) {
	     message.xhtml = xhtml;
	     }
	     return message;
	     }
	     */
	
	  }, {
	    key: 'getAvatar',
	    value: function getAvatar(id) {
	      if (!id) {
	        return false;
	      }
	      var roster = this.store.get("roster"),
	          user = _.find(roster, function (item) {
	        return String(item.id) === String(id);
	      });
	      return user ? user.photo_url : '';
	    }
	  }, {
	    key: 'processCard',
	    value: function processCard(card) {
	      if (!_.isString(card)) {
	        return false;
	      }
	      try {
	        var cardObj = JSON.parse(card);
	        if (_.has(cardObj, 'activity.html')) {
	          cardObj.activity.html = this.substituteMentionTagsForHtml(cardObj.activity.html);
	        }
	        return cardObj;
	      } catch (err) {
	        _logger2.default.error("Error trying to render a card", err);
	        return false;
	      }
	    }
	  }, {
	    key: 'getNotificationAvatar',
	    value: function getNotificationAvatar(sender) {
	      if (!sender) {
	        return false;
	      }
	      var type = sender.type;
	
	      if (type === 'user') {
	        return this.getAvatar(_utils2.default.jid.user_id(sender.id));
	      }
	
	      return false;
	    }
	  }, {
	    key: 'getMentionTags',
	    value: function getMentionTags(message) {
	      return $("<div>" + message + "</div>").find("hc-mention");
	    }
	  }, {
	    key: 'substituteMentionTagsForHtml',
	    value: function substituteMentionTagsForHtml(messageText) {
	      var that = this;
	      this.getMentionTags(messageText).each(function () {
	        var mentionName = $(this).text();
	        var mentionNameWithTag = $('<hc-mention>').append($(this).clone()).html();
	        var mentionHtml = _utils2.default.escapeAndLinkify(mentionName, that.getMentionArguments());
	        messageText = messageText.replace(mentionNameWithTag, mentionHtml);
	      });
	      return messageText;
	    }
	  }, {
	    key: 'isOneToOneChatClosed',
	    value: function isOneToOneChatClosed(message, jid, active_rooms) {
	      var roster = this.store.get("roster");
	      return !active_rooms[jid] && !message.is_user_sent && _utils2.default.jid.is_private_chat(jid) && roster[jid] && parseFloat(message.ts) >= roster[jid].closed_at;
	    }
	  }, {
	    key: 'isEnsoVideoHistoryMessage',
	    value: function isEnsoVideoHistoryMessage(message) {
	      var messageBody = _.get(message, 'message', '');
	
	      return message.message_format === 'html' && messageBody.indexOf('<a') !== -1 && messageBody.indexOf('data-target-options') !== -1 && messageBody.indexOf('enso_invite') !== -1 && messageBody.indexOf(_video_call_strings2.default.join_video_call_message) !== -1 && messageBody.indexOf('</a>') !== -1;
	    }
	  }]);
	  return MessageProcessor;
	}();
	
	module.exports = MessageProcessor;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  return Array.isArray(arr) ? arr : (0, _from2.default)(arr);
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	exports.getAuthenticatedFileUrl = getAuthenticatedFileUrl;
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getAuthenticatedFileUrl(id) {
	  var thumbnail = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  var api_host = _configuration_store2.default.get('api_host'),
	      thumb = thumbnail ? '?thumbnail=true' : '';
	  return 'https://' + api_host + '/v2/file/' + id + thumb;
	}
	
	/**
	 * @class File
	 *
	 * @property {number} id
	 * @property {string} name
	 * @property {string} desc
	 * @property {number} size
	 * @property {string} date
	 * @property {string} url
	 * @property {string} thumb_url
	 * @property {number} group_id
	 * @property {number} user_id
	 * @property {string} auth_scheme
	 *
	 * Derived properties
	 * @property {string} file_type
	 * @property {string} file_name
	 * @property {string} file_ext
	 * @property {string} file_size
	 * @property {boolean} is_authenticated
	 */
	
	var File = function () {
	
	  /**
	  * @constructs
	  * @param {object} input
	  * @param {string|null} input.id
	  * @param {string} input.name
	  * @param {string} input.desc
	  * @param {string|number} input.size
	  * @param {string} input.date
	  * @param {string|null} input.url
	  * @param {string|null} input.thumb_url
	  * @param {string|null} input.group_id
	  * @param {string|null} input.user_id
	  * @param {string|null} input.auth_scheme
	  * @param {boolean} input.is_authenticated
	  */
	
	  function File() {
	    var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	    (0, _classCallCheck3.default)(this, File);
	
	    this.id = input.id || null;
	    this.name = input.name || '';
	    this.desc = input.desc || '';
	    this.size = parseInt(input.size, 10) || 0;
	    this.date = input.date ? new Date(input.date) : '';
	    this.url = input.is_authenticated ? getAuthenticatedFileUrl(input.id, false) : input.url || null;
	    this.thumb_url = input.is_authenticated ? getAuthenticatedFileUrl(input.id, true) : input.thumb_url || null;
	    this.group_id = parseInt(input.group_id, 10) || null;
	    this.user_id = parseInt(input.user_id, 10) || null;
	    this.auth_scheme = input.auth_scheme || '';
	    this.is_authenticated = input.is_authenticated || false;
	
	    // Derive props
	    this.file_name = this.name.split('/').pop();
	    this.file_type = _utils2.default.file.get_file_type(this.name, true);
	    this.file_ext = _utils2.default.file.get_extension(this.name);
	    this.file_size = _utils2.default.file.get_size_string(this.size);
	
	    // Preview Thumb
	    this.preview_thumbnail = this.file_type === 'img' ? new Image() : null;
	  }
	
	  /**
	   * Takes a file node from a message stanza or IQ query result for a chat's files,
	   * and returns a File model. Example stanzas:
	   *
	   *  Legacy XMPP Message File Node
	   *
	   *  <message xmlns="jabber:client" type="groupchat"
	   *           from="1_example@conf.devvm.hipchat.com/Bob Test"
	   *           mid="96d28d5c-99ef-4e32-9b10-e56037fb826c" ts="1456172560.068233"
	   *           to="1_1@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222">
	   *    <body>File uploaded: https://s3.amazonaws.com/devuploads.hipchat.com/30/263/Lv6iCamVfouH9U3/dean_cain.jpg</body>
	   *    <x xmlns="http://hipchat.com/protocol/muc#room">
	   *      <file>
	   *        <name>30/263/Lv6iCamVfouH9U3/dean_cain.jpg</name>
	   *        <desc>test</desc>
	   *        <bucket>devuploads.hipchat.com</bucket>
	   *        <endpoint>s3.amazonaws.com</endpoint>
	   *        <size>12777</size>
	   *        <thumb>30/263/Lv6iCamVfouH9U3/dean_cain_thumb.jpg</thumb>
	   *        <thumb_url>https://s3.amazonaws.com/devuploads.hipchat.com/30/263/Lv6iCamVfouH9U3/dean_cain_thumb.jpg</thumb_url>
	   *        <file_url>https://s3.amazonaws.com/devuploads.hipchat.com/30/263/Lv6iCamVfouH9U3/dean_cain.jpg</file_url>
	   *      </file>
	   *    </x>
	   *    <delay from_jid="30_263@chat.devvm.hipchat.com" stamp="2016-01-04T22:28:11Z" xmlns="urn:xmpp:delay"/>
	   *  </message>
	   *
	   *  Legacy XMPP IQ File List Query
	   *
	   *  <iq from="1_1@chat.hipchat.com" id="1" type="result">
	   *    <query xmlns="http://hipchat.com/protocol/files">
	   *      <item>
	   *        <id>2</id>
	   *        <name>10803/29833/randomchars/lolwut.png</name>
	   *        <thumbnail>10803/29833/rnd/lolwut_thumb.png</thumbnail>
	   *        <bucket>downloads.hipchat.com</bucket>
	   *        <size>1803</size>
	   *        <desc>OMG LOLWUT</desc>
	   *        <group_id>10803</group_id>
	   *        <user_id>29833</user_id>
	   *        <date>2013-03-10T12:00:00Z</date>
	   *        <authenticated>0</authenticated>
	   *        <file_url>https://s3.amazonaws.com/devuploads.hipchat.com/10803/29833/rnd/lolwut.png</file_url>
	   *        <thumb_url>https://s3.amazonaws.com/devuploads.hipchat.com/10803/29833/rnd/lolwut_thumb.png</thumb_url>
	   *      </item>
	   *      <item>...</item>
	   *      <item>...</item>
	   *    </query>
	   *  </iq>
	   *
	   *  Signed XMPP File Node
	   *
	   *  <message>
	   *    <body>User description: https://api.hipchat.com/v2/file/file_id</body>
	   *    <delay xmlns="urn:xmpp:delay" from_jid="..." stamp="..."/>
	   *    <authenticated_file xmlns="http://hipchat.com/protocol/file">
	   *      <desc>User description</desc>
	   *      <id>7c2f5173-c9f9-4840-8471-eca32ab8151b</id>
	   *      <date>2013-03-10T12:00:00Z</date>
	   *      <name>filename.txt</name>
	   *      <size>12777</size>
	   *      <group_id>10803</group_id>
	   *      <user_id>29833</user_id>
	   *      <auth_scheme>bearer</auth_scheme>
	   *    </authenticated_file>
	   *    <x xmlns="...">
	   *      HipChat custom x element
	   *    </x>
	   *  </message>
	   *
	   *  Signed XMPP IQ File List Query
	   *
	   *   <iq from="1_1@chat.hipchat.com" id="1" type="result">
	   *     <query xmlns="http://hipchat.com/protocol/file">
	   *       <authenticated_file>
	   *         <id>7c2f5173-c9f9-4840-8471-eca32ab8151b</id>
	   *         <desc>User description</desc>
	   *         <date>2013-03-10T12:00:00Z</date>
	   *         <name>filename.txt</name>
	   *         <size>12777</size>
	   *         <group_id>10803</group_id>
	   *         <user_id>29833</user_id>
	   *         <auth_scheme>bearer</auth_scheme>
	   *       </authenticated_file>
	   *       <authenticated_file>...</authenticated_file>
	   *       <authenticated_file>...</authenticated_file>
	   *     </query>
	   *   </iq>
	   *
	   * @static
	   * @method fromXMPP
	   * @param xmpp - xml result from a iq or message
	   * @returns {File}
	   */
	
	
	  (0, _createClass3.default)(File, null, [{
	    key: 'fromXMPP',
	    value: function fromXMPP(file) {
	      var url, is_authenticated;
	
	      function queryContent(name) {
	        var defaultVal = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	        var node = file.querySelector(name);
	        return _.get(node, 'textContent', defaultVal);
	      }
	
	      // <authenticated_file> node has the secure file namespace or is in a <query> node that does
	      if (file.getAttribute('xmlns') === NS.HC_AUTHENTICATED_FILE || file.nodeName === 'authenticated_file') {
	        url = queryContent('url');
	        is_authenticated = true;
	      } else {
	        url = queryContent('file_url');
	        is_authenticated = false;
	      }
	
	      return new File({
	        id: queryContent('id'),
	        name: queryContent('name', ''),
	        desc: queryContent('desc', ''),
	        size: queryContent('size', 0),
	        date: new Date(queryContent('date', '')),
	        url: url,
	        thumb_url: queryContent('thumb_url', ''),
	        group_id: queryContent('group_id'),
	        user_id: queryContent('user_id'),
	        auth_scheme: queryContent('auth_scheme'),
	        is_authenticated: is_authenticated
	      });
	    }
	
	    /**
	    * Returns file model from the rest message representation. This is for fetching
	    * recent message history for a room via Coral.
	    *
	    * NOTE: This is not currently in use. It's here in anticipation of a Strophe
	    *       plugin implementation for messages.
	    *
	    * Legacy File
	    *
	    * {
	    *   "date": "2016-02-19T22:10:27.764729+00:00",
	    *   "file": {
	    *     "name": "IMG_1498.jpg",
	    *     "size": 1392206,
	    *     "thumb_url": "https://s3.amazonaws.com/devuploads.hipchat.com/1/2/XdKMxPuW12nbHyf/IMG_1498_thumb.jpg",
	    *     "url": "https://s3.amazonaws.com/devuploads.hipchat.com/1/2/XdKMxPuW12nbHyf/IMG_1498.jpg"
	    *   },
	    *   "from": {
	    *     "id": 2,
	    *     "links": {
	    *       "self": "https://devvm.hipchat.com/v2/user/2"
	    *     },
	    *     "mention_name": "BobTest",
	    *     "name": "Bob Test",
	    *     "version": "VT20ETYG"
	    *   },
	    *   "id": "e089070f-6918-43bb-8868-eb9d65f225eb",
	    *   "mentions": [],
	    *   "message": "Here's that picture you wanted.",
	    *   "type": "message"
	    * }
	    *
	    * Signed File
	    *
	    * {
	    *   "date": "2016-02-19T22:10:27.764729+00:00",
	    *   "authenticated_file": {
	    *     "id": "7c2f5173-c9f9-4840-8471-eca32ab8151b",
	    *     "name": "IMG_1498.jpg",
	    *     "size": 1392206
	    *   },
	    *   "from": {
	    *     "id": 2,
	    *     "links": {
	    *       "self": "https://devvm.hipchat.com/v2/user/2"
	    *     },
	    *     "mention_name": "BobTest",
	    *     "name": "Bob Test",
	    *     "version": "VT20ETYG"
	    *   },
	    *   "id": "e089070f-6918-43bb-8868-eb9d65f225eb",
	    *   "mentions": [],
	    *   "message": "Here's that picture you wanted.",
	    *   "type": "message"
	    * }
	    *
	    * @static
	    * @method fromREST
	    * @param {object} json
	    * @returns {File}
	    */
	
	  }, {
	    key: 'fromREST',
	    value: function fromREST(json) {
	      var file = json.authenticated_file,
	          is_authenticated = true;
	
	      if (!file) {
	        file = json.file;
	        is_authenticated = false;
	      }
	
	      return new File({
	        id: file.id,
	        name: file.name,
	        desc: json.message,
	        size: file.size,
	        date: json.date,
	        url: file.url,
	        thumb_url: file.thumb_url,
	        is_authenticated: is_authenticated
	      });
	    }
	
	    /**
	     * Returns a file model from the XML2JSON representation of a message stanza
	     * received via XMPP or the JSON representation of a message fetched via Coral.
	     *
	     * NOTE: This is a temporary solution until a Strophe plugin is built to handle
	     *       processing messages which would use the `fromXMPP` and `fromREST` methods.
	     *
	     * Legacy FileModel:
	     *
	     * {
	     *   "date": "2016-02-19T22:10:27.764729+00:00",
	     *     "x": {
	     *       "xmlns": "http://hipchat.com/protocol/muc#room",
	     *       "file": {
	     *       "name": "30/263/Lv6iCamVfouH9U3/dean_cain.jpg",
	     *       "desc": "test",
	     *       "bucket": "devuploads.hipchat.com",
	     *       "endpoint": "s3.amazonaws.com",
	     *       "size": "12777",
	     *       "thumb": "30/263/Lv6iCamVfouH9U3/dean_cain_thumb.jpg",
	     *       "thumb_url": "https://s3.amazonaws.com/devuploads.hipchat.com/30/263/Lv6iCamVfouH9U3/dean_cain_thumb.jpg",
	     *       "file_url": "https://s3.amazonaws.com/devuploads.hipchat.com/30/263/Lv6iCamVfouH9U3/dean_cain.jpg"
	     *     }
	     *   }
	     *   "from": {
	     *     "id": 2,
	     *     "links": {
	     *       "self": "https://devvm.hipchat.com/v2/user/2"
	     *     },
	     *     "mention_name": "BobTest",
	     *     "name": "Bob Test",
	     *     "version": "VT20ETYG"
	     *   },
	     *   "id": "e089070f-6918-43bb-8868-eb9d65f225eb",
	     *   "mentions": [],
	     *   "message": "Here's that picture you wanted.",
	     *   "type": "message"
	     * }
	     *
	     * Signed FileModel:
	     *
	     * {
	     *   "date": "2016-02-19T22:10:27.764729+00:00",
	     *   "authenticated_file": {
	     *     "xmlns": "http://hipchat.com/protocol/muc#room",
	     *     "id": "7c2f5173-c9f9-4840-8471-eca32ab8151b",
	     *     "desc": "User description",
	     *     "id": "7c2f5173-c9f9-4840-8471-eca32ab8151b",
	     *     "date": "2013-03-10T12:00:00Z",
	     *     "name": "filename.txt",
	     *     "size": "12777",
	     *     "group_id": "10803",
	     *     "user_id": "29833",
	     *     "auth_scheme": "bearer"
	     *   }
	     *   "from": {
	     *     "id": 2,
	     *     "links": {
	     *       "self": "https://devvm.hipchat.com/v2/user/2"
	     *     },
	     *     "mention_name": "BobTest",
	     *     "name": "Bob Test",
	     *     "version": "VT20ETYG"
	     *   },
	     *   "id": "e089070f-6918-43bb-8868-eb9d65f225eb",
	     *   "mentions": [],
	     *   "message": "Here's that picture you wanted.",
	     *   "type": "message"
	     * }
	     *
	     * @static
	     * @method fromMessageObject
	     * @param {object} msg
	     * @returns {File}
	     */
	
	  }, {
	    key: 'fromMessageObject',
	    value: function fromMessageObject(msg) {
	      var file = msg.authenticated_file,
	          url,
	          desc,
	          is_authenticated;
	
	      // Secure file
	      if (file) {
	        url = file.url;
	        is_authenticated = true;
	
	        // Legacy file
	      } else {
	          // via XMPP
	          if (msg.x) {
	            file = Array.isArray(msg.x) ? msg.x[0].file : msg.x.file;
	            url = file.file_url;
	            // via API
	          } else {
	              file = msg.file;
	              url = file.url;
	            }
	          is_authenticated = false;
	        }
	
	      // Use the file desc for XMPP
	      if (file.desc !== undefined && !msg.replace) {
	        desc = file.desc || '';
	
	        // Use the message body for REST
	      } else {
	          desc = msg.body || msg.message;
	        }
	
	      return new File({
	        id: file.id,
	        name: file.name,
	        desc: desc,
	        size: file.size,
	        date: file.date || msg.date,
	        url: url,
	        thumb_url: file.thumb_url,
	        group_id: file.group_id,
	        user_id: file.user_id,
	        auth_scheme: file.auth_scheme,
	        is_authenticated: is_authenticated
	      });
	    }
	  }]);
	  return File;
	}();

	exports.default = File;

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _assign = __webpack_require__(148);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Global actions intended for non react managed actions like mention clicks, etc.
	 * @module actions/AppActions
	 */
	module.exports = {
	
	  /**
	   * Opens a chat based on an HTML element with a data-mention-name attribute.
	   * Used primarily to allow hyperlinks to open a 1-1 chat by mention name.
	   * @param {HTMLAnchorElement} target Hyperlink
	   * @param {Attr} target.dataset.mentionName HipChat registered @-mention name of user
	   */
	  openChatByMentionName: function openChatByMentionName(target) {
	    var mentionName = typeof target === 'string' ? target : target.dataset.mentionName;
	    _app_dispatcher2.default.dispatch('open-chat-by-mention-name', mentionName);
	    _analytics_actions2.default.chatRoomMentionClicked();
	  },
	
	  /**
	   * Open a chat by JID
	   * @param data
	   */
	  openChatByJID: function openChatByJID(data) {
	    _app_dispatcher2.default.dispatch('set-route', { jid: data.jid });
	    data.source = "jid";
	    _analytics_dispatcher2.default.dispatch('analytics-open-room', data);
	  },
	
	  /**
	   * Set route by JID
	   * @param jid
	   */
	  navigateToChat: function navigateToChat(jid) {
	    if (jid) {
	      _app_dispatcher2.default.dispatch('set-route', {
	        jid: jid
	      });
	    }
	  },
	
	  restoreRoomOrder: function restoreRoomOrder(jid) {
	    _app_dispatcher2.default.dispatch('restore-room-order', {
	      jid: jid
	    });
	  },
	
	
	  /**
	   * Add file to the chat input for uploading via fileUrl
	   * @param fileUrl
	   * @param source dragndrop or paste
	   */
	  addFileForUploadWithUrl: function addFileForUploadWithUrl(fileUrl, source) {
	    if (fileUrl) {
	      _app_dispatcher2.default.dispatch('add-file-for-upload-with-url', {
	        fileUrl: fileUrl,
	        source: source
	      });
	    }
	  },
	
	  /**
	   * Add file to the chat input for uploading via base64
	   * @param base64 valid base64 string
	   * @param fileName
	   * @param source dragndrop or paste
	   */
	  addFileForUploadWithBase64: function addFileForUploadWithBase64(base64, fileName, source) {
	    if (base64) {
	      _app_dispatcher2.default.dispatch('add-file-for-upload-with-base64', {
	        base64: base64,
	        fileName: fileName,
	        source: source
	      });
	    }
	  },
	
	  /**
	   * Request addLive credentials from the server
	   * @param jid
	   * @param callback
	   */
	  requestAddLiveCredentials: function requestAddLiveCredentials(jid, callback) {
	    _app_dispatcher2.default.dispatch('request-addlive-credentials', { jid: jid }, callback);
	  },
	
	  /**
	   * Analytics event
	   * @private
	   */
	  logoClicked: function logoClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.logo.clicked"
	    });
	  },
	
	  /**
	   * Enables an "experimental" feature in a way that can be triggered by Optimizely.  This will be added to the
	   * features map on the hc.config object
	   *
	   * @param {String} featureName the name of the feature to enable
	   * @param {String} user_jid user jid
	   */
	  enableDarkFeature: function enableDarkFeature(featureName, user_jid) {
	    _app_dispatcher2.default.dispatch("enable-dark-feature", { name: featureName });
	
	    var analyticsData = {
	      name: "hipchat.client.darkfeature.enabled",
	      feature: featureName,
	      user_jid: user_jid
	    };
	    _analytics_dispatcher2.default.dispatch("analytics-event", analyticsData);
	  },
	
	  clearWebCookies: function clearWebCookies(cb) {
	    _app_dispatcher2.default.dispatch("clear-web-cookies", cb);
	  },
	
	  revokeOauth2Token: function revokeOauth2Token(cb) {
	    _app_dispatcher2.default.dispatch("revoke-oauth2-token", cb);
	  },
	
	  /**
	   * Requests room participants from API v2.
	   */
	  fetchRoomParticipants: function fetchRoomParticipants(room, includeOffline) {
	    _app_dispatcher2.default.dispatch("fetch-room-participants", room, includeOffline);
	  },
	
	  /**
	   * Logs user out of /chat
	   */
	  signout: function signout() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.profile.signout.clicked"
	    });
	    _app_dispatcher2.default.dispatch('signout');
	  },
	
	  logInToAnotherTeam: function logInToAnotherTeam() {
	    _analytics_actions2.default.logInToAnotherTeamClicked();
	    _spi2.default.onLogInToAnotherTeam();
	  },
	
	  showNotification: function showNotification() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    if (_preferences_store2.default.shouldIssueNotification()) {
	      var notification_types = (0, _assign2.default)({}, _preferences_store2.default.getNotificationTypes(), options.notification_types);
	      options.notification_types = notification_types;
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      _spi2.default.onNotification.apply(_spi2.default, [options].concat(args));
	    }
	  },
	
	  updateTotalUnreadCount: function updateTotalUnreadCount() {
	    _spi2.default.onTotalUnreadCountUpdate.apply(this, arguments);
	  },
	
	  openExternalWindow: function openExternalWindow() {
	    _spi2.default.openExternalWindow.apply(_spi2.default, arguments);
	  },
	
	  dismissReadOnlyModal: function dismissReadOnlyModal() {
	    _app_dispatcher2.default.dispatch('dismiss-read-only-modal');
	  }
	
	};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _analytics_keys = __webpack_require__(197);
	
	var _analytics_keys2 = _interopRequireDefault(_analytics_keys);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  successfulAuthEvent: function successfulAuthEvent(jid, token) {
	    _analytics_dispatcher2.default.dispatch("analytics-initial-auth-done", { jid: jid, token: token });
	  },
	  inviteTeamClickedEvent: function inviteTeamClickedEvent(source) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.' + source + '.invite.team.clicked'
	    });
	  },
	  inviteUserToRoomClickedEvent: function inviteUserToRoomClickedEvent(source) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.' + source + '.invite.user.to.room.clicked'
	    });
	  },
	  createRoomClickedEvent: function createRoomClickedEvent(source) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.' + source + '.create.room.clicked'
	    });
	  },
	  connectDialogLinkClickedEvent: function connectDialogLinkClickedEvent(addon_key) {
	    _analytics_dispatcher2.default.dispatch('analytics-connect-dialog-click', { addon_key: addon_key });
	  },
	  connectDialogClosedEvent: function connectDialogClosedEvent(addon_key) {
	    _analytics_dispatcher2.default.dispatch('analytics-connect-dialog-close', { addon_key: addon_key });
	  },
	  newChatButtonClicked: function newChatButtonClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.top.new.chat.button.clicked'
	    });
	  },
	  failedMessageRetried: function failedMessageRetried() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.queued.retry'
	    });
	  },
	  failedMessageCanceled: function failedMessageCanceled() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.queued.cancel'
	    });
	  },
	  lobbyRoomNavItemClicked: function lobbyRoomNavItemClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.left.navigation.lobby.clicked'
	    });
	  },
	  lobbyNoResults: function lobbyNoResults(query) {
	    if (query && query.length) {
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: 'hipchat.client.lobby.noresults',
	        properties: {
	          queryLength: query.length
	        }
	      });
	    }
	  },
	  lobbyFocusedWithKeyboardShortcut: function lobbyFocusedWithKeyboardShortcut() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.keyboard.navigation.lobby.selected'
	    });
	  },
	  quickSwitcherNoResults: function quickSwitcherNoResults(query) {
	    if (query && query.length) {
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: 'hipchat.client.switcher.noresults',
	        properties: {
	          queryLength: query.length
	        }
	      });
	    }
	  },
	  quickSwitcherViewed: function quickSwitcherViewed() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.switcher.viewed'
	    });
	  },
	  logInToAnotherTeamClicked: function logInToAnotherTeamClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.multiorg.account.another_team.clicked'
	    });
	  },
	  fileUploadRequested: function fileUploadRequested(fileType, roomType, source) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.file.uploaded.' + roomType,
	      properties: {
	        fileType: fileType,
	        source: source
	      }
	    });
	  },
	  roomNotificationIconClicked: function roomNotificationIconClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.room.notifications.icon.clicked'
	    });
	  },
	  hideGifsClicked: function hideGifsClicked(oldVal, newVal) {
	    _analytics_dispatcher2.default.dispatch('analytics-hide-gifs', {
	      oldVal: oldVal,
	      newVal: newVal
	    });
	  },
	  privateRoomNotificationClicked: function privateRoomNotificationClicked(oldVal, newVal) {
	    _analytics_dispatcher2.default.dispatch('analytics-room-notification-setting', {
	      name: "hipchat.client.settings.notifications.privateroom",
	      props: {
	        oldVal: oldVal,
	        newVal: newVal
	      }
	    });
	  },
	  openRoomNotificationClicked: function openRoomNotificationClicked(oldVal, newVal) {
	    _analytics_dispatcher2.default.dispatch('analytics-room-notification-setting', {
	      name: "hipchat.client.settings.notifications.openroom",
	      props: {
	        oldVal: oldVal,
	        newVal: newVal
	      }
	    });
	  },
	  lightThemeSelected: function lightThemeSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.theme.light'
	    });
	  },
	  darkThemeSelected: function darkThemeSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.theme.dark'
	    });
	  },
	  tighterTextDensitySelected: function tighterTextDensitySelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.textdensity.tighter'
	    });
	  },
	  normalTextDensitySelected: function normalTextDensitySelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.textdensity.normal'
	    });
	  },
	  classicChatViewSelected: function classicChatViewSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.chatview.classic'
	    });
	  },
	  classicNeueChatViewSelected: function classicNeueChatViewSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.chatview.classicneue'
	    });
	  },
	  fullNamesNameDisplaySelected: function fullNamesNameDisplaySelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.namedisplay.fullnames'
	    });
	  },
	  mentionNamesNameDisplaySelected: function mentionNamesNameDisplaySelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.namedisplay.mentionname'
	    });
	  },
	  animatedAvatarsSelected: function animatedAvatarsSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.avatars.animated'
	    });
	  },
	  staticAvatarsSelected: function staticAvatarsSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.avatars.static'
	    });
	  },
	  generalSettingsPanelSelected: function generalSettingsPanelSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.general.clicked'
	    });
	  },
	  notificationsSettingsPanelSelected: function notificationsSettingsPanelSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.notifications.clicked'
	    });
	  },
	  appearanceSettingsPanelSelected: function appearanceSettingsPanelSelected() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.settings.appearance.clicked'
	    });
	  },
	  roomNotificationDropdownClicked: function roomNotificationDropdownClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.room.notifications.dropdown.clicked'
	    });
	  },
	  roomNotificationLevelChanged: function roomNotificationLevelChanged(oldValue, newValue) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.room.notifications.level.changed',
	      properties: {
	        oldValue: oldValue,
	        newValue: newValue
	      }
	    });
	  },
	  globalNotificationLevelChanged: function globalNotificationLevelChanged(oldValue, newValue) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.global.notifications.level.changed',
	      properties: {
	        oldValue: oldValue,
	        newValue: newValue
	      }
	    });
	  },
	  handleLaunchToActiveChatList: function handleLaunchToActiveChatList(data) {
	    _analytics_dispatcher2.default.dispatch('performance-timing:analytics-launch-to-active-chat-list', {
	      size: _.get(data, "size")
	    });
	  },
	  handleLaunchToChat: function handleLaunchToChat(data) {
	    _analytics_dispatcher2.default.dispatch('performance-timing:analytics-launch-to-chat', {
	      size: _.get(data, "size")
	    });
	  },
	  handleLaunchToChatComplete: function handleLaunchToChatComplete(data) {
	    _analytics_dispatcher2.default.dispatch('performance-timing:analytics-launch-to-chat-complete', {
	      jid: _.get(data, "jid"),
	      id: _.get(data, "id")
	    });
	  },
	  roomIntegrationsDropdownClicked: function roomIntegrationsDropdownClicked(hasWarningIcon) {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.room.integrations.dropdown.clicked',
	      properties: {
	        hasWarningIcon: hasWarningIcon
	      }
	    });
	  },
	  roomIntegrationsLinkClicked: function roomIntegrationsLinkClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.room.integrations.link.clicked'
	    });
	  },
	  roomIntegrationsGlanceClicked: function roomIntegrationsGlanceClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.room.integrations.glance.clicked'
	    });
	  },
	  roomIntegrationsGlanceDismissed: function roomIntegrationsGlanceDismissed() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.room.integrations.glance.dismissed'
	    });
	  },
	  tryToReconnectFromHeader: function tryToReconnectFromHeader() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.reconnection.header.try.again.button.clicked'
	    });
	  },
	  connectionUIStateOffline: function connectionUIStateOffline() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.connection.ui.offline'
	    });
	  },
	  connectionUIStateConnecting: function connectionUIStateConnecting() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.connection.ui.connecting'
	    });
	  },
	  connectionUIStateConnectDelay: function connectionUIStateConnectDelay() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.connection.ui.connectdelay'
	    });
	  },
	  connectionUIStateCannotConnect: function connectionUIStateCannotConnect() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.connection.ui.cannotconnect'
	    });
	  },
	  editProfileClicked: function editProfileClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.top.navigation.profile.editProfile.clicked'
	    });
	  },
	  searchInputClicked: function searchInputClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.search.clicked'
	    });
	  },
	  searchInputSubmitted: function searchInputSubmitted(jidOrId) {
	    var type = void 0;
	    if (_utils2.default.jid.is_chat(jidOrId)) {
	      type = _utils2.default.room.detect_chat_type(jidOrId);
	    } else if (_utils2.default.jid.is_lobby(jidOrId) || jidOrId === 'all') {
	      type = 'all';
	    } else if (jidOrId) {
	      if (jidOrId === "muc") {
	        type = 'allroom';
	      } else if (jidOrId === "1-1") {
	        type = 'allpeople';
	      } else if (jidOrId.indexOf('rid') === 0) {
	        type = 'groupchat';
	      } else if (jidOrId.indexOf('uid') === 0) {
	        type = 'chat';
	      }
	    }
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.search.submit',
	      properties: {
	        type: type
	      }
	    });
	  },
	  chatRoomMentionClicked: function chatRoomMentionClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.chat.room.mention.clicked'
	    });
	  },
	  inviteToRoomRightSidebarClicked: function inviteToRoomRightSidebarClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.lobby.invite.room.righticon.clicked'
	    });
	  },
	  roomMenuInviteClicked: function roomMenuInviteClicked() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.lobby.room.menu.invite.clicked'
	    });
	  },
	  inviteUsersToRoomSent: function inviteUsersToRoomSent(type, numInvites) {
	    var event = void 0;
	
	    if (type === _analytics_keys2.default.ROOM_MENU) {
	      event = 'hipchat.client.lobby.room.menu.invite.sent';
	    }
	
	    if (type === _analytics_keys2.default.RIGHT_SIDEBAR) {
	      event = 'hipchat.client.lobby.invite.room.righticon.sent';
	    }
	
	    if (event) {
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: event,
	        properties: {
	          numInvites: numInvites
	        }
	      });
	    }
	  },
	  inviteTeamSent: function inviteTeamSent(type, numInvites) {
	    var event = void 0;
	    if (type === _analytics_keys2.default.LOBBY) {
	      event = 'hipchat.client.lobby.invite.sent';
	    } else if (_analytics_keys2.default.TOP === type || _analytics_keys2.default.LEFT === type) {
	      event = 'hipchat.client.' + type + '.navigation.invite.team.sent';
	    }
	    if (event) {
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: event,
	        properties: {
	          numInvites: numInvites
	        }
	      });
	    }
	  },
	  slashCommandUsed: function slashCommandUsed(_ref) {
	    var room = _ref.room;
	    var slashUsed = _ref.slashUsed;
	
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.slash.used',
	      properties: {
	        slashUsed: slashUsed,
	        room: room
	      }
	    });
	  },
	  slashCommandUsedInAutocomplete: function slashCommandUsedInAutocomplete(_ref2) {
	    var room = _ref2.room;
	    var slashUsed = _ref2.slashUsed;
	
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.slash.used.autocompleted',
	      properties: {
	        slashUsed: slashUsed,
	        room: room
	      }
	    });
	  },
	  userInviteURLCopied: function userInviteURLCopied() {
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.user.inviteURL.copied'
	    });
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AnalyticsKeys = (0, _freeze2.default)({
	    ROOM_MENU: 'room-menu',
	    RIGHT_SIDEBAR: 'right-sidebar',
	    LOBBY: 'lobby',
	    INVITE_USERS_DIALOG: 'invite_users_dialog',
	    QUICK_SWITCHER: 'quick_switcher',
	    LEFT: 'left',
	    TOP: 'top'
	});
	
	exports.default = AnalyticsKeys;
	module.exports = exports['default'];

/***/ },
/* 198 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var DIALOG_CLICK = exports.DIALOG_CLICK = 'dialog-button-click';
	var DIALOG_FILTER_CHANGED = exports.DIALOG_FILTER_CHANGED = 'dialog-filter-changed';
	var RECEIVE_PARAMETERS = exports.RECEIVE_PARAMETERS = 'receive-parameters';
	var GLANCE_UPDATE = exports.GLANCE_UPDATE = 'glance-update';
	var MESSAGE_RECEIVED = exports.MESSAGE_RECEIVED = 'message-received';

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _general_error_helper = __webpack_require__(200);
	
	var _general_error_helper2 = _interopRequireDefault(_general_error_helper);
	
	var _config_actions = __webpack_require__(159);
	
	var _config_actions2 = _interopRequireDefault(_config_actions);
	
	var _configuration_model = __webpack_require__(201);
	
	var _configuration_model2 = _interopRequireDefault(_configuration_model);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var IQProcessor = function () {
	  function IQProcessor(data) {
	    (0, _classCallCheck3.default)(this, IQProcessor);
	
	    var is_guest = _.get(data, 'is_guest', false);
	
	    this.deferredReady = function () {
	      return new _promise2.default(function (res) {
	        _app_dispatcher2.default.dispatch('app-state-ready');
	        res();
	      });
	    };
	
	    // Set instance variables
	    this.__reset();
	    this.storedRequiredStanzas = [];
	    this.requiredStanzas = [];
	    this.setRequiredStanzas(is_guest);
	  }
	
	  (0, _createClass3.default)(IQProcessor, [{
	    key: 'setRequiredStanzas',
	    value: function setRequiredStanzas(is_guest) {
	      var stanzas;
	      if (is_guest) {
	        stanzas = ['http://hipchat.com/protocol/emoticons'];
	      } else {
	        stanzas = ['jabber:iq:roster', 'http://jabber.org/protocol/disco#items', 'http://hipchat.com/protocol/emoticons'];
	      }
	      this.requiredStanzas = this.requiredStanzas.concat(stanzas);
	    }
	  }, {
	    key: 'addRequiredStartupStanza',
	    value: function addRequiredStartupStanza() {
	      this.requiredStanzas.unshift('http://hipchat.com/protocol/startup');
	    }
	
	    /**
	     * Handles an incoming IQ stanza.
	     *
	     * Must be called with processor instance context (bind, call, apply)
	     *
	     * @param iq_stanza The IQ stanza
	     * @param store The store to receive the stanza.
	     */
	
	  }, {
	    key: 'handleIQ',
	    value: function handleIQ(iq_stanza, store) {
	      var _this = this;
	
	      _.forEach(_utils2.default.toArray(iq_stanza), function (iq) {
	        if (iq.query) {
	          _this.handleOrStoreStanza(iq, store);
	        }
	      });
	    }
	  }, {
	    key: 'handleStanza',
	    value: function handleStanza(iq, store) {
	      switch (iq.query.xmlns) {
	        case 'jabber:iq:roster':
	          _logger2.default.debug('Roster Received', { verbose: iq });
	          if (_.has(iq, "query.item") && (iq.type !== 'set' || this.__isReady())) {
	            store.handleRoster(iq.query.item);
	          } else {
	            _logger2.default.debug('Roster Update Skipped', { verbose: iq });
	          }
	          break;
	        case 'http://jabber.org/protocol/disco#info':
	          var room = {
	            jid: iq.from,
	            name: _.get(iq, 'query.identity.name'),
	            x: _.get(iq, 'query.x')
	          };
	          store.handleRooms(room);
	          break;
	        case 'http://jabber.org/protocol/disco#items':
	          _logger2.default.debug('Rooms List Received', { verbose: iq });
	          if (_.has(iq, "query.item")) {
	            store.handleRooms(iq.query.item);
	          }
	          break;
	        case 'http://hipchat.com/protocol/profile':
	          store.handleProfile(iq);
	          break;
	        case 'http://hipchat.com/protocol/emoticons':
	          _logger2.default.debug('Emoticons Received', { verbose: iq });
	          if (_.has(iq, "query")) {
	            store.handleEmoticons(iq.query, iq.type);
	          }
	          break;
	        case 'http://hipchat.com/protocol/muc#room':
	          if (_.has(iq, "query.item") && (iq.type !== 'set' || this.__isReady())) {
	            store.determineRoomUpdate(iq.query.item);
	          }
	          break;
	        case 'http://hipchat.com/protocol/integrations':
	          this.__handleIntegrations(iq);
	          break;
	        case 'http://hipchat.com/protocol/integrations#ui':
	          this.__handleIntegrationsUiPush(iq);
	          break;
	        case 'http://hipchat.com/protocol/startup':
	          store.handleStartupIQAutoJoin([].concat(_.get(iq, 'query.preferences.autoJoin.item', [])));
	          _config_actions2.default.updateAppConfiguration(new _configuration_model2.default(iq.query));
	          _analytics_dispatcher2.default.dispatch("analytics-start-iq-response-received");
	          break;
	        default:
	          return true;
	      }
	    }
	
	    /**
	     * Handles or stores an IQ stanza depending on the init-state of the app.
	     *
	     * If a non-required IQ stanza arrives before all of the required stanzas have been processed,
	     * it is stored it temporarily.
	     *
	     * Once all {@link requiredStanzas} have arrived, we process the stanzas stored in {@link otherStanzas}.
	     *
	     * @param iq The IQ stanza to process.
	     * @param store The store to receive the stanza.
	     */
	
	  }, {
	    key: 'handleOrStoreStanza',
	    value: function handleOrStoreStanza(iq, store) {
	      if (this.allRequiredStanzasProcessed) {
	        this.handleStanza(iq, store);
	        return;
	      }
	
	      if (!this.allRequiredStanzasProcessed && _.includes(this.requiredStanzas, iq.query.xmlns) && _.get(iq, ['type']) !== 'set') {
	        if (iq.error) {
	          (0, _general_error_helper2.default)(iq);
	        } else {
	          this.storedRequiredStanzas.push(iq);
	
	          this.receivedRequiredStanzas[iq.query.xmlns] = true;
	          this.allRequiredStanzasProcessed = this.allRequiredStanzasArrived();
	
	          if (this.allRequiredStanzasProcessed) {
	            this.flushRequiredStanzas(store);
	            this.flushNonRequiredStanzas(store);
	            this.deferredReady().catch(function (e) {
	              _logger2.default.type('iq-processor').withCallStack().error(e);
	              _logger2.default.error(e);
	              _analytics_dispatcher2.default.dispatch("analytics-event", {
	                name: 'hipchat.client.load.error',
	                properties: {
	                  errorMessage: e.message,
	                  errorName: e.name,
	                  errorDescription: e.description,
	                  errorStack: e.stack
	                }
	              });
	            });
	          }
	        }
	      } else {
	        this.queueStanza(iq);
	      }
	    }
	
	    /**
	     * Processes all required stanzas which we've received in the proper order.
	     *
	     * @param store
	     */
	
	  }, {
	    key: 'flushRequiredStanzas',
	    value: function flushRequiredStanzas(store) {
	      var _this2 = this;
	
	      var handle = function handle(namespace) {
	        var stanza = _.find(_this2.storedRequiredStanzas, function (stnz) {
	          return _.get(stnz, ['query', 'xmlns']) === namespace;
	        });
	        _this2.handleStanza(stanza, store);
	        _.pull(_this2.storedRequiredStanzas, stanza);
	      };
	      _.every(this.requiredStanzas, function (namespace) {
	        if (namespace === 'http://hipchat.com/protocol/startup') {
	          _app_dispatcher2.default.registerOnce('after:updated:config', function () {
	            _.each(_this2.requiredStanzas, function (ns) {
	              handle(ns);
	            });
	          });
	          handle(namespace);
	          _.pull(_this2.requiredStanzas, namespace);
	          return false;
	        }
	        handle(namespace);
	        return true;
	      });
	    }
	
	    /**
	     * Processes all non-required stanzas which have built up before the app is ready.
	     *
	     * @param store
	     */
	
	  }, {
	    key: 'flushNonRequiredStanzas',
	    value: function flushNonRequiredStanzas(store) {
	      var _this3 = this;
	
	      _.each(this.otherStanzas, function (iq) {
	        _this3.handleStanza(iq, store);
	      });
	      this.otherStanzas = [];
	    }
	
	    /**
	     * Stores an IQ stanza to be processed later.
	     *
	     * @param iq
	     */
	
	  }, {
	    key: 'queueStanza',
	    value: function queueStanza(iq) {
	      this.otherStanzas.push(iq);
	    }
	
	    /**
	     * Returns true if all required stanzas have arrived.
	     * @returns {*}
	     */
	
	  }, {
	    key: 'allRequiredStanzasArrived',
	    value: function allRequiredStanzasArrived() {
	      var _this4 = this;
	
	      return _.every(this.requiredStanzas, function (stanza) {
	        return _this4.receivedRequiredStanzas[stanza];
	      });
	    }
	
	    /**
	     * Resets the IQProcessor to the initial state.
	     *
	     * Exposed for testing only.
	     *
	     * @private
	     */
	
	  }, {
	    key: '__reset',
	    value: function __reset() {
	      this.allRequiredStanzasProcessed = false;
	      this.receivedRequiredStanzas = {};
	      this.otherStanzas = [];
	      this.storedRequiredStanzas = [];
	      this.requiredStanzas = [];
	    }
	
	    /**
	     * Returns the current value of allRequiredStanzasProcessed.
	     *
	     * Exposed for testing only.
	     * @private
	     */
	
	  }, {
	    key: '__isReady',
	    value: function __isReady() {
	      return this.allRequiredStanzasProcessed;
	    }
	  }, {
	    key: '__handleIntegrations',
	    value: function __handleIntegrations(iq) {
	      if (iq.type === 'set') {
	
	        var data = iq.query.__text;
	        if (typeof data === "string") {
	          data = JSON.parse(data);
	        }
	
	        _app_dispatcher2.default.dispatch('integration-update', data);
	      }
	    }
	  }, {
	    key: '__handleIntegrationsUiPush',
	    value: function __handleIntegrationsUiPush(iq) {
	      if (iq.type === 'set') {
	
	        var data = iq.query.__text;
	        if (typeof data === "string") {
	          data = JSON.parse(data);
	        }
	        var glances = data.glance;
	        _app_dispatcher2.default.dispatch('glance-metadata-pushed', _utils2.default.toArray(glances));
	      }
	    }
	  }]);
	  return IQProcessor;
	}();
	
	module.exports = IQProcessor;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var AppDispatcher = __webpack_require__(9);
	
	var errorsToHandle = ["500", "403"];
	
	module.exports = function (stanza) {
	  if (stanza.error && stanza.error.code && _.includes(errorsToHandle, stanza.error.code)) {
	    AppDispatcher.dispatch("general-error", stanza);
	  }
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(148);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _preferences_model = __webpack_require__(165);
	
	var _preferences_model2 = _interopRequireDefault(_preferences_model);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class ConfigurationModel
	 *
	 * Authentication properties:
	 *
	 * @property {string} auth_method - 'oauth2' or 'nonce'
	 * @property {string} [auth_nonce] - set if auth_method is nonce
	 * @property {string} oauth_token - auth token for v2 api
	 * @property {number} [oauth_token_expires_in] - milliseconds, provided in oauth mode. In nonce mode, provided token has 1 month expiry
	 * @property {string} apiv1_token - auth token for v1 api
	 * @property {number} apiv1_token_expires_in - milliseconds
	 * @property {string} sid - Bosh session id
	 *
	 * Application urls & hosts:
	 *
	 * @property {string} base_url - defaults to empty string
	 * @property {string} video_base_url - defaults to hipchat.com/video
	 * @property {string} bind_url
	 * @property {string} api_host
	 * @property {string} conference_server
	 * @property {string} chat_server
	 * @property {string} web_server
	 * @property {string} route
	 * @property {string} invite_url
	 * @property {string} group_invite_url
	 * @property {string} video_chat_uri
	 *
	 * User Details:
	 *
	 * @property {string} jid
	 * @property {number} user_id
	 * @property {string} user_name
	 * @property {number} group_id
	 * @property {string} group_name
	 * @property {string} mention
	 * @property {boolean} is_admin
	 * @property {boolean} is_guest
	 * @property {string} email
	 * @property {string} title
	 * @property {string} photo_small
	 * @property {string} photo_large
	 * @property {string} group_avatar_url
	 * @property {number} addlive_app_id
	 *
	 * Guest Details (only there if user is guest):
	 *
	 * @property {string} [guest_key]
	 * @property {number} [room_id]
	 * @property {string} [room_name]
	 * @property {string} [room_jid]
	 *
	 * Client identifiers:
	 *
	 * @property {string} client_type
	 * @property {string} client_subtype
	 * @property {string} client_version_id
	 * @property {string} client_os_version_id
	 * @property {string} client_node
	 *
	 * Environment configuration:
	 *
	 * @property {string} asset_base_uri
	 * @property {string} video_chat_enabled
	 * @property {string} private_rooms_enabled
	 * @property {string} guest_access_enabled
	 * @property {string} html5_routing_enabled
	 * @property {string} display_name
	 * @property {object} ui
	 * @property {object} app_config_overrides
	 * @property {object} native_feature_flags
	 * @property {object} log_to_file
	 *
	 * Dictionaries:
	 *
	 * @property {object} feature_flags
	 * @property {object} emoticons
	 * @property {object} smileys
	 * @property {object} keyboard_shortcuts
	 * @property {object} permissions
	 * @property {object} plan
	 * @property {PreferencesModel} preferences - See [PreferencesModel]{@link class:PreferencesModel}
	 */
	
	// Avatar url comes in sometimes with size identifer, sometimes without
	// Make sure it's there and the right one. No need for 2000px avatar images
	function normalizeAvatarUrl(url, absUrl) {
	  var extensionRegex = /((_\d+)?(\.\w{3,4}))$/;
	  if (absUrl && _.isString(absUrl)) {
	    return absUrl.replace(extensionRegex, '_125$3');
	  }
	  if (_.isString(url)) {
	    return url.replace(extensionRegex, '_125$3');
	  }
	  return url;
	}
	
	// The Big Switch. Go through each key and fix/properly coerce the value
	function normalizeConfiguration(input) {
	  return _.transform(input, function (result, val, key, original) {
	    switch (key) {
	
	      case 'access_token':
	        result.oauth_token = val;
	        break;
	
	      // OAuth token provided in seconds. Add 5 and convert to milliseconds
	      case 'expires_in':
	        result.oauth_token_expires_in = (val + 5) * 1000;
	        break;
	
	      // API V1 token is an object. The token itself is optional (not in php init state) and
	      // may be in the token or __text val depending on source. Expiry is a timestamp of
	      // seconds since EPOCH. Need to convert to milliseconds from now (plus 5 seconds)
	      case 'token':
	        var expiration = parseInt(val.expiration, 10);
	        var ttl = parseInt(val.ttl, 10);
	        var serverTimestamp = (expiration - ttl) * 1000;
	        var currentTimestamp = new Date().getTime();
	        if (currentTimestamp > serverTimestamp) {
	          currentTimestamp = serverTimestamp;
	          _logger2.default.warn('Local date might be wrong. Server date:', new Date(serverTimestamp));
	        }
	        result.apiv1_token = val.token || val.__text;
	        result.apiv1_token = result.apiv1_token === 'false' ? null : result.apiv1_token;
	        result.apiv1_token_expires_in = expiration * 1000 - currentTimestamp + 5000;
	        break;
	
	      case 'user_id':
	      case 'group_id':
	      case 'addlive_app_id':
	      case 'room_id':
	        result[key] = parseInt(val, 10);
	        break;
	      case 'group_invite_url':
	        result['invite_url'] = val;
	        break;
	      case 'is_admin':
	      case 'is_guest':
	      case 'video_chat_enabled':
	      case 'private_rooms_enabled':
	      case 'guest_access_enabled':
	      case 'html5_routing_enabled':
	      case 'log_to_file':
	        result[key] = _utils2.default.coerceBoolean(val);
	        break;
	
	      case 'prefs':
	      case 'preferences':
	        result.preferences = new _preferences_model2.default(val, true);
	        break;
	
	      case 'features':
	        result.features = _.transform(val, function (features, featureVal, featureKey) {
	          features[featureKey] = _utils2.default.coerceBoolean(featureVal);
	        });
	        break;
	
	      case 'feature_flags':
	        result.feature_flags = _utils2.default.features.reconcileFeatureFlags(original.native_feature_flags || {}, val);
	        break;
	
	      case 'native_feature_flags':
	        result.native_feature_flags = _.isObject(val) ? val : {};
	        break;
	
	      case 'display_name':
	        result.display_name = _.isString(val) ? val : "";
	        break;
	
	      // The following are returned from the server with different names from different sources
	      case 'mention_name':
	        result.mention = val;
	        break;
	
	      case 'name':
	        result.user_name = val;
	        break;
	
	      case 'video_chat_uri':
	        result.video_chat_uri = val;
	        break;
	
	      case 'video_base_url':
	        result.video_base_url = val;
	        break;
	
	      case 'group_avatar_url':
	      case 'group_absolute_avatar_url':
	        result.group_avatar_url = normalizeAvatarUrl(original.group_avatar_url, original.group_absolute_avatar_url);
	        break;
	
	      // Ignored keys
	      case 'xmlns':
	      case 'anonymous':
	      case 'el':
	      case 'minimal':
	      case 'mobile':
	      case 'vertical_tabs':
	      case 'welcome_msg':
	      case 'onRefreshOAuthAccessToken':
	      case 'source_json':
	      case 'plan':
	      case 'state':
	      case 'token_type':
	        break;
	
	      default:
	        result[key] = val;
	    }
	  });
	}
	
	var ConfigurationModel = function ConfigurationModel() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	  (0, _classCallCheck3.default)(this, ConfigurationModel);
	
	  (0, _assign2.default)(this, normalizeConfiguration(input));
	};
	
	exports.default = ConfigurationModel;
	module.exports = exports['default'];

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PresenceProcessor = function () {
	  function PresenceProcessor(data) {
	    (0, _classCallCheck3.default)(this, PresenceProcessor);
	
	    this.processorData = data;
	    this.queued = [];
	    this.ready = false;
	    this.subscribeToEvents();
	  }
	
	  (0, _createClass3.default)(PresenceProcessor, [{
	    key: 'subscribeToEvents',
	    value: function subscribeToEvents() {
	      var _this = this;
	
	      _app_dispatcher2.default.registerOnce('app-state-ready', function () {
	        _this.ready = true;
	        _this.handlePresence(_this.queued);
	        _this.queued = [];
	      });
	    }
	  }, {
	    key: 'update',
	    value: function update(data) {
	      this.processorData = null;
	      this.processorData = data;
	    }
	  }, {
	    key: 'handlePresence',
	    value: function handlePresence(presences) {
	      var presArray = _utils2.default.toArray(presences);
	      if (!this.ready) {
	        this.queued = this.queued.concat(presArray);
	      } else {
	        if (this.processorData.is_guest) {
	          this.handlePresencesForGuest(presArray);
	        } else {
	          var groupedPresences = _.groupBy(presArray, function (pres) {
	            if (_utils2.default.jid.is_room(_utils2.default.jid.bare_jid(pres.from))) {
	              return 'room';
	            }
	            return 'global';
	          });
	          this.handleRoomPresences(groupedPresences['room']);
	          this.handleGlobalPresences(groupedPresences['global']);
	        }
	      }
	    }
	  }, {
	    key: 'handlePresencesForGuest',
	    value: function handlePresencesForGuest(presArray) {
	      var _this2 = this;
	
	      _.forEach(presArray, function (pres) {
	        pres.x = _utils2.default.toArray(pres.x);
	
	        _this2._handleUser(pres);
	
	        // Transform for global presences
	        _this2.roomToGlobalPresence(pres);
	      });
	
	      this.handleGlobalPresences(presArray);
	    }
	  }, {
	    key: '_handleUser',
	    value: function _handleUser(pres) {
	      var item = _.get(pres.x[0], 'item');
	
	      if (item) {
	        var jid = _utils2.default.jid.bare_jid(pres.from);
	
	        if (pres.type === "unavailable") {
	          this._handleUnavailableUser(pres, item);
	        } else if (item.role === "participant") {
	          this.addRoomParticipant(jid, _utils2.default.jid.bare_jid(item.jid), _utils2.default.jid.resource(pres.from), pres);
	        } else if (item.role === "visitor") {
	          this.addRoomVisitor(jid, _utils2.default.jid.bare_jid(item.jid), _utils2.default.jid.resource(pres.from), item.mention_name, pres);
	        }
	      }
	    }
	  }, {
	    key: '_handleUnavailableUser',
	    value: function _handleUnavailableUser(pres, item) {
	      var jid = _utils2.default.jid.bare_jid(pres.from);
	
	      if (this._isAddresseeCurrentUser(pres, item) && this._hasNotAffiliation(pres, item)) {
	        this.revokeGuestAccess();
	      } else {
	        this.removeRoomParticipant(jid, _utils2.default.jid.bare_jid(item.jid), item.role, pres.status);
	      }
	    }
	  }, {
	    key: '_isAddresseeCurrentUser',
	    value: function _isAddresseeCurrentUser(pres, item) {
	      var currentUserJid = _utils2.default.jid.bare_jid(pres.to);
	
	      return currentUserJid === item.jid;
	    }
	  }, {
	    key: '_hasNotAffiliation',
	    value: function _hasNotAffiliation(pres, item) {
	      var status = _.get(pres.x[0], 'status');
	
	      return status && Number(status.code) === 307 && item.affiliation === 'none';
	    }
	  }, {
	    key: 'roomToGlobalPresence',
	    value: function roomToGlobalPresence(pres) {
	      // Guests & Visitors have room presences
	      // that must be handled like global presences
	      pres.x = _utils2.default.toArray(pres.x);
	      pres.from = _.get(pres, "x[0].item.jid", pres.from);
	    }
	  }, {
	    key: 'handleRoomPresences',
	    value: function handleRoomPresences(presences) {
	      var _this3 = this;
	
	      var jid;
	      _.map(presences, function (presence) {
	        jid = _utils2.default.jid.bare_jid(presence.from);
	        if (presence.x) {
	          presence.x = _utils2.default.toArray(presence.x);
	          if (presence.x[0].item) {
	            var item = presence.x[0].item;
	
	            if (presence.type === 'unavailable' && _.isString(presence.status) && (item.affiliation === 'member' || item.affiliation === 'owner')) {
	
	              _this3.removeRoomParticipant(jid, _utils2.default.jid.bare_jid(item.jid), item.role, presence.status);
	            } else if (presence.x[0].status && Number(presence.x[0].status.code) === 307 && item.affiliation === 'none') {
	
	              if (item.actor && _utils2.default.jid.bare_jid(item.actor.jid) === item.jid) {
	                // Basic close room
	                _app_dispatcher2.default.dispatch('close-room', {
	                  jid: jid
	                });
	              } else {
	                // User was removed by admin
	                _app_dispatcher2.default.dispatch('user-removed', {
	                  room: jid,
	                  user_jid: _utils2.default.jid.bare_jid(item.jid),
	                  role: item.role
	                });
	              }
	            } else if (item.role === 'visitor') {
	
	              _this3.addRoomVisitor(jid, _utils2.default.jid.bare_jid(item.jid), _utils2.default.jid.resource(presence.from), item.mention_name, presence);
	            } else if (item && item.jid) {
	
	              _app_dispatcher2.default.dispatch('room-presence-received', {
	                room: jid,
	                user_jid: _utils2.default.jid.bare_jid(item.jid),
	                user_id: _utils2.default.jid.user_id(item.jid),
	                role: item.role,
	                affiliation: item.affiliation,
	                type: presence.type || ""
	              });
	            }
	          }
	        } else if (presence.type === 'error' && presence.error) {
	
	          _app_dispatcher2.default.dispatch('show-flag', {
	            type: "error",
	            title: presence.error.text.__text,
	            close: "auto"
	          });
	
	          _app_dispatcher2.default.dispatch('close-room', {
	            jid: jid,
	            type: 'room',
	            doNotNotifyHC: true
	          });
	        }
	      });
	    }
	  }, {
	    key: 'handleGlobalPresences',
	    value: function handleGlobalPresences(presences) {
	      var _this4 = this;
	
	      var presObj = {};
	      _.forEach(presences, function (presence) {
	        var jid = _utils2.default.jid.bare_jid(presence.from);
	        var seconds = presence.query ? presence.query.seconds : false;
	        var delay = presence.delay ? presence.delay.stamp : false;
	        var show = _this4.getState(presence);
	        if (!(_this4.processorData.current_user_jid === jid && (show === "mobile" || show === "unavailable"))) {
	          presObj[jid] = {
	            show: show,
	            status: presence.status || '',
	            seconds: seconds || '',
	            idleTime: _this4.getIdleTime(seconds, delay)
	          };
	        }
	      });
	      if (_.size(presObj) > 0) {
	        _app_dispatcher2.default.dispatch('global-presence-received', presObj);
	      }
	    }
	  }, {
	    key: 'getState',
	    value: function getState(presence) {
	      if (presence.type && presence.type === 'unavailable' && presence.mobile) {
	        return 'mobile';
	      } else if (presence.type && presence.type === 'unavailable' && !presence.mobile) {
	        return 'unavailable';
	      } else if (presence.show) {
	        return presence.show;
	      }
	      return 'chat';
	    }
	  }, {
	    key: 'getIdleTime',
	    value: function getIdleTime(seconds, delay) {
	      var result = "";
	      if (delay && seconds) {
	        var now = _utils2.default.getMoment();
	        var seconds_diff = now - (_utils2.default.getMoment(delay) - seconds);
	        result = _utils2.default.user.format_idle_time(seconds_diff);
	      }
	      return result;
	    }
	  }, {
	    key: 'revokeGuestAccess',
	    value: function revokeGuestAccess() {
	      _app_dispatcher2.default.dispatch('guest-access-revoked');
	    }
	  }, {
	    key: 'addRoomParticipant',
	    value: function addRoomParticipant(room_jid, user_jid, user_name, presence) {
	      _app_dispatcher2.default.dispatch('add-room-participant', {
	        room: room_jid,
	        user_jid: user_jid,
	        user_name: user_name,
	        presence: {
	          show: this.getState(presence),
	          status: presence.status || ''
	        }
	      });
	    }
	  }, {
	    key: 'removeRoomParticipant',
	    value: function removeRoomParticipant(room_jid, participant_jid, role, status) {
	      _app_dispatcher2.default.dispatch('remove-room-participant', {
	        room: room_jid,
	        participant: participant_jid,
	        role: role === 'visitor' ? 'guests' : 'members',
	        status: status || ''
	      });
	    }
	  }, {
	    key: 'addRoomVisitor',
	    value: function addRoomVisitor(room_jid, participant_jid, participant_name, mention, presence) {
	      _app_dispatcher2.default.dispatch('add-room-visitor', {
	        room: room_jid,
	        participant: participant_jid,
	        user_name: participant_name,
	        user_mention: mention,
	        presence: {
	          show: this.getState(presence),
	          status: presence.status || ''
	        }
	      });
	    }
	  }]);
	  return PresenceProcessor;
	}();
	
	module.exports = PresenceProcessor;

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  create_room: 'Create room',
	  delete_room: 'Delete room',
	  disable_guest: 'Disable guest access',
	  join: 'Join room',
	  ok: 'Ok',
	  OK: 'OK',
	  save: 'Save',
	  delete: 'Delete',
	  close: 'Close',
	  cancel: 'Cancel',
	  apply: 'Apply',
	  rename: 'Rename',
	  try_again: 'Try again',
	  archive: 'Archive',
	  archive_room: 'Archive room',
	  unarchive: 'Unarchive',
	  unarchive_room: 'Unarchive room',
	  confirm_archive: 'This will prevent any people from chatting in the room.',
	  confirm_disable_guest: 'The room URL will be disabled and current guests will be kicked from the room',
	  confirm_delete: function confirm_delete(room) {
	    return 'Are you sure you want to delete ' + room + '?';
	  },
	  room_deleted: function room_deleted(room) {
	    return room + ' deleted.';
	  },
	  room_archived: 'Room archived.',
	  room_unarchived: 'Room unarchived.',
	  archive_room_name: function archive_room_name(room) {
	    return 'Archive ' + room;
	  },
	  unarchive_room_name: function unarchive_room_name(room) {
	    return 'Unarchive ' + room;
	  },
	  really_archive: function really_archive(room) {
	    return 'Are you sure you want to archive the ' + room + ' room?';
	  },
	  really_unarchive: function really_unarchive(room) {
	    return 'Are you sure you want to unarchive the ' + room + ' room?';
	  },
	  really_disable_guest: 'Are you sure you want to disable guest access?',
	  invite_users: function invite_users(room) {
	    return 'Invite people to ' + room;
	  },
	  choose_removed_members: 'Remove people',
	  join_room: function join_room(room) {
	    return 'Join ' + room;
	  },
	  rename_room: function rename_room(room) {
	    return 'Rename ' + room;
	  },
	  invited_to_join: function invited_to_join(inviter, room) {
	    return inviter + ' invited you to join ' + room;
	  },
	  disable_guest_fail: 'Couldn\'t disable guest access.',
	  enable_guest_fail: 'Couldn\'t enable guest access.',
	  archive_fail: 'Couldn\'t archive room.',
	  unarchive_fail: 'Couldn\'t unarchive room.',
	  delete_room_fail: 'Couldn\'t delete room.',
	  set_privacy: 'Set privacy',
	  notify_for_room: 'A message is sent to an open room I\'m in',
	  notify_for_private_room: 'A message is sent to a private room I\'m in',
	  notify_for_tag: 'I\'m mentioned in a room',
	  notify_for_private: 'I receive a private message',
	  play_sound_part_1: 'Play sound for',
	  play_sound_part_2: 'notifications',
	  basic_play_sound: 'Play sound for new messages',
	  message_notifications: 'message',
	  video_notifications: 'video',
	  message_and_video_notifications: 'message and video',
	  show_toasters: 'Show a popup',
	  hide_presence_messages: 'Show joined/left room messages',
	  use_24_hour_format: 'Display time in 24-hour format',
	  hide_gifs_by_default: 'Hide gifs by default',
	  hide_attached_cards_by_default: 'Hide inline previews by default',
	  replace_text_emoticons: 'Turn text emoticons into images',
	  show_unread_divider: 'Show divider for unread messages',
	  create_a_new_room: 'Create a new room',
	  change_privacy: 'Change privacy',
	  theme: 'Theme',
	  density: 'Text density',
	  chat_view: 'Chat view',
	  name_display: 'Name display',
	  animated_avatars: 'Animated avatars',
	  names: 'Name',
	  mentions: '@mention name',
	  light: 'Light',
	  dark: 'Dark',
	  normal: 'Normal',
	  tighter: 'Tighter',
	  classic: 'Classic',
	  classic_neue: 'With avatars',
	  animated: 'Show animation',
	  static: 'Show as static images',
	  call_from: 'Call from',
	  answer: 'Answer',
	  decline: 'Decline',
	  start_up_with_windows: 'Start up with Windows',
	  enable_spell_check: 'Enable spell check',
	  enable_autocorrect: 'Correct spelling automatically',
	  idle: 'Idle',
	  minutes: 'minutes',
	  maximum_idle_minutes: 'maximum of 99',
	  minimum_idle_minutes: 'minimum of 1',
	  keep_popups_visible: 'Keeping popups visible until ' + _common_strings2.default.app_name + ' is focused',
	  blink_taskbar: 'Blinking the taskbar',
	  bounce_icon: 'Bounce the dock icon',
	  bounce_icon_once: 'once',
	  bounce_icon_forever: 'until I look',
	  proxy_settings_description: function proxy_settings_description(display_name) {
	    return 'Modify the server that ' + _common_strings2.default.app_name + ' connects to by using the ' + display_name + ' Proxy Settings';
	  },
	  proxy_settings: function proxy_settings(display_name) {
	    return display_name + ' Proxy Settings';
	  },
	  title_settings: function title_settings(group_name) {
	    return group_name + ' Settings';
	  },
	  room_notifications: 'Room notifications',
	  beta: 'Beta',
	  appearance: 'Appearance',
	  general: 'General',
	  notifications: 'Notifications',
	  connection: 'Connection',
	  notify_when_header: 'Notify me when',
	  notify_rooms_header: 'Rooms',
	  notify_for_oto_per_room_enabled: 'Notify me for 1-to-1 messages',
	  notify_for_oto: 'I receive a 1-to-1 message',
	  dnd_header: 'Do not Disturb',
	  do_not_notify_when_dnd: 'Stop all notifications',
	  do_not_notify_when_dnd_basic: 'Enable notifications while status is set to Do Not Disturb',
	  notify_when_dnd: 'Send all notifications',
	  notify_for_video_when_dnd: 'Send a notification for video calls only',
	  enable_logging: 'Log additional chat data',
	  edit_message: 'Edit message',
	  delete_message: 'Are you sure? When it\'s gone, it\'s gone.',
	  not_editable: function not_editable(action) {
	    return 'It\'s too late to ' + action + ' this';
	  },
	  not_editable_body: function not_editable_body(thresholdInHours) {
	    return 'We\'d all like to re-write history, but it\'s been more than ' + thresholdInHours + ' hours since this message was sent.';
	  },
	  user_joined: function user_joined(displayName) {
	    return displayName + ' has joined.';
	  },
	  user_joined_link: 'Go say hi!',
	  suggestions: 'SUGGESTIONS',
	  message: 'MESSAGE',
	  welcome_to_hipchat: 'Welcome to HipChat!',
	  choose_people_to_chat: 'Choose a few people to chat with',
	  join_some_rooms: 'Join some rooms',
	  introduce_yourself: 'Introduce yourself',
	  skip_dialog_button: 'Skip',
	  start_button: 'Start',
	  next_button: 'Next',
	  skip_this_step_button: 'Skip this step',
	  finish_and_send_button: 'Finish and send message',
	  we_ll_help_you: 'We\'ll help you get started chatting with your team. ',
	  this_won_t_take_long: '(This won\'t take long and is totally worth it.) ',
	  lets_put_together_a_list_of_people: 'Let\'s put together a list of a few people you might be chatting with a lot. Choose the people you\'d like to meet. ',
	  weve_got_a_few_sugg_on_rooms: 'We\'ve got a few suggestions on rooms (group chats) to start you off with. You\'ll discover more, of course, but this is a good place to begin. ',
	  you_are_all_set: 'You\'re all set. Write a message (or use ours) introducing yourself to the team. We\'ll post it in each room you chose. ',
	  welcome_messages: function welcome_messages() {
	    var welcome_messages = ['@here Hey everybody! I\'m new here. I\'m sure we\'ll talk more real soon. Just wanted to introduce myself. ', '@here Hi there, I just joined and thought I\'d introduce myself. ', '@here Hi everyone, I\'m new here. I just wanted to say hi. Have an (awesome) day! '];
	    var randomIndex = _.random(0, welcome_messages.length - 1);
	    return welcome_messages[randomIndex];
	  },
	  got_that_person_down: 'Got that 1 person down. ',
	  got_those_people_down: function got_those_people_down(number) {
	    return 'Got those ' + number + ' people down. ';
	  },
	  that_is_a_good_roome_choice: 'That\'s a good room choice. ',
	  those_are_some_good_roome_choices: 'Those are some good room choices. ',
	  use_here_in_tour_message: 'Use @here in your message to mention everyone currently in the room. ',
	  welcome_message_err: function welcome_message_err(value) {
	    return 'Message max length is ' + value + ' symbols. ';
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * FlagActions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	
	var FlagActions = {
	
	  showFlag: function showFlag(flag_data) {
	    AppDispatcher.dispatch('show-flag', flag_data);
	  },
	
	  removeFlag: function removeFlag(flag_index) {
	    AppDispatcher.dispatch('remove-flag', flag_index);
	  },
	
	  dismissAlertFlag: function dismissAlertFlag() {
	    AppDispatcher.dispatch('dismiss-alert-flag');
	  }
	};
	
	module.exports = FlagActions;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @typedef {{name: string, key: string}} AnalyticsEventKeys
	 * @type {Object.<string, string>}
	 */
	var AnalyticsEventKeys = (0, _freeze2.default)({
	  AUTH: "hipchat.client.app.perf.auth.server",
	  BROWSER_METRICS: "browser.metrics.app",
	  CLIENT_CURRENT: "hipchat.client.current",
	  CLIENT_LAUNCH: "hipchat.client.launch",
	  CLIENT_READY: "hipchat.client.ready",
	  CLIENT_READY_FOR_USER: "hipchat.client.app.perf.load.ready",
	  CONNECTION_ESTABLISHED: "hc_web.hcjsclient.initial.connection.established",
	  DOM_READY: "hipchat.client.app.perf.nav.timing.dom",
	  INITIAL_EMOTICONS: "hipchat.client.app.perf.emoticons.initial.server",
	  INITIAL_FETCH: "hc_web.hcjsclient.initial.data.fetch",
	  INITIAL_IQ: "hipchat.client.app.perf.iq.initial.server",
	  INITIAL_PRESENCE: "hipchat.client.app.perf.presence.initial.server",
	  INITIAL_ROOMS: "hipchat.client.app.perf.rooms.initial.server",
	  INITIAL_ROSTER: "hipchat.client.app.perf.roster.initial.server",
	  CHAT_SENDABLE: "hipchat.client.app.perf.user.chat-sendable",
	  CHAT_IS_COMPLETE: "hipchat.client.app.perf.user.chat-is-complete",
	  LAUNCH_TO_ACTIVE_CHAT_LIST: "hipchat.client.app.perf.user.launch-to-active-chat-list",
	  LAUNCH_TO_CHAT: "hipchat.client.app.perf.user.launch-to-chat",
	  LAUNCH_TO_CHAT_COMPLETE: "hipchat.client.app.perf.user.launch-to-chat-complete",
	  LOBBY_RENDER: "hipchat.client.app.perf.lobby.panel.render",
	  PRODUCT: "HipChat",
	  RECONNECTION: "hc_web.hcjsclient.reconnection",
	  ROOM_FILES_LOAD: "hipchat.client.app.perf.room.files.load.server",
	  ROOM_HISTORY_LOAD: "hipchat.client.app.perf.room.history.load.server",
	  ROOM_MEMBERS_LOAD: "hipchat.client.app.perf.room.members.load.server",
	  ROOM_RENDER: "hipchat.client.app.perf.room.render"
	});
	exports.default = AnalyticsEventKeys;
	module.exports = exports['default'];

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _hipchat = __webpack_require__(207);
	
	var _hipchat2 = _interopRequireDefault(_hipchat);
	
	var _apiV = __webpack_require__(246);
	
	var _apiV2 = _interopRequireDefault(_apiV);
	
	var _rest = __webpack_require__(220);
	
	var _rest2 = _interopRequireDefault(_rest);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _dal = __webpack_require__(144);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _user = __webpack_require__(152);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _room = __webpack_require__(153);
	
	var _room2 = _interopRequireDefault(_room);
	
	var _emoticon = __webpack_require__(155);
	
	var _emoticon2 = _interopRequireDefault(_emoticon);
	
	var _dal3 = __webpack_require__(249);
	
	var _dal4 = _interopRequireDefault(_dal3);
	
	var _dal5 = __webpack_require__(251);
	
	var _dal6 = _interopRequireDefault(_dal5);
	
	var _dal7 = __webpack_require__(252);
	
	var _dal8 = _interopRequireDefault(_dal7);
	
	var _dal9 = __webpack_require__(253);
	
	var _dal10 = _interopRequireDefault(_dal9);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Top level API for server communication. Passes through to HJC
	 * until all of the HJC module have been rewritten and/or moved
	 * to the xmpp, rest or internal_api modules.
	 *
	 * This should be the single entry point used in the app for server
	 * communication. The long-term goal is to expand on this to also
	 * include localStorage, and possibly analytics.
	 *
	 * @module DAL
	 */
	var DAL = {
	
	  /**
	   * Start up XMPP connection
	   *
	   * @method attemptConnect
	   */
	
	  attemptConnect: function attemptConnect() {
	    _connection_manager2.default.connect();
	  },
	
	
	  /**
	   * Resume a chat session after connection down
	   *
	   * @method attemptReconnect
	   */
	  attemptReconnect: function attemptReconnect() {
	    var resetAndReconnect = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	    _connection_manager2.default.reconnect(resetAndReconnect);
	  },
	
	
	  /**
	   * Kill chat session
	   *
	   * @method terminateChatSession
	   * @param {boolean} [shouldReconnect=true]
	   */
	  terminateChatSession: function terminateChatSession() {
	    var shouldReconnect = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	    _connection_manager2.default.disconnect(shouldReconnect);
	  },
	
	
	  /**
	   * Send initial presence to the server to announce the client has connected
	   *
	   * @method sendInitialPresence
	   * @param {string} [show = 'chat']
	   * @returns {Promise<undefined>}
	   */
	  sendInitialPresence: function sendInitialPresence() {
	    var show = arguments.length <= 0 || arguments[0] === undefined ? _presence2.default.AVAILABLE : arguments[0];
	
	    return _connection_manager2.default.Connection.Presence.sendInitialPresence(show);
	  },
	
	
	  /**
	   * Change user presence/status
	   *
	   * @method setPresence
	   * @param {string} [show = 'chat']
	   * @param {string|null} [status = null]
	   * @returns {Promise<undefined>}
	   */
	  setPresence: function setPresence() {
	    var show = arguments.length <= 0 || arguments[0] === undefined ? _presence2.default.AVAILABLE : arguments[0];
	    var status = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	    return _connection_manager2.default.Connection.Presence.setPresence(show, status);
	  },
	
	
	  /**
	   * Join a room
	   *
	   * @method joinRoom
	   * @param {string} jid
	   * @param {number} [maxstanzas=0]
	   * @param {boolean} [limitPresences=true]
	   * @returns {Promise<JoinRoomResponse, DALError>}
	   */
	  joinRoom: function joinRoom(jid) {
	    var maxstanzas = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var limitPresences = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	
	    return _connection_manager2.default.Connection.Rooms.join(jid, maxstanzas, null, limitPresences);
	  },
	
	
	  /**
	   * Join a one-to-one chat
	   *
	   * @method joinChat
	   * @param {string} jid
	   */
	  joinChat: function joinChat(jid) {
	    var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _hipchat2.default.joinChat(jid, cb);
	  },
	
	
	  /**
	   * Join a set of rooms
	   *
	   * @param {array} rooms - list of objects containing a JID {jid:'jid'}
	   * @param {number} [maxstanzas=0]
	   */
	  joinRooms: function joinRooms(rooms) {
	    var maxstanzas = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	    var map = rooms.reduce(function (result, room) {
	      if (_utils2.default.jid.is_room(room.jid)) {
	        result.push(_connection_manager2.default.Connection.Rooms.join(room.jid, maxstanzas));
	      } else {
	        //TODO: need to refactor this method next to also return a promise and add it to promise map returned here
	        _hipchat2.default.joinChat(room.jid);
	      }
	      return result;
	    }, []);
	    return _promise2.default.all(map);
	  },
	
	
	  /**
	   * Leave a room/chat
	   *
	   * @param jid
	   * @param {string} type - "chat" or "groupchat"
	   * @returns {Promise<undefined,DALError>}
	   */
	  leaveRoom: function leaveRoom(jid, type) {
	    if (type === 'groupchat') {
	      return _connection_manager2.default.Connection.Rooms.leave(jid);
	    }
	    _hipchat2.default.sendStateMessage(jid, type, 'gone');
	    return _promise2.default.resolve();
	  },
	
	
	  /**
	   * Fetch a list of participants in a room
	   *
	   * @method fetchParticipants
	   * @param {number} room id
	   * @returns {Promise<Object, DALError>}
	   */
	  fetchParticipants: function fetchParticipants(roomId) {
	    var includeOffline = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return _rest2.default.fetchRoomParticipants(roomId, includeOffline);
	  },
	
	
	  /**
	   * Fetch profile for a user
	   *
	   * @method fetchProfile
	   * @param {string} jid
	   * @param {function} [callback]
	   */
	  fetchProfile: function fetchProfile(jid) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _hipchat2.default.fetchUserProfile(jid, callback);
	  },
	
	
	  /**
	   * Fetch the history from the server
	   *
	   * @param {string} jid
	   * @param {string|date} [before]
	   * @param {number} [maxstanzas=50]
	   * @param {number} id
	   * @param {function} callback
	   */
	  fetchHistory: function fetchHistory(jid, before) {
	    var maxstanzas = arguments.length <= 2 || arguments[2] === undefined ? 50 : arguments[2];
	    var id = arguments[3];
	    var callback = arguments.length <= 4 || arguments[4] === undefined ? _.noop : arguments[4];
	
	    _hipchat2.default.fetchHistory(jid, before, maxstanzas, id, callback);
	  },
	
	
	  /**
	   * @method fetchRecentHistory
	   * @param {object} data
	   * @param {object} data.path
	   * @param {string} data.path.type
	   * @param {string|number} data.path.identifier - room or user id
	   * @param {object} data.params - querystring / post body params
	   * @param {function} [callback]
	   */
	  fetchRecentHistory: function fetchRecentHistory(data) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    if (data.path.type === 'user') {
	      _apiV2.default.user.recent_history(data, callback);
	    } else {
	      _apiV2.default.room.recent_history(data, callback);
	    }
	  },
	
	
	  /**
	   * Fetch files for a room/chat
	   *
	   * @param {string} jid
	   * @param {date} [before=null]
	   * @param {number} [limit=50]
	   * @returns {Promise<ChatFilesResponse, DALError>}
	   */
	  fetchFiles: function fetchFiles(jid) {
	    var before = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var after = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    var limit = arguments.length <= 3 || arguments[3] === undefined ? 50 : arguments[3];
	
	    return _connection_manager2.default.Connection.Chat.getFiles(jid, before, after, limit);
	  },
	
	
	  /**
	   * Fetch links for a room/chat
	   *
	   * @param {string} jid
	   * @param {date} [before=null]
	   * @param {date} [after=null]
	   * @param {number} [limit=50]
	   * @returns {Promise<ChatLinksResponse, DALError>}
	   */
	  fetchLinks: function fetchLinks(jid) {
	    var before = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var after = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    var limit = arguments.length <= 3 || arguments[3] === undefined ? 50 : arguments[3];
	
	    return _connection_manager2.default.Connection.Chat.getLinks(jid, before, after, limit);
	  },
	
	
	  /**
	   * Fetch presences for given users
	   *
	   * @method fetchPresences
	   * @param {array} ids - list of user ids
	   * @param {function} [callback]
	   */
	  fetchPresences: function fetchPresences(ids) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _hipchat2.default.fetchPresence(ids, callback);
	  },
	
	
	  /**
	   * Limit the presences you are subscribed to
	   *
	   * @method filterPresences
	   * @param {Array<string|number>} ids - array of user ids
	   * @returns {Promise<undefined,DALError>}
	   */
	  filterPresences: function filterPresences(ids) {
	    return _connection_manager2.default.Connection.Presence.filterPresences(ids);
	  },
	
	
	  /**
	   * Sends a message
	   *
	   * @method sendMessage
	   * @param {string} message
	   * @returns {Promise}
	   */
	  sendMessage: function sendMessage(message) {
	    _hipchat2.default.sendMessage(message);
	  },
	
	
	  /**
	   * Edits a message
	   *
	   * @method editMessage
	   * @param {string} jid message jid
	   * @param {string} message edited message
	   * @param {string} original_mid original message id
	   * @param {ts} ts timestamp
	   */
	  editMessage: function editMessage(jid, message, original_mid, ts) {
	    _hipchat2.default.editMessage(jid, message, original_mid, ts);
	  },
	
	
	  /**
	   * Deletes a message
	   *
	   * @method deleteMessage
	   * @param {string} message the message to delete
	   */
	  deleteMessage: function deleteMessage(message) {
	    _hipchat2.default.deleteMessage(message);
	  },
	
	
	  /**
	   * Send a state-change message
	   *
	   * @param {string} jid
	   * @param {string} type
	   * @param {string} state
	   */
	  sendStateMessage: function sendStateMessage(jid, type, state) {
	    _hipchat2.default.sendStateMessage(jid, type, state);
	  },
	
	
	  /**
	   * @method sendVideoMessage
	   * @param {string} jid
	   * @param {string} [type='call']
	   * @param {boolean} [audioOnly=false]
	   * @param {string} [url]
	   * @param {string} [service]
	   * @param {function} [callback=_.noop]
	   * @param {string} reason
	   */
	  sendVideoMessage: function sendVideoMessage(jid) {
	    var type = arguments.length <= 1 || arguments[1] === undefined ? 'call' : arguments[1];
	    var audioOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	    var url = arguments[3];
	    var service = arguments[4];
	    var callback = arguments.length <= 5 || arguments[5] === undefined ? _.noop : arguments[5];
	    var reason = arguments[6];
	
	    _hipchat2.default.sendVideoMessage({ jid: jid, type: type, audioOnly: audioOnly, url: url, service: service, callback: callback, reason: reason });
	  },
	
	
	  /**
	   * @method sendEnsoInviteMessage
	   * @param {string} jid
	   * @param {string} url
	   */
	  sendEnsoInviteMessage: function sendEnsoInviteMessage(jid, url) {
	    var message = '<a href="' + url + '" data-target-options="enso_invite">' + _video_call_strings2.default.join_video_call_message + '</a>';
	    _apiV2.default.user.send_private_message({
	      path: {
	        identifier: _utils2.default.jid.user_id(jid)
	      },
	      params: {
	        message: message,
	        notify: false,
	        message_format: 'html'
	      }
	    });
	  },
	
	
	  /**
	   * @method sendFile
	   * @param {string} jid
	   * @param {object} uploadData
	   * @param {object} uploadData.path
	   * @param {string} uploadData.path.identifier - room id
	   * @param {object} uploadData.params
	   * @param {file|object} uploadData.params.file
	   * @param {string} uploadData.params.fileName
	   * @param {string} uploadData.params.message
	   * @param {string} uploadData.params.progressBarSelector
	   * @param {function} uploadData.params.success
	   * @param {function} uploadData.params.error
	   */
	  sendFileMessage: function sendFileMessage(jid, uploadData) {
	    if (_utils2.default.jid.is_private_chat(jid)) {
	      return _apiV2.default.user.share_file(uploadData);
	    }
	
	    return _apiV2.default.room.share_file(uploadData);
	  },
	
	
	  /**
	   * @method requestAddliveCredentials
	   * @param {string} jid
	   * @param {function} [callback]
	   */
	  requestAddliveCredentials: function requestAddliveCredentials(jid) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _hipchat2.default.requestAddliveCredentials(jid, callback);
	  },
	
	
	  /**
	   * @method clearWebCookies
	   * @param {function} [callback]
	   */
	  clearWebCookies: function clearWebCookies() {
	    var callback = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	    _hipchat2.default.clearWebCookies(callback);
	  },
	
	
	  /**
	   * Fetch a current API V1 token from server
	   *
	   * @method updateAPIV1Token
	   * @return {promise}
	   */
	  updateAPIV1Token: function updateAPIV1Token() {
	    return _connection_manager2.default.updateApiV1Token();
	  },
	
	
	  /**
	   * Revoke oauth2 token
	   *
	   * @method revokeOauth2Token
	   * @param callback
	   */
	  revokeOauth2Token: function revokeOauth2Token() {
	    var callback = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	    _hipchat2.default.revokeOauth2Token(callback);
	  },
	
	
	  /**
	   * @method inviteUsersToRoom
	   * @param {string} roomJid
	   * @param {array} userJids
	   * @param {function} [callback]
	   */
	  inviteUsersToRoom: function inviteUsersToRoom(roomJid, userJids) {
	    var callback = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	    _hipchat2.default.inviteUsersToRoom(roomJid, userJids, callback);
	  },
	
	
	  /**
	   * @method removeUsersFromRoom
	   * @param {string} roomJid
	   * @param {array} userJids
	   * @param {function} [callback]
	   */
	  removeUsersFromRoom: function removeUsersFromRoom(roomJid, userJids) {
	    var callback = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	    _hipchat2.default.removeUsersFromRoom(roomJid, userJids, callback);
	  },
	
	
	  /**
	   * @method savePreferences
	   * @param {object} prefs
	   * @param {function} [callback]
	   */
	  savePreferences: function savePreferences(prefs) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _hipchat2.default.savePreferences(prefs, callback);
	  },
	
	
	  /**
	   * @method fetchReadstate
	   * @param {function} [callback]
	   */
	  fetchReadstate: function fetchReadstate() {
	    _hipchat2.default.readstate.fetch();
	  },
	
	
	  /**
	   * @method updateReadstate
	   * @param {object} data
	   */
	  updateReadstate: function updateReadstate(data) {
	    _hipchat2.default.readstate.update(data);
	  },
	
	
	  /**
	   * @method removeReadstate
	   * @param {object} data
	   */
	  removeReadstate: function removeReadstate(data) {
	    _hipchat2.default.readstate.remove(data);
	  },
	
	
	  /**
	   * @method retryReadstate
	   */
	  retryReadstate: function retryReadstate() {
	    _hipchat2.default.readstate.retry();
	  },
	
	
	  /**
	   * @method resetReadstate
	   */
	  resetReadstate: function resetReadstate() {
	    _hipchat2.default.readstate.reset();
	  },
	
	
	  /**
	   * @method syncIntegrations
	   * @param {object} data
	   * @param {object} data.integrations
	   * @param {object} data.room_ids
	   * @param callback
	   */
	  syncIntegrations: function syncIntegrations(data) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _apiV2.default.integrations.sync(data, callback);
	  },
	
	
	  /**
	   * @method getSignedUrl
	   * @param {object} data
	   * @param {string} data.extension
	   * @param {string} [data.attribute=url]
	   * @param {object} params - query params
	   * @param {function} [callback]
	   */
	  getSignedUrl: function getSignedUrl(data, params) {
	    var callback = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	    _apiV2.default.integrations.getSignedUrl(data, params, callback);
	  },
	
	
	  /**
	   * @method requestWithSignedUrl
	   * @param {object} data
	   * @param {object} params
	   * @param {function} [callback]
	   */
	  requestWithSignedUrl: function requestWithSignedUrl(data, params) {
	    var callback = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	    _apiV2.default.integrations.requestWithSignedUrl(data, params, callback);
	  },
	
	
	  /**
	   * @method fetchAllGlancesForRoom
	   * @param {object} data
	   * @param {function} [callback]
	   */
	  fetchAllGlancesForRoom: function fetchAllGlancesForRoom(data) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _apiV2.default.integrations.fetchAllGlancesForRoom(data, callback);
	  },
	
	
	  /**
	   * @method fetchSignedFile
	   * @param {string} url
	   * @return {promise}
	   */
	  fetchSignedFile: function fetchSignedFile(url) {
	    return _rest2.default.fetchSignedFile(url);
	  },
	
	
	  /**
	   * @method fetchSignedThumbnailCollection
	   * @param {Object} fileObjects
	   * @returns {promise}
	   */
	  fetchSignedThumbnailCollection: function fetchSignedThumbnailCollection(fileObjects) {
	    return _rest2.default.fetchSignedThumbnailCollection(fileObjects);
	  },
	
	
	  /**
	   * @method checkNetwork
	   * @return {promise}
	   */
	  checkNetwork: function checkNetwork() {
	    return _rest2.default.checkNetwork();
	  },
	
	
	  /**
	   * @method isConnected
	   * @return {boolean}
	   */
	  isConnected: function isConnected() {
	    return _connection_manager2.default.isConnected();
	  },
	
	
	  /**
	   * @method fetchVideoToken
	   */
	  fetchVideoToken: function fetchVideoToken(recipient_id, room_id) {
	    return _rest2.default.fetchVideoToken(recipient_id, room_id);
	  },
	
	
	  /**
	   * @method fetchAlertFlags
	   */
	  fetchAlertFlag: function fetchAlertFlag() {
	    return _rest2.default.fetchAlertFlag();
	  },
	
	
	  /**
	   * @method dismissAlertFlag
	   */
	  dismissAlertFlag: function dismissAlertFlag(data) {
	    return _rest2.default.dismissAlertFlag(data);
	  },
	
	
	  /**
	   * @method fetchReadOnlyContent
	   */
	  fetchReadOnlyContent: function fetchReadOnlyContent() {
	    return _rest2.default.fetchReadOnlyContent();
	  }
	};
	
	DAL.User = _dal4.default;
	DAL.Cache = _dal2.default;
	DAL.Room = _dal6.default;
	DAL.Emoticon = _dal8.default;
	DAL.Connection = _dal10.default;
	
	DAL.Models = {
	  Room: _room2.default,
	  User: _user2.default,
	  Emoticon: _emoticon2.default,
	  DALError: _dalError2.default
	};
	
	exports.default = DAL;
	module.exports = exports['default'];

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _constants = __webpack_require__(163);
	
	var Constants = _interopRequireWildcard(_constants);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _readstate = __webpack_require__(243);
	
	var _readstate2 = _interopRequireDefault(_readstate);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _x2js = __webpack_require__(213);
	
	var _x2js2 = _interopRequireDefault(_x2js);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var noop = function noop() {
	  return {};
	};
	var isNil = function isNil(val) {
	  return val === null || val === undefined;
	};
	
	/**
	 * HipChat Client
	 */
	
	var HipChat = function () {
	  /**
	   * Creates an instance of the HipChat client that interacts with HipChat's XMPP
	   * service via BOSH
	   * @returns {object}      HipChat instance
	   */
	
	  function HipChat() {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, HipChat);
	
	
	    /**
	     * config contains all of the properties needed to connect to an HC server
	     *
	     * For nonce based auth (web/session based), the following are required:
	     *
	     *   * auth_method = 'nonce'
	     *   * auth_nonce: nonce value used to validate auth. Issued by web
	     *   * jid: user's jid
	     *   * user_id
	     *   * route: xmpp route (e.g., xmpp:devvm.hipchat.com:5222)
	     *   * bind_url: BOSH end-point (e.g. https://likeabosh.hipchat.com/http-bind/)
	     *   * chat_server: XMPP end-point (e.g. chat.hipchat.com)
	     *
	     * For oauth2 based auth, the following are required:
	     *
	     *   * auth_method = 'oauth2'
	     *   * access_token: OAuth2 access token obtained through 3LO dance
	     *   * jid: user's jid
	     *   * user_id
	     *   * route: xmpp route (e.g., xmpp:devvm.hipchat.com:5222)
	     *   * bind_url: BOSH end-point (e.g. https://likeabosh.hipchat.com/http-bind/)
	     *   * chat_server: XMPP end-point (e.g. chat.hipchat.com)
	     *
	     * @type {object}
	     * @required
	     */
	
	    // instance properties
	    this.cached_profiles = {};
	    this.savePrefsAttempts = 0;
	    this.savePrefsRetryDelay = Constants.RECONNECT_DELAY_MS;
	
	    /**
	     * @deprecated
	     * @type {ReadState}
	     */
	    this.readstate = new _readstate2.default({
	      fetchCallback: function fetchCallback(err, data) {
	        _app_dispatcher2.default.dispatch('DAL:readstate-fetched', err, data);
	      },
	      patchCallBack: function patchCallBack(err, data) {
	        _app_dispatcher2.default.dispatch('DAL:readstate-patched', err, data);
	      }
	    });
	
	    _app_dispatcher2.default.registerOnce({
	      'DAL:cache-configured': function DALCacheConfigured() {
	        _this.readstate.loadStorage();
	      }
	    });
	
	    this.parsedCallback = function (data, once, cb) {
	      if (typeof once === 'function') {
	        cb = once;
	        once = false;
	      }
	      cb(data);
	      return !once;
	    };
	
	    this.sendIQ = function (stanza, cb) {
	      // Wer're just passing the same thing through in both cases here... combine?
	      return _connection_manager2.default.sendIQ(stanza.tree(), function (data) {
	        return _this.parsedCallback(_x2js2.default.xml2json(data), cb);
	      }, function (err) {
	        return _this.parsedCallback(_x2js2.default.xml2json(err), cb);
	      });
	    };
	
	    this.subscribe = function (evt, once, opts, cb) {
	      var from, id, ns, type;
	      if (isNil(once)) {
	        once = false;
	      }
	      if (isNil(opts)) {
	        opts = null;
	      }
	      switch (evt) {
	        case 'roomChange':
	          evt = 'iq';
	          type = 'set';
	          ns = 'http://hipchat.com/protocol/muc#room';
	          break;
	        case 'presenceError':
	          evt = 'presence';
	          type = 'error';
	          ns = 'http://jabber.org/protocol/muc#room';
	          break;
	        case 'joinRoom':
	          evt = 'presence';
	          type = null;
	          ns = null;
	          break;
	        case 'videoMessage':
	          evt = 'message';
	          type = null;
	          ns = null;
	        default:
	          type = null;
	          ns = null;
	      }
	      if (opts) {
	        id = opts.id;
	        from = opts.from;
	      }
	      return _connection_manager2.default.addHandler(function (data) {
	        var jsonified_data = _x2js2.default.xml2json(data);
	        return _this.parsedCallback(jsonified_data, once, cb);
	      }, ns, evt, type, id, from);
	    };
	
	    this.toXMPPDate = function (dttm) {
	      if (typeof dttm === 'string') {
	        return dttm;
	      }
	      return new Date(dttm.setMilliseconds(0)).toISOString().replace(/\.000/, '');
	    };
	
	    this.getJidType = function (jid) {
	      var re;
	      re = new RegExp(_configuration_store2.default.get('conference_server'));
	      if (re.test(jid)) {
	        return 'groupchat';
	      }
	      return 'chat';
	    };
	  }
	
	  (0, _createClass3.default)(HipChat, [{
	    key: 'on',
	    value: function on(evt, opts) {
	      var cb = arguments.length <= 2 || arguments[2] === undefined ? noop : arguments[2];
	
	      if (typeof opts === 'function') {
	        cb = opts;
	        opts = null;
	      }
	      return this.subscribe(evt, false, opts, cb);
	    }
	  }, {
	    key: 'once',
	    value: function once(evt, opts) {
	      var cb = arguments.length <= 2 || arguments[2] === undefined ? noop : arguments[2];
	
	      if (typeof opts === 'function') {
	        cb = opts;
	        opts = null;
	      }
	      return this.subscribe(evt, true, opts, cb);
	    }
	  }, {
	    key: 'off',
	    value: function off(subscriptionRef) {
	      return _connection_manager2.default.deleteHandler(subscriptionRef);
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'fetchPresence',
	    value: function fetchPresence(uid) {
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      var stanza;
	      if (isNil(uid)) {
	        uid = [];
	      }
	      if (!Array.isArray(uid)) {
	        uid = [uid];
	      }
	      stanza = $iq({
	        type: 'get'
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/presence'
	      });
	      uid.forEach(function (id) {
	        return stanza.c('uid', id).up();
	      });
	      return this.sendIQ(stanza, cb);
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'inviteUsersToRoom',
	    value: function inviteUsersToRoom(room_jid, user_jids, reason, id) {
	      var attrs, node;
	      if (isNil(user_jids)) {
	        user_jids = [];
	      }
	      if (isNil(reason)) {
	        reason = '';
	      }
	      if (isNil(id)) {
	        id = null;
	      }
	      if (!Array.isArray(user_jids)) {
	        user_jids = [user_jids];
	      }
	      attrs = {
	        to: room_jid,
	        id: Math.random() * 10000000 | 0
	      };
	      if (id !== null) {
	        attrs['id'] = id;
	      }
	      node = $msg(attrs).c('x', {
	        xmlns: 'http://jabber.org/protocol/muc#user'
	      });
	      user_jids.forEach(function (jid) {
	        node.c('invite', {
	          to: jid
	        });
	        node.c('reason');
	        node.t(reason);
	        node.up();
	        return node.up();
	      });
	      return _connection_manager2.default.send(node.tree());
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'removeUsersFromRoom',
	    value: function removeUsersFromRoom(room_jid, user_jids) {
	      var cb = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	      var stanza;
	      if (isNil(user_jids)) {
	        user_jids = [];
	      }
	      if (!Array.isArray(user_jids)) {
	        user_jids = [user_jids];
	      }
	      _logger2.default.info('Removing users from room - room_jid: ' + room_jid + ', user_jids: ' + user_jids);
	      stanza = $iq({
	        type: 'set',
	        to: room_jid
	      }).c('query', {
	        xmlns: 'http://hipchat.com'
	      });
	      user_jids.forEach(function (jid) {
	        stanza.c('item', {
	          jid: jid,
	          affiliation: "none"
	        });
	        return stanza.up();
	      });
	      return this.sendIQ(stanza, cb);
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'fetchHistory',
	    value: function fetchHistory(jid, before, maxstanzas, id, cb) {
	      var opts, stanza;
	      if (isNil(maxstanzas)) {
	        maxstanzas = 50;
	      }
	      if (_configuration_store2.default.isGuest()) {
	        return false;
	      }
	      _logger2.default.info('Getting history - jid: ' + jid);
	      opts = {
	        xmlns: 'http://hipchat.com/protocol/history',
	        maxstanzas: maxstanzas,
	        type: this.getJidType(jid)
	      };
	      if (!isNil(before)) {
	        opts.before = this.toXMPPDate(before);
	      }
	      stanza = $iq({
	        type: 'get',
	        to: jid,
	        id: id
	      }).c('query', opts);
	      return this.sendIQ(stanza, cb);
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'fetchUserProfile',
	    value: function fetchUserProfile(jid) {
	      var _this2 = this;
	
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      var stanza;
	      if (!jid) {
	        return;
	      }
	      if (this.cached_profiles[jid] && cb) {
	        cb(this.cached_profiles[jid]);
	        return;
	      }
	      _logger2.default.info('Fetching profile - jid: ' + jid);
	      stanza = $iq({
	        type: 'get',
	        to: jid
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/profile'
	      });
	      return this.sendIQ(stanza, function (data) {
	        if (!data.error) {
	          _this2.cached_profiles[jid] = data;
	        }
	        if (cb) {
	          return cb(data);
	        }
	      });
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'joinChat',
	    value: function joinChat(jid) {
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];
	
	      return this.sendStateMessage(jid, 'chat', 'active');
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'sendMessage',
	    value: function sendMessage(msg) {
	      var attrs, node;
	      attrs = {
	        to: msg.jid,
	        type: this.getJidType(msg.jid),
	        id: Math.random() * 10000000 | 0
	      };
	      if (msg.id !== null) {
	        attrs['id'] = msg.id;
	      }
	      node = $msg(attrs).c('body').t(msg.text).up();
	      if (attrs.type === 'chat') {
	        attrs.from = _configuration_store2.default.get('jid');
	        node.c('active', {
	          xmlns: 'http://jabber.org/protocol/chatstates'
	        }).up().c('x', {
	          xmlns: 'http://hipchat.com'
	        }).c('echo').up().up();
	      }
	      if (msg.xhtml) {
	        node.c('html').c('body').c('p').h(msg.xhtml);
	      }
	      return _connection_manager2.default.send(node.tree());
	    }
	
	    /**
	     * Sends a message stanza with a replace node
	     * @deprecated
	     */
	
	  }, {
	    key: 'editMessage',
	    value: function editMessage(jid, text, original_mid, ts, id) {
	      var attrs, node;
	      if (isNil(id)) {
	        id = null;
	      }
	      attrs = {
	        to: jid,
	        type: this.getJidType(jid),
	        from: _configuration_store2.default.get('jid'),
	        id: Math.random() * 10000000 | 0
	      };
	      if (id !== null) {
	        attrs['id'] = id;
	      }
	      node = $msg(attrs).c('body').t(text).up();
	      node.c('replace', {
	        xmlns: 'urn:xmpp:message-correct:0',
	        id: original_mid,
	        ts: ts
	      }).up().c('x', {
	        xmlns: 'http://hipchat.com'
	      }).c('echo');
	      return _connection_manager2.default.send(node.tree());
	    }
	
	    /**
	     * Deletes a message
	     * @deprecated
	     */
	
	  }, {
	    key: 'deleteMessage',
	    value: function deleteMessage(msg) {
	      // current implementation of deleting a message is to send an edit message with an empty message body
	      // shortcutting to reusing sendEditMessage for now to minimize code duplication
	      return this.editMessage(msg.from, "", msg.mid, msg.ts);
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'sendStateMessage',
	    value: function sendStateMessage(jid, type, state) {
	      var attrs, node;
	      attrs = {
	        to: jid,
	        type: type,
	        id: Math.random() * 10000000 | 0
	      };
	      node = $msg(attrs).c(state, {
	        xmlns: 'http://jabber.org/protocol/chatstates'
	      }).up();
	      return _connection_manager2.default.send(node.tree());
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'savePreferences',
	    value: function savePreferences() {
	      var _this3 = this;
	
	      var changeset = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      var token = _configuration_store2.default.get('apiv1_token');
	      if (!token || _configuration_store2.default.get('is_guest') || !_connection_manager2.default.isConnected()) {
	        return;
	      }
	      if (_.has(changeset, 'autoJoin')) {
	        if (!Array.isArray(changeset.autoJoin)) {
	          delete changeset.autoJoin;
	        } else {
	          changeset.autoJoin = _.reduce(changeset.autoJoin, function (acc, room) {
	            if (_.isPlainObject(room) && !_.isEmpty(room)) {
	              acc.push(room);
	            }
	
	            return acc;
	          }, []);
	        }
	      }
	      if (!_.isEmpty(changeset)) {
	        var jsonResp;
	        return $.ajax({
	          type: 'POST',
	          dataType: 'json',
	          url: _configuration_store2.default.get('base_url') + '/api/save_preferences',
	          data: {
	            json: (0, _stringify2.default)(_.omitBy(changeset, _.isNull)),
	            user_id: _configuration_store2.default.get('user_id'),
	            group_id: _configuration_store2.default.get('group_id'),
	            token: token,
	            format: 'json'
	          },
	          async: true,
	          complete: function complete(resp) {
	            try {
	              jsonResp = JSON.parse(resp.responseText);
	              if (jsonResp.error && jsonResp.error === 'Invalid token') {
	                _connection_manager2.default.updateApiV1Token().then(function () {
	                  _this3.savePrefsAttempts++;
	                  if (_this3.savePrefsAttempts <= 5) {
	                    _this3.savePrefsRetryDelay = _utils2.default.decorrelatedJitter(Constants.RECONNECT_MAX_DELAY, Constants.RECONNECT_DELAY_MS, _this3.savePrefsRetryDelay, Constants.RECONNECT_BACKOFF_FACTOR);
	                    _.delay(_this3.savePreferences.bind(_this3), _this3.savePrefsRetryDelay);
	                  }
	                });
	              } else {
	                _this3.savePrefsAttempts = 0;
	                cb();
	              }
	            } catch (e) {
	              _logger2.default.warn('[API V1 response structure:] ' + resp.responseText);
	              cb(resp.responseText);
	            }
	          }
	        });
	      }
	    }
	
	    /**
	     * Looks to be completely unused
	     * @deprecated
	     */
	
	  }, {
	    key: 'sendUploadMessage',
	    value: function sendUploadMessage(data) {
	      var attrs, file_info, msg;
	      if (!_connection_manager2.default.isConnected()) {
	        return false;
	      }
	      file_info = _x2js2.default.xml2json(data.file_info);
	      attrs = {
	        to: data.jid,
	        type: data.type
	      };
	      msg = $msg(attrs).c('x', {
	        xmlns: 'http://hipchat.com/protocol/muc#room'
	      }).c('file', {
	        'id': file_info.response.file_id
	      }).up().up();
	      if (data.type !== 'groupchat') {
	        msg.c('x', {
	          xmlns: 'http://hipchat.com'
	        }).c('echo').up().up();
	      }
	      return _connection_manager2.default.send(msg.tree());
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'clearWebCookies',
	    value: function clearWebCookies() {
	      var cb = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	      var url = _utils2.default.url.clearWebCookies(_configuration_store2.default.get('web_server'));
	      if (url) {
	        _utils2.default.request.simplePost(url, cb);
	      }
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'revokeOauth2Token',
	    value: function revokeOauth2Token() {
	      var cb = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	      var token = _configuration_store2.default.getOAuthToken(),
	          url = _utils2.default.url.revokeOauth2Token(_configuration_store2.default.get('api_host'), token);
	      $.ajax({
	        type: 'DELETE',
	        beforeSend: function beforeSend(xhr) {
	          xhr.setRequestHeader('Authorization', 'Bearer ' + token);
	        },
	        url: url,
	        async: true,
	        success: function success(resp) {
	          cb(resp);
	        },
	        error: function error(resp) {
	          cb(resp);
	        }
	      });
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'requestAddliveCredentials',
	    value: function requestAddliveCredentials(jid) {
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      var done, fail, stanza;
	      stanza = $iq({
	        to: jid,
	        type: 'get'
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/addlive'
	      });
	      done = function done(resp) {
	        resp = _x2js2.default.xml2json(resp);
	        return cb(null, resp.query);
	      };
	      fail = function fail(resp) {
	        resp = _x2js2.default.xml2json(resp);
	        return cb(resp.error);
	      };
	      return _connection_manager2.default.sendIQ(stanza, done, fail);
	    }
	
	    /**
	     * @deprecated
	     */
	
	  }, {
	    key: 'sendVideoMessage',
	    value: function sendVideoMessage() {
	      var attrs = void 0,
	          data = arguments.length <= 0 ? undefined : arguments[0],
	          type = data.type,
	          node = void 0,
	          id = Math.random() * 10000000 | 0;
	      if (isNil(data.type)) {
	        type = 'call';
	      }
	      if (!_connection_manager2.default.isConnected()) {
	        return false;
	      }
	      attrs = {
	        to: data.jid,
	        type: this.getJidType(data.jid),
	        from: _configuration_store2.default.get('user_jid'),
	        id: id
	      };
	      node = $msg(attrs).c('x', {
	        xmlns: 'http://hipchat.com/protocol/' + data.service
	      }).c(type);
	      if (data.service === 'enso') {
	        if (type === 'call') {
	          node.c('url').t(data.url);
	          node.up().up().up().c('body').t(_video_call_strings2.default.enso_to_addlive(data.url.replace('/join/', '/call/')));
	        } else if (type === 'decline') {
	          node.c('reason').t(data.reason);
	        }
	      } else {
	        node.c('audio').up();
	        if (!data.audio_only) {
	          node.c('video');
	        }
	      }
	      this.once('videoMessage', { id: id }, data.callback);
	      return _connection_manager2.default.send(node.tree());
	    }
	  }]);
	  return HipChat;
	}();
	
	exports.default = new HipChat();
	module.exports = exports['default'];

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _for = __webpack_require__(145);
	
	var _for2 = _interopRequireDefault(_for);
	
	var _constants = __webpack_require__(163);
	
	var Constants = _interopRequireWildcard(_constants);
	
	var _timer = __webpack_require__(209);
	
	var _timer2 = _interopRequireDefault(_timer);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _connection_manager_connection = __webpack_require__(210);
	
	var _connection_manager_connection2 = _interopRequireDefault(_connection_manager_connection);
	
	var _x2js = __webpack_require__(213);
	
	var _x2js2 = _interopRequireDefault(_x2js);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _config_actions = __webpack_require__(159);
	
	var _config_actions2 = _interopRequireDefault(_config_actions);
	
	var _configuration_model = __webpack_require__(201);
	
	var _configuration_model2 = _interopRequireDefault(_configuration_model);
	
	var _connection_actions = __webpack_require__(215);
	
	var _connection_actions2 = _interopRequireDefault(_connection_actions);
	
	var _ping_plugin = __webpack_require__(216);
	
	var _ping_plugin2 = _interopRequireDefault(_ping_plugin);
	
	var _connection_hooks_plugin = __webpack_require__(230);
	
	var _connection_hooks_plugin2 = _interopRequireDefault(_connection_hooks_plugin);
	
	var _rooms_plugin = __webpack_require__(231);
	
	var _rooms_plugin2 = _interopRequireDefault(_rooms_plugin);
	
	var _chat_plugin = __webpack_require__(233);
	
	var _chat_plugin2 = _interopRequireDefault(_chat_plugin);
	
	var _presence_plugin = __webpack_require__(234);
	
	var _presence_plugin2 = _interopRequireDefault(_presence_plugin);
	
	var _xmpp_trap_plugin = __webpack_require__(235);
	
	var _xmpp_trap_plugin2 = _interopRequireDefault(_xmpp_trap_plugin);
	
	var _roster_plugin = __webpack_require__(238);
	
	var _roster_plugin2 = _interopRequireDefault(_roster_plugin);
	
	var _emoticons_plugin = __webpack_require__(239);
	
	var _emoticons_plugin2 = _interopRequireDefault(_emoticons_plugin);
	
	var _cache_plugin = __webpack_require__(240);
	
	var _cache_plugin2 = _interopRequireDefault(_cache_plugin);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _dal3 = __webpack_require__(144);
	
	var _dal4 = _interopRequireDefault(_dal3);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var STATE = (0, _for2.default)('HJC.Connection.Manager.State');
	var PREFIX = '[Connection]';
	
	/**
	 * @class ConnectionManager
	 * @singleton
	 */
	
	var ConnectionManager = function () {
	  function ConnectionManager() {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, ConnectionManager);
	
	
	    /**
	     * Internal STATE
	     */
	    this[STATE] = {
	      isInitialConnect: true,
	      connected: false,
	      shouldReconnect: true, //should only ever be set to false when exiting the app
	      isRefreshOAuthTokenInFlight: false,
	      isSessionRequestInFlight: false,
	      reconnectDelay: Constants.RECONNECT_DELAY_MS,
	      oauthTokenRefreshDelay: Constants.OAUTH_TOKEN_REFRESH_DELAY_MS,
	      reconnectAttempts: 0,
	      disconnectedTimestamp: null
	    };
	
	    this.refreshOAuthToken = function () {
	      _promise2.default.resolve();
	    };
	
	    /**
	     * Can't instantiate this until after we get the bind_url
	     * @property Connection
	     * @type {Strophe.Connection}
	     */
	    this.Connection = null;
	
	    /**
	     * Started once the CM sends a 'connect' stanza to the server when
	     * trying to reconnect. If the app connects before it runs out, it
	     * will clear itself. If not, it will re-call the 'reconnect' method
	     * to try again
	     *
	     * @property {Timer} reconnectionTimer
	     */
	    this.reconnectionTimer = new _timer2.default(function () {
	      if (_this[STATE].shouldReconnect || _this.isBOSHSessionExpired()) {
	        _this.reconnect(false);
	      }
	    }, this[STATE].reconnectDelay);
	
	    /**
	     * For OAuth, starts once connection is established and executes
	     * an hour later when the oauth token has expired to get a new token
	     *
	     * @property {Timer} oauthRefreshTimer
	     */
	    this.oauthRefreshTimer = new _timer2.default(function () {
	      _logger2.default.debug(PREFIX, 'OAuth timer expired. Fetching new OAuth token');
	      _analytics_dispatcher2.default.dispatch('analytics-event', {
	        name: 'hipchat.client.oauth.token.refresh.requested',
	        properties: {
	          reason: 'Token expiry timer lapsed'
	        }
	      });
	      _this._getNewOAuthToken().then(_.noop).catch(function (err) {
	        _logger2.default.error(PREFIX, 'Failed to fetch new OAuth token due to: ' + err);
	      });
	    }, 3599000, 5000);
	    this.oauthRetryTimer = null;
	
	    /**
	     * The apiV1TokenRefreshTimer is started on initial connect.
	     * Refreshes the token each time it fires, then starts over again
	     */
	    this.apiV1TokenRefreshTimer = new _timer2.default(function () {
	      _this.updateApiV1Token().catch(function () {});
	    }, _configuration_store2.default.getApiV1TokenExpiry(), 5000);
	  }
	
	  //TODO: temp stopgap to get this holdover callback from native initState in here
	
	
	  (0, _createClass3.default)(ConnectionManager, [{
	    key: 'setOAuthTokenCallback',
	    value: function setOAuthTokenCallback(callback) {
	      if (_.isFunction(callback)) {
	        this.refreshOAuthToken = callback;
	      }
	      return this;
	    }
	
	    /**
	     * Begins connection. Nothing happens until this method is called
	     *
	     * @method connect
	     */
	
	  }, {
	    key: 'connect',
	    value: function connect() {
	      var _this2 = this;
	
	      return this._initializeSession().then(function () {
	
	        /**
	         * Install Strophe Connection plugins. You only need to do this once, and before
	         * the Strophe.Connection is instantiated. Installing them here as the client
	         * configuration will be guaranteed by this point from the _initializeSession method.
	         * NOTE: ConnectionHooks must be installed first as it provides hooks
	         * other plugins are using
	         */
	        Strophe.addConnectionPlugin('ConnectionHooks', new _connection_hooks_plugin2.default());
	        Strophe.addConnectionPlugin('XMPPTrapPlugin', new _xmpp_trap_plugin2.default());
	        Strophe.addConnectionPlugin('Presence', new _presence_plugin2.default());
	        Strophe.addConnectionPlugin('Ping', new _ping_plugin2.default());
	        Strophe.addConnectionPlugin('Rooms', new _rooms_plugin2.default());
	        Strophe.addConnectionPlugin('Chat', new _chat_plugin2.default());
	        Strophe.addConnectionPlugin('Roster', new _roster_plugin2.default());
	        Strophe.addConnectionPlugin('Emoticons', new _emoticons_plugin2.default());
	        Strophe.addConnectionPlugin('Cache', new _cache_plugin2.default());
	
	        _this2.Connection = new _connection_manager_connection2.default();
	        return _this2._doConnect();
	      }).then(function () {
	        _this2._registerEventListeners();
	      }).catch(function (error) {
	        _logger2.default.error('[ConnectionManager.connect]: ', error);
	      });
	    }
	
	    /**
	     * Does the initial connection handshake requests to the server. If
	     * the ajax and auth handshake is successful, will resolve. If the
	     * requests time out, auth fail or connection fail, will reject
	     * @returns {Promise}
	     * @private
	     */
	
	  }, {
	    key: '_doConnect',
	    value: function _doConnect() {
	      var _this3 = this;
	
	      return new _promise2.default(function (resolve, reject) {
	        _this3.Connection.ConnectionHooks.addXmppConnectedHandler(function () {
	          _logger2.default.debug(PREFIX, 'Strophe successfully connected');
	          _this3._resetForNewReconnection();
	          _this3[STATE].connected = true;
	
	          resolve();
	          return false;
	        });
	
	        _this3.Connection.ConnectionHooks.addXmppDisconnectedHandler(function (status, condition) {
	          _logger2.default.error(PREFIX, 'Strophe failed to connect. Status: ' + status + ', Condition: ' + condition);
	          reject({ status: status, condition: condition });
	          return false;
	        });
	
	        _this3.Connection.connect(_configuration_store2.default.get('jid'), null, _this3._onConnectionChange.bind(_this3), null, null, _configuration_store2.default.get('route'));
	      });
	    }
	
	    /**
	     * Initiate reconnection request through Strophe
	     *
	     * @method reconnect
	     */
	
	  }, {
	    key: 'reconnect',
	    value: function reconnect() {
	      var resetAndReconnect = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	      if (this[STATE].connected || this[STATE].isSessionRequestInFlight) {
	        return _promise2.default.resolve();
	      }
	
	      if (resetAndReconnect) {
	        this._resetForNewReconnection();
	        this[STATE].connected = false;
	        clearTimeout(this.oauthRetryTimer);
	      }
	
	      return this._doReconnect();
	    }
	
	    /**
	     * @method _doReconnect
	     */
	
	  }, {
	    key: '_doReconnect',
	    value: function _doReconnect() {
	      var _this4 = this;
	
	      _logger2.default.debug(PREFIX, 'Strophe reconnecting');
	
	      this.reconnectionTimer.clear();
	      this[STATE].reconnectAttempts++;
	      if (this[STATE].reconnectAttempts < 6) {
	        this._signalReconnecting();
	      }
	
	      return this._reestablishSession().then(function () {
	        _this4.Connection.disconnect('Resetting before reconnect');
	        _this4.Connection.reset();
	        return _this4._doConnect();
	      }).catch(function (data) {
	        _logger2.default.error(PREFIX, 'Error reestablishing connection. Server response: ' + (0, _stringify2.default)(data));
	        // Your session cookie has expired. You need to login again
	        if (data && data.refresh_page) {
	          _connection_actions2.default.reconnectionError(PREFIX + ' Error reestablishing connection. Server response: ' + (0, _stringify2.default)(data));
	        }
	
	        _this4._setReconnectTimer();
	
	        if (_this4[STATE].reconnectAttempts < 5) {
	          _this4._signalReconnectDelay();
	          _logger2.default.debug(PREFIX, 'reconnect(). Next attempt in ' + _this4[STATE].reconnectDelay / 1000 + 's');
	        } else {
	          _this4._signalConnectionFailed('Error: 5 failure attempts to reestablish connection. Server response (if any): ' + (0, _stringify2.default)(data));
	        }
	      });
	    }
	
	    /**
	     * Disconnect from xmpp, put in not-connected STATE
	     * and kill any timers going on
	     *
	     * @method disconnect
	     * @param {boolean} should_reconnect
	     */
	
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      var should_reconnect = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	      _logger2.default.debug(PREFIX, 'disconnect() called.');
	      if (!should_reconnect) {
	        _logger2.default.debug(PREFIX, 'disconnect() called. Should not auto-reconnect.');
	        this[STATE].shouldReconnect = false;
	        this.reconnectionTimer.clear();
	      }
	      this[STATE].connected = false;
	      this.Connection.disconnect();
	      this.Connection.flush();
	    }
	
	    /**
	     * Pass through to Strophe.Connection.send
	     * @method send
	     */
	
	  }, {
	    key: 'send',
	    value: function send() {
	      var _Connection;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      if (!this.Connection) {
	        _logger2.default.error(PREFIX, 'Attempted to send stanza before establishing an initial XMPP connection:', arguments[0].outerHTML);
	        return;
	      }
	      (_Connection = this.Connection).send.apply(_Connection, args);
	    }
	
	    /**
	     * Pass through to Strophe.Connection.sendIQ
	     */
	
	  }, {
	    key: 'sendIQ',
	    value: function sendIQ() {
	      var _Connection2;
	
	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	
	      if (!this.Connection) {
	        _logger2.default.error(PREFIX, 'Attempted to sendIQ before establishing an initial XMPP connection:', arguments[0].outerHTML);
	        return;
	      }
	      (_Connection2 = this.Connection).sendIQ.apply(_Connection2, args);
	    }
	
	    /**
	     * Pass through to Strophe.Connection.addHandler
	     * @returns {Strophe.Handler}
	     */
	
	  }, {
	    key: 'addHandler',
	    value: function addHandler() {
	      if (this.Connection) {
	        var _Connection3;
	
	        return (_Connection3 = this.Connection).addHandler.apply(_Connection3, arguments);
	      }
	    }
	
	    /**
	     * Pass through to Strophe.Connection.addTimedHandler
	     * @returns {Strophe.Handler}
	     */
	
	  }, {
	    key: 'addTimedHandler',
	    value: function addTimedHandler() {
	      if (this.Connection) {
	        var _Connection4;
	
	        return (_Connection4 = this.Connection).addTimedHandler.apply(_Connection4, arguments);
	      }
	    }
	
	    /**
	     * Pass through to Strophe.Connection.deleteHandler
	     * @method deleteHandler
	     */
	
	  }, {
	    key: 'deleteHandler',
	    value: function deleteHandler() {
	      if (this.Connection) {
	        var _Connection5;
	
	        (_Connection5 = this.Connection).deleteHandler.apply(_Connection5, arguments);
	      }
	    }
	
	    /**
	     * Returns the time (in milliseconds) the last disconnection occurrred
	     * @return {Date} The time the last disconnect occurred
	     */
	
	  }, {
	    key: 'getDisconnectedTimestamp',
	    value: function getDisconnectedTimestamp() {
	      return this[STATE].disconnectedTimestamp;
	    }
	
	    /**
	     * @method isConnected
	     * @returns {boolean} is it currently connected
	     */
	
	  }, {
	    key: 'isConnected',
	    value: function isConnected() {
	      return this[STATE].connected;
	    }
	
	    /**
	     * @method isInitialConnect
	     * @returns {boolean}
	     */
	
	  }, {
	    key: 'isInitialConnect',
	    value: function isInitialConnect() {
	      return this[STATE].isInitialConnect;
	    }
	
	    /**
	     * @method isBOSHSessionExpired
	     */
	
	  }, {
	    key: 'isBOSHSessionExpired',
	    value: function isBOSHSessionExpired() {
	      return _utils2.default.now() - this.Connection.last_BOSH_activity > this.Connection.allowedInactivityInterval + Constants.NETWORK_LATENCY_GRACE_PERIOD;
	    }
	
	    /**
	     * @method updateApiV1Token - Send the IQ to update the API V1 token
	     * @return {promise}
	     */
	
	  }, {
	    key: 'updateApiV1Token',
	    value: function updateApiV1Token() {
	      var _this5 = this;
	
	      return new _promise2.default(function (resolve) {
	        var stanza = $iq({
	          type: 'get',
	          to: _configuration_store2.default.get('chat_server')
	        }).c('query', {
	          xmlns: 'http://hipchat.com/protocol/auth'
	        });
	        _this5.Connection.sendIQ(stanza, function (response) {
	          var parsedResponse = _x2js2.default.xml2json(response);
	          if (parsedResponse.query.token) {
	            _config_actions2.default.updateAuthTokens(new _configuration_model2.default({
	              token: _x2js2.default.xml2json(response).query.token
	            }));
	            _this5.apiV1TokenRefreshTimer.clear().resetTime(_configuration_store2.default.getApiV1TokenExpiry()).start();
	          }
	          resolve();
	        });
	      });
	    }
	
	    /**
	     * @function _initializeSession
	     * @private
	     * @returns {Promise}
	     */
	
	  }, {
	    key: '_initializeSession',
	    value: function _initializeSession() {
	      var _this6 = this;
	
	      return new _promise2.default(function (resolve, reject) {
	        // If in oauth mode, we should've been provided the config we need so resolve with what we have
	        // If there's a base_url defined, then we're connecting to a server that requires a nonce token
	        // (ie. connecting to atlassian.hipchat.com from a devvm). This only happens when you gulp build
	        // with an explicit HC_WEB_BASEURL defined. In that case, we need to get that session token
	        // and then resolve with the response we get. Otherwise, just proceed and connect. In production,
	        // no base_url is defined, and the session token is passed from web in the initial STATE
	        if (!_configuration_store2.default.get('base_url') || _configuration_store2.default.isOAuth()) {
	          _dal4.default.configure(_configuration_store2.default.get('user_id'), _configuration_store2.default.get('group_id'));
	          return resolve();
	        }
	
	        var request = $.ajax({
	          url: _configuration_store2.default.get('base_url') + '/chat/session?nonce_auth=1',
	          type: 'GET',
	          headers: {
	            'accepts': 'application/json'
	          }
	        });
	
	        request.done(function (response) {
	          if (response.error) {
	            reject(response.error);
	          } else {
	            _config_actions2.default.updateAppConfiguration(new _configuration_model2.default(response));
	            _dal4.default.configure(_configuration_store2.default.get('user_id'), _configuration_store2.default.get('group_id'));
	            resolve();
	          }
	        }).fail(function (jqXHR) {
	          _this6._handleErrorResponse(jqXHR, reject);
	        });
	      });
	    }
	
	    /**
	     * For Nonce, post ajax req to /chat/session to reestablish session
	     * For OAuth, if the token is old, get a new one
	     *
	     * @function _reestablishSession
	     * @private
	     */
	
	  }, {
	    key: '_reestablishSession',
	    value: function _reestablishSession() {
	      var _this7 = this;
	
	      return new _promise2.default(function (resolve, reject) {
	        if (_configuration_store2.default.isNonce()) {
	          _this7[STATE].isSessionRequestInFlight = true;
	
	          var request = $.ajax({
	            url: _configuration_store2.default.get('base_url') + '/chat/session',
	            type: 'GET',
	            timeout: 10000,
	            data: {
	              is_guest: _configuration_store2.default.isGuest(),
	              guest_key: _configuration_store2.default.get('guest_key'),
	              uid: _configuration_store2.default.get('user_id'),
	              nonce_auth: 1
	            }
	          });
	
	          request.done(function (response) {
	            if (response.error) {
	              reject(response);
	            } else {
	              _config_actions2.default.updateAppConfiguration(new _configuration_model2.default(response));
	              resolve();
	            }
	          }).fail(function (jqXHR) {
	            _this7._handleErrorResponse(jqXHR, reject);
	          }).always(function () {
	            _this7[STATE].isSessionRequestInFlight = false;
	          });
	        } else if (_configuration_store2.default.isOAuth()) {
	          if (_this7.oauthRefreshTimer.hasExpired()) {
	            _analytics_dispatcher2.default.dispatch('analytics-event', {
	              name: 'hipchat.client.oauth.token.refresh.requested',
	              properties: {
	                reason: '_reestablishSession() called'
	              }
	            });
	            _this7._getNewOAuthToken().then(resolve).catch(reject);
	          } else {
	            _dal2.default.checkNetwork().then(resolve).catch(reject);
	          }
	        }
	      });
	    }
	
	    /**
	     * Does the jQuery-specific responseText checking on the xhr for errors
	     *
	     * @param xhr the jqXHR object
	     * @param callback the function you intend to use as your error handler
	     * @private
	     */
	
	  }, {
	    key: '_handleErrorResponse',
	    value: function _handleErrorResponse(xhr, callback) {
	      var response = xhr.responseText;
	      if (_.isString(response) && response !== "") {
	        try {
	          response = JSON.parse(response);
	        } catch (e) {
	          response = {
	            error: e
	          };
	        }
	      }
	      callback(response, xhr);
	    }
	
	    /**
	     * Request the startup stanza from xmpp, and resolve
	     * once it comes back
	     *
	     * @method _getStartupStanza
	     * @private
	     * @returns {Promise}
	     */
	
	  }, {
	    key: '_getStartupStanza',
	    value: function _getStartupStanza() {
	      var _this8 = this;
	
	      return new _promise2.default(function (resolve) {
	        var stanza = $iq({
	          type: 'get',
	          id: Math.random() * 10000000 | 0
	        }).c('query', {
	          xmlns: 'http://hipchat.com/protocol/startup',
	          send_auto_join_user_presences: false
	        });
	        _this8.Connection.sendIQ(stanza, function (d) {
	          resolve();
	        });
	      });
	    }
	
	    /**
	     * Fetch feature flags from [server]/api/features
	     *
	     * @method _getFeatureFlags
	     * @private
	     * @returns {Object}
	     */
	
	  }, {
	    key: '_getFeatureFlags',
	    value: function _getFeatureFlags() {
	      return new _promise2.default(function (resolve, reject) {
	        $.ajax({
	          type: 'POST',
	          url: _utils2.default.url.featureFlagsAPI(_configuration_store2.default.get('base_url')),
	          dataType: 'json',
	          data: {
	            user_id: _configuration_store2.default.get('user_id'),
	            group_id: _configuration_store2.default.get('group_id')
	          }
	        }).done(function (data) {
	          var featureFlags = _.pickBy(data.features, function (val, key) {
	            return key.indexOf('web_client') === 0 || key === 'btf' || key === 'entity_versioning';
	          } // conditions copied from chat.php
	          );
	          // Pass native_feature_flags along with feature_flags so Configuration Model
	          // correctly reconciles the flags
	          var flags = new _configuration_model2.default({
	            'feature_flags': featureFlags,
	            'native_feature_flags': _configuration_store2.default.get("native_feature_flags")
	          });
	          _config_actions2.default.updateFeatureFlags(flags);
	          resolve(flags);
	        }).fail(function (jqXHR, textStatus) {
	          _logger2.default.error("[_getFeatureFlags]", jqXHR.statusText);
	          reject(jqXHR.statusText);
	        });
	      });
	    }
	
	    /**
	     * @method _setReconnectTimer
	     */
	
	  }, {
	    key: '_setReconnectTimer',
	    value: function _setReconnectTimer() {
	      var decorrelatedJitterMS = _utils2.default.decorrelatedJitter(Constants.RECONNECT_MAX_DELAY, Constants.RECONNECT_DELAY_MS, this[STATE].reconnectDelay, Constants.RECONNECT_BACKOFF_FACTOR);
	      this[STATE].reconnectDelay = Math.round(decorrelatedJitterMS / 1000) * 1000;
	      _logger2.default.debug(PREFIX, 'Attempting reconnect in ' + this[STATE].reconnectDelay);
	      this.reconnectionTimer.resetTime(this[STATE].reconnectDelay).start();
	    }
	
	    /**
	    * Reset variables used for reconnection attempts.
	    * This should only be used after 5 failed reconnection attempts.
	    *
	    * @method _resetForNewReconnection
	    */
	
	  }, {
	    key: '_resetForNewReconnection',
	    value: function _resetForNewReconnection() {
	      this[STATE].shouldReconnect = true;
	      this[STATE].reconnectDelay = Constants.RECONNECT_DELAY_MS;
	      this[STATE].reconnectAttempts = 0;
	    }
	
	    /**
	     * Callback fired whenever Strophe signals a connection change
	     * Exported to make mocking easier. Not to be used outside of testing
	     *
	     * @method _onConnectionChange
	     * @private
	     * @param status
	     * @param condition
	     */
	
	  }, {
	    key: '_onConnectionChange',
	    value: function _onConnectionChange(status, condition) {
	      var _this9 = this;
	
	      switch (status) {
	
	        /**
	         * Reset flags to connected status
	         * Kill reconnect timer
	         * Emit connect + initial-connect/reconnect events
	         */
	        case Strophe.Status.CONNECTED:
	          this._updateSID();
	
	          _logger2.default.debug(PREFIX, 'Strophe connected');
	
	          var promises = [];
	
	          if (_configuration_store2.default.isOAuth()) {
	            promises.push(this._getStartupStanza().then(function () {
	              _logger2.default.debug(PREFIX, 'Startup stanza received');
	              _config_actions2.default.updateAuthTokens({
	                apiv1_token: _configuration_store2.default.getApiV1Token()
	              });
	              _this9.apiV1TokenRefreshTimer.resetTime(_configuration_store2.default.getApiV1TokenExpiry()).restart();
	            }).catch(function (err) {
	              _logger2.default.error(PREFIX, 'Error getting startup stanza', err);
	            }));
	            if (this[STATE].isInitialConnect) {
	              this.oauthRefreshTimer.resetTime(_configuration_store2.default.getOAuthTokenExpiry()).start();
	            } else {
	              this.oauthRefreshTimer.resume();
	            }
	          } else if (_configuration_store2.default.isNonce() && !_configuration_store2.default.isGuest()) {
	            this.apiV1TokenRefreshTimer.resetTime(_configuration_store2.default.getApiV1TokenExpiry()).restart();
	          }
	
	          if (this[STATE].isInitialConnect) {
	            _connection_actions2.default.stropheConnected();
	          } else {
	            _connection_actions2.default.stropheReconnected();
	          }
	
	          promises.push(this._getFeatureFlags().then(function () {
	            _logger2.default.debug(PREFIX, 'Feature flags received');
	          }).catch(function (err) {
	            _logger2.default.error(PREFIX, 'Error getting feature flags', err);
	          }));
	
	          return _promise2.default.all(promises).then(function () {
	            if (_this9[STATE].isInitialConnect) {
	              _connection_actions2.default.appStateConnected();
	              _this9[STATE].isInitialConnect = false;
	            } else {
	              _connection_actions2.default.appStateReconnected();
	            }
	          }).catch(function (err) {
	            _logger2.default.error(PREFIX, 'Unknown connection error', err);
	          });
	
	        /**
	         * Reset flags to disconnected status
	         * If condition is 'conflict', disable reconnect
	         * Emit connection fail
	         */
	        case Strophe.Status.CONNFAIL:
	        case Strophe.Status.AUTHFAIL:
	
	          _logger2.default.debug(PREFIX, '[Strophe] Offline. Condition: ' + condition);
	          this[STATE].connected = false;
	          if (condition === 'conflict' || condition === 'not-allowed' || condition === 'not-authorized') {
	            _connection_actions2.default.stropheAuthFailed(status, condition);
	            this.reconnectionTimer.clear();
	          } else if (condition === 'policy-violation') {
	            _connection_actions2.default.strophePolicyViolation(status, condition);
	            this.reconnectionTimer.clear();
	          } else {
	            this._signalConnectionFailed(condition);
	          }
	          break;
	
	        /**
	         * Reset flags to disconnected status
	         * Start reconnection timer
	         */
	        case Strophe.Status.DISCONNECTED:
	
	          _logger2.default.debug(PREFIX, '[Strophe] Disconnected');
	          this[STATE].disconnectedTimestamp = new Date().getTime();
	          this[STATE].connected = false;
	          this.oauthRefreshTimer.pause();
	          this.apiV1TokenRefreshTimer.clear();
	          _connection_actions2.default.stropheDisconnected();
	          if (this[STATE].shouldReconnect) {
	            _logger2.default.debug(PREFIX, '[Strophe] Disconnected and attempting Reconnect');
	            this.reconnect(false);
	          }
	          break;
	
	        /**
	         * Just log. No further action needed
	         */
	        case Strophe.Status.AUTHENTICATING:
	          _logger2.default.debug(PREFIX, '[Strophe] Authenticating');
	          _connection_actions2.default.stropheAuthenticating();
	          break;
	
	        case Strophe.Status.CONNECTING:
	          _logger2.default.debug(PREFIX, '[Strophe] Connecting');
	          break;
	
	        case Strophe.Status.DISCONNECTING:
	          _logger2.default.debug(PREFIX, '[Strophe] Disconnecting. Condition: ' + condition);
	          _connection_actions2.default.stropheDisconnecting({ status: status, condition: condition });
	          break;
	      }
	    }
	
	    /**
	     * @function _getNewOAuthToken
	     * @private
	     */
	
	  }, {
	    key: '_getNewOAuthToken',
	    value: function _getNewOAuthToken() {
	      var _this10 = this;
	
	      // This is currently a pretty janky scenario as the function to actually get a new oauth token is passed in the initState from native
	      // TODO: make this a spi
	      if (this[STATE].isRefreshOAuthTokenInFlight) {
	        _logger2.default.error('Oauth: OAuth token refresh already in progress');
	      }
	
	      return new _promise2.default(function (resolve, reject) {
	        _this10._tryToGetOAuthToken()
	
	        // Success will resolve to: { "access_token": "t0k3n", "expires_in": 0000 }
	        // expires_in is number of seconds (not milliseconds)
	        .then(function (data) {
	          _logger2.default.debug(PREFIX, 'Successfully received new OAuth token. Expires in: ' + data.expires_in + ' seconds.');
	          _this10[STATE].isRefreshOAuthTokenInFlight = false;
	          _this10.oauthRefreshTimer.resetTime(_configuration_store2.default.getOAuthTokenExpiry()).start();
	          try {
	            _config_actions2.default.updateAuthTokens(new _configuration_model2.default(data));
	          } catch (e) {
	            _logger2.default.error(PREFIX, 'Downstream error captured when dispatching new oauth token to the rest of the app: ' + e.message);
	          }
	          resolve();
	        })
	
	        // Rejection will resolve to: { "error": "some error", "error_code": 000, "error_description": "long error string" }
	        // error_code of 302 (or 401) should trigger sign-out as the oauth refresh token on the native side has been revoked
	        .catch(function (data) {
	          _logger2.default.error(PREFIX, 'Failed to retrieve OAuth token: ' + data.error_description);
	          _connection_actions2.default.stropheAuthFailed({
	            status: Strophe.Status.AUTHFAIL,
	            condition: data.error_description
	          });
	          reject();
	        });
	      });
	    }
	  }, {
	    key: '_tryToGetOAuthToken',
	    value: function _tryToGetOAuthToken() {
	      var _this11 = this;
	
	      return new _promise2.default(function (resolve, reject) {
	        var attempts = 1,
	            delay = Constants.OAUTH_TOKEN_REFRESH_DELAY_MS,
	            tryAgain = void 0;
	
	        var onError = function onError(data) {
	          _this11[STATE].isRefreshOAuthTokenInFlight = false;
	          _logger2.default.debug(PREFIX, 'Attempt #' + attempts + ' to refresh oauth token failed with ' + data.error_code + ', ' + data.error_description + '. Retrying again in ' + delay);
	          if (data.error_code === 302 || data.error_code === 401 || data.error_code === 400 && data.error === 'invalid_grant') {
	            reject(data);
	            return;
	          }
	
	          attempts++;
	          delay = _utils2.default.decorrelatedJitter(Constants.OAUTH_TOKEN_REFRESH_MAX_DELAY, Constants.OAUTH_TOKEN_REFRESH_DELAY_MS, delay, Constants.OAUTH_TOKEN_REFRESH_BACKOFF_FACTOR);
	          _this11.oauthRetryTimer = setTimeout(tryAgain, delay);
	        };
	
	        tryAgain = function tryAgain() {
	          _logger2.default.debug(PREFIX, 'Trying to refresh oauth token. Attempt #' + attempts);
	          _this11[STATE].isRefreshOAuthTokenInFlight = true;
	          _this11.refreshOAuthToken().then(resolve).catch(onError);
	        };
	
	        tryAgain();
	      });
	    }
	
	    /**
	     * @private
	     */
	
	  }, {
	    key: '_registerEventListeners',
	    value: function _registerEventListeners() {
	      $(window).on('beforeunload', this._unloadListener.bind(this));
	    }
	
	    /**
	     * Event listener registered on window when the page is being unloaded
	     * @private
	     */
	
	  }, {
	    key: '_unloadListener',
	    value: function _unloadListener() {
	      if (this[STATE].connected) {
	        this.disconnect(false);
	      }
	    }
	  }, {
	    key: '_updateSID',
	    value: function _updateSID() {
	      var sid = _.clone(this.Connection._proto.sid);
	      _config_actions2.default.updateSID(new _configuration_model2.default({
	        sid: sid
	      }));
	    }
	  }, {
	    key: '_signalReconnecting',
	    value: function _signalReconnecting() {
	      _connection_actions2.default.stropheReconnecting({
	        reconnectAttempts: this[STATE].reconnectAttempts
	      });
	    }
	  }, {
	    key: '_signalReconnectDelay',
	    value: function _signalReconnectDelay() {
	      _connection_actions2.default.stropheReconnectDelay({
	        reconnectDelay: this[STATE].reconnectDelay
	      });
	    }
	  }, {
	    key: '_signalConnectionFailed',
	    value: function _signalConnectionFailed(data) {
	      _connection_actions2.default.stropheConnectionFailed(Strophe.Status.CONNFAIL, data);
	    }
	
	    /**
	     * Reset configuration variables to empty STATE
	     * FOR TESTING ONLY
	     * @method reset
	     */
	
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this.Connection = null;
	      this.oauthRefreshTimer.clear();
	      this.reconnectionTimer.clear();
	      this.apiV1TokenRefreshTimer.clear();
	      this[STATE].connected = false;
	      this[STATE].isInitialConnect = true;
	      this[STATE].shouldReconnect = true;
	      this[STATE].reconnectDelay = Constants.RECONNECT_DELAY_MS;
	      this[STATE].reconnectAttempts = 0;
	      this[STATE].isRefreshOAuthTokenInFlight = false;
	      this[STATE].isSessionRequestInFlight = false;
	      $(window).off('beforeunload', this._unloadListener.bind(this));
	    }
	  }]);
	  return ConnectionManager;
	}();
	
	exports.default = new ConnectionManager();
	module.exports = exports['default'];

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Instead of using window.setTimeout for anything that requires real
	 * time-based intervals, use this. It sets an interval that checks
	 * on a given frequency to see if the number of ms have passed since
	 * you started the timer.
	 *
	 * @class Timer
	 */
	
	var Timer = function () {
	
	  /**
	   * @constructs
	   * @param {function} callback
	   * @param {number} delay
	   * @param {number} [interval]
	   * @param {boolean} repeat
	   */
	
	  function Timer(callback, delay, interval) {
	    var repeat = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	    (0, _classCallCheck3.default)(this, Timer);
	
	    this._callback = callback;
	    this._delay = delay;
	    this._repeat = repeat;
	    this.id = null;
	    this.resetTime(delay, interval);
	    this.started = false;
	    this.cleared = false;
	  }
	
	  /**
	   * Starts the timer. Can optionally override the callback,
	   * delay or interval set in the constructor when calling start().
	   * @method start
	   */
	
	
	  (0, _createClass3.default)(Timer, [{
	    key: 'start',
	    value: function start() {
	      var _this = this;
	
	      if (this.id) {
	        this.clear();
	        _logger2.default.info('[Timer]', 'Timer was already running. Clearing timer and restarting.');
	      }
	      this._startTime = new Date().getTime();
	      this.started = true;
	      this.cleared = false;
	      this.id = setInterval(function () {
	        if (_this.hasExpired()) {
	          _this.resolve();
	        }
	      }, this._frequency);
	      return this;
	    }
	
	    /**
	     * Update the time for the timer
	     * @param {number} delay
	     * @param {number} [interval=1000]
	     */
	
	  }, {
	    key: 'resetTime',
	    value: function resetTime(delay) {
	      var interval = arguments.length <= 1 || arguments[1] === undefined ? this._frequency || 1000 : arguments[1];
	
	      this._delay = delay;
	      this._frequency = interval < delay ? interval : delay;
	      return this;
	    }
	
	    /**
	     * Restarts the timer
	     * @method reset
	     */
	
	  }, {
	    key: 'restart',
	    value: function restart() {
	      this.clear().start();
	      return this;
	    }
	
	    /**
	     * Clears the timer
	     * @method clear
	     */
	
	  }, {
	    key: 'clear',
	    value: function clear() {
	      clearInterval(this.id);
	      this.id = null;
	      this.cleared = true;
	      this.started = false;
	      return this;
	    }
	
	    /**
	     * Pauses the timer
	     * @method pause
	     */
	
	  }, {
	    key: 'pause',
	    value: function pause() {
	      if (!this._paused) {
	        clearInterval(this.id);
	        this._paused = true;
	      }
	    }
	
	    /**
	     * Resumes the timer
	     * @method resume
	     */
	
	  }, {
	    key: 'resume',
	    value: function resume() {
	      if (this._paused) {
	        this._paused = false;
	        var remaining = Math.max(this._delay - new Date().getTime() + this._startTime, 0);
	        this.resetTime(remaining).start();
	      }
	    }
	
	    /**
	     * Clear timer and execute callback
	     * @method resolve
	     */
	
	  }, {
	    key: 'resolve',
	    value: function resolve() {
	      if (!this._repeat) {
	        this.clear();
	      }
	      this._callback();
	    }
	
	    /**
	     * Check to see if enough time has passed
	     * @method hasExpired
	     */
	
	  }, {
	    key: 'hasExpired',
	    value: function hasExpired() {
	      return new Date().getTime() - this._startTime >= this._delay;
	    }
	  }]);
	  return Timer;
	}();

	exports.default = Timer;
	module.exports = exports['default'];

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	__webpack_require__(211);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _config_actions = __webpack_require__(159);
	
	var _config_actions2 = _interopRequireDefault(_config_actions);
	
	var _configuration_model = __webpack_require__(201);
	
	var _configuration_model2 = _interopRequireDefault(_configuration_model);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _client_type = __webpack_require__(212);
	
	var _client_type2 = _interopRequireDefault(_client_type);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Have to create a temporary faux-class here to fix the prototype chain
	 * that is broken due to the way Strophe is written (sadpanda)
	 */
	var StropheConnectionClassFix = function StropheConnectionClassFix() {
	  Strophe.Connection.apply(this, arguments);
	};
	
	StropheConnectionClassFix.prototype = _.extend(StropheConnectionClassFix.prototype, Strophe.Connection.prototype);
	
	/**
	 * Extends Strophe.Connection to apply overrides for
	 * HipChat authentication.
	 *
	 * @class HCStropheConnection
	 */
	
	var Connection = function (_StropheConnectionCla) {
	  (0, _inherits3.default)(Connection, _StropheConnectionCla);
	
	
	  /**
	   * @constructs
	   */
	
	  function Connection() {
	    (0, _classCallCheck3.default)(this, Connection);
	
	
	    /**
	     * @property {boolean} supportsRestarts
	     */
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Connection).call(this, _configuration_store2.default.get('bind_url')));
	
	    _this.supportsRestarts = false;
	    return _this;
	  }
	
	  /**
	   * @override
	   * @method connect
	   */
	
	
	  (0, _createClass3.default)(Connection, [{
	    key: 'connect',
	    value: function connect() {
	      var _this2 = this,
	          _get2;
	
	      var onAuthSuccessCallback = function onAuthSuccessCallback(elem) {
	        var jid = elem.textContent,
	            access_token = elem.getAttribute('oauth2_token') || _configuration_store2.default.getOAuthToken();
	        _analytics_actions2.default.successfulAuthEvent(jid, access_token);
	        _config_actions2.default.updateAuthTokens(new _configuration_model2.default({ access_token: access_token }));
	        return _this2._sasl_success_cb(elem);
	      };
	      var onAuthFailedCallback = function onAuthFailedCallback(elem) {
	        if (_this2._sasl_success_handler) {
	          _this2.deleteHandler(_this2._sasl_success_handler);
	          _this2._sasl_success_handler = null;
	        }
	        if (_this2._sasl_challenge_handler) {
	          _this2.deleteHandler(_this2._sasl_challenge_handler);
	          _this2._sasl_challenge_handler = null;
	        }
	
	        if (_this2._sasl_mechanism) {
	          _this2._sasl_mechanism.onFailure();
	        }
	
	        var conditionElement = elem.firstElementChild;
	        var condition = conditionElement && conditionElement.nodeName || null;
	        _this2._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
	        return false;
	      };
	
	      // Need to reapply these callbacks each time connect is called to handle auth
	      this._sasl_success_handler = this._addSysHandler(onAuthSuccessCallback, null, 'success', null, null);
	      this._sasl_failure_handler = this._addSysHandler(onAuthFailedCallback, null, 'failure', null, null);
	      this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null);
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(Connection.prototype), 'connect', this)).call.apply(_get2, [this].concat(args));
	    }
	
	    /**
	     * @override
	     * @method authenticate
	     */
	
	  }, {
	    key: 'authenticate',
	    value: function authenticate() {
	      if (!this.supportsRestarts && this._needsRestartFeature()) {
	        _config_actions2.default.serverUnsupportedError('stream-restart-unsupported');
	        return;
	      }
	      return this.send(this._buildRequestAuthExchangeTree());
	    }
	
	    /**
	     * @override
	     * @method _sasl_auth1_cb
	     */
	
	  }, {
	    key: '_sasl_auth1_cb',
	    value: function _sasl_auth1_cb() {
	      this.authenticated = true;
	      return this._changeConnectStatus(Strophe.Status.CONNECTED, null);
	    }
	
	    /**
	     * @override
	     * @method _connect_cb
	     */
	
	  }, {
	    key: '_connect_cb',
	    value: function _connect_cb(req, callback, raw) {
	      var _this3 = this;
	
	      var body = this._proto._reqToData(req);
	      if (!body) {
	        return;
	      }
	
	      var updateRestartSupport = function updateRestartSupport(elem) {
	        _this3.supportsRestarts = _this3.supportsRestarts || elem.getElementsByTagNameNS("http://hipchat.com", "authrestartlogic").length > 0;
	      };
	
	      var inactivity = body.getAttribute('inactivity');
	      var wait = body.getAttribute('wait');
	      this.allowedInactivityInterval = parseInt(inactivity ? inactivity : wait, 10) * 1000;
	
	      updateRestartSupport(body);
	      this._addSysHandler(updateRestartSupport, null, 'stream:features', null, null);
	      return (0, _get4.default)((0, _getPrototypeOf2.default)(Connection.prototype), '_connect_cb', this).call(this, req, callback, raw);
	    }
	
	    /**
	     * @method needsRestartFeature
	     * @returns {boolean}
	     */
	
	  }, {
	    key: '_needsRestartFeature',
	    value: function _needsRestartFeature() {
	      return _configuration_store2.default.isOAuth();
	    }
	
	    /**
	     * Builds the correctly formatted auth exchange stanza
	     *
	     * @private
	     * @method _buildRequestAuthExchangeTree
	     * @returns {stanza}
	     */
	
	  }, {
	    key: '_buildRequestAuthExchangeTree',
	    value: function _buildRequestAuthExchangeTree() {
	      var clientType = void 0,
	          clientSubType = void 0,
	          clientIdentifier = void 0,
	          exchange = void 0;
	
	      clientType = _configuration_store2.default.get('client_type');
	
	      if (clientType === _client_type2.default.WEB) {
	        clientSubType = _utils2.default.browser.family();
	      } else {
	        clientSubType = _configuration_store2.default.get('client_subtype');
	      }
	
	      clientIdentifier = clientType + '_' + clientSubType;
	
	      switch (_configuration_store2.default.get('auth_method')) {
	        case 'nonce':
	          exchange = $build('auth', {
	            xmlns: Strophe.NS.SASL,
	            mechanism: 'X-HIPCHAT-WEB',
	            nonce: _configuration_store2.default.getNonceToken(),
	            oauth2_token: 'true',
	            node: _configuration_store2.default.get('client_node'),
	            ver: _configuration_store2.default.get('client_version_id')
	          });
	          exchange.t(_configuration_store2.default.get('jid').split('@')[0]);
	          break;
	
	        case 'oauth2':
	          exchange = $build('auth', {
	            xmlns: 'http://hipchat.com',
	            mechanism: 'oauth2',
	            oauth2_token: 'false',
	            restart_stream: 'true',
	            node: _configuration_store2.default.get('client_node'),
	            ver: _configuration_store2.default.get('client_version_id')
	          });
	          exchange.t(Base64.encode('\u0000' + _configuration_store2.default.getOAuthToken() + '\u0000' + clientIdentifier));
	          break;
	      }
	      return exchange.tree();
	    }
	  }]);
	  return Connection;
	}(StropheConnectionClassFix);
	
	exports.default = Connection;
	module.exports = exports['default'];

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Monkey-patches Strophe.Request
	 *
	 * Strophe.Request is called internally throughout Strophe.Connection for XHRs.
	 * In order to modify that logic, we either have to rewrite all of Strophe.Connection's
	 * methods that call it or overwrite Strophe.Request directly... which we're doing here
	 * (sadplanet)
	 */
	var originalXHRFactory = Strophe.Request.prototype._newXHR;
	
	Strophe.Request.prototype._newXHR = function () {
	
	  var xhr = originalXHRFactory.bind(this)(),
	      originalOnReadyStateChange = xhr.onreadystatechange;
	
	  /**
	   *
	   * This _customTimeout method allows us to notify the wrapper
	   * when the network appears to be up, but requests are timing out
	   *
	   */
	  xhr._customTimeout = xhr.ontimeout;
	  xhr.ontimeout = function () {
	    _spi2.default.onHostRequestTimeout();
	    if (xhr._customTimeout) {
	      xhr._customTimeout.apply(xhr, arguments);
	    }
	  };
	
	  xhr.send = function () {
	    return function () {
	      try {
	        return XMLHttpRequest.prototype.send.apply(xhr, arguments);
	      } catch (err) {
	        return Strophe.warn(err.message);
	      }
	    };
	  }(this);
	
	  xhr.onreadystatechange = function () {
	    if (this.readyState === 1 && !this.withCredentials) {
	      this.withCredentials = true;
	    }
	    return originalOnReadyStateChange.apply(this, arguments);
	  };
	
	  return xhr;
	};

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _freeze2.default)({
	  WEB: 'web',
	  QT: 'qt',
	  MAC: 'mac'
	});
	module.exports = exports['default'];

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _x2js = __webpack_require__(214);
	
	var _x2js2 = _interopRequireDefault(_x2js);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = new _x2js2.default({ stripWhitespaces: false });
	module.exports = exports['default'];

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof exports?module.exports=e():t.X2JS=e()}(this,function(){return function(t){"use strict";function e(){void 0===t.escapeMode&&(t.escapeMode=!0),t.attributePrefix=t.attributePrefix||"",t.arrayAccessForm=t.arrayAccessForm||"none",t.emptyNodeForm=t.emptyNodeForm||"text",void 0===t.enableToStringFunc&&(t.enableToStringFunc=!0),t.arrayAccessFormPaths=t.arrayAccessFormPaths||[],void 0===t.skipEmptyTextNodesForObj&&(t.skipEmptyTextNodesForObj=!0),void 0===t.stripWhitespaces&&(t.stripWhitespaces=!0),t.datetimeAccessFormPaths=t.datetimeAccessFormPaths||[],void 0===t.useDoubleQuotes&&(t.useDoubleQuotes=!1)}function r(){function t(t){var e=String(t);return 1===e.length&&(e="0"+e),e}"function"!=typeof String.prototype.trim&&(String.prototype.trim=function(){return this.replace(/^\s+|^\n+|(\s|\n)+$/g,"")}),"function"!=typeof Date.prototype.toISOString&&(Date.prototype.toISOString=function(){return this.getUTCFullYear()+"-"+t(this.getUTCMonth()+1)+"-"+t(this.getUTCDate())+"T"+t(this.getUTCHours())+":"+t(this.getUTCMinutes())+":"+t(this.getUTCSeconds())+"."+String((this.getUTCMilliseconds()/1e3).toFixed(3)).slice(2,5)+"Z"})}function n(t){var e=t.localName;return null==e&&(e=t.baseName),(null==e||""==e)&&(e=t.nodeName),e}function i(t){return t.prefix}function o(t){return"string"==typeof t?t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;"):t}function a(e,r,n){switch(t.arrayAccessForm){case"property":e[r]instanceof Array?e[r+"_asArray"]=e[r]:e[r+"_asArray"]=[e[r]]}if(!(e[r]instanceof Array)&&t.arrayAccessFormPaths.length>0){for(var i=0;i<t.arrayAccessFormPaths.length;i++){var o=t.arrayAccessFormPaths[i];if("string"==typeof o){if(o==n)break}else if(o instanceof RegExp){if(o.test(n))break}else if("function"==typeof o&&o(e,r,n))break}i!=t.arrayAccessFormPaths.length&&(e[r]=[e[r]])}}function s(t){var e=t.split(/[-T:+Z]/g),r=new Date(e[0],e[1]-1,e[2]),n=e[5].split(".");if(r.setHours(e[3],e[4],n[0]),n.length>1&&r.setMilliseconds(n[1]),e[6]&&e[7]){var i=60*e[6]+Number(e[7]),o=/\d\d-\d\d:\d\d$/.test(t)?"-":"+";i=0+("-"==o?-1*i:i),r.setMinutes(r.getMinutes()-i-r.getTimezoneOffset())}else-1!==t.indexOf("Z",t.length-1)&&(r=new Date(Date.UTC(r.getFullYear(),r.getMonth(),r.getDate(),r.getHours(),r.getMinutes(),r.getSeconds(),r.getMilliseconds())));return r}function c(e,r,n){if(t.datetimeAccessFormPaths.length>0){for(var i=n.split(".#")[0],o=0;o<t.datetimeAccessFormPaths.length;o++){var a=t.datetimeAccessFormPaths[o];if("string"==typeof a){if(a==i)break}else if(a instanceof RegExp){if(a.test(i))break}else if("function"==typeof a&&a(obj,r,i))break}return o!=t.datetimeAccessFormPaths.length?s(e):e}return e}function l(e,r){if(e.nodeType==b.DOCUMENT_NODE){for(var o=new Object,s=e.childNodes,u=0;u<s.length;u++){var f=s.item(u);if(f.nodeType==b.ELEMENT_NODE){var _=n(f);o[_]=l(f,_)}}return o}if(e.nodeType==b.ELEMENT_NODE){var o=new Object,d=n(e);o.__cnt=0;var s=e.childNodes,p=Array.prototype.filter.call(s,function(t){return t.nodeType===b.TEXT_NODE}).length;if(p>1&&p===s.length){var h=document.createDocumentFragment(),g=document.createTextNode(e.textContent);h.appendChild(g),s=h.childNodes}Array.prototype.forEach.call(s,function(t){if("html"===n(t)&&"http://jabber.org/protocol/xhtml-im"===t.namespaceURI)for(var e=0;e<t.childNodes.length;e++){var r=t.childNodes.item(e),i=n(r);"body"===i&&"http://www.w3.org/1999/xhtml"===r.namespaceURI&&(o.xhtml_im_body=r.innerHTML)}});for(var u=0;u<s.length;u++){var f=s.item(u),_=n(f);f.nodeType!=b.COMMENT_NODE&&(o.__cnt++,null==o[_]?(o[_]=l(f,r+"."+_),a(o,_,r+"."+_)):(null!=o[_]&&(o[_]instanceof Array||(o[_]=[o[_]],a(o,_,r+"."+_))),o[_][o[_].length]=l(f,r+"."+_)))}for(var m=0;m<e.attributes.length;m++){var x=e.attributes.item(m);o.__cnt++;var y=t.attributePrefix;"http://jabber.org/protocol/httpbind"===e.namespaceURI&&"body"===d&&(y="boshwrapper_"),o[y+x.name]=x.value}var v=i(e);return null!=v&&""!=v&&(o.__cnt++,o.__prefix=v),null!=o["#text"]&&(o.__text=o["#text"],o.__text instanceof Array&&(o.__text=o.__text.join("\n")),t.stripWhitespaces&&(o.__text=o.__text.trim()),delete o["#text"],"property"==t.arrayAccessForm&&delete o["#text_asArray"],o.__text=c(o.__text,_,r+"."+_)),null!=o["#cdata-section"]&&(o.__cdata=o["#cdata-section"],delete o["#cdata-section"],"property"==t.arrayAccessForm&&delete o["#cdata-section_asArray"]),1==o.__cnt&&null!=o.__text?o=o.__text:0==o.__cnt&&"text"==t.emptyNodeForm?o="":o.__cnt>1&&null!=o.__text&&t.skipEmptyTextNodesForObj&&(t.stripWhitespaces&&""==o.__text||""==o.__text.trim())&&delete o.__text,delete o.__cnt,!t.enableToStringFunc||null==o.__text&&null==o.__cdata||(o.toString=function(){return(null!=this.__text?this.__text:"")+(null!=this.__cdata?this.__cdata:"")}),o}return e.nodeType==b.TEXT_NODE||e.nodeType==b.CDATA_SECTION_NODE?e.nodeValue:void 0}function u(e,r,n,i){var a="<"+(null!=e&&null!=e.__prefix?e.__prefix+":":"")+r;if(null!=n)for(var s=0;s<n.length;s++){var c=n[s],l=e[c];t.escapeMode&&(l=o(l)),a+=" "+c.substr(t.attributePrefix.length)+"=",a+=t.useDoubleQuotes?'"'+l+'"':"'"+l+"'"}return a+=i?"/>":">"}function f(t,e){return"</"+(null!=t.__prefix?t.__prefix+":":"")+e+">"}function _(t,e){return-1!==t.indexOf(e,t.length-e.length)}function d(e,r){return"property"==t.arrayAccessForm&&_(r.toString(),"_asArray")||0==r.toString().indexOf(t.attributePrefix)||0==r.toString().indexOf("__")||e[r]instanceof Function?!0:!1}function p(t){var e=0;if(t instanceof Object)for(var r in t)d(t,r)||e++;return e}function h(e){var r=[];if(e instanceof Object)for(var n in e)-1==n.toString().indexOf("__")&&0==n.toString().indexOf(t.attributePrefix)&&r.push(n);return r}function g(e){var r="";return null!=e.__cdata&&(r+="<![CDATA["+e.__cdata+"]]>"),null!=e.__text&&(r+=t.escapeMode?o(e.__text):e.__text),r}function m(e){var r="";return e instanceof Object?r+=g(e):null!=e&&(r+=t.escapeMode?o(e):e),r}function x(t,e,r){var n="";if(0==t.length)n+=u(t,e,r,!0);else for(var i=0;i<t.length;i++)n+=u(t[i],e,h(t[i]),!1),n+=y(t[i]),n+=f(t[i],e);return n}function y(t){var e="",r=p(t);if(r>0)for(var n in t)if(!d(t,n)){var i=t[n],o=h(i);if(null==i||void 0==i)e+=u(i,n,o,!0);else if(i instanceof Object)if(i instanceof Array)e+=x(i,n,o);else if(i instanceof Date)e+=u(i,n,o,!1),e+=i.toISOString(),e+=f(i,n);else{var a=p(i);a>0||null!=i.__text||null!=i.__cdata?(e+=u(i,n,o,!1),e+=y(i),e+=f(i,n)):e+=u(i,n,o,!0)}else e+=u(i,n,o,!1),e+=m(i),e+=f(i,n)}return e+=m(t)}var v="1.1.8";t=t||{},e(),r();var b={ELEMENT_NODE:1,TEXT_NODE:3,CDATA_SECTION_NODE:4,COMMENT_NODE:8,DOCUMENT_NODE:9};this.parseXmlString=function(t){var e=window.ActiveXObject||"ActiveXObject"in window;if(void 0===t)return null;var r;if(window.DOMParser){var n=new window.DOMParser,i=null;if(!e)try{i=n.parseFromString("INVALID","text/xml").childNodes[0].namespaceURI}catch(o){i=null}try{r=n.parseFromString(t,"text/xml"),null!=i&&r.getElementsByTagNameNS(i,"parsererror").length>0&&(r=null)}catch(o){r=null}}else 0==t.indexOf("<?")&&(t=t.substr(t.indexOf("?>")+2)),r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(t);return r},this.asArray=function(t){return void 0===t||null==t?[]:t instanceof Array?t:[t]},this.toXmlDateTime=function(t){return t instanceof Date?t.toISOString():"number"==typeof t?new Date(t).toISOString():null},this.asDateTime=function(t){return"string"==typeof t?s(t):t},this.xml2json=function(t){return l(t)},this.xml_str2json=function(t){var e=this.parseXmlString(t);return null!=e?this.xml2json(e):null},this.json2xml_str=function(t){return y(t)},this.json2xml=function(t){var e=this.json2xml_str(t);return this.parseXmlString(e)},this.getVersion=function(){return v}}});

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * ConnectionActions
	 */
	exports.default = {
	  stropheConnected: function stropheConnected() {
	    _app_dispatcher2.default.dispatch('strophe-connected');
	  },
	  stropheReconnected: function stropheReconnected() {
	    _app_dispatcher2.default.dispatch('strophe-reconnected');
	  },
	  stropheReconnecting: function stropheReconnecting(params) {
	    _app_dispatcher2.default.dispatch('strophe-reconnecting', params);
	  },
	  stropheReconnectDelay: function stropheReconnectDelay(params) {
	    _app_dispatcher2.default.dispatch('strophe-reconnect-delay', params);
	  },
	  stropheAuthenticating: function stropheAuthenticating() {
	    _app_dispatcher2.default.dispatch('strophe-authenticating');
	  },
	  stropheDisconnected: function stropheDisconnected() {
	    _app_dispatcher2.default.dispatch('strophe-disconnected');
	  },
	  stropheDisconnecting: function stropheDisconnecting() {
	    _app_dispatcher2.default.dispatch('strophe-disconnecting');
	  },
	  stropheAuthFailed: function stropheAuthFailed(status, condition) {
	    _app_dispatcher2.default.dispatch('strophe-auth-failed', status, condition);
	  },
	  stropheConnectionFailed: function stropheConnectionFailed(status, condition) {
	    _app_dispatcher2.default.dispatch('strophe-connection-failed', status, condition);
	  },
	  strophePolicyViolation: function strophePolicyViolation(status, condition) {
	    _app_dispatcher2.default.dispatch('strophe-policy-violation', status, condition);
	  },
	  reconnect: function reconnect() {
	    _app_dispatcher2.default.dispatch('attempt-reconnect');
	  },
	  reconnectionError: function reconnectionError(error) {
	    _app_dispatcher2.default.dispatch('reconnection-error', error);
	  },
	  disconnect: function disconnect() {
	    var should_reconnect = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    _app_dispatcher2.default.dispatch('attempt-disconnect', should_reconnect);
	  },
	  handleReconnectLinkClick: function handleReconnectLinkClick() {
	    _app_dispatcher2.default.dispatch('attempt-reconnect-without-reset');
	  },
	  appStateConnected: function appStateConnected() {
	    _app_dispatcher2.default.dispatch('app-state-connected');
	  },
	  appStateReconnected: function appStateReconnected() {
	    _app_dispatcher2.default.dispatch('app-state-reconnected');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _timer = __webpack_require__(209);
	
	var _timer2 = _interopRequireDefault(_timer);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _constants = __webpack_require__(163);
	
	var Constants = _interopRequireWildcard(_constants);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PING_RESPONSE_TIMEOUT = Constants.XMPP_INACTIVITY_INTERVAL + Constants.XMPP_PONG_WAIT + Constants.NETWORK_LATENCY_GRACE_PERIOD;
	var GRACEFUL_INACTIVITY_PERIOD = Constants.XMPP_INACTIVITY_INTERVAL + Constants.NETWORK_LATENCY_GRACE_PERIOD;
	
	/**
	 * Strophe Connection Plugin for handling pings
	 *
	 * @class PingPlugin
	 * @property {Timer} xmppPingTimer
	 * @property {Strophe.Connection} Connection
	 */
	
	var PingPlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(PingPlugin, _AbstractPlugin);
	
	  function PingPlugin() {
	    (0, _classCallCheck3.default)(this, PingPlugin);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(PingPlugin).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(PingPlugin, [{
	    key: 'init',
	
	
	    /**
	     * @override
	     */
	    value: function init() {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(PingPlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	
	      Strophe.addNamespace('PING', 'urn:xmpp:ping');
	
	      this.pingTimer = new _timer2.default(this.ping.bind(this), GRACEFUL_INACTIVITY_PERIOD);
	    }
	
	    /**
	     * If the server returns an XMPP body that is not empty, restart
	     * the timer. If the timer runs out, and there hasn't been an XMPP
	     * response that contains childNodes, send a ping to keep the BOSH
	     * session alive
	     *
	     * @override
	     */
	
	  }, {
	    key: 'onConnected',
	    value: function onConnected() {
	      var _this2 = this;
	
	      this.Connection.ConnectionHooks.addXmlInputHandler(function (xmpp) {
	        if (xmpp.hasChildNodes()) {
	          _this2.pingTimer.restart();
	        }
	        return true;
	      });
	    }
	
	    /**
	     * If we lose connection, clear the ping timer
	     *
	     * @override
	     */
	
	  }, {
	    key: 'onDisconnected',
	    value: function onDisconnected() {
	      this.pingTimer.clear();
	    }
	
	    /**
	     * @private
	     * @method _doPing
	     */
	
	  }, {
	    key: 'ping',
	    value: function ping() {
	      var type = 'get',
	          to = _configuration_store2.default.get('chat_server'),
	          stanza = $iq({ type: type, to: to }).c('ping', { xmlns: Strophe.NS.PING }).tree();
	
	      this.Connection.sendIQ(stanza, null, this._onPingError.bind(this), PING_RESPONSE_TIMEOUT);
	      _logger2.default.debug('[PING]', 'Sending ping to keep XMPP session alive');
	    }
	
	    /**
	     * If this IQ times out, the stanza passed in from Strophe will be null
	     * @private
	     */
	
	  }, {
	    key: '_onPingError',
	    value: function _onPingError(stanza) {
	      if (!stanza) {
	        _logger2.default.debug('[PING]', 'Ping request timed out. Disconnecting Strophe');
	        this.Connection.disconnect();
	      }
	    }
	  }]);
	  return PingPlugin;
	}(_abstract_plugin2.default);

	exports.default = PingPlugin;
	module.exports = exports['default'];

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _network_status_helper = __webpack_require__(218);
	
	var _network_status_helper2 = _interopRequireDefault(_network_status_helper);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _constants = __webpack_require__(163);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class AbstractPlugin
	 * @property {Strophe.Connection} Connection
	 */
	
	var AbstractPlugin = function () {
	  function AbstractPlugin() {
	    (0, _classCallCheck3.default)(this, AbstractPlugin);
	
	    this.Connection = null;
	  }
	
	  /**
	   * @method init
	   * @param {Strophe.Connection} connection
	   */
	
	
	  (0, _createClass3.default)(AbstractPlugin, [{
	    key: 'init',
	    value: function init(connection) {
	      this.Connection = connection;
	      this.connected = false;
	    }
	
	    /**
	     * @method onStatusChanged
	     * @param {Strophe.Status} status
	     * @param {string} [reason]
	     */
	
	  }, {
	    key: 'statusChanged',
	    value: function statusChanged(status, reason) {
	      switch (status) {
	        case Strophe.Status.CONNECTED:
	          this.connected = true;
	          this.onConnected();
	          break;
	
	        case Strophe.Status.AUTHENTICATING:
	          this.onAuthenticating();
	          break;
	
	        case Strophe.Status.CONNECTING:
	          this.onConnecting();
	          break;
	
	        case Strophe.Status.DISCONNECTING:
	          this.onDisconnecting();
	          break;
	
	        case Strophe.Status.AUTHFAIL:
	          this.onAuthFailure();
	          break;
	
	        case Strophe.Status.CONNFAIL:
	          this.onConnectionFailure();
	          break;
	
	        case Strophe.Status.DISCONNECTED:
	          this.connected = false;
	          this.onDisconnected(reason);
	          break;
	      }
	    }
	
	    /**
	     * @method onConnected
	     */
	
	  }, {
	    key: 'onConnected',
	    value: function onConnected() {}
	
	    /**
	     * @method onAuthenticating
	     */
	
	  }, {
	    key: 'onAuthenticating',
	    value: function onAuthenticating() {}
	
	    /**
	     * @method onConnecting
	     */
	
	  }, {
	    key: 'onConnecting',
	    value: function onConnecting() {}
	
	    /**
	     * @method onDisconnecting
	     */
	
	  }, {
	    key: 'onDisconnecting',
	    value: function onDisconnecting() {}
	
	    /**
	     * @method onDisconnected
	     * @param {string} [reason]
	     */
	
	  }, {
	    key: 'onDisconnected',
	    value: function onDisconnected(reason) {}
	
	    /**
	     * @method onAuthFailure
	     */
	
	  }, {
	    key: 'onAuthFailure',
	    value: function onAuthFailure() {}
	
	    /**
	     * @method onConnectionFailure
	     */
	
	  }, {
	    key: 'onConnectionFailure',
	    value: function onConnectionFailure() {}
	  }, {
	    key: 'isConnected',
	    value: function isConnected() {
	      return this.connected;
	    }
	
	    /**
	     * Wrapper for Connection.sendIQ.
	     *
	     * @method sendIQWithOfflineGuard
	     * @param {object} stanza
	     * @param {function} onSuccess
	     * @param {function} onError
	     *
	     * @returns {Promise<success, error>}
	     */
	
	  }, {
	    key: 'sendIQWithOfflineGuard',
	    value: function sendIQWithOfflineGuard(stanza) {
	      var _this = this;
	
	      var onSuccess = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	      var onError = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	
	      return new _promise2.default(function (resolve, reject) {
	        if (!_network_status_helper2.default.isOnline() || !_this.isConnected()) {
	          return reject(_dalError2.default.ofType(_dalError2.default.Types.OFFLINE));
	        }
	
	        var success = function success(xmpp) {
	          onSuccess(xmpp);
	          resolve();
	        };
	        var error = function error(xmppErr) {
	          onError(xmppErr);
	          if (!xmppErr) {
	            //On xmpp reqest timeout, the stanza will be null.
	            return reject(_dalError2.default.ofType(_dalError2.default.Types.TIMEOUT));
	          }
	          return reject(_dalError2.default.fromXMPP(xmppErr));
	        };
	
	        _this.Connection.sendIQ(stanza.tree(), success, error, _constants.XMPP_SEND_IQ_TIMEOUT);
	      });
	    }
	
	    /**
	     * test is it online returns resolved or rejected Promise.
	     *
	     * @method checkIfOnline
	     *
	     * @returns {Promise}
	     */
	
	  }, {
	    key: 'checkIfOnline',
	    value: function checkIfOnline() {
	      var _this2 = this;
	
	      return new _promise2.default(function (resolve, reject) {
	        if (!_network_status_helper2.default.isOnline() || !_this2.isConnected()) {
	          reject(_dalError2.default.ofType(_dalError2.default.Types.OFFLINE));
	        } else {
	          resolve();
	        }
	      });
	    }
	  }]);
	  return AbstractPlugin;
	}();

	exports.default = AbstractPlugin;
	module.exports = exports['default'];

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _network_status_actions = __webpack_require__(219);
	
	var _network_status_actions2 = _interopRequireDefault(_network_status_actions);
	
	var _rest = __webpack_require__(220);
	
	var _rest2 = _interopRequireDefault(_rest);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NetworkStatusHelper = function () {
	  function NetworkStatusHelper() {
	    (0, _classCallCheck3.default)(this, NetworkStatusHelper);
	
	    this._state = false;
	    this._shouldCheckNetwork = true;
	    this._currentConfirmNetworkUpPromise = null;
	  }
	
	  (0, _createClass3.default)(NetworkStatusHelper, [{
	    key: 'initialize',
	    value: function initialize() {
	      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var _ref$doHealthCheck = _ref.doHealthCheck;
	      var doHealthCheck = _ref$doHealthCheck === undefined ? true : _ref$doHealthCheck;
	
	      this._state = true;
	      this._shouldCheckNetwork = !!doHealthCheck;
	
	      if (_configuration_store2.default.get('client_type') === 'web') {
	        $(window).on('online', this.onNetworkUp.bind(this));
	        $(window).on('offline', this.onNetworkDown.bind(this));
	      }
	    }
	
	    /**
	     * called by the external API or the browser when online status detected
	     */
	
	  }, {
	    key: 'onNetworkUp',
	    value: function onNetworkUp() {
	      this._currentConfirmNetworkUpPromise = null;
	
	      if (this._state === true) {
	        return;
	      }
	
	      _logger2.default.debug('[NetworkStatusHelper]', 'network up event received, signaling UI');
	      this._state = true;
	      _network_status_actions2.default.networkUp();
	    }
	
	    /**
	     * called by the external API or the browser when offline status detected
	     */
	
	  }, {
	    key: 'onNetworkDown',
	    value: function onNetworkDown() {
	      var _this = this;
	
	      this._currentConfirmNetworkUpPromise = null;
	
	      if (this._state === false) {
	        return _promise2.default.resolve();
	      }
	
	      _logger2.default.debug('[NetworkStatusHelper]', 'network down event received, performing health check to confirm');
	
	      if (!this._shouldCheckNetwork) {
	        _logger2.default.debug('[NetworkStatusHelper]', 'health check disabled, signaling offline to UI');
	        this._state = false;
	        _network_status_actions2.default.networkDown();
	        return;
	      }
	
	      var confirmNetworkUpPromise = this._confirmNetworkUp().then(function () {
	        _logger2.default.error('[NetworkStatusHelper]', 'network down event received, health check indicates we are still online, leaving UI as is');
	      }).catch(function () {
	        _logger2.default.debug('[NetworkStatusHelper]', 'network down event received, health check confirmed');
	        if (_this._currentConfirmNetworkUpPromise === confirmNetworkUpPromise) {
	          _logger2.default.debug('[NetworkStatusHelper]', 'health check still current, signaling offline to UI');
	          _this._state = false;
	          _network_status_actions2.default.networkDown();
	        } else {
	          _logger2.default.debug('[NetworkStatusHelper]', 'health check was cancelled, no UI changes');
	        }
	      });
	
	      this._currentConfirmNetworkUpPromise = confirmNetworkUpPromise;
	      return confirmNetworkUpPromise;
	    }
	  }, {
	    key: '_confirmNetworkUp',
	    value: function _confirmNetworkUp() {
	      return _rest2.default.checkNetwork();
	    }
	
	    /**
	     * Check our network connectivity
	     *
	     * @method isOnline
	     * @returns {boolean}
	     */
	
	  }, {
	    key: 'isOnline',
	    value: function isOnline() {
	      return this._state;
	    }
	  }]);
	  return NetworkStatusHelper;
	}();
	
	exports.default = new NetworkStatusHelper();
	module.exports = exports['default'];

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _network_status_helper = __webpack_require__(218);
	
	var _network_status_helper2 = _interopRequireDefault(_network_status_helper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * NetworkStatusActions
	 */
	exports.default = {
	  onNetworkDown: function onNetworkDown() {
	    _network_status_helper2.default.onNetworkDown();
	  },
	  onNetworkUp: function onNetworkUp() {
	    _network_status_helper2.default.onNetworkUp();
	  },
	  networkDown: function networkDown() {
	    _app_dispatcher2.default.dispatch('network-down');
	  },
	  networkUp: function networkUp() {
	    _app_dispatcher2.default.dispatch('network-up');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _room = __webpack_require__(153);
	
	var _room2 = _interopRequireDefault(_room);
	
	var _user = __webpack_require__(152);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _constants = __webpack_require__(163);
	
	var _deflate = __webpack_require__(221);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @module REST
	 */
	exports.default = {
	
	  /**
	   * POST: https://{api_host}/v2/room
	   *
	   * @method createRoom
	   * @param name
	   * @param topic
	   * @param privacy
	   * @returns {Promise<Object, DALError>} - Object with room's "id" property
	   */
	
	  createRoom: function createRoom(name, topic, privacy) {
	    return new _promise2.default(function (resolve, reject) {
	      var request = new XMLHttpRequest();
	      var url = 'https://' + _configuration_store2.default.get('api_host') + '/v2/room';
	
	      var success = function success() {
	        var data = JSON.parse(request.responseText);
	        data = data.entity ? data.entity : data;
	        resolve(data);
	      };
	      var error = function error() {
	        return reject(_dalError2.default.fromJqXHR(request));
	      };
	
	      // Status handler
	      request.onreadystatechange = function () {
	        if (request.readyState === 4) {
	          var status = request.status;
	          var isSuccess = status >= 200 && status < 300 || status === 304;
	          if (isSuccess) {
	            success();
	          } else {
	            error();
	          }
	        }
	      };
	
	      // Making request
	      request.open('POST', url, true);
	      request.setRequestHeader('Content-Type', 'application/json');
	      request.setRequestHeader('Authorization', 'Bearer ' + _configuration_store2.default.get('oauth_token'));
	      request.send((0, _stringify2.default)({ name: name, topic: topic, privacy: privacy }));
	    });
	  },
	
	
	  /**
	   * DELETE: https://{api_host}/v2/room/{id}
	   * @param id
	   * @returns {Promise<undefined,DALError>} - ajax returns 204 so no content in resolve
	   */
	  deleteRoom: function deleteRoom(id) {
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: 'https://' + _configuration_store2.default.get('api_host') + '/v2/room/' + id,
	        type: 'DELETE',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        success: function success() {
	          return resolve();
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	
	
	  /**
	   * GET: https://{api_host}/v2/room/{id}
	   *
	   * @method fetchRoom
	   * @param id
	   * @returns {Promise<Room, DALError>}
	   */
	  fetchRoom: function fetchRoom(id) {
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: 'https://' + _configuration_store2.default.get('api_host') + '/v2/room/' + id,
	        type: 'GET',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        success: function success(data) {
	          return resolve(_room2.default.fromREST(data));
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	
	
	  /**
	   * PUT: https://{api_host}/v2/room/{id}/avatar
	   *
	   * @method uploadRoomAvatar
	   * @param id
	   * @param avatar - Base64 encoded image string without data URI/MimeType (Ex: "data:image/png;base64,")
	   * @returns {Promise<Object, DALError>} - Object with room's "id" property
	   */
	  uploadRoomAvatar: function uploadRoomAvatar(id, avatar) {
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: 'https://' + _configuration_store2.default.get('api_host') + '/v2/room/' + id + '/avatar',
	        type: 'PUT',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        data: (0, _stringify2.default)({ avatar: avatar }),
	        success: function success(data) {
	          return resolve({ room_id: id });
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	
	
	  /**
	   * DELETE: https://{api_host}/v2/oauth/token/{token}
	   *
	   * @method revokeOAuthToken
	   */
	  revokeOAuthToken: function revokeOAuthToken() {},
	
	
	  /**
	   * POST: https://{api_host}/v2/sync/users
	   *
	   * @method syncRoster
	   * @params {Roster} cached - the cached roster
	   * @returns {Promise<Array<User>, DALError>}
	   */
	  syncRoster: function syncRoster() {
	    var cached = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    return new _promise2.default(function (resolve, reject) {
	      var fields = ['xmpp_jid', 'name', 'mention_name', 'email', 'title', 'photo_url',
	      // 'timezone', // this isn't actually useful
	      'version', 'is_guest'].join(',');
	
	      var knownUsers = _.transform(cached, function (result, user, id) {
	        result[id] = user.version;
	        return result;
	      });
	
	      var params = {
	        url: 'https://' + _configuration_store2.default.get('api_host') + '/v2/sync/users?auth_token=' + _configuration_store2.default.getOAuthToken() + '&expand=changedUsers&fields=' + fields,
	        type: 'POST',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'X-Requested-With': 'XMLHttpRequest'
	        },
	        data: (0, _stringify2.default)({ requireFullList: true, knownUsers: knownUsers }),
	        success: function success(response) {
	          resolve(response.changedUsers.map(function (user) {
	            return _user2.default.fromREST(user);
	          }));
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      };
	
	      if (params.data.length >= _constants.SYNC_REQUEST_GZIP_SIZE) {
	        params.headers['Content-Encoding'] = 'gzip';
	        params.data = (0, _deflate.gzip)(params.data);
	        params.processData = false;
	      }
	
	      $.ajax(params);
	    });
	  },
	
	
	  /**
	   * POST: https://{api_host}/v2/sync/rooms
	   *
	   * @method syncRooms
	   * @params {RoomsList} cached - the cached rooms list
	   * @returns {Promise<Array<Room>, DALError>}
	   */
	  syncRooms: function syncRooms() {
	    var cached = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    return new _promise2.default(function (resolve, reject) {
	      var fields = ['xmpp_jid', 'name', 'privacy', 'is_guest_accessible', 'guest_access_url', 'avatar_url', 'is_archived', 'topic', 'version', 'owner'].join(',');
	
	      var knownRooms = _.transform(cached, function (result, room, id) {
	        // HW-1298 fix problem with cache on some old versions of HipChat server
	        if (room.name) {
	          result[id] = room.version;
	        }
	        return result;
	      });
	
	      var params = {
	        url: 'https://' + _configuration_store2.default.get('api_host') + '/v2/sync/rooms?auth_token=' + _configuration_store2.default.getOAuthToken() + '&expand=changedRooms&fields=' + fields,
	        type: 'POST',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'X-Requested-With': 'XMLHttpRequest'
	        },
	        data: (0, _stringify2.default)({ requireFullList: true, knownRooms: knownRooms }),
	        success: function success(response) {
	          resolve(response.changedRooms.map(function (room) {
	            return _room2.default.fromREST(room);
	          }));
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      };
	
	      if (params.data.length >= _constants.SYNC_REQUEST_GZIP_SIZE) {
	        params.headers['Content-Encoding'] = 'gzip';
	        params.data = (0, _deflate.gzip)(params.data);
	        params.processData = false;
	      }
	
	      $.ajax(params);
	    });
	  },
	
	
	  /**
	   * Update a room details
	   * PUT: https://{api_host}/room/{room_id}
	   *
	   * @method updateRoomDetails
	   */
	  updateRoomDetails: function updateRoomDetails() {},
	
	
	  /**
	   * Fetch a list of participants in a room
	   * GET: https://{api_host}/v2/room/{room_id}/participant
	   *
	   * @method fetchRoomParticipants
	   */
	  fetchRoomParticipants: function fetchRoomParticipants(roomId) {
	    var includeOffline = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: 'https://' + _configuration_store2.default.get('api_host') + '/v2/room/' + roomId + '/participant',
	        type: 'GET',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        data: {
	          'include-offline': includeOffline,
	          'expand': 'items',
	          'max-results': _app_config2.default.room_participant_page_limit,
	          'fields': 'is_guest,is_group_admin,xmpp_jid,group,name,mention_name,is_present_in_room'
	        },
	        success: function success(data) {
	          return resolve({ roomId: roomId, participants: data.items });
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	
	
	  /**
	   * Fetch recent history for a room or chat
	   * GET: https://{api_host}/user/{user_id}/history/latest
	   * GET: https://{api_host}/room/{room_id}/history/latest
	   *
	   * @method fetchRecentHistory
	   */
	  fetchRecentHistory: function fetchRecentHistory() {},
	
	
	  /**
	   * Upload a file to a room or chat
	   * POST: https://{api_host}/room/{room_id}/share/file
	   * POST: https://{api_host}/user/{user_id}/share/file
	   *
	   * @method sendFileMessage
	   */
	  sendFileMessage: function sendFileMessage() {},
	
	
	  /**
	   * Send a private message to a user
	   * POST: https://{api_host}/user/{user_id}/message
	   *
	   * @method sendPrivateMessage
	   */
	  sendPrivateMessage: function sendPrivateMessage() {},
	
	
	  /**
	   * POST: https://{api_host}/addon/sync
	   *
	   * @method syncIntegrations
	   */
	  syncIntegrations: function syncIntegrations() {},
	
	
	  /**
	   * GET: https://{api_host}/addon/signed-url/{room_id}/{addon_key}/{mod_type}/{key}/{addon_timestamp}
	   *
	   * @method getSignedUrl
	   */
	  getSignedUrl: function getSignedUrl() {},
	
	
	  /**
	   * Calls getSignedUrl, then makes a GET request to it
	   *
	   * @method requestWithSignedUrl
	   */
	  requestWithSignedUrl: function requestWithSignedUrl() {},
	
	
	  /**
	   * Fetch the signed url for a secure file
	   * GET: https://{api_host}/v2/file/{file_id}
	   *
	   * @method fetchSignedFile
	   */
	  fetchSignedFile: function fetchSignedFile(url) {
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: url,
	        type: 'GET',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        success: function success(data) {
	          return resolve(data);
	        },
	        error: function error(jqXHR) {
	          var error = _dalError2.default.fromJqXHR(jqXHR);
	          _logger2.default.error('[Secure files] Error while getting signed url', error);
	          reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	
	
	  /**
	   * Fetch signed thumbnails for secure files
	   * GET: https://{api_host}/v2/file/mget/thumbnails
	   *
	   * @param {Array} fileObjects
	   * @method fetchSignedThumbnails
	   */
	  fetchSignedThumbnailCollection: function fetchSignedThumbnailCollection(fileObjects) {
	    var url = 'https://' + _configuration_store2.default.get('api_host') + '/v2/file/mget/thumbnails';
	    var ids = _.keys(fileObjects);
	
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: url,
	        method: 'POST',
	        dataType: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        data: (0, _stringify2.default)({ ids: ids }),
	        success: function success(_ref) {
	          var files = _ref.files;
	
	          _.forIn(files, function (value, key) {
	            if (!value) {
	              _logger2.default.error('[Secure files] Error while getting signed thumbnail for file with id ' + key);
	              fileObjects[key].errCb({ status: 400 });
	            } else {
	              fileObjects[key].cb(value);
	            }
	          });
	
	          resolve(files);
	        },
	        error: function error(jqXHR) {
	          var error = _dalError2.default.fromJqXHR(jqXHR);
	
	          _logger2.default.error('[Secure files] Error while getting signed thumbnails', error);
	          _.forIn(fileObjects, function (value) {
	            value.errCb(error);
	          });
	          reject(error);
	        }
	      });
	    });
	  },
	
	
	  /**
	   * GET: https://{api_host}/v2/video/token
	   *
	   * @returns {Promise}
	   */
	  fetchVideoToken: function fetchVideoToken() {
	    var recipient_id = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var room_id = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	    var url = 'https://' + _configuration_store2.default.get('api_host') + '/v2/video' + (recipient_id ? '/callee/' + recipient_id : '') + '/token';
	    if (room_id) {
	      url += '?room=' + room_id;
	    }
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: url,
	        method: 'GET',
	        type: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        success: function success(data, text, jqXHR) {
	          try {
	            var parsed_response = JSON.parse(data);
	            resolve(parsed_response);
	          } catch (e) {
	            reject(_dalError2.default.fromJqXHR(jqXHR));
	          }
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	
	
	  /**
	   * Ensure that we have a network connection, hits features endpoint for btf, health-check for cloud
	   * HEAD: https://{api_host}/v2/health-check
	   */
	  checkNetwork: function checkNetwork() {
	    var url = _.get(_configuration_store2.default.get('feature_flags'), 'btf', false) ? _utils2.default.url.featureFlagsAPI(_configuration_store2.default.get('base_url')) : _utils2.default.url.networkCheckAPI(_configuration_store2.default.get('api_host'));
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: url,
	        type: 'HEAD',
	        timeout: 10000,
	        success: function success() {
	          return resolve();
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	  fetchAlertFlag: function fetchAlertFlag() {
	    var url = 'https://' + _configuration_store2.default.get('api_host') + '/v2/flag';
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: url,
	        method: 'GET',
	        type: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        success: function success(data) {
	          return resolve(data);
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	  dismissAlertFlag: function dismissAlertFlag(_ref2) {
	    var id = _ref2.id;
	
	    var url = 'https://' + _configuration_store2.default.get('api_host') + '/v2/flag/dismiss';
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: url,
	        method: 'POST',
	        type: 'json',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': 'Bearer ' + _configuration_store2.default.get('oauth_token')
	        },
	        data: (0, _stringify2.default)({ id: id }),
	        success: function success() {
	          return resolve();
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  },
	  fetchReadOnlyContent: function fetchReadOnlyContent() {
	    return new _promise2.default(function (resolve, reject) {
	      $.ajax({
	        url: '/login_interstitial',
	        type: 'GET',
	        timeout: 10000,
	        success: function success(data) {
	          return resolve(data);
	        },
	        error: function error(jqXHR) {
	          return reject(_dalError2.default.fromJqXHR(jqXHR));
	        }
	      });
	    });
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var zlib_deflate = __webpack_require__(222);
	var utils = __webpack_require__(223);
	var strings = __webpack_require__(228);
	var msg = __webpack_require__(227);
	var zstream = __webpack_require__(229);
	
	var toString = Object.prototype.toString;
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	var Z_NO_FLUSH      = 0;
	var Z_FINISH        = 4;
	
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_SYNC_FLUSH    = 2;
	
	var Z_DEFAULT_COMPRESSION = -1;
	
	var Z_DEFAULT_STRATEGY    = 0;
	
	var Z_DEFLATED  = 8;
	
	/* ===========================================================================*/
	
	
	/**
	 * class Deflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[deflate]],
	 * [[deflateRaw]] and [[gzip]].
	 **/
	
	/* internal
	 * Deflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Deflate#onData]] not overriden.
	 **/
	
	/**
	 * Deflate.result -> Uint8Array|Array
	 *
	 * Compressed result, generated by default [[Deflate#onData]]
	 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
	 * push a chunk with explicit flush (call [[Deflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/
	
	/**
	 * Deflate.err -> Number
	 *
	 * Error code after deflate finished. 0 (Z_OK) on success.
	 * You will not need it in real life, because deflate errors
	 * are possible only on wrong options or bad `onData` / `onEnd`
	 * custom handlers.
	 **/
	
	/**
	 * Deflate.msg -> String
	 *
	 * Error message, if [[Deflate.err]] != 0
	 **/
	
	
	/**
	 * new Deflate(options)
	 * - options (Object): zlib deflate options.
	 *
	 * Creates new deflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `level`
	 * - `windowBits`
	 * - `memLevel`
	 * - `strategy`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw deflate
	 * - `gzip` (Boolean) - create gzip wrapper
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 * - `header` (Object) - custom header for gzip
	 *   - `text` (Boolean) - true if compressed data believed to be text
	 *   - `time` (Number) - modification time, unix timestamp
	 *   - `os` (Number) - operation system code
	 *   - `extra` (Array) - array of bytes with extra data (max 65536)
	 *   - `name` (String) - file name (binary string)
	 *   - `comment` (String) - comment (binary string)
	 *   - `hcrc` (Boolean) - true if header crc should be added
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var deflate = new pako.Deflate({ level: 3});
	 *
	 * deflate.push(chunk1, false);
	 * deflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (deflate.err) { throw new Error(deflate.err); }
	 *
	 * console.log(deflate.result);
	 * ```
	 **/
	var Deflate = function(options) {
	
	  this.options = utils.assign({
	    level: Z_DEFAULT_COMPRESSION,
	    method: Z_DEFLATED,
	    chunkSize: 16384,
	    windowBits: 15,
	    memLevel: 8,
	    strategy: Z_DEFAULT_STRATEGY,
	    to: ''
	  }, options || {});
	
	  var opt = this.options;
	
	  if (opt.raw && (opt.windowBits > 0)) {
	    opt.windowBits = -opt.windowBits;
	  }
	
	  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
	    opt.windowBits += 16;
	  }
	
	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data
	
	  this.strm = new zstream();
	  this.strm.avail_out = 0;
	
	  var status = zlib_deflate.deflateInit2(
	    this.strm,
	    opt.level,
	    opt.method,
	    opt.windowBits,
	    opt.memLevel,
	    opt.strategy
	  );
	
	  if (status !== Z_OK) {
	    throw new Error(msg[status]);
	  }
	
	  if (opt.header) {
	    zlib_deflate.deflateSetHeader(this.strm, opt.header);
	  }
	};
	
	/**
	 * Deflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
	 *   converted to utf8 byte sequence.
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
	 *
	 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
	 * new compressed chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the compression context.
	 *
	 * On fail call [[Deflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * array format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Deflate.prototype.push = function(data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var status, _mode;
	
	  if (this.ended) { return false; }
	
	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);
	
	  // Convert data if needed
	  if (typeof data === 'string') {
	    // If we need to compress text, change encoding to utf8.
	    strm.input = strings.string2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }
	
	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;
	
	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }
	    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */
	
	    if (status !== Z_STREAM_END && status !== Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }
	    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
	      if (this.options.to === 'string') {
	        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
	      } else {
	        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	      }
	    }
	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
	
	  // Finalize on the last chunk.
	  if (_mode === Z_FINISH) {
	    status = zlib_deflate.deflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === Z_OK;
	  }
	
	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === Z_SYNC_FLUSH) {
	    this.onEnd(Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }
	
	  return true;
	};
	
	
	/**
	 * Deflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Deflate.prototype.onData = function(chunk) {
	  this.chunks.push(chunk);
	};
	
	
	/**
	 * Deflate#onEnd(status) -> Void
	 * - status (Number): deflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called once after you tell deflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Deflate.prototype.onEnd = function(status) {
	  // On success - join
	  if (status === Z_OK) {
	    if (this.options.to === 'string') {
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};
	
	
	/**
	 * deflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * Compress `data` with deflate alrorythm and `options`.
	 *
	 * Supported options are:
	 *
	 * - level
	 * - windowBits
	 * - memLevel
	 * - strategy
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
	 *
	 * console.log(pako.deflate(data));
	 * ```
	 **/
	function deflate(input, options) {
	  var deflator = new Deflate(options);
	
	  deflator.push(input, true);
	
	  // That will never happens, if you don't cheat with options :)
	  if (deflator.err) { throw deflator.msg; }
	
	  return deflator.result;
	}
	
	
	/**
	 * deflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function deflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return deflate(input, options);
	}
	
	
	/**
	 * gzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but create gzip wrapper instead of
	 * deflate one.
	 **/
	function gzip(input, options) {
	  options = options || {};
	  options.gzip = true;
	  return deflate(input, options);
	}
	
	
	exports.Deflate = Deflate;
	exports.deflate = deflate;
	exports.deflateRaw = deflateRaw;
	exports.gzip = gzip;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils   = __webpack_require__(223);
	var trees   = __webpack_require__(224);
	var adler32 = __webpack_require__(225);
	var crc32   = __webpack_require__(226);
	var msg   = __webpack_require__(227);
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;
	
	
	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;
	
	
	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;
	
	
	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED               = 4;
	var Z_DEFAULT_STRATEGY    = 0;
	
	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;
	
	
	/* The deflate compression method */
	var Z_DEFLATED  = 8;
	
	/*============================================================================*/
	
	
	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;
	
	
	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES       = 30;
	/* number of distance codes */
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE     = 2*L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS  = 15;
	/* All codes must not exceed MAX_BITS bits */
	
	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
	
	var PRESET_DICT = 0x20;
	
	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;
	
	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */
	
	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
	
	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}
	
	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}
	
	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
	
	
	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;
	
	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }
	
	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}
	
	
	function flush_block_only (s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}
	
	
	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}
	
	
	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}
	
	
	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;
	
	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }
	
	  strm.avail_in -= len;
	
	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  }
	
	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }
	
	  strm.next_in += len;
	  strm.total_in += len;
	
	  return len;
	}
	
	
	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;
	
	  var _win = s.window; // shortcut
	
	  var wmask = s.w_mask;
	  var prev  = s.prev;
	
	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */
	
	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];
	
	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
	
	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }
	
	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
	
	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;
	
	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */
	
	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }
	
	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");
	
	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);
	
	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
	
	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;
	
	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
	
	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}
	
	
	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;
	
	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
	
	  do {
	    more = s.window_size - s.lookahead - s.strstart;
	
	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}
	
	
	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
	
	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;
	
	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */
	
	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);
	
	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);
	
	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }
	
	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;
	
	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];
	
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;
	
	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */
	
	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
	
	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}
	
	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;
	
	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }
	
	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {
	
	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }
	
	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	
	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");
	
	    s.strstart += s.lookahead;
	    s.lookahead = 0;
	
	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;
	
	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	
	
	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	
	  s.insert = 0;
	
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	
	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	
	  return BS_NEED_MORE;
	}
	
	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */
	
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }
	
	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }
	
	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
	
	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
	
	      s.lookahead -= s.match_length;
	
	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
	
	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */
	
	  var max_insert;
	
	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }
	
	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }
	
	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH-1;
	
	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	
	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {
	
	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH-1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */
	
	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
	
	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length-1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH-1;
	      s.strstart++;
	
	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }
	
	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);
	
	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);
	
	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	
	  return BS_BLOCK_DONE;
	}
	
	
	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */
	
	  var _win = s.window;
	
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }
	
	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }
	
	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);
	
	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
	
	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */
	
	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }
	
	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	var Config = function (good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	};
	
	var configuration_table;
	
	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */
	
	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];
	
	
	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;
	
	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);
	
	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;
	
	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}
	
	
	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */
	
	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */
	
	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */
	
	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */
	
	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */
	
	  this.head = null;   /* Heads of the hash chains or NIL. */
	
	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */
	
	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */
	
	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */
	
	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */
	
	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */
	
	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */
	
	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */
	
	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/
	
	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */
	
	  this.nice_match = 0; /* Stop searching when current match exceeds this */
	
	              /* used by trees.c: */
	
	  /* Didn't use ct_data typedef below to suppress compiler warning */
	
	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
	
	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);
	  this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);
	
	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */
	
	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS+1);
	  /* number of codes at each bit length for an optimal tree */
	
	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */
	  zero(this.heap);
	
	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */
	
	  this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */
	
	  this.l_buf = 0;          /* buffer index for literals or lengths */
	
	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */
	
	  this.last_lit = 0;      /* running index in l_buf */
	
	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */
	
	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */
	
	
	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */
	
	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}
	
	
	function deflateResetKeep(strm) {
	  var s;
	
	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;
	
	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;
	
	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}
	
	
	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}
	
	
	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}
	
	
	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;
	
	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }
	
	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	
	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }
	
	
	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	
	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */
	
	  var s = new DeflateState();
	
	  strm.state = s;
	  s.strm = strm;
	
	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;
	
	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
	
	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);
	
	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */
	
	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
	
	  s.pending_buf_size = s.lit_bufsize * 4;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);
	
	  s.d_buf = s.lit_bufsize >> 1;
	  s.l_buf = (1 + 2) * s.lit_bufsize;
	
	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;
	
	  return deflateReset(strm);
	}
	
	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}
	
	
	function deflate(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only
	
	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }
	
	  s = strm.state;
	
	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }
	
	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;
	
	  /* Write the header */
	  if (s.status === INIT_STATE) {
	
	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	                );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;
	
	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);
	
	      s.status = BUSY_STATE;
	      putShortMSB(s, header);
	
	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }
	
	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	
	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;
	
	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;
	
	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif
	
	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }
	
	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }
	
	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }
	
	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));
	
	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
	
	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero(s.head); // Fill with NIL (= 0);
	
	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}
	
	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }
	
	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }
	
	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}
	
	function deflateEnd(strm) {
	  var status;
	
	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	  strm.state = null;
	
	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}
	
	/* =========================================================================
	 * Copy the source state to the destination state
	 */
	//function deflateCopy(dest, source) {
	//
	//}
	
	exports.deflateInit = deflateInit;
	exports.deflateInit2 = deflateInit2;
	exports.deflateReset = deflateReset;
	exports.deflateResetKeep = deflateResetKeep;
	exports.deflateSetHeader = deflateSetHeader;
	exports.deflate = deflate;
	exports.deflateEnd = deflateEnd;
	exports.deflateInfo = 'pako deflate (from Nodeca project)';
	
	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateSetDictionary = deflateSetDictionary;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/


/***/ },
/* 223 */
/***/ function(module, exports) {

	'use strict';
	
	
	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');
	
	
	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }
	
	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }
	
	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }
	
	  return obj;
	};
	
	
	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};
	
	
	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i=0; i<len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function(chunks) {
	    var i, l, len, pos, chunk, result;
	
	    // calculate data length
	    len = 0;
	    for (i=0, l=chunks.length; i<l; i++) {
	      len += chunks[i].length;
	    }
	
	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i=0, l=chunks.length; i<l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }
	
	    return result;
	  }
	};
	
	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i=0; i<len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function(chunks) {
	    return [].concat.apply([], chunks);
	  }
	};
	
	
	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};
	
	exports.setTyped(TYPED_OK);


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils = __webpack_require__(223);
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;
	
	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;
	
	/*============================================================================*/
	
	
	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
	
	// From zutil.h
	
	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */
	
	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */
	
	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */
	
	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	
	var D_CODES       = 30;
	/* number of distance codes */
	
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	
	var HEAP_SIZE     = 2*L_CODES + 1;
	/* maximum heap size */
	
	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */
	
	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */
	
	
	/* ===========================================================================
	 * Constants
	 */
	
	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */
	
	var END_BLOCK   = 256;
	/* end of block literal code */
	
	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */
	
	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */
	
	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */
	
	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
	
	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
	
	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
	
	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */
	
	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */
	
	// We pre-fill arrays with 0 to avoid uninitialized gaps
	
	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */
	
	// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES+2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */
	
	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */
	
	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */
	
	var _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */
	
	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */
	
	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */
	
	
	var StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {
	
	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */
	
	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	};
	
	
	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;
	
	
	var TreeDesc = function(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	};
	
	
	
	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}
	
	
	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short (s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}
	
	
	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}
	
	
	function send_code(s, c, tree) {
	  send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);
	}
	
	
	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}
	
	
	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;
	
	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}
	
	
	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */
	
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }
	
	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */
	
	  for (h = s.heap_max+1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n*2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */
	
	    if (n > max_code) { continue; } /* not a leaf node */
	
	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n-base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }
	
	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */
	
	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length-1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits+1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);
	
	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m*2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;
	        tree[m*2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */
	
	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits-1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
	
	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n*2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);
	
	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}
	
	
	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS+1);
	  /* number of codes at each bit length for an optimal tree */
	
	  // do check in _tr_init()
	  //if (static_init_done) return;
	
	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/
	
	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES-1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1<<extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length-1] = code;
	
	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0 ; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1<<extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");
	
	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }
	
	  n = 0;
	  while (n <= 143) {
	    static_ltree[n*2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n*2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n*2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n*2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES+1, bl_count);
	
	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n*2 + 1]/*.Len*/ = 5;
	    static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);
	  }
	
	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);
	
	  //static_init_done = true;
	}
	
	
	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */
	
	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }
	
	  s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}
	
	
	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}
	
	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */
	
	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}
	
	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n*2;
	  var _m2 = m*2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}
	
	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }
	
	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;
	
	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}
	
	
	// inlined manually
	// var SMALLEST = 1;
	
	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */
	
	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;
	
	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code+LITERALS+1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");
	
	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */
	
	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");
	
	    } while (lx < s.last_lit);
	  }
	
	  send_code(s, END_BLOCK, ltree);
	}
	
	
	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */
	
	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;
	
	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;
	
	    } else {
	      tree[n*2 + 1]/*.Len*/ = 0;
	    }
	  }
	
	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;
	
	    if (has_stree) {
	      s.static_len -= stree[node*2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;
	
	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }
	
	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/
	
	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */
	
	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;
	
	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;
	
	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	
	  } while (s.heap_len >= 2);
	
	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];
	
	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);
	
	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}
	
	
	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */
	
	  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */
	
	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */
	
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */
	
	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n+1)*2 + 1]/*.Len*/;
	
	    if (++count < max_count && curlen === nextlen) {
	      continue;
	
	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;
	
	    } else if (curlen !== 0) {
	
	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6*2]/*.Freq*/++;
	
	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10*2]/*.Freq*/++;
	
	    } else {
	      s.bl_tree[REPZ_11_138*2]/*.Freq*/++;
	    }
	
	    count = 0;
	    prevlen = curlen;
	
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */
	
	  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */
	
	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */
	
	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	
	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n+1)*2 + 1]/*.Len*/;
	
	    if (++count < max_count && curlen === nextlen) {
	      continue;
	
	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);
	
	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count-3, 2);
	
	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count-3, 3);
	
	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count-11, 7);
	    }
	
	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */
	
	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
	
	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */
	
	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3*(max_blindex+1) + 5+5+4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));
	
	  return max_blindex;
	}
	
	
	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */
	
	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes-1,   5);
	  send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
	
	  send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
	
	  send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}
	
	
	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;
	
	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }
	
	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }
	
	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}
	
	
	var static_init_done = false;
	
	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{
	
	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }
	
	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
	
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	
	  /* Initialize the first block of the first file: */
	  init_block(s);
	}
	
	
	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}
	
	
	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES<<1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}
	
	
	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */
	
	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {
	
	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }
	
	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	
	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */
	
	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);
	
	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len+3+7) >>> 3;
	    static_lenb = (s.static_len+3+7) >>> 3;
	
	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));
	
	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }
	
	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }
	
	  if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */
	
	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);
	
	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
	
	    send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);
	
	  } else {
	    send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);
	
	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}
	
	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;
	
	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
	
	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;
	
	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc*2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
	
	    s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }
	
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	
	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif
	
	  return (s.last_lit === s.lit_bufsize-1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}
	
	exports._tr_init  = _tr_init;
	exports._tr_stored_block = _tr_stored_block;
	exports._tr_flush_block  = _tr_flush_block;
	exports._tr_tally = _tr_tally;
	exports._tr_align = _tr_align;


/***/ },
/* 225 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.
	
	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;
	
	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;
	
	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);
	
	    s1 %= 65521;
	    s2 %= 65521;
	  }
	
	  return (s1 | (s2 << 16)) |0;
	}
	
	
	module.exports = adler32;


/***/ },
/* 226 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.
	
	
	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];
	
	  for (var n =0; n < 256; n++) {
	    c = n;
	    for (var k =0; k < 8; k++) {
	      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }
	
	  return table;
	}
	
	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();
	
	
	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;
	
	  crc = crc ^ (-1);
	
	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }
	
	  return (crc ^ (-1)); // >>> 0;
	}
	
	
	module.exports = crc32;


/***/ },
/* 227 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  '2':    'need dictionary',     /* Z_NEED_DICT       2  */
	  '1':    'stream end',          /* Z_STREAM_END      1  */
	  '0':    '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	// String encode/decode helpers
	'use strict';
	
	
	var utils = __webpack_require__(223);
	
	
	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safary
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;
	
	try { String.fromCharCode.apply(null, [0]); } catch(__) { STR_APPLY_OK = false; }
	try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch(__) { STR_APPLY_UIA_OK = false; }
	
	
	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = new utils.Buf8(256);
	for (var q=0; q<256; q++) {
	  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
	}
	_utf8len[254]=_utf8len[254]=1; // Invalid sequence start
	
	
	// convert string to array (typed, when possible)
	exports.string2buf = function (str) {
	  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
	
	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
	      c2 = str.charCodeAt(m_pos+1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }
	
	  // allocate buffer
	  buf = new utils.Buf8(buf_len);
	
	  // convert
	  for (i=0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
	      c2 = str.charCodeAt(m_pos+1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | (c >>> 6);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | (c >>> 12);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | (c >>> 18);
	      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    }
	  }
	
	  return buf;
	};
	
	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // use fallback for big arrays to avoid stack overflow
	  if (len < 65537) {
	    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
	      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
	    }
	  }
	
	  var result = '';
	  for (var i=0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}
	
	
	// Convert byte array to binary string
	exports.buf2binstring = function(buf) {
	  return buf2binstring(buf, buf.length);
	};
	
	
	// Convert binary string (typed, when possible)
	exports.binstring2buf = function(str) {
	  var buf = new utils.Buf8(str.length);
	  for (var i=0, len=buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};
	
	
	// convert array to string
	exports.buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;
	
	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len*2);
	
	  for (out=0, i=0; i<len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) { utf16buf[out++] = c; continue; }
	
	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }
	
	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = (c << 6) | (buf[i++] & 0x3f);
	      c_len--;
	    }
	
	    // terminated by end of string?
	    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }
	
	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
	      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
	    }
	  }
	
	  return buf2binstring(utf16buf, out);
	};
	
	
	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	exports.utf8border = function(buf, max) {
	  var pos;
	
	  max = max || buf.length;
	  if (max > buf.length) { max = buf.length; }
	
	  // go back from last position, until start of sequence found
	  pos = max-1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }
	
	  // Fuckup - very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) { return max; }
	
	  // If we came to start of buffer - that means vuffer is too small,
	  // return max too.
	  if (pos === 0) { return max; }
	
	  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
	};


/***/ },
/* 229 */
/***/ function(module, exports) {

	'use strict';
	
	
	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}
	
	module.exports = ZStream;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Strophe Connection Plugin that uses the xmlInput, xmlOutput,
	 * rawInput, and rawOutput methods in Strophe.Connection and
	 * turns them into hooks that all Connection plugins can hook into.
	 *
	 * This follows the existing Strophe convention in that you'll now call
	 * addXmlInputHandler, passing in a function. If the function returns
	 * true, it will be persistent. If not, it will be cleaned up on first
	 * iteration.
	 *
	 * NOTE: This plugin must be installed before any others to ensure
	 * no conflicts
	 *
	 * @class HooksPlugin
	 */
	
	var ConnectionHooksPlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(ConnectionHooksPlugin, _AbstractPlugin);
	
	  function ConnectionHooksPlugin() {
	    (0, _classCallCheck3.default)(this, ConnectionHooksPlugin);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ConnectionHooksPlugin).call(this));
	
	    _this.handlers = {};
	    _this.added = {};
	    _this.removed = {};
	    _this.reset();
	    return _this;
	  }
	
	  (0, _createClass3.default)(ConnectionHooksPlugin, [{
	    key: 'statusChanged',
	    value: function statusChanged(status, condition) {
	      switch (status) {
	        case Strophe.Status.CONNECTED:
	          this.xmppConnected(status, condition);
	          break;
	
	        case Strophe.Status.CONNFAIL:
	        case Strophe.Status.AUTHFAIL:
	        case Strophe.Status.ERROR:
	        case Strophe.Status.DISCONNECTED:
	          this.xmppDisconnected(status, condition);
	          break;
	      }
	      (0, _get4.default)((0, _getPrototypeOf2.default)(ConnectionHooksPlugin.prototype), 'statusChanged', this).call(this, status, condition);
	    }
	  }, {
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(ConnectionHooksPlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	      this.Connection.xmlInput = this._createHooksHandler('xmlInput');
	      this.Connection.xmlOutput = this._createHooksHandler('xmlOutput');
	      this.Connection.rawInput = this._createHooksHandler('rawInput');
	      this.Connection.rawOutput = this._createHooksHandler('rawOutput');
	      this.xmppConnected = this._createHooksHandler('xmppConnected');
	      this.xmppDisconnected = this._createHooksHandler('xmppDisconnected');
	
	      /**
	       * Add a handler that will be fired when the xmlInput method is called on the connection
	       * (each time a new request body is received). The handler function will be called, and
	       * passed in the XML response body. If the handler returns true, it will be persistent, and called
	       * for every request until it is removed. If it returns a falsy value, it will only fire once
	       *
	       * @method addXmlInputHandler
	       * @param {Function} handler
	       * @returns {Function} handler
	       */
	      this.addXmlInputHandler = this._createAddHandler('xmlInput');
	
	      /**
	       * Add a handler that will be fired when the xmlOutput method is called on the connection
	       * (each time a new request body is sent). The handler function will be called, and
	       * passed in the XML request body. If the handler returns true, it will be persistent, and called
	       * for every request until it is removed. If it returns a falsy value, it will only fire once
	       *
	       * @method addXmlOutputHandler
	       * @param {Function} handler
	       * @returns {Function} handler
	       */
	      this.addXmlOutputHandler = this._createAddHandler('xmlOutput');
	
	      /**
	       * Add a handler that will be fired when the rawInput method is called on the connection
	       * (each time a new request body is received). The handler function will be called, and
	       * passed in the plain text response body. If the handler returns true, it will be persistent,
	       * and called for every request until it is removed. If it returns a falsy value, it will only fire once
	       *
	       * @method addRawInputHandler
	       * @param {Function} handler
	       * @returns {Function} handler
	       */
	      this.addRawInputHandler = this._createAddHandler('rawInput');
	
	      /**
	       * Add a handler that will be fired when the rawOutput method is called on the connection
	       * (each time a new request body is sent). The handler function will be called, and
	       * passed in the plain text request body. If the handler returns true, it will be persistent, and called
	       * for every request until it is removed. If it returns a falsy value, it will only fire once
	       *
	       * @method addRawOutputHandler
	       * @param {Function} handler
	       * @returns {Function} handler
	       */
	      this.addRawOutputHandler = this._createAddHandler('rawOutput');
	
	      /**
	       * Remove an xmlInput handler that was added with the addXmlInputHandler method. Pass it the
	       * handler function as was returned by addXmlInputHandler.
	       *
	       * @method deleteXmlInputHandler
	       * @param {Function} handler
	       */
	      this.deleteXmlInputHandler = this._createDeleteHandler('xmlInput');
	
	      /**
	       * Remove an xmlOutput handler that was added with the addXmlOutputHandler method. Pass it the
	       * handler function as was returned by addXmlOutputHandler.
	       *
	       * @method deleteXmlOutputHandler
	       * @param {Function} handler
	       */
	      this.deleteXmlOutputHandler = this._createDeleteHandler('xmlOutput');
	
	      /**
	       * Remove an rawInput handler that was added with the addRawInputHandler method. Pass it the
	       * handler function as was returned by addRawInputHandler.
	       *
	       * @method deleteRawInputHandler
	       * @param {Function} handler
	       */
	      this.deleteRawInputHandler = this._createDeleteHandler('rawInput');
	
	      /**
	       * Remove an rawOutput handler that was added with the addRawOutputHandler method. Pass it the
	       * handler function as was returned by addRawOutputHandler.
	       *
	       * @method deleteRawOutputHandler
	       * @param {Function} handler
	       */
	      this.deleteRawOutputHandler = this._createDeleteHandler('rawOutput');
	
	      /**
	       * Add a handler that will be fired when strophe successfully connects.
	       * If the handler returns true, it will be persistent, and called on every reconnection
	       * until it is removed. If it returns a falsy value, it will only fire once
	       *
	       * @method addXmppConnectedHandler
	       * @param {Function} handler
	       * @returns {Function} handler
	       */
	      this.addXmppConnectedHandler = this._createAddHandler('xmppConnected');
	
	      /**
	       * Remove an xmppConnected handler that was added with the addXmppConnectedHandler method.
	       * Pass it the handler function as was returned by addXmppConnectedHandler.
	       *
	       * @method deleteXmppConnectedHandler
	       * @param {Function} handler
	       */
	      this.deleteXmppConnectedHandler = this._createDeleteHandler('xmppConnected');
	
	      /**
	       * Add a handler that will be fired when strophe disconnects for any reason.
	       * The handler will be passed the Strophe.Status enum and condition string if provided.
	       * If the handler returns true, it will be persistent, and called on every disconnect
	       * until it is removed. If it returns a falsy value, it will only fire once
	       *
	       * @method addXmppDisconnectedHandler
	       * @param {Function} handler
	       * @returns {Function} handler
	       */
	      this.addXmppDisconnectedHandler = this._createAddHandler('xmppDisconnected');
	
	      /**
	       * Remove an xmppDisconnected handler that was added with the addXmppDisconnectedHandler method.
	       * Pass it the handler function as was returned by addXmppDisconnectedHandler.
	       *
	       * @method deleteXmppDisconnectedHandler
	       * @param {Function} handler
	       */
	      this.deleteXmppDisconnectedHandler = this._createDeleteHandler('xmppDisconnected');
	    }
	
	    /**
	     * When the connection is lost, remove all the xml/raw input/output handlers
	     */
	
	  }, {
	    key: 'onDisconnected',
	    value: function onDisconnected() {
	      this.reset();
	    }
	
	    /**
	     * Reset the handlers to the default empty state. Called on init and on disconnection.
	     * Don't actually clear the connection handlers on disconnection, as they should remain
	     * persistent across reconnection events. Only clear out the xml/raw input/output handlers
	     */
	
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this.handlers.xmlInput = [];
	      this.handlers.xmlOutput = [];
	      this.handlers.rawInput = [];
	      this.handlers.rawOutput = [];
	      this.handlers.xmppConnected = this.handlers.xmppConnected || [];
	      this.handlers.xmppDisconnected = this.handlers.xmppDisconnected || [];
	      this.added.xmlInput = [];
	      this.added.xmlOutput = [];
	      this.added.rawInput = [];
	      this.added.rawOutput = [];
	      this.added.xmppConnected = this.added.xmppConnected || [];
	      this.added.xmppDisconnected = this.added.xmppDisconnected || [];
	      this.removed.xmlInput = [];
	      this.removed.xmlOutput = [];
	      this.removed.rawInput = [];
	      this.removed.rawOutput = [];
	      this.removed.xmppConnected = this.removed.xmppConnected || [];
	      this.removed.xmppDisconnected = this.removed.xmppDisconnected || [];
	    }
	
	    /**
	     * Add handler factory
	     * @param type
	     * @returns {Function}
	     * @private
	     */
	
	  }, {
	    key: '_createAddHandler',
	    value: function _createAddHandler(type) {
	      var _this2 = this;
	
	      return function (handler) {
	        if (!_.includes(_this2.added[type], handler) && !_.includes(_this2.handlers[type], handler)) {
	          _this2.added[type].push(handler);
	        }
	        return handler;
	      };
	    }
	
	    /**
	     * @param type
	     * @returns {Function}
	     * @private
	     */
	
	  }, {
	    key: '_createDeleteHandler',
	    value: function _createDeleteHandler(type) {
	      var _this3 = this;
	
	      return function (handler) {
	        _this3.removed[type].push(handler);
	      };
	    }
	
	    /**
	     * Hooks factory
	     * @param type
	     * @returns {Function}
	     * @private
	     */
	
	  }, {
	    key: '_createHooksHandler',
	    value: function _createHooksHandler(type) {
	      var _this4 = this;
	
	      if (this.Connection[type] !== Strophe.Connection.prototype[type]) {
	        throw new Error('\n        Error installing Strophe Connection Hooks plugin.\n        Strophe.Connection.' + type + ' has already been overwritten.\n        Please ensure that the ConnectionHooks plugin is installed\n        before any other plugin, and that nothing is overwriting the\n        ' + type + ' method.\n      ');
	      }
	
	      return function () {
	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	          args[_key2] = arguments[_key2];
	        }
	
	        // remove handlers
	        while (_this4.removed[type].length > 0) {
	          _.pull(_this4.handlers[type], _this4.removed[type].pop());
	        }
	
	        // add new handlers
	        while (_this4.added[type].length > 0) {
	          _this4.handlers[type].push(_this4.added[type].pop());
	        }
	
	        var handlers = _this4.handlers[type];
	        _this4.handlers[type] = [];
	
	        // iterate through handlers and execute them. If they return true,
	        // keep them. If they return false or throw an exception, remove them
	        handlers.forEach(function (handler) {
	          try {
	            if (handler.apply(undefined, args)) {
	              _this4.handlers[type].push(handler);
	            }
	          } catch (e) {
	            Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);
	          }
	        });
	      };
	    }
	  }]);
	  return ConnectionHooksPlugin;
	}(_abstract_plugin2.default);

	exports.default = ConnectionHooksPlugin;
	module.exports = exports['default'];

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _room = __webpack_require__(153);
	
	var _room2 = _interopRequireDefault(_room);
	
	var _xmppUtils = __webpack_require__(232);
	
	var _xmppUtils2 = _interopRequireDefault(_xmppUtils);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Strophe Connection plugin that contains logic around
	 * creating, modifying, deleting rooms
	 */
	
	var RoomsPlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(RoomsPlugin, _AbstractPlugin);
	
	  function RoomsPlugin() {
	    (0, _classCallCheck3.default)(this, RoomsPlugin);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RoomsPlugin).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(RoomsPlugin, [{
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(RoomsPlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	      Strophe.addNamespace('HC', NS.HC);
	      Strophe.addNamespace('HC_MUC_ROOM', NS.HC_MUC_ROOM);
	      Strophe.addNamespace('HC_MUC_PERMISSIONS', NS.HC_MUC_PERMISSIONS);
	      Strophe.addNamespace('MUC_USER', NS.MUC_USER);
	      Strophe.addNamespace('MUC_OWNER', NS.MUC_OWNER);
	    }
	
	    /**
	     * Create a new room by sending an "available" presence with
	     * the new room details to a non-existent room jid.
	     * http://xmpp.org/extensions/xep-0045.html#createroom
	     * https://extranet.atlassian.com/pages/viewpage.action?pageId=2334034757#HipChatClients:HowDoTheyWork?-JoiningroomJoiningaroom
	     *
	     * @method create
	     * @param {string} name
	     * @param {string} topic
	     * @param {string} privacy
	     * @returns {Promise<CreateRoomResponse, DALError>}
	     */
	
	  }, {
	    key: 'create',
	    value: function create(name, topic, privacy) {
	      var _this2 = this;
	
	      var jid = _xmppUtils2.default.createRoomJid(name);
	      return new _promise2.default(function (resolve, reject) {
	
	        /**
	         * Creating a room via XMPP triggers an iq "set" stanza to be
	         * returned with the room id, name, topic, privacy and version:
	         *
	         * <iq xmlns="jabber:client" to="${my_jid}" type="set">
	         *  <query xmlns="http://hipchat.com/protocol/muc#room">
	         *    <item jid="${room_jid}" name="${name}">
	         *      <id>2115114</id>
	         *      <name>${name}</name>
	         *      <topic>${topic}</topic>
	         *      <privacy>${privacy}</privacy>
	         *      <owner>${owner_jid}</owner>
	         *      <guest_url />
	         *      <version>${version_hash}</version>
	         *      <num_participants>0</num_participants>
	         *    </item>
	         *  </query>
	         * </iq>
	         *
	         * We'll listen for that iq, and resolve with the room id
	         * so the return value of this api is the same as the rest version
	         *
	         * @typedef {object} CreateRoomResponse
	         * @property {number} id
	         */
	        var successHandler = _this2.Connection.addHandler(function (xmpp) {
	          var item = xmpp.querySelector('item[jid="' + jid + '"]');
	          if (item && item.getAttribute('name') === name) {
	            var id = parseInt(item.querySelector('id').textContent, 10);
	            resolve({ id: id });
	            return false;
	          }
	          return true;
	        }, Strophe.NS.HC_MUC_ROOM, 'iq', 'set');
	
	        _this2.checkIfOnline().then(function () {
	          _this2.join(jid, 0, { name: name, topic: topic, privacy: privacy }).catch(function (error) {
	            _this2.Connection.deleteHandler(successHandler);
	            reject(error);
	          });
	        }, function (connectionError) {
	          _this2.Connection.deleteHandler(successHandler);
	          reject(connectionError);
	        });
	      });
	    }
	
	    /**
	     * Join a room by sending an "available" presence to the room jid.
	     * http://xmpp.org/extensions/xep-0045.html#enter
	     * https://extranet.atlassian.com/pages/viewpage.action?pageId=2334034757#HipChatClients:HowDoTheyWork?-JoiningroomJoiningaroom
	     *
	     * TODO: If a maxstanzas value is provided, this method triggers multiple side-effects
	     * TODO: in that it returns a join success AND history messages. It may make sense to
	     * TODO: either break this into multiple methods or make the return value an observable.
	     * TODO: For now, just returning the join success and letting the global trap take care of history
	     *
	     * @method join
	     * @param {string} jid
	     * @param {number} [maxstanzas=0]
	     * @param {object} [newRoomOpts=null] options if room being joined is a new room.
	     *  - Should be an object containing: { name, topic, privacy }
	     * @returns {Promise<JoinRoomResponse, DALError>}
	     */
	
	  }, {
	    key: 'join',
	    value: function join(jid) {
	      var maxstanzas = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	      var _this3 = this;
	
	      var newRoomOpts = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	      var limitPresences = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];
	
	      var id = 'joinRoom:' + _.uniqueId(),
	          room = jid + '/' + _configuration_store2.default.get('user_name'),
	          type = 'available',
	          stanza = $pres({ type: type, to: room, id: id }).c('x', { xmlns: Strophe.NS.MUC }).c('history', { maxstanzas: maxstanzas }).up().up();
	
	      if (newRoomOpts) {
	        stanza.c('x', { xmlns: Strophe.NS.HC_MUC_ROOM }).c('name').t(newRoomOpts.name).up().c('topic').t(newRoomOpts.topic).up().c('privacy').t(newRoomOpts.privacy).up().up();
	      }
	
	      if (!_configuration_store2.default.get('is_guest', false) && limitPresences) {
	        //HC Servers that do not recognize this element will simply ignore it and function as always
	        //sending all room participant presences automatically after room join.
	        stanza.c('limit', {
	          maxmemberpresences: _app_config2.default.initial_room_participants_limit,
	          xmlns: Strophe.NS.HC
	        });
	      }
	
	      return new _promise2.default(function (resolve, reject) {
	        var successHandler = void 0,
	            errorHandler = void 0;
	
	        successHandler = _this3.Connection.addHandler(function (xmpp) {
	          var mucUser = xmpp.getElementsByTagNameNS(Strophe.NS.MUC_USER, 'x')[0];
	          if (mucUser.querySelector('status[code="110"]')) {
	            _this3.Connection.deleteHandler(errorHandler);
	            resolve(_this3._processJoinRoomPresence(xmpp));
	            return false;
	          }
	          return true;
	        }, Strophe.NS.MUC_USER, 'presence', null, null, room);
	
	        errorHandler = _this3.Connection.addHandler(function (xmpp) {
	          _this3.Connection.deleteHandler(successHandler);
	          reject(_dalError2.default.fromXMPP(xmpp));
	          return false;
	        }, null, 'presence', 'error', id, null);
	
	        _this3.Connection.send(stanza.tree());
	      });
	    }
	
	    /**
	     * Leave a room. Sends an unavailable presence to the room. The room returns
	     * a corresponding unavailable presence back to you with status code of 110:
	     *
	     * <presence xmlns='jabber:client' from='room_jid/User Name' type='unavailable' to='my_full_jid'>
	     *  <x xmlns='http://jabber.org/protocol/muc#user'>
	     *    <item affiliation='member' jid='my_bar_jid' role='none'/>
	     *    <status code='110'/>
	     *  </x>
	     *  <status>reason for leaving (unused)</status>
	     * </presence>
	     *
	     * @method leave
	     * @param {string} jid
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'leave',
	    value: function leave(jid) {
	      var _this4 = this;
	
	      var room = jid + '/' + _configuration_store2.default.get('user_name'),
	          stanza = $pres({ to: room, type: 'unavailable' });
	
	      return new _promise2.default(function (resolve, reject) {
	
	        _this4.Connection.addHandler(function (xmpp) {
	          var mucUser = xmpp.getElementsByTagNameNS(Strophe.NS.MUC_USER, 'x')[0];
	
	          if (xmpp.getAttribute('type') === 'error') {
	            reject(_dalError2.default.fromXMPP(xmpp));
	            return false;
	          } else if (mucUser.querySelector('status[code="110"]')) {
	            resolve();
	            return false;
	          }
	          return true;
	        }, null, 'presence', ['unavailable', 'error'], null, room);
	
	        _this4.Connection.send(stanza.tree());
	      });
	    }
	
	    /**
	     * Fetch details for a specific room
	     * http://xmpp.org/extensions/xep-0045.html#disco-roominfo
	     *
	     * @method fetch
	     * @param {string} jid
	     * @returns {Promise<Room, DALError>}
	     */
	
	  }, {
	    key: 'fetch',
	    value: function fetch(jid) {
	      var _this5 = this;
	
	      var stanza = $iq({ type: 'get', to: jid }).c('query', { xmlns: Strophe.NS.DISCO_INFO });
	
	      return new _promise2.default(function (resolve, reject) {
	        _this5.Connection.sendIQ(stanza.tree(), function (xmpp) {
	          return resolve(_room2.default.fromXMPPDiscoInfo(xmpp));
	        }, function (xmpp) {
	          return reject(_dalError2.default.fromXMPP(xmpp));
	        });
	      });
	    }
	
	    /**
	     * Rename a room. Sends rename IQ to server. Success response is an empty result IQ:
	     * <iq xmlns='jabber:client' type='result' from='room_jid' id='XXX' to='my_full_jid'/>
	     *
	     * @method rename
	     * @param {string} jid
	     * @param {string} name
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'rename',
	    value: function rename(jid, name) {
	      var stanza = $iq({ type: 'set', to: jid }).c('query', { xmlns: Strophe.NS.HC }).c('rename').t(name);
	
	      return this.sendIQWithOfflineGuard(stanza);
	    }
	
	    /**
	     * Downloads the entire rooms list from XMPP. Last resort if sync'ing fails; This is
	     * slow and expensive for large groups.
	     *
	     * @method getAll
	     * @returns {Promise<Array<Room>, DALError>}
	     */
	
	  }, {
	    key: 'getAll',
	    value: function getAll() {
	      var _this6 = this;
	
	      var stanza = $iq({ type: 'get', to: _configuration_store2.default.get('conference_server') }).c('query', { xmlns: Strophe.NS.DISCO_ITEMS, ignore_archived: true });
	
	      return new _promise2.default(function (resolve, reject) {
	        var success = function success(xmpp) {
	          var query = xmpp.getElementsByTagNameNS(Strophe.NS.DISCO_ITEMS, 'query')[0],
	              items = (0, _from2.default)(query.querySelectorAll('item')),
	              rooms = items.map(function (item) {
	            return _room2.default.fromXMPPDiscoItem(item);
	          });
	          resolve(rooms);
	        };
	
	        var error = function error(xmpp) {
	          return reject(_dalError2.default.fromXMPP(xmpp));
	        };
	
	        _this6.Connection.sendIQ(stanza.tree(), success, error);
	      });
	    }
	
	    /**
	     * Change a room's privacy setting. Success response is an empty result IQ:
	     * <iq xmlns='jabber:client' type='result' from='room_jid' id='XXX' to='my_full_jid'/>
	     *
	     * @method setPrivacy
	     * @param {string} jid
	     * @param {string} privacy - "public" or "private"
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'setPrivacy',
	    value: function setPrivacy(jid, privacy) {
	      var stanza = $iq({ type: 'set', to: jid }).c('query', { xmlns: Strophe.NS.HC }).c('privacy').t(privacy);
	
	      return this.sendIQWithOfflineGuard(stanza);
	    }
	
	    /**
	     * Set room topic
	     *
	     * @method setTopic
	     * @param {string} jid
	     * @param {string} [topic='']
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'setTopic',
	    value: function setTopic(jid) {
	      var _this7 = this;
	
	      var topic = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	
	      topic = topic.trim().substr(0, _app_config2.default.max_topic_text_length);
	      var stanza = $msg({ to: jid, type: 'groupchat' }).c('subject').t(topic);
	
	      return new _promise2.default(function (resolve, reject) {
	        var success = void 0,
	            error = void 0,
	            timeout = void 0;
	
	        success = _this7.Connection.addHandler(function (message) {
	          var subjectNode = message.querySelector('subject'),
	              subject = subjectNode ? subjectNode.textContent.trim() : '';
	          if (subject === topic) {
	            _this7.Connection.deleteHandler(error);
	            _this7.Connection.deleteTimedHandler(timeout);
	            resolve();
	            return false;
	          }
	          return true;
	        }, null, 'message', 'groupchat', null, jid, { matchBare: true });
	
	        error = _this7.Connection.addHandler(function (message) {
	          _this7.Connection.deleteHandler(success);
	          _this7.Connection.deleteTimedHandler(timeout);
	          reject(_dalError2.default.fromXMPP(message));
	        }, null, 'message', 'error', null, jid, { matchBare: true });
	
	        timeout = _this7.Connection.addTimedHandler(_app_config2.default.default_message_confirmation_timeout, function () {
	          _this7.Connection.deleteHandler(success);
	          _this7.Connection.deleteHandler(error);
	          reject(_dalError2.default.ofType(_dalError2.default.Types.TIMEOUT));
	        });
	
	        _this7.Connection.send(stanza.tree());
	      });
	    }
	
	    /**
	     * Set guest access on a room. Success response is an empty result IQ:
	     * <iq xmlns='jabber:client' type='result' from='room_jid' id='XXX' to='my_full_jid'/>
	     *
	     * @method setGuestAccess
	     * @param {string} jid
	     * @param {boolean} enabled
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'setGuestAccess',
	    value: function setGuestAccess(jid, enabled) {
	      var stanza = $iq({ type: 'set', to: jid }).c('query', { xmlns: Strophe.NS.HC }).c('guest_access').t(enabled ? 1 : 0);
	
	      return this.sendIQWithOfflineGuard(stanza);
	    }
	
	    /**
	     * @method inviteUsers
	     * @param {string} roomJid
	     * @param {array} userJids
	     * @returns {Promise}
	     */
	
	  }, {
	    key: 'inviteUsers',
	    value: function inviteUsers(roomJid, userJids) {}
	
	    /**
	     * @method removeUsers
	     * @param {string} roomJid
	     * @param {array} userJids
	     * @returns {Promise}
	     */
	
	  }, {
	    key: 'removeUsers',
	    value: function removeUsers(roomJid, userJids) {}
	
	    /**
	     * Delete a room.
	     * Sends an IQ to tell the server to delete the room. The server will respond with
	     * an empty IQ result that matches your sent IQ id and room
	     *
	     * <iq xmlns='jabber:client' type='result' from='the-room-you-deleted@conf.btf.hipchat.com'
	     *   id='10:sendIQ' to='1_2@chat.btf.hipchat.com'/>
	     *
	     * @method delete
	     * @param {string} jid
	     * @returns {Promise}
	     */
	
	  }, {
	    key: 'delete',
	    value: function _delete(jid) {
	      var stanza = $iq({ type: 'set', to: jid }).c('query', { xmlns: Strophe.NS.MUC_OWNER }).c('destroy');
	
	      return this.sendIQWithOfflineGuard(stanza);
	    }
	
	    /**
	     * Process a join room presence response stanza:
	     *
	     *  <presence xmlns="jabber:client" to="1_4@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222" from="1_adfasdfasdfas@conf.devvm.hipchat.com/Homer Simpson">
	     *    <x xmlns="http://jabber.org/protocol/muc#user">
	     *      <item affiliation="owner" jid="1_4@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222" role="participant" />
	     *      <status code="110" />
	     *    </x>
	     *    <x xmlns="http://hipchat.com/protocol/muc#room">
	     *      <name>adfasdfasdfas</name>
	     *      <privacy>public</privacy>
	     *      <topic />
	     *      <rostersize>1</rostersize>
	     *    </x>
	     *    <x xmlns="http://hipchat.com/protocol/muc#permissions">
	     *      <permission>room:invite_user</permission>
	     *      <permission>room:create</permission>
	     *      <permission>update_own_user</permission>
	     *    </x>
	     *  </presence>
	     *
	     * @param xmpp
	     * @returns {JoinRoomResponse}
	     * @private
	     */
	
	  }, {
	    key: '_processJoinRoomPresence',
	    value: function _processJoinRoomPresence(xmpp) {
	      var permsNode = xmpp.getElementsByTagNameNS(Strophe.NS.HC_MUC_PERMISSIONS, 'x')[0],
	          item = xmpp.getElementsByTagNameNS(Strophe.NS.MUC_USER, 'x')[0].querySelector('item'),
	          mucRoomNode = item = xmpp.getElementsByTagNameNS(Strophe.NS.HC_MUC_ROOM, 'x')[0],
	          topicNode = mucRoomNode ? mucRoomNode.querySelector('topic') : null,
	          topic = topicNode ? topicNode.textContent : '',
	          permissions = permsNode ? _.map(permsNode.querySelectorAll('permission'), function (ele) {
	        return ele.textContent;
	      }) : [],
	          rosterSize = xmpp.querySelector('rostersize') ? parseInt(xmpp.querySelector('rostersize').textContent, 10) : 0;
	
	      /**
	       * @typedef {object} JoinRoomResponse
	       * @property {string} jid
	       * @property {string} type - "groupchat"
	       * @property {string} [role]
	       * @property {string} [affiliation]
	       * @property {Array<string>} permissions - list of permissions the current user has on this room
	       */
	      return {
	        jid: Strophe.getBareJidFromJid(xmpp.getAttribute('from')),
	        type: 'groupchat',
	        role: item ? item.getAttribute('role') : null,
	        affiliation: item ? item.getAttribute('affiliation') : null,
	        permissions: permissions,
	        roster_size: rosterSize,
	        topic: topic
	      };
	    }
	  }]);
	  return RoomsPlugin;
	}(_abstract_plugin2.default);

	exports.default = RoomsPlugin;
	module.exports = exports['default'];

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LETTER_UTF8_RANGES = "A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
	
	exports.default = {
	
	  /**
	   * Slugify a string
	   * @param {string} str
	   * @returns {string}
	   */
	
	  toSlug: function toSlug(str) {
	    var from = "",
	        to = "aaaaeeeeiiiioooouuuunc";
	    str = str.replace(/^\s+|\s+$/g, "").toLowerCase();
	    for (var i = 0; i < from.length; i++) {
	      str = str.replace(new RegExp(from.charAt(i), "g"), to.charAt(i));
	    }
	    str = str.replace(new RegExp("[^0-9" + LETTER_UTF8_RANGES + " -]", 'g'), "").replace(/\s+/g, "_").replace(/-+/g, "-");
	    return str;
	  },
	
	
	  /**
	   * Create a new room jid from the name
	   * @param {string} name
	   * @returns {string}
	   */
	  createRoomJid: function createRoomJid(name) {
	    var _ConfigStore$getAll = _configuration_store2.default.getAll();
	
	    var group_id = _ConfigStore$getAll.group_id;
	    var conference_server = _ConfigStore$getAll.conference_server;
	    var slug = this.toSlug(name);
	    return group_id + "_" + slug + "@" + conference_server;
	  },
	
	
	  /**
	   * Formats a date to the format XMPP recognizes
	   * @param {date|string} date
	   * @returns {string}
	   */
	  toXMPPDate: function toXMPPDate(date) {
	    if (_.isDate(date)) {
	      return new Date(date.setMilliseconds(0)).toISOString().replace(/\.000/, '');
	    }
	    return date;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	var _xmppUtils = __webpack_require__(232);
	
	var _xmppUtils2 = _interopRequireDefault(_xmppUtils);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _file = __webpack_require__(194);
	
	var _file2 = _interopRequireDefault(_file);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ChatPlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(ChatPlugin, _AbstractPlugin);
	
	  function ChatPlugin() {
	    (0, _classCallCheck3.default)(this, ChatPlugin);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ChatPlugin).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(ChatPlugin, [{
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(ChatPlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	      Strophe.addNamespace('HC_LINKS', NS.HC_LINKS);
	      Strophe.addNamespace('HC_FILES', NS.HC_FILES);
	    }
	
	    /**
	     * Get list of links for a given room/one-to-one.
	     * Tetra is not currently honoring the limit parameter here -- HC-28429
	     *
	     * @param {string} jid
	     * @param {date} [before=null]
	     * @param {date} [after=null]
	     * @param {number} [limit=50]
	     * @returns {Promise<ChatLinksResponse, DALError>}
	     */
	
	  }, {
	    key: 'getLinks',
	    value: function getLinks(jid, before, after) {
	      var _this2 = this;
	
	      var limit = arguments.length <= 3 || arguments[3] === undefined ? 50 : arguments[3];
	
	      var query = {
	        xmlns: Strophe.NS.HC_LINKS,
	        limit: limit
	      };
	
	      if (before) {
	        query.before = _xmppUtils2.default.toXMPPDate(before);
	      } else if (after) {
	        query.after = _xmppUtils2.default.toXMPPDate(after);
	      }
	
	      var stanza = $iq({ type: 'get', to: jid }).c('query', query);
	
	      return new _promise2.default(function (resolve, reject) {
	        var success = function success(xmpp) {
	          resolve(_this2._processLinksResponse(xmpp, before, limit));
	        };
	
	        var error = function error(xmpp) {
	          reject(_dalError2.default.fromXMPP(xmpp));
	        };
	
	        _this2.Connection.sendIQ(stanza.tree(), success, error);
	      });
	    }
	
	    /**
	     * Get list of files for a given room/one-to-one
	     * Tetra is not currently honoring the limit parameter here -- HC-28429
	     *
	     * @param {string} jid
	     * @param {date} [before=null]
	     * @param {date} [after=null]
	     * @param {number} [limit=50]
	     * @returns {Promise<ChatFilesResponse, DALError>}
	     */
	
	  }, {
	    key: 'getFiles',
	    value: function getFiles(jid, before, after) {
	      var _this3 = this;
	
	      var limit = arguments.length <= 3 || arguments[3] === undefined ? 50 : arguments[3];
	
	      var query = {
	        xmlns: Strophe.NS.HC_FILES,
	        limit: limit
	      };
	
	      if (before) {
	        query.before = _xmppUtils2.default.toXMPPDate(before);
	      } else if (after) {
	        query.after = _xmppUtils2.default.toXMPPDate(after);
	      }
	
	      var stanza = $iq({ type: 'get', to: jid }).c('query', query).c('auth_scheme', 'bearer');
	
	      return new _promise2.default(function (resolve, reject) {
	        var success = function success(xmpp) {
	          resolve(_this3._processFilesResponse(xmpp, before, limit));
	        };
	
	        var error = function error(xmpp) {
	          reject(_dalError2.default.fromXMPP(xmpp));
	        };
	
	        _this3.Connection.sendIQ(stanza.tree(), success, error);
	      });
	    }
	
	    /**
	     * Process successful links query iq response:
	     *
	     * <iq xmlns='jabber:client' type='result' from='10804_samar@conf.hipchat.com' id='15:sendIQ' to='10804_220836@chat.hipchat.com/web||proxy|proxy-b301.hipchat.com|5252'>
	     *  <query xmlns='http://hipchat.com/protocol/links'>
	     *    <item>
	     *      <id>246769778</id>
	     *      <group_id>10804</group_id>
	     *      <user_id>3197019</user_id>
	     *      <url>https://austin.craigslist.org/hsh/5369067832.html</url>
	     *      <date>2016-01-11T16:45:22Z</date>
	     *    </item>
	     *    ...
	     *  </query>
	     * </iq>
	     *
	     * @param xmpp
	     * @param before
	     * @param limit
	     * @returns {ChatLinksResponse}
	     * @private
	     */
	
	  }, {
	    key: '_processLinksResponse',
	    value: function _processLinksResponse(xmpp, before, limit) {
	      var query = xmpp.getElementsByTagNameNS(Strophe.NS.HC_LINKS, 'query')[0],
	          jid = Strophe.getBareJidFromJid(xmpp.getAttribute('from')),
	          items = query.querySelectorAll('item'),
	          end = items.length < limit;
	
	      /**
	       * @typedef {Object} ChatLink
	       * @property {number} id
	       * @property {number} group_id
	       * @property {number} user_id
	       * @property {string} url
	       * @property {date} date
	       * @property {string} name
	       */
	      var links = _.map(items, function (item) {
	        return {
	          id: parseInt(item.querySelector('id').textContent, 10),
	          group_id: parseInt(item.querySelector('group_id').textContent, 10),
	          user_id: parseInt(item.querySelector('user_id').textContent, 10),
	          url: item.querySelector('url').textContent,
	          date: new Date(item.querySelector('date').textContent),
	          name: item.querySelector('url').textContent.split('/').pop()
	        };
	      });
	
	      links = _.orderBy(links, 'date', 'desc');
	
	      /*
	       * NOTE: HipChat Server v1.3.1 and lower do not honor the "before" param
	       * in the fetchLinks api, so you'll get the same result set back on every
	       * request. This check is to ensure the links we just got back are indeed
	       * older than what was requested.
	       */
	      var oldestLinkDate = _.get(_.last(links), 'date');
	      if (links.length && before && before - oldestLinkDate <= 0) {
	        links = [];
	        end = true;
	      }
	
	      /**
	       * @typedef {Object} ChatLinksResponse
	       * @property {string} jid
	       * @property {boolean} end
	       * @property {Array<ChatLink>} links
	       */
	      return { jid: jid, links: links, end: end };
	    }
	
	    /**
	     * Process successful files query iq response. Using the File model to normalize
	     * authenticated/secure files and unauthenticated/legacy files. See the model
	     * for sample data and details on the returned File object.
	     *
	     * @param xmpp
	     * @param before
	     * @param limit
	     * @returns {ChatFilesResponse}
	     * @private
	     */
	
	  }, {
	    key: '_processFilesResponse',
	    value: function _processFilesResponse(xmpp, before, limit) {
	      var query = xmpp.getElementsByTagNameNS(Strophe.NS.HC_FILES, 'query')[0],
	          jid = Strophe.getBareJidFromJid(xmpp.getAttribute('from')),
	          items = void 0,
	          end = void 0;
	
	      items = query.querySelectorAll('authenticated_file');
	      if (items.length === 0) {
	        items = query.querySelectorAll('item');
	      }
	      end = items.length < limit;
	
	      var files = _.map(items, function (item) {
	        return _file2.default.fromXMPP(item);
	      });
	
	      /*
	       * NOTE: HipChat Server v1.3.1 and lower do not honor the "before" param
	       * in the fetchFiles api, so you'll get the same result set back on every
	       * request. This check is to ensure the files we just got back are indeed
	       * older than what was requested.
	       */
	      var oldestFileDate = _.get(_.last(files), 'date');
	      if (files.length && before && before - oldestFileDate <= 0) {
	        files = [];
	        end = true;
	      }
	
	      /**
	       * @typedef {Object} ChatFilesResponse
	       * @property {string} jid
	       * @property {boolean} end
	       * @property {Array<File>} files
	       */
	      return { jid: jid, files: files, end: end };
	    }
	  }]);
	  return ChatPlugin;
	}(_abstract_plugin2.default);

	exports.default = ChatPlugin;
	module.exports = exports['default'];

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PresencePlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(PresencePlugin, _AbstractPlugin);
	
	  function PresencePlugin() {
	    var _Object$getPrototypeO;
	
	    (0, _classCallCheck3.default)(this, PresencePlugin);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(PresencePlugin)).call.apply(_Object$getPrototypeO, [this].concat(args)));
	
	    _this.idleTimestamp = null;
	    return _this;
	  }
	
	  (0, _createClass3.default)(PresencePlugin, [{
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(PresencePlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	      Strophe.addNamespace('HC_PRESENCE', NS.HC_PRESENCE);
	      Strophe.addNamespace('ENTITY_CAPABILITIES', NS.ENTITY_CAPABILITIES);
	      Strophe.addNamespace('LAST_ACTIVITY', NS.LAST_ACTIVITY);
	    }
	
	    /**
	     * Sends the initial presence to tell the server the client has
	     * connected or reconnected. Send on connection events. Same as
	     * regular presence, but includes the ENTITY_CAPABILITIES info:
	     *
	     * <presence roster_presences="false" xmlns="jabber:client">
	     *  <show>chat</show>
	     *  <c xmlns="http://jabber.org/protocol/caps"
	     *     node="http://hipchat.com/client/web"
	     *     ver="4.15.0"
	     *     os_ver="Chrome 49"/>
	     * </presence>
	     *
	     * @param {string} [show = 'chat']
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'sendInitialPresence',
	    value: function sendInitialPresence() {
	      var show = arguments.length <= 0 || arguments[0] === undefined ? _presence2.default.AVAILABLE : arguments[0];
	
	      return this.setPresence(show, null, true);
	    }
	
	    /**
	     * Sends global presences to the server to broadcast your status.
	     * Subscribes to echoes of these presences since the server will
	     * send the right back to you as long as you're subscribed to your
	     * own presence updates -- which you should always be
	     *
	     * Just presence (show):
	     *
	     * <presence roster_presences="false" xmlns="jabber:client">
	     *   <show>dnd</show>
	     * </presence>
	     *
	     * Presence and status text:
	     *
	     * <presence roster_presences="false" xmlns="jabber:client">
	     *   <show>chat</show>
	     *   <status>I'm back</status>
	     * </presence>
	     *
	     * Idle (show === 'away'):
	     *
	     * <presence roster_presences="false" xmlns="jabber:client">
	     *   <show>away</show>
	     *   <status>I'm away</status>
	     *   <query xmlns="jabber:iq:last" seconds="900"/>
	     * </presence>
	     *
	     * @param {string} [show = 'chat']
	     * @param {string|null} [status = null]
	     * @param {boolean} [send_caps = false]
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'setPresence',
	    value: function setPresence() {
	      var show = arguments.length <= 0 || arguments[0] === undefined ? _presence2.default.AVAILABLE : arguments[0];
	
	      var _this2 = this;
	
	      var status = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      var send_caps = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	      return new _promise2.default(function (resolve, reject) {
	        var success = void 0,
	            error = void 0;
	
	        success = _this2.Connection.addHandler(function () {
	          _this2.Connection.deleteHandler(error);
	          resolve();
	          return false;
	        }, null, 'presence', null, null, _configuration_store2.default.get('jid'), { matchBare: true });
	
	        error = _this2.Connection.addHandler(function (xmpp) {
	          _this2.Connection.deleteHandler(success);
	          reject(_dalError2.default.fromXMPP(xmpp));
	          return false;
	        }, null, 'presence', 'error', null, _configuration_store2.default.get('jid'), { matchBare: true });
	
	        _this2.Connection.send(_this2._createPresenceStanza(show, status, send_caps));
	      });
	    }
	
	    /**
	     * Sets global presence filter to the provided list of user ids.
	     * Must include the current user's id; it will be appended if absent.
	     * We should *always* be subscribed to receive our own presences.
	     *
	     * Sends:
	     *
	     * <iq type="set" xmlns="jabber:client">
	     *  <query xmlns="http://hipchat.com/protocol/presence" action="presence_filter">
	     *    <uid>1</uid>
	     *    <uid>2</uid>
	     *    <uid>3</uid>
	     *    ...
	     *  </query>
	     * </iq>
	     *
	     * Receives:
	     *
	     * <iq xmlns='jabber:client' type='result' from='jid' id='18:sendIQ' to='my-jid'/>
	     *
	     * @param {Array<string|number>} idList = [[]]
	     * @returns {Promise<undefined,DALError>}
	     */
	
	  }, {
	    key: 'filterPresences',
	    value: function filterPresences() {
	      var _this3 = this;
	
	      var idList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	
	      var currentUserId = _configuration_store2.default.get('user_id').toString(),
	          stanza = $iq({ type: 'set' }).c('query', {
	        xmlns: Strophe.NS.HC_PRESENCE,
	        action: 'presence_filter'
	      });
	
	      if (!_.find(idList, function (item) {
	        return item.toString() === currentUserId;
	      })) {
	        idList.push(currentUserId);
	      }
	
	      idList.forEach(function (uid) {
	        stanza.c('uid', uid).up();
	      });
	
	      return new _promise2.default(function (resolve, reject) {
	        _this3.Connection.sendIQ(stanza.tree(), function (iq) {
	          return resolve();
	        }, function (err) {
	          return reject(_dalError2.default.fromXMPP(err));
	        });
	      });
	    }
	
	    /**
	     * @method _createPresenceStanza
	     * @param {string} [show = 'chat']
	     * @param {string|null} [status = null]
	     * @param {boolean} [send_caps = false]
	     * @returns {*} Strophe presence stanza object
	     * @private
	     */
	
	  }, {
	    key: '_createPresenceStanza',
	    value: function _createPresenceStanza() {
	      var show = arguments.length <= 0 || arguments[0] === undefined ? _presence2.default.AVAILABLE : arguments[0];
	      var status = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      var send_caps = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	      var stanza = $pres({ roster_presences: 'false' }).c('show').t(show).up();
	
	      if (status) {
	        stanza.c('status').t(status).up();
	      }
	
	      if (show === _presence2.default.IDLE) {
	        stanza.c('query', {
	          xmlns: Strophe.NS.LAST_ACTIVITY,
	          seconds: this._getIdleSeconds()
	        }).up();
	        this._updateIdleTimestamp();
	      } else {
	        this._resetIdleTimestamp();
	      }
	
	      if (send_caps) {
	        stanza.c('c', {
	          xmlns: Strophe.NS.ENTITY_CAPABILITIES,
	          node: _configuration_store2.default.get('client_node'),
	          ver: _configuration_store2.default.get('client_version_id'),
	          os_ver: _configuration_store2.default.get('client_os_version_id')
	        }).up();
	      }
	
	      return stanza.tree();
	    }
	
	    /**
	     * Get the current idle preference in milliseconds
	     * @returns {number}
	     * @private
	     */
	
	  }, {
	    key: '_getIdlePreferenceMS',
	    value: function _getIdlePreferenceMS() {
	      return _preferences_store2.default.get('idleMinutes') * 60 * 1000;
	    }
	
	    /**
	     * Get the number of seconds the user has been idle.
	     * @returns {number}
	     * @private
	     */
	
	  }, {
	    key: '_getIdleSeconds',
	    value: function _getIdleSeconds() {
	      if (this.idleTimestamp) {
	        return Math.round((new Date().getTime() - this.idleTimestamp + this._getIdlePreferenceMS()) / 1000);
	      }
	      return this._getIdlePreferenceMS() / 1000;
	    }
	
	    /**
	     * Update idleTimestamp value any time you set presence to 'away'
	     * @private
	     */
	
	  }, {
	    key: '_updateIdleTimestamp',
	    value: function _updateIdleTimestamp() {
	      this.idleTimestamp = this.idleTimestamp ? this.idleTimestamp : new Date().getTime();
	    }
	
	    /**
	     * Clear idleTimestamp any time you set presence to something
	     * other than 'away'
	     * @private
	     */
	
	  }, {
	    key: '_resetIdleTimestamp',
	    value: function _resetIdleTimestamp() {
	      this.idleTimestamp = null;
	    }
	  }]);
	  return PresencePlugin;
	}(_abstract_plugin2.default);

	exports.default = PresencePlugin;
	module.exports = exports['default'];

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _iq_processor = __webpack_require__(236);
	
	var _iq_processor2 = _interopRequireDefault(_iq_processor);
	
	var _bosh_actions = __webpack_require__(237);
	
	var _bosh_actions2 = _interopRequireDefault(_bosh_actions);
	
	var _x2js = __webpack_require__(213);
	
	var _x2js2 = _interopRequireDefault(_x2js);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * This is the "global xmpp trap" that propagates the majority of the
	 * XMPP data to our application -- and is a total and terrible hack.
	 *
	 * The xmlInput and rawInput methods are noops within Strophe that can be overridden
	 * to provide custom xml processing before moving them along to Strophe's handlers.
	 * Here, we're building a JSON blob out of the 2 methods since they're called
	 * one after the other, and bypassing Strophe from there -- passing the converted
	 * JSON up to our app via the receivedServerData action (shrug)
	 *
	 * @class XMPPTrapPlugin
	 */
	
	var XMPPTrapPlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(XMPPTrapPlugin, _AbstractPlugin);
	
	  function XMPPTrapPlugin() {
	    (0, _classCallCheck3.default)(this, XMPPTrapPlugin);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(XMPPTrapPlugin).call(this));
	
	    _this.queue = null;
	    return _this;
	  }
	
	  /**
	   * Create a single instance of the handler callbacks that are bound to 'this'
	   * just after the plugin is instantiated. These will be the callback instances
	   * registered to the xmlInput and rawInput hooks each time
	   * @param args
	   */
	
	
	  (0, _createClass3.default)(XMPPTrapPlugin, [{
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(XMPPTrapPlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	      this.xmlInputHandler = this.onXmlInput.bind(this);
	      this.xmlOutputHandler = this.onXmlOutput.bind(this);
	      this.rawInputHandler = this.onRawInput.bind(this);
	    }
	
	    /**
	     * On connected, attach the global trap handlers.
	     * @override
	     */
	
	  }, {
	    key: 'onConnected',
	    value: function onConnected() {
	      this.Connection.last_BOSH_activity = new Date().getTime();
	      this.Connection.ConnectionHooks.addXmlInputHandler(this.xmlInputHandler);
	      this.Connection.ConnectionHooks.addRawInputHandler(this.rawInputHandler);
	      this.Connection.ConnectionHooks.addXmlOutputHandler(this.xmlOutputHandler);
	    }
	
	    /**
	     * Called by Strophe on each ajax response with the parsed XML data
	     * @param elem
	     * @returns {boolean} true - always return true
	     */
	
	  }, {
	    key: 'onXmlInput',
	    value: function onXmlInput(elem) {
	      try {
	        _logger2.default.logXML(elem, 'RECV');
	        var xmpp = this._removeExcludedNodes(elem);
	        this.queue = {
	          xml: xmpp,
	          json: _x2js2.default.xml2json(xmpp)
	        };
	        var is_iq_stanza = !!_.get(this.queue.json, 'iq', false);
	        if (is_iq_stanza) {
	          this.queue.json = _iq_processor2.default.transform(this.queue.json);
	        }
	      } catch (e) {
	        _logger2.default.type('xmpp-trap').error('Exception thrown in xmlInput handler: ' + e.message + '.');
	      }
	      return true;
	    }
	
	    /**
	     * Called by Strophe on each ajax response with the raw body text
	     * @param raw
	     * @returns {boolean} true - always return true
	     */
	
	  }, {
	    key: 'onRawInput',
	    value: function onRawInput(raw) {
	      try {
	        this.Connection.last_BOSH_activity = new Date().getTime();
	        if (this.queue.xml && this.queue.xml.hasChildNodes()) {
	          if (this.queue.json.message) {
	            this.queue.json.message = this._fixXhtmlMessageBody(raw, this.queue.json.message);
	          }
	          _bosh_actions2.default.receivedServerData(this.queue.json);
	        }
	        this.queue = null;
	      } catch (e) {
	        _logger2.default.type('xmpp-trap').error('Exception thrown in rawInput handler: ' + e.message + '.');
	      }
	      return true;
	    }
	
	    /**
	     * Called by Strophe just *after* sending each ajax request.
	     * Useful for logging
	     * @param elem
	     * @returns {boolean} true - always return true
	     */
	
	  }, {
	    key: 'onXmlOutput',
	    value: function onXmlOutput(elem) {
	      _logger2.default.logXML(elem, 'SEND');
	      return true;
	    }
	
	    /**
	     * As we begin to properly manage xmpp in the DAL, we should start removing from incoming
	     * XML before passing it to the app to prevent data propagating multiple times. This
	     * is done on a clone of the xml passed in, as we don't want to remove the nodes from
	     * the original as the nodes won't make it to our plugin handlers.
	     * @param {xml} xmpp raw xml input from the ajax request
	     * @returns {xml} clone of the original xml with appropriate nodes removed
	     */
	
	  }, {
	    key: '_removeExcludedNodes',
	    value: function _removeExcludedNodes(xmpp) {
	      var exclusions = [],
	          elem = xmpp.cloneNode(true);
	
	      var iqIgnoreList = [NS.ROSTER, NS.DISCO_ITEMS, NS.DISCO_INFO, NS.HC_LINKS, NS.HC_FILES, NS.HC_AUTHENTICATED_FILE];
	
	      (0, _from2.default)(elem.querySelectorAll('iq')).forEach(function (iq) {
	        if (_.includes(['result', 'error'], iq.getAttribute('type'))) {
	          var query = iq.querySelector('query');
	          if (query && _.includes(iqIgnoreList, query.getAttribute('xmlns'))) {
	            exclusions.push(iq);
	          }
	        }
	      });
	
	      exclusions.forEach(function (node) {
	        elem.removeChild(node);
	      });
	
	      return elem;
	    }
	
	    /**
	     * Regexes out the xhtml body of an xhtml message from the raw ajax response.
	     * (noidea) why or what purpose this serves, but this has existed since the
	     * first commit of HJC (shrug)
	     */
	
	  }, {
	    key: '_fixXhtmlMessageBody',
	    value: function _fixXhtmlMessageBody(raw, messages) {
	      return _.map([].concat(messages), function (message) {
	        if (_.get(message, 'html.body.xmlns') === 'http://www.w3.org/1999/xhtml') {
	          var messageExtractor = new RegExp("mid=['\"]" + message.mid + "['\"]\.+?</message>", "i"),
	              xhtmlBodyExtractor = new RegExp("<body[^>]*xmlns=[\"']http:\\/\\/www\\.w3\\.org\\/1999\\/xhtml[\"'][^>]*>(.*?)<\/body>", "i"),
	              matches = messageExtractor.exec(raw) || [];
	          if (matches.length) {
	            matches = xhtmlBodyExtractor.exec(matches[0]) || [];
	            if (matches.length > 1) {
	              message.html.body.__text = matches[1];
	            }
	          }
	        }
	        return message;
	      });
	    }
	  }]);
	  return XMPPTrapPlugin;
	}(_abstract_plugin2.default);

	exports.default = XMPPTrapPlugin;
	module.exports = exports['default'];

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  transform: function transform(data) {
	    var _this = this;
	
	    var xmlns = void 0,
	        transformer = void 0;
	
	    // Single IQ: normalize to array
	    if (!_.isArray(data.iq)) {
	      data.iq = [data.iq];
	    }
	
	    data.iq = data.iq.map(function (iq) {
	      xmlns = _.get(iq, 'query.xmlns');
	      transformer = _this._getTransformer(xmlns);
	
	      return transformer(iq);
	    });
	
	    return data;
	  },
	  _getTransformer: function _getTransformer(xmlns) {
	    var transformer = void 0;
	
	    switch (xmlns) {
	      case 'http://hipchat.com/protocol/muc#room':
	        transformer = this._hipchatRoomEntity;
	        break;
	      default:
	        transformer = _.identity;
	        break;
	    }
	
	    return transformer;
	  },
	  _hipchatRoomEntity: function _hipchatRoomEntity(iq) {
	    // This stanza also comes through for room deletions, which do not
	    // have an owner
	    if (_.has(iq, 'query.item.owner')) {
	      iq.query.item.owner = _utils2.default.jid.user_id(iq.query.item.owner);
	    }
	
	    return iq;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  receivedServerData: function receivedServerData(data) {
	    _app_dispatcher2.default.dispatch('server-data', data);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _user = __webpack_require__(152);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RosterPlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(RosterPlugin, _AbstractPlugin);
	
	  function RosterPlugin() {
	    (0, _classCallCheck3.default)(this, RosterPlugin);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RosterPlugin).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(RosterPlugin, [{
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(RosterPlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	    }
	
	    /**
	     * Get the full roster from XMPP
	     *
	     * @method getRoster
	     * @returns {Promise<Array<User>, DALError>}
	     */
	
	  }, {
	    key: 'getRoster',
	    value: function getRoster() {
	      var _this2 = this;
	
	      var stanza = $iq({ type: 'get' }).c('query', { xmlns: Strophe.NS.ROSTER });
	
	      return new _promise2.default(function (resolve, reject) {
	        var success = function success(xmpp) {
	          var query = xmpp.getElementsByTagNameNS(Strophe.NS.ROSTER, 'query')[0],
	              items = (0, _from2.default)(query.querySelectorAll('item')),
	              users = items.map(function (item) {
	            return _user2.default.fromXMPP(item);
	          });
	          resolve(users);
	        };
	
	        var error = function error(xmpp) {
	          return reject(_dalError2.default.fromXMPP(xmpp));
	        };
	
	        _this2.Connection.sendIQ(stanza.tree(), success, error);
	      });
	    }
	  }]);
	  return RosterPlugin;
	}(_abstract_plugin2.default);

	exports.default = RosterPlugin;
	module.exports = exports['default'];

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _emoticon = __webpack_require__(155);
	
	var _emoticon2 = _interopRequireDefault(_emoticon);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var EmoticonsPlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(EmoticonsPlugin, _AbstractPlugin);
	
	  function EmoticonsPlugin() {
	    (0, _classCallCheck3.default)(this, EmoticonsPlugin);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(EmoticonsPlugin).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(EmoticonsPlugin, [{
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(EmoticonsPlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	      Strophe.addNamespace('HC_EMOTICONS', NS.HC_EMOTICONS);
	    }
	
	    /**
	     * Get the full emoticon list from XMPP
	     *
	     * @method getEmoticons
	     * @returns {Promise<Array<Emoticon>, DALError>}
	     */
	
	  }, {
	    key: 'getEmoticons',
	    value: function getEmoticons() {
	      var _this2 = this;
	
	      var cached_ver = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	
	      var stanza = $iq({ type: 'get' }).c('query', { xmlns: Strophe.NS.HC_EMOTICONS, ver: cached_ver });
	
	      return new _promise2.default(function (resolve, reject) {
	        var success = function success(xmpp) {
	          var query = xmpp.getElementsByTagNameNS(Strophe.NS.HC_EMOTICONS, 'query')[0];
	          var ver = query.getAttribute('ver') || '';
	          var path_prefix = query.querySelector('path_prefix').textContent || '';
	          var items = (0, _from2.default)(query.querySelectorAll('item'));
	          var emoticons = items.map(function (item) {
	            return _emoticon2.default.fromXMPP(item);
	          });
	
	          resolve({ ver: ver, path_prefix: path_prefix, emoticons: emoticons });
	        };
	
	        var error = function error(xmpp) {
	          reject(_dalError2.default.fromXMPP(xmpp));
	        };
	
	        _this2.Connection.sendIQ(stanza.tree(), success, error);
	      });
	    }
	  }]);
	  return EmoticonsPlugin;
	}(_abstract_plugin2.default);

	exports.default = EmoticonsPlugin;
	module.exports = exports['default'];

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _from = __webpack_require__(118);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get3 = __webpack_require__(47);
	
	var _get4 = _interopRequireDefault(_get3);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _abstract_plugin = __webpack_require__(217);
	
	var _abstract_plugin2 = _interopRequireDefault(_abstract_plugin);
	
	var _user = __webpack_require__(152);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _room = __webpack_require__(153);
	
	var _room2 = _interopRequireDefault(_room);
	
	var _emoticon = __webpack_require__(155);
	
	var _emoticon2 = _interopRequireDefault(_emoticon);
	
	var _dal = __webpack_require__(144);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	var _constants = __webpack_require__(163);
	
	var _hash = __webpack_require__(241);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var CachePlugin = function (_AbstractPlugin) {
	  (0, _inherits3.default)(CachePlugin, _AbstractPlugin);
	
	  function CachePlugin() {
	    var _Object$getPrototypeO;
	
	    (0, _classCallCheck3.default)(this, CachePlugin);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(CachePlugin)).call.apply(_Object$getPrototypeO, [this].concat(args)));
	
	    _this.disconnectedTimestamp = null;
	    return _this;
	  }
	
	  (0, _createClass3.default)(CachePlugin, [{
	    key: 'init',
	    value: function init() {
	      var _get2;
	
	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	
	      (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(CachePlugin.prototype), 'init', this)).call.apply(_get2, [this].concat(args));
	      Strophe.addNamespace('HC_MUC_ROOM', NS.HC_MUC_ROOM);
	      Strophe.addNamespace('HC_ROSTER_HASH', NS.HC_ROSTER_HASH);
	      Strophe.addNamespace('HC_ROOMS_HASH', NS.HC_ROOMS_HASH);
	      Strophe.addNamespace('HC_EMOTICONS', NS.HC_EMOTICONS);
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'onConnected',
	    value: function onConnected() {
	      this.Connection.addHandler(this.updateCacheFromRosterPush.bind(this), NS.ROSTER, 'iq', 'set');
	      this.Connection.addHandler(this.updateCacheFromRoomPush.bind(this), NS.HC_MUC_ROOM, 'iq', 'set');
	      this.Connection.addHandler(this.updateCacheFromEmoticonPush.bind(this), NS.HC_EMOTICONS, 'iq', 'set');
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'onDisconnected',
	    value: function onDisconnected() {
	      this.disconnectedTimestamp = new Date().getTime();
	    }
	
	    /*
	     * Updates the Cached user list when roster pushes from the server are received.
	     * If there is no cached roster currently, disregard. Pushes should not be
	     * saved as the entire roster.
	     */
	
	  }, {
	    key: 'updateCacheFromRosterPush',
	    value: function updateCacheFromRosterPush(xmpp) {
	      _dal2.default.has(_dal2.default.Keys.ROSTER).then(function (hasRoster) {
	        if (!hasRoster) {
	          return;
	        }
	
	        var query = xmpp.getElementsByTagNameNS(Strophe.NS.ROSTER, 'query')[0],
	            items = query.querySelectorAll('item'),
	            users = (0, _from2.default)(items).map(function (item) {
	          return _user2.default.fromXMPP(item);
	        });
	        return _dal2.default.updateRoster(users);
	      }).catch(_.noop);
	      return true;
	    }
	
	    /*
	     * Updates the cached rooms list when room pushes from the server are received.
	     * If there is no cached rooms list, disregard. Pushes should not be
	     * saved as the entire list.
	     */
	
	  }, {
	    key: 'updateCacheFromRoomPush',
	    value: function updateCacheFromRoomPush(xmpp) {
	      _dal2.default.has(_dal2.default.Keys.ROOMS).then(function (hasRooms) {
	        if (!hasRooms) {
	          return;
	        }
	
	        var query = xmpp.getElementsByTagNameNS(Strophe.NS.HC_MUC_ROOM, 'query')[0],
	            items = query.querySelectorAll('item'),
	            rooms = (0, _from2.default)(items).map(function (item) {
	          return _room2.default.fromXMPPMucRoom(item);
	        });
	        return _dal2.default.updateRooms(rooms);
	      }).catch(_.noop);
	      return true;
	    }
	
	    /*
	     * Updates the cached emoticons list when emoticon pushes from the server are received.
	     * If there is no cached emoticons list, disregard. Pushes should not be
	     * saved as the entire list.
	     */
	
	  }, {
	    key: 'updateCacheFromEmoticonPush',
	    value: function updateCacheFromEmoticonPush(xmpp) {
	      _dal2.default.has(_dal2.default.Keys.EMOTICONS).then(function (hasEmoticons) {
	        if (!hasEmoticons) {
	          return;
	        }
	
	        var query = xmpp.getElementsByTagNameNS(Strophe.NS.HC_EMOTICONS, 'query')[0],
	            items = query.querySelectorAll('item'),
	            emoticons = (0, _from2.default)(items).map(function (item) {
	          return _emoticon2.default.fromXMPP(item);
	        });
	
	        return _dal2.default.updateEmoticons({
	          type: 'set',
	          query: {
	            item: emoticons
	          }
	        });
	      }).catch(_.noop);
	      return true;
	    }
	
	    /**
	     * Determines if the `disconnected_time` is within the threshold that should
	     * trigger syncing-on-reconnection
	     *
	     * @method isReconnectedWithinSyncThreshold
	     * @returns {boolean}
	     */
	
	  }, {
	    key: 'isReconnectedWithinSyncThreshold',
	    value: function isReconnectedWithinSyncThreshold() {
	      var result = false,
	          time_since_disconnected = void 0;
	
	      if (_.isFinite(this.disconnectedTimestamp)) {
	        time_since_disconnected = Date.now() - this.disconnectedTimestamp;
	        result = time_since_disconnected < _constants.RECONNECT_SYNC_THRESHOLD;
	      }
	
	      return result;
	    }
	
	    /**
	     * Checks to see if the provided version of the roster is in sync with
	     * the server. If the provided cache is empty, resolves with false.
	     * If not, will request the server hash value via xmpp and compare it
	     * with the calculated hash value, and resolve with whether they match.
	     *
	     * @method isResourceInSync
	     * @param {string} resource - either DAL.Cache.Keys.ROSTER or ROOMS
	     * @param {string} cache - Roster or Rooms cache
	     * @returns {Promise<boolean>}
	     */
	
	  }, {
	    key: 'isResourceInSync',
	    value: function isResourceInSync(resource, cache) {
	      if ((0, _keys2.default)(cache).length === 0) {
	        return _promise2.default.resolve(false);
	      }
	      return this.getResourceHash(resource).then(function (serverHash) {
	
	        var resourceList = (0, _keys2.default)(cache).reduce(function (result, id) {
	          if (!(cache[id].is_deleted || cache[id].is_archived)) {
	            result.push({ id: id, version: cache[id].version });
	          }
	          return result;
	        }, []);
	
	        return (0, _hash.create)(resourceList) === serverHash;
	      });
	    }
	
	    /**
	     * Get the server version-hash of the roster or rooms list.
	     * Returns a Promise that will resolve with either the hash
	     * or null if an error occurred. Will not reject.
	     *
	     * <iq xmlns='jabber:client'
	     *   to='1_4@chat.devvm.hipchat.com/web||proxy|devvm.hipchat.com|5222'
	     *   type='result'
	     *   id='551ac781-4175-44a1-9fad-f5d5396b2244:sendIQ'>
	     *     <query xmlns='http://hipchat.com/protocol/users#hash'>4118399e0e44423d602c8a804dddd672</query>
	     * </iq>
	     *
	     * @method getResourceHash
	     * @param {string} resource - 'roster' or 'rooms-wo-archived'
	     * @returns {Promise<hash|null>}
	     */
	
	  }, {
	    key: 'getResourceHash',
	    value: function getResourceHash(resource) {
	      var _this2 = this;
	
	      var xmlns = resource === _dal2.default.Keys.ROSTER ? Strophe.NS.HC_ROSTER_HASH : Strophe.NS.HC_ROOMS_HASH,
	          type = 'get',
	          use_full_list = true,
	          stanza = $iq({ type: type }).c('query', { xmlns: xmlns, use_full_list: use_full_list });
	
	      return new _promise2.default(function (resolve) {
	        var success = function success(xmpp) {
	          var query = xmpp.getElementsByTagNameNS(xmlns, 'query')[0];
	          resolve(query ? query.textContent.trim() : null);
	        };
	
	        var error = function error() {
	          resolve(null);
	        };
	
	        _this2.Connection.sendIQ(stanza.tree(), success, error);
	      });
	    }
	  }]);
	  return CachePlugin;
	}(_abstract_plugin2.default);

	exports.default = CachePlugin;
	module.exports = exports['default'];

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var md5 = __webpack_require__(242);
	
	/**
	 * Serializes the given list of `users`. The serialization logic is:
	 * - Sort users on the uniqueId portion of the JID
	 * - Map each user to "<user_id>:<version>"
	 * - Join with commas
	 *
	 * @param {array} users The users to serialize
	 * @returns {string} The serialized users string
	 */
	var serialize = function serialize(items) {
	  var list = items.concat().filter(function (item) {
	    return 'id' in item && 'version' in item;
	  }).sort(function (a, b) {
	    var aId = Number(a.id),
	        bId = Number(b.id);
	
	    if (aId < bId) {
	      return -1;
	    } else if (bId < aId) {
	      return 1;
	    }
	    return 0;
	  }).map(function (item) {
	    return item.id + ':' + item.version;
	  });
	
	  return list.join(',');
	};
	
	/**
	 * Serializes and hashes the given list of `users`.
	 *
	 * @param {array} users The users to hash
	 * @returns {string} The hashed users string
	 */
	var create = function create(items) {
	  if (!Array.isArray(items)) {
	    return '';
	  }
	  return md5(serialize(items));
	};
	
	module.exports = {
	  create: create,
	  serialize: serialize
	};

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * JavaScript MD5 1.0.1
	 * https://github.com/blueimp/JavaScript-MD5
	 *
	 * Copyright 2011, Sebastian Tschan
	 * https://blueimp.net
	 *
	 * Licensed under the MIT license:
	 * http://www.opensource.org/licenses/MIT
	 * 
	 * Based on
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	/*jslint bitwise: true */
	/*global unescape, define */
	
	(function ($) {
	    'use strict';
	
	    /*
	    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	    * to work around bugs in some JS interpreters.
	    */
	    function safe_add(x, y) {
	        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
	            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	        return (msw << 16) | (lsw & 0xFFFF);
	    }
	
	    /*
	    * Bitwise rotate a 32-bit number to the left.
	    */
	    function bit_rol(num, cnt) {
	        return (num << cnt) | (num >>> (32 - cnt));
	    }
	
	    /*
	    * These functions implement the four basic operations the algorithm uses.
	    */
	    function md5_cmn(q, a, b, x, s, t) {
	        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
	    }
	    function md5_ff(a, b, c, d, x, s, t) {
	        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	    }
	    function md5_gg(a, b, c, d, x, s, t) {
	        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	    }
	    function md5_hh(a, b, c, d, x, s, t) {
	        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	    }
	    function md5_ii(a, b, c, d, x, s, t) {
	        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	    }
	
	    /*
	    * Calculate the MD5 of an array of little-endian words, and a bit length.
	    */
	    function binl_md5(x, len) {
	        /* append padding */
	        x[len >> 5] |= 0x80 << (len % 32);
	        x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	        var i, olda, oldb, oldc, oldd,
	            a =  1732584193,
	            b = -271733879,
	            c = -1732584194,
	            d =  271733878;
	
	        for (i = 0; i < x.length; i += 16) {
	            olda = a;
	            oldb = b;
	            oldc = c;
	            oldd = d;
	
	            a = md5_ff(a, b, c, d, x[i],       7, -680876936);
	            d = md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
	            c = md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
	            b = md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
	            a = md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
	            d = md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
	            c = md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
	            b = md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
	            a = md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
	            d = md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
	            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
	            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
	            a = md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
	            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
	            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
	            b = md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);
	
	            a = md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
	            d = md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
	            c = md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
	            b = md5_gg(b, c, d, a, x[i],      20, -373897302);
	            a = md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
	            d = md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
	            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
	            b = md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
	            a = md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
	            d = md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
	            c = md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
	            b = md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
	            a = md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
	            d = md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
	            c = md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
	            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
	
	            a = md5_hh(a, b, c, d, x[i +  5],  4, -378558);
	            d = md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
	            c = md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
	            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
	            a = md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
	            d = md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
	            c = md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
	            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
	            a = md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
	            d = md5_hh(d, a, b, c, x[i],      11, -358537222);
	            c = md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
	            b = md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
	            a = md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
	            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
	            c = md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
	            b = md5_hh(b, c, d, a, x[i +  2], 23, -995338651);
	
	            a = md5_ii(a, b, c, d, x[i],       6, -198630844);
	            d = md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
	            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
	            b = md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
	            a = md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
	            d = md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
	            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
	            b = md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
	            a = md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
	            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
	            c = md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
	            b = md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
	            a = md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
	            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
	            c = md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
	            b = md5_ii(b, c, d, a, x[i +  9], 21, -343485551);
	
	            a = safe_add(a, olda);
	            b = safe_add(b, oldb);
	            c = safe_add(c, oldc);
	            d = safe_add(d, oldd);
	        }
	        return [a, b, c, d];
	    }
	
	    /*
	    * Convert an array of little-endian words to a string
	    */
	    function binl2rstr(input) {
	        var i,
	            output = '';
	        for (i = 0; i < input.length * 32; i += 8) {
	            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
	        }
	        return output;
	    }
	
	    /*
	    * Convert a raw string to an array of little-endian words
	    * Characters >255 have their high-byte silently ignored.
	    */
	    function rstr2binl(input) {
	        var i,
	            output = [];
	        output[(input.length >> 2) - 1] = undefined;
	        for (i = 0; i < output.length; i += 1) {
	            output[i] = 0;
	        }
	        for (i = 0; i < input.length * 8; i += 8) {
	            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
	        }
	        return output;
	    }
	
	    /*
	    * Calculate the MD5 of a raw string
	    */
	    function rstr_md5(s) {
	        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
	    }
	
	    /*
	    * Calculate the HMAC-MD5, of a key and some data (raw strings)
	    */
	    function rstr_hmac_md5(key, data) {
	        var i,
	            bkey = rstr2binl(key),
	            ipad = [],
	            opad = [],
	            hash;
	        ipad[15] = opad[15] = undefined;
	        if (bkey.length > 16) {
	            bkey = binl_md5(bkey, key.length * 8);
	        }
	        for (i = 0; i < 16; i += 1) {
	            ipad[i] = bkey[i] ^ 0x36363636;
	            opad[i] = bkey[i] ^ 0x5C5C5C5C;
	        }
	        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
	        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
	    }
	
	    /*
	    * Convert a raw string to a hex string
	    */
	    function rstr2hex(input) {
	        var hex_tab = '0123456789abcdef',
	            output = '',
	            x,
	            i;
	        for (i = 0; i < input.length; i += 1) {
	            x = input.charCodeAt(i);
	            output += hex_tab.charAt((x >>> 4) & 0x0F) +
	                hex_tab.charAt(x & 0x0F);
	        }
	        return output;
	    }
	
	    /*
	    * Encode a string as utf-8
	    */
	    function str2rstr_utf8(input) {
	        return unescape(encodeURIComponent(input));
	    }
	
	    /*
	    * Take string arguments and return either raw or hex encoded strings
	    */
	    function raw_md5(s) {
	        return rstr_md5(str2rstr_utf8(s));
	    }
	    function hex_md5(s) {
	        return rstr2hex(raw_md5(s));
	    }
	    function raw_hmac_md5(k, d) {
	        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
	    }
	    function hex_hmac_md5(k, d) {
	        return rstr2hex(raw_hmac_md5(k, d));
	    }
	
	    function md5(string, key, raw) {
	        if (!key) {
	            if (!raw) {
	                return hex_md5(string);
	            }
	            return raw_md5(string);
	        }
	        if (!raw) {
	            return hex_hmac_md5(key, string);
	        }
	        return raw_hmac_md5(key, string);
	    }
	
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return md5;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        $.md5 = md5;
	    }
	}(this));


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _readstate_request = __webpack_require__(244);
	
	var _readstate_request2 = _interopRequireDefault(_readstate_request);
	
	var _readstate_error = __webpack_require__(245);
	
	var _readstate_error2 = _interopRequireDefault(_readstate_error);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _network_status_helper = __webpack_require__(218);
	
	var _network_status_helper2 = _interopRequireDefault(_network_status_helper);
	
	var _constants = __webpack_require__(163);
	
	var Constants = _interopRequireWildcard(_constants);
	
	var _dal = __webpack_require__(144);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ReadState = function () {
	  function ReadState() {
	    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    (0, _classCallCheck3.default)(this, ReadState);
	
	    this.request = new _readstate_request2.default();
	
	    // set this to a valid log level to enable logging
	    this.logLevel = null;
	
	    this.queued = false;
	    this.waiting = false;
	    this.disabled = false;
	    this.fetched = false;
	
	    this.timer = null;
	    this.backoff = Constants.READSTATE_DEFAULT_BACKOFF;
	    this.retryCount = 0;
	    this.api_token = null;
	
	    this.fetchCallback = config.fetchCallback || _.noop;
	    this.patchCallback = config.patchCallback || _.noop;
	
	    this.state = {
	      server: null,
	      client: {},
	      inflight: {}
	    };
	
	    this.debouncedPatch = _.debounce(this.tryPatch, Constants.READSTATE_UPDATE_DEBOUNCE).bind(this);
	  }
	
	  (0, _createClass3.default)(ReadState, [{
	    key: 'log',
	    value: function log() {
	      if (_logger2.default.levels.indexOf(this.logLevel) !== -1) {
	        _logger2.default[this.logLevel].apply(_logger2.default, arguments);
	      }
	    }
	  }, {
	    key: 'loadStorage',
	    value: function loadStorage() {
	      var _this = this;
	
	      this.log('[ReadState] loadStorage');
	      return _dal2.default.get(_dal2.default.Keys.READSTATE).then(function (storedClientState) {
	        if (_.isPlainObject(storedClientState) && !_.isEmpty(storedClientState)) {
	          _this.state.client = storedClientState;
	          _dal2.default.unset(_dal2.default.Keys.READSTATE);
	          _this.queued = true;
	        }
	      });
	    }
	  }, {
	    key: 'fetch',
	    value: function fetch() {
	      this.log('[ReadState] fetch');
	
	      this.clearTimer();
	
	      this.state.server = null;
	      this.fetched = false;
	      this.tryFetch();
	    }
	  }, {
	    key: 'update',
	    value: function update(data) {
	      if (!_utils2.default.jid.is_chat(data.jid)) {
	        return false;
	      }
	      this.log('[ReadState] update', data);
	
	      this.state.client[data.jid] = {
	        op: 'add',
	        mid: data.mid,
	        timestamp: data.timestamp
	      };
	      _dal2.default.set(_dal2.default.Keys.READSTATE, this.state.client);
	
	      if (this.fetched) {
	        this.debouncedPatch();
	      }
	    }
	  }, {
	    key: 'remove',
	    value: function remove(data) {
	      if (!_utils2.default.jid.is_chat(data.jid)) {
	        return false;
	      }
	      this.log('[ReadState] remove', data);
	
	      this.state.client[data.jid] = {
	        op: 'remove'
	      };
	      _dal2.default.set(_dal2.default.Keys.READSTATE, this.state.client);
	
	      if (this.fetched) {
	        this.debouncedPatch();
	      }
	    }
	  }, {
	    key: 'retry',
	    value: function retry() {
	      this.log('[ReadState] retry');
	
	      this.disabled = false;
	      this.dequeue();
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this.log('[ReadState] reset');
	
	      this.clearTimer();
	
	      this.queued = false;
	      this.state.client = {};
	      _dal2.default.unset(_dal2.default.Keys.READSTATE);
	    }
	  }, {
	    key: 'tryFetch',
	    value: function tryFetch() {
	      this.log('[ReadState] tryFetch');
	
	      if (!_network_status_helper2.default.isOnline()) {
	        this.log('[ReadState] Aborting fetch', { 'isOnline': _network_status_helper2.default.isOnline() });
	        this.fetchCallback(_readstate_error2.default.OFFLINE, null);
	        this.enqueue(this.backoff);
	        return;
	      } else if (this.waiting) {
	        this.log('[ReadState] Aborting fetch', { 'waiting': this.waiting });
	        return;
	      }
	
	      this.waiting = true;
	      this.disabled = false;
	
	      this.api_token = _configuration_store2.default.get('oauth_token');
	
	      if (this.queued) {
	        this.request.get(this.handleRefetchResponse.bind(this), false);
	      } else {
	        this.request.get(this.handleGetResponse.bind(this), true);
	      }
	    }
	  }, {
	    key: 'tryPatch',
	    value: function tryPatch() {
	      this.log('[ReadState] tryPatch');
	
	      if (!_network_status_helper2.default.isOnline()) {
	        this.log('[ReadState] Aborting patch', { 'isOnline': _network_status_helper2.default.isOnline() });
	        this.patchCallback(_readstate_error2.default.OFFLINE, null);
	        return;
	      } else if (this.waiting) {
	        this.log('[ReadState] Aborting patch', { 'waiting': this.waiting });
	        this.queued = true;
	        return;
	      } else if (!this.state.server) {
	        this.log('[ReadState] Aborting patch', { 'serverState': this.state.server });
	        this.queued = true;
	        this.fetch();
	        return;
	      } else if (this.disabled) {
	        this.log('[ReadState] Aborting patch', { 'disabled': this.disabled });
	        return;
	      }
	
	      this.patch(this.state.client);
	    }
	  }, {
	    key: 'patch',
	    value: function patch(data) {
	      var withCounts = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      var patch_data = this.buildPatchBody(data);
	
	      if (patch_data.length === 0) {
	        this.log('[ReadState] Aborting patch', {
	          'patch_data': patch_data,
	          'withCounts': withCounts
	        });
	        this.queued = false;
	        if (withCounts) {
	          this.fetch();
	          this.waiting = true;
	        }
	        return;
	      }
	
	      this.log('[ReadState] Sending patch data', patch_data);
	
	      this.waiting = true;
	      this.queued = false;
	
	      this.api_token = _configuration_store2.default.get('oauth_token');
	
	      _dal2.default.unset(_dal2.default.Keys.READSTATE);
	      this.state.inflight = _.clone(data);
	      this.state.client = {};
	
	      this.request.patch(patch_data, this.handlePatchResponse.bind(this), withCounts);
	    }
	  }, {
	    key: 'buildPatchBody',
	    value: function buildPatchBody(state) {
	      var _this2 = this;
	
	      var body = [];
	
	      _.forOwn(state, function (val, key) {
	        var obj = {
	          op: val.op,
	          path: '/' + key
	        };
	
	        if (val.op === 'add') {
	          obj.value = {
	            mid: val.mid || Constants.READSTATE_NULL_MID,
	            timestamp: val.timestamp ? val.timestamp.toFixed(6) : Constants.READSTATE_NULL_TS
	          };
	        }
	
	        var server_ts = _.get(_this2.state.server[key], 'timestamp', 0);
	        if (val.op === 'remove' || !server_ts || val.timestamp && server_ts < val.timestamp) {
	          body.push(obj);
	        }
	      });
	
	      return body;
	    }
	  }, {
	    key: 'handleResponse',
	    value: function handleResponse(err, res) {
	      this.disabled = false;
	      this.waiting = false;
	
	      this.handleError(err);
	      this.updateBackoffInterval(res, err);
	      this.handleBackoff();
	    }
	  }, {
	    key: 'handleError',
	    value: function handleError(err) {
	      var _this3 = this,
	          _errorHandlers;
	
	      if (!err) {
	        this.retryCount = 0;
	        return false;
	      }
	
	      this.queued = true;
	
	      var errorHandlers = (_errorHandlers = {}, (0, _defineProperty3.default)(_errorHandlers, _readstate_error2.default.UNAUTHORIZED, function () {
	        _this3.disabled = true;
	        if (_this3.api_token !== _configuration_store2.default.get('oauth_token')) {
	          _this3.retry();
	        } else {
	          _configuration_store2.default.once('change:oauth_token', _this3.retry.bind(_this3));
	        }
	      }), (0, _defineProperty3.default)(_errorHandlers, _readstate_error2.default.BAD_REQUEST, function () {
	        _this3.disabled = true;
	        _this3.reset();
	      }), (0, _defineProperty3.default)(_errorHandlers, _readstate_error2.default.DISABLED, function () {
	        _this3.disabled = true;
	      }), (0, _defineProperty3.default)(_errorHandlers, _readstate_error2.default.RATE_LIMITED, function () {
	        _this3.retryCount++;
	      }), (0, _defineProperty3.default)(_errorHandlers, _readstate_error2.default.UNAVAILABLE, function () {
	        _this3.retryCount++;
	      }), _errorHandlers);
	
	      if (errorHandlers[err]) {
	        this.log('[ReadState] handleError: %s', err);
	        errorHandlers[err]();
	      }
	    }
	  }, {
	    key: 'handleServerData',
	    value: function handleServerData(body) {
	      body = body && Array.isArray(body.items) ? body.items : [];
	      this.resetServerState(body);
	      this.fetched = true;
	      return body;
	    }
	  }, {
	    key: 'handleGetResponse',
	    value: function handleGetResponse(err, body, res) {
	      var data = null;
	
	      this.handleResponse(err, res);
	      if (!err) {
	        data = this.handleServerData(body);
	      }
	      this.fetchCallback(err, data);
	    }
	  }, {
	    key: 'handleRefetchResponse',
	    value: function handleRefetchResponse(err, body, res) {
	      this.handleResponse(err, res);
	
	      if (err) {
	        return this.fetchCallback(err, null);
	      }
	
	      this.handleServerData(body);
	      this.patch(this.state.client, true);
	    }
	  }, {
	    key: 'handlePatchResponse',
	    value: function handlePatchResponse(err, body, res) {
	      this.handleResponse(err, res);
	
	      if (err) {
	        this.reapplyInflightData();
	      } else {
	        this.updateServerState();
	      }
	
	      if (body) {
	        var data = this.handleServerData(body);
	        this.fetchCallback(err, data);
	      }
	
	      this.patchCallback(err, body);
	    }
	  }, {
	    key: 'updateBackoffInterval',
	    value: function updateBackoffInterval(res, err) {
	      var backoff = res.backoff ? res.backoff * 1000 : 0;
	
	      if (err === _readstate_error2.default.RATE_LIMITED) {
	        backoff = this.handleRateLimitReset(res.rateLimitReset, res.serverTime, backoff);
	      } else if (err === _readstate_error2.default.UNAVAILABLE) {
	        backoff = this.jitterBackoff(backoff);
	        backoff = Math.min(backoff, Constants.READSTATE_MAX_BACKOFF);
	      }
	
	      if (backoff && backoff !== this.backoff) {
	        this.log('[ReadState] Changing backoff interval. New value: %s', backoff);
	        this.backoff = backoff;
	      }
	    }
	  }, {
	    key: 'handleRateLimitReset',
	    value: function handleRateLimitReset(resetTime, serverTime, backoff) {
	      var nowTime = serverTime ? serverTime : Date.now(),
	          diff = resetTime + 5 - nowTime;
	
	      return diff > 0 ? diff * 1000 : this.jitterBackoff(backoff);
	    }
	  }, {
	    key: 'jitterBackoff',
	    value: function jitterBackoff(backoff) {
	      var max = Constants.READSTATE_MAX_BACKOFF,
	          base = Constants.READSTATE_DEFAULT_BACKOFF,
	          factor = Constants.READSTATE_BACKOFF_FACTOR;
	
	      return _utils2.default.decorrelatedJitter(max, backoff || base, this.backoff, factor);
	    }
	  }, {
	    key: 'handleBackoff',
	    value: function handleBackoff() {
	      this.log('[ReadState] handleBackoff', {
	        backoff: this.backoff,
	        disabled: this.disabled
	      });
	      this.clearTimer();
	      if (this.backoff && !this.disabled) {
	        this.enqueue(this.backoff);
	      }
	    }
	  }, {
	    key: 'enqueue',
	    value: function enqueue(backoff) {
	      this.waiting = true;
	      this.timer = setTimeout(this.dequeue.bind(this), backoff);
	    }
	  }, {
	    key: 'dequeue',
	    value: function dequeue() {
	      this.log('[ReadState] dequeue');
	      this.clearTimer();
	      if (!this.state.server || !this.fetched) {
	        this.fetch();
	      } else if (this.queued) {
	        this.queued = false;
	        this.tryPatch(false);
	      }
	    }
	  }, {
	    key: 'clearTimer',
	    value: function clearTimer() {
	      if (this.timer) {
	        clearTimeout(this.timer);
	        this.timer = null;
	        this.waiting = false;
	      }
	    }
	  }, {
	    key: 'resetServerState',
	    value: function resetServerState(data) {
	      var _this4 = this;
	
	      this.state.server = {};
	
	      if (!Array.isArray(data)) {
	        return;
	      }
	
	      data.forEach(function (chat) {
	        if (chat.xmppJid) {
	          _this4.state.server[chat.xmppJid] = {
	            mid: chat.mid,
	            timestamp: Number(chat.timestamp)
	          };
	        }
	      });
	    }
	  }, {
	    key: 'reapplyInflightData',
	    value: function reapplyInflightData() {
	      var _this5 = this;
	
	      _.forOwn(this.state.inflight, function (val, key) {
	        if (!_this5.state.client[key] || val.timestamp > _this5.state.client[key].timestamp) {
	          _this5.state.client[key] = val;
	        }
	      });
	
	      this.state.inflight = {};
	      _dal2.default.set(_dal2.default.Keys.READSTATE, this.state.client);
	    }
	  }, {
	    key: 'updateServerState',
	    value: function updateServerState() {
	      var _this6 = this;
	
	      if (!this.state.server) {
	        this.state.server = {};
	      }
	
	      _.forOwn(this.state.inflight, function (val, key) {
	        if (_this6.state.server[key] && val.op === 'remove') {
	          delete _this6.state.server[key];
	        } else if (!_this6.state.server[key] || val.timestamp > Number(_this6.state.server[key].timestamp)) {
	          _this6.state.server[key] = val;
	        }
	      });
	
	      this.state.inflight = {};
	    }
	  }]);
	  return ReadState;
	}();
	
	exports.default = ReadState;
	module.exports = exports['default'];

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _readstate_error = __webpack_require__(245);
	
	var _readstate_error2 = _interopRequireDefault(_readstate_error);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ReadStateRequest = function () {
	  function ReadStateRequest() {
	    (0, _classCallCheck3.default)(this, ReadStateRequest);
	  }
	
	  (0, _createClass3.default)(ReadStateRequest, [{
	    key: 'request',
	
	
	    /**
	     * Handles making the various API requests for readstate.
	     * @param {String} HTTP request method
	     * @param {String} API request URL
	     * @param {Object|null} request body
	     * @param {Function} callback function
	     * @param {Object} XMLHttpRequest object (not used, passed-in to facilitate testing)
	     * @return {Object} XMLHttpRequest object
	     */
	    value: function request(method, url) {
	      var data = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	      var _this = this;
	
	      var callback = arguments.length <= 3 || arguments[3] === undefined ? function () {} : arguments[3];
	      var xhr = arguments.length <= 4 || arguments[4] === undefined ? new XMLHttpRequest() : arguments[4];
	
	      if (!method || !url) {
	        return;
	      }
	
	      var handler = function handler(evt) {
	        var req = evt.target;
	
	        var _handleResponse = _this.handleResponse(req);
	
	        var err = _handleResponse.err;
	        var body = _handleResponse.body;
	        var res = _handleResponse.res;
	
	
	        if (typeof callback === 'function') {
	          callback(err, body, res);
	        }
	      };
	
	      xhr.open(method, url);
	      xhr.setRequestHeader('Authorization', 'Bearer ' + _configuration_store2.default.getOAuthToken());
	      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	
	      if (method.toUpperCase() === 'PATCH') {
	        xhr.setRequestHeader('Content-Type', 'application/json-patch+json');
	      } else {
	        xhr.setRequestHeader('Content-Type', 'application/json');
	      }
	
	      xhr.addEventListener('load', handler);
	      xhr.addEventListener('error', handler);
	      xhr.addEventListener('abort', handler);
	      xhr.addEventListener('timeout', handler);
	
	      if (data) {
	        data = (0, _stringify2.default)(data);
	      }
	
	      xhr.send(data);
	      return xhr;
	    }
	  }, {
	    key: 'getUrl',
	    value: function getUrl(withCounts) {
	      var host = _configuration_store2.default.get('api_host'),
	          query = withCounts ? '?expand=items.unreadCount' : '';
	
	      return 'https://' + host + '/v2/readstate' + query;
	    }
	
	    /**
	     * Gets the user's readstate data from the Coral v2 API.
	     * @param {Function} callback function
	     * @param {Boolean} return unread counts
	     * @return {Object} XMLHttpRequest object
	     */
	
	  }, {
	    key: 'get',
	    value: function get(callback) {
	      var withCounts = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	      var url = this.getUrl(withCounts);
	      _logger2.default.log('[ReadStateRequest] Initiating get request', url);
	      return this.request('GET', url, null, callback);
	    }
	
	    /**
	     * Updates the user's readstate data in the Coral v2 API.
	     * @param {Object} readstate patch object
	     * @param {Function} callback function
	     * @param {Boolean} return unread counts
	     * @return {Object} XMLHttpRequest object
	     */
	
	  }, {
	    key: 'patch',
	    value: function patch(data, callback) {
	      var withCounts = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	      var url = this.getUrl(withCounts);
	      return this.request('PATCH', url, data, callback);
	    }
	
	    /**
	     * Processes the `xhr`'s status and response. Returns an object
	     * with `err` and `body` properties which are populated as needed.
	     * @param {Object} XMLHttpRequest object
	     * @return { err: String, body: Object|null, res: Object }
	     */
	
	  }, {
	    key: 'handleResponse',
	    value: function handleResponse(xhr) {
	      var err = _readstate_error2.default.handleRequestErrors(xhr.status),
	          serverDate = xhr.getResponseHeader('Date'),
	          serverFormat = 'ddd, D MMM YYYY H:mm:ss',
	          res = {
	        status: xhr.status,
	        backoff: xhr.getResponseHeader('X-Backoff'),
	        rateLimitReset: Number(xhr.getResponseHeader('X-RateLimit-Reset')),
	        serverTime: serverDate ? Number(_moment2.default.utc(serverDate, serverFormat).unix()) : null
	      },
	          body = void 0;
	
	      // Response may not be valid JSON
	      try {
	        body = JSON.parse(xhr.responseText);
	      } catch (e) {
	        body = null;
	      }
	
	      return { err: err, body: body, res: res };
	    }
	  }]);
	  return ReadStateRequest;
	}();
	
	exports.default = ReadStateRequest;
	module.exports = exports['default'];

/***/ },
/* 245 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var ReadStateError = {
	
	  // The browser or native wrapper is (or at least think it is) offline.
	  OFFLINE: 'offline',
	
	  // HTTP 401 - User is not authorized to make requests to the API.
	  // The client should retry the request once a new oauth token is received.
	  UNAUTHORIZED: 'unauthorized',
	
	  // HTTP 404 - The readstate feature is not enabled for the user's group.
	  // The client should stop trying to update readstate until reconnect.
	  DISABLED: 'disabled',
	
	  // HTTP 429 - The client has made too many API requests in a set timeframe.
	  // The client should schedule a retry for when the rate limit gets reset.
	  RATE_LIMITED: 'rateLimited',
	
	  // HTTP 4XX - The client is making a bad request.
	  // The client is attempting to send data that does not conform to the
	  // server spec, and should stop trying to update readstate.
	  BAD_REQUEST: 'badRequest',
	
	  // HTTP 0 - Request was unsuccessful because the request timed out or
	  // because the browser might be offline.
	  // HTTP 5XX - Server is not accepting readstate updates at this time.
	  // This may be due to too much load. So the client should continue
	  // to retry this request, but backoff up to a maximum.
	  UNAVAILABLE: 'unavailable',
	
	  handleRequestErrors: function handleRequestErrors(status) {
	    var err = null;
	
	    if (status === 401) {
	      return ReadStateError.UNAUTHORIZED;
	    } else if (status === 404) {
	      return ReadStateError.DISABLED;
	    } else if (status === 429) {
	      return ReadStateError.RATE_LIMITED;
	    } else if (status >= 400 && status < 500) {
	      return ReadStateError.BAD_REQUEST;
	    } else if (!status || status >= 500) {
	      return ReadStateError.UNAVAILABLE;
	    }
	
	    return err;
	  }
	};
	
	exports.default = ReadStateError;
	module.exports = exports['default'];

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _typeof2 = __webpack_require__(23);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _uploader = __webpack_require__(247);
	
	var _uploader2 = _interopRequireDefault(_uploader);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _versionInfo = __webpack_require__(141);
	
	var _versionInfo2 = _interopRequireDefault(_versionInfo);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _uri_template = __webpack_require__(170);
	
	var _uri_template2 = _interopRequireDefault(_uri_template);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*global escape*/
	
	
	var MAX_URL_LENGTH = 2048;
	var CONNECT_API_VERSION = _versionInfo2.default.connect_api_version;
	
	var HCApiClient = function () {
	  function HCApiClient() {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, HCApiClient);
	
	    this.room = {
	
	      /**
	       * @deprecated
	       */
	      recent_history: function recent_history(data, callback) {
	        _this.request('GET', 'room/' + data.path.identifier + '/history/latest', data.params, callback);
	      },
	
	      /**
	       * Looks to be unused
	       * @deprecated
	       */
	      invite_users: function invite_users(data, callback) {
	        _this.request('POST', 'room/' + data.path.identifier + '/invite/' + data.user_id, data.params, callback);
	      },
	
	      /**
	       * @deprecated
	       */
	      update_room: function update_room(data, callback) {
	        _this.request('PUT', 'room/' + data.path.identifier, data.params, callback, true);
	      },
	
	      /**
	       * @deprecated
	       */
	      share_file: function share_file(data) {
	        data.params.token = _configuration_store2.default.getOAuthToken();
	        return _uploader2.default.uploadFile(_this.getUrl('room/' + data.path.identifier + '/share/file'), data.params);
	      }
	    };
	
	    this.user = {
	
	      /**
	       * @deprecated
	       */
	      recent_history: function recent_history(data, callback) {
	        _this.request('GET', 'user/' + data.path.identifier + '/history/latest', data.params, callback);
	      },
	
	      /**
	       * @deprecated
	       */
	      share_file: function share_file(data) {
	        data.params.token = _configuration_store2.default.getOAuthToken();
	        return _uploader2.default.uploadFile(_this.getUrl('user/' + data.path.identifier + '/share/file'), data.params);
	      },
	
	      /**
	       * @deprecated
	       */
	      send_private_message: function send_private_message(data) {
	        _this.request('POST', 'user/' + data.path.identifier + '/message', data.params, _.noop, true);
	      }
	    };
	
	    this.integrations = {
	
	      /**
	       * @deprecated
	       */
	      sync: function sync(data, callback) {
	
	        function createSyncBody(integrations, room_ids) {
	          var req = {
	            'knownIntegrations': {},
	            'connectApiVersion': CONNECT_API_VERSION
	          };
	
	          _.each(room_ids || [], function (room_id) {
	            req.knownIntegrations[room_id] = {};
	          });
	
	          // for each room
	          _.each(integrations, function (addons, roomId) {
	            // Only sync rooms we are actually wanting to sync, not for all rooms in store
	            if (!_.includes(room_ids, roomId)) {
	              return;
	            }
	
	            req.knownIntegrations[roomId] = {};
	
	            // for each add-on in the room
	            _.each(addons, function (addon) {
	              req.knownIntegrations[roomId][addon.addon_key] = addon.version;
	            });
	          });
	          return req;
	        }
	
	        var str_room_ids = _.map(data.room_ids, function (room_id) {
	          return String(room_id);
	        });
	        var body = createSyncBody(data.integrations, str_room_ids);
	
	        _this.request('POST', 'addon/sync', body, callback, true);
	      },
	
	      /**
	       * @deprecated
	       */
	      getSignedUrl: function getSignedUrl(requestData, parameters, callback) {
	        _this.integrations._signedUrl(requestData, parameters, callback);
	      },
	
	      /**
	       * @deprecated
	       */
	      requestWithSignedUrl: function requestWithSignedUrl(requestData, parameters, callback) {
	        _this.integrations._signedUrl(requestData, parameters, function (data, result) {
	          var location = data ? data.location : null;
	          if (!location) {
	            callback(data, result);
	          } else {
	            location = _utils2.default.addConnectApiVersionToUrl(location);
	            _this.requestUrl('GET', location, null, null, callback, null, data.timeout);
	          }
	        });
	      },
	
	      fetchAllGlancesForRoom: function fetchAllGlancesForRoom(requestData, callback) {
	        var resultPromise = new _promise2.default(function (resolve, reject) {
	          _this.integrations._allSignedGlances(requestData, function (data, result) {
	            if (!data || data.error || result.status >= 300) {
	              var error = data && data.error ? data.error : '(status code: ' + result.status + ')';
	              reject(error);
	            } else {
	              var promises = _.map(data, function (glance_result, key) {
	                var promise = new _promise2.default(function (mapResolve, mapReject) {
	                  if (!glance_result.success) {
	                    _logger2.default.warn('[HC-Integrations]', 'Failed to fetch signed url for Glance ' + key);
	                    var path = null;
	                    mapResolve({ path: path, data: data, result: result });
	                  } else {
	                    (function () {
	                      var glance_url = _utils2.default.addConnectApiVersionToUrl(glance_result['url']);
	                      _this.requestUrl('GET', glance_url, null, null, function (req_data, req_result) {
	                        mapResolve({
	                          path: glance_url,
	                          data: req_data,
	                          result: req_result
	                        });
	                      });
	                    })();
	                  }
	                });
	                return { promise: promise, key: key };
	              });
	
	              resolve(promises);
	            }
	          });
	        });
	
	        callback(resultPromise);
	      },
	
	      _signedUrl: function _signedUrl(data, parameters, callback) {
	        var ext = data.extension;
	        var attribute = data.attribute || "url";
	
	        var usedParameters = {};
	        var url = data.extension[attribute];
	        if (url) {
	          var template = new _uri_template2.default(url);
	          usedParameters = template.getTemplateValuesFromParameters(parameters);
	        }
	
	        var mod_type = attribute + '@' + ext.type;
	        var path = 'addon/signed-url/' + data.room_id + '/' + ext.addon_key + '/' + mod_type + '/' + ext.key + '/' + ext.addon_timestamp;
	        _this.request('GET', path, usedParameters, callback, null, data.timeout);
	      },
	
	      _allSignedGlances: function _allSignedGlances(data, callback) {
	        _this.request('GET', 'addon/signed-urls/' + data.room_id + '/glances', {}, callback, null, data.timeout);
	      }
	    };
	  }
	
	  (0, _createClass3.default)(HCApiClient, [{
	    key: 'getAPIRoot',
	    value: function getAPIRoot() {
	      var api_host = _configuration_store2.default.get('api_host');
	      return 'https://' + api_host + '/v2/';
	    }
	  }, {
	    key: 'url',
	    value: function url(url_path, data) {
	      /**
	       * A UTF-8 compatible version of deprecated encode
	       */
	      function encodePath(path_to_encode) {
	        var newPath = "",
	            additionallyEncode = ['?', '&'];
	
	        if (typeof path_to_encode === "string") {
	          newPath = encodeURI(path_to_encode);
	          additionallyEncode.forEach(function (charToEncode) {
	            newPath = newPath.replace(new RegExp('\\' + charToEncode, 'g'), encodeURIComponent(charToEncode));
	          });
	          return newPath;
	        }
	      }
	
	      var url = this.getAPIRoot() + encodePath(url_path),
	          values = [],
	          queryString = function queryString(query) {
	        for (var key in query) {
	          if (query[key]) {
	            values.push(encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));
	          }
	        }
	        return values.length ? '?' + values.join('&') : '';
	      };
	
	      if (!data) {
	        return url;
	      } else if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) === 'object') {
	        data = _.omitBy(data, function (val) {
	          return !val;
	        });
	        return url + queryString(data);
	      }
	    }
	  }, {
	    key: 'getUrl',
	    value: function getUrl(path, payload, postJSON) {
	      if (postJSON) {
	        return this.url(path);
	      }
	      return this.url(path, payload);
	    }
	  }, {
	    key: 'request',
	    value: function request(method, path, payload, callback, postJSON, timeout) {
	      var url = this.getUrl(path, payload, postJSON);
	      if (url.length > MAX_URL_LENGTH) {
	        _logger2.default.warn('Unsafe URL length (' + url.length + '): ' + url);
	      }
	      this.requestUrl(method, url, _configuration_store2.default.getOAuthToken(), payload, callback, postJSON, timeout);
	    }
	  }, {
	    key: 'requestUrl',
	    value: function requestUrl(method, url, token, payload, callback, postJSON, timeout) {
	      var _this2 = this;
	
	      var options = {
	        url: url,
	        type: method
	      };
	
	      if (timeout) {
	        options["timeout"] = timeout;
	      }
	
	      if (postJSON) {
	        options["contentType"] = "application/json";
	        options["data"] = (0, _stringify2.default)(payload);
	      }
	
	      if (token) {
	        options["beforeSend"] = function (request) {
	          request.setRequestHeader("Authorization", "Bearer " + token);
	        };
	      }
	
	      $.ajax(options).done(function (data, textStatus, jqXHR) {
	        _this2.handleResponse(jqXHR, callback);
	      }).fail(function (jqXHR) {
	        _this2.handleResponse(jqXHR, callback);
	      });
	    }
	  }, {
	    key: 'handleResponse',
	    value: function handleResponse(xhr, callback) {
	      var response = xhr.responseText;
	      if (_.isString(response) && response !== "") {
	        try {
	          response = JSON.parse(response);
	        } catch (e) {
	          response = {
	            error: e
	          };
	        }
	      }
	      callback(response, xhr);
	    }
	  }]);
	  return HCApiClient;
	}();
	
	exports.default = new HCApiClient();
	module.exports = exports['default'];

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _utf = __webpack_require__(248);
	
	var _utf2 = _interopRequireDefault(_utf);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _events = __webpack_require__(89);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  /**
	   * Returns a promise that will resolve with the given `file`'s contents
	   *
	   * @param {string} file The path to the file to read
	   * @returns {Promise} A promise that will be resolved/rejected based on the outcome of the the read.
	   */
	
	  _readFile: function _readFile(file) {
	    return new _promise2.default(function (resolve, reject) {
	      var reader = new FileReader();
	
	      reader.onloadend = function () {
	        if (reader.error) {
	          reject(reader.error);
	        } else {
	          resolve(reader.result);
	        }
	
	        reader.onloadend = null; // Cleanup
	      };
	
	      reader.readAsArrayBuffer(file);
	    });
	  },
	
	
	  /**
	   * Builds the contents of a file message for multi-part XHR upload
	   *
	   * @param {ArrayBuffer} config.fileContent The content for the request body
	   * @param {string} config.fileType The MIME type for the file to upload
	   * @param {string} config.fileName The name of the file to upload
	   * @param {string} config.message The message content
	   * @param {string} boundary The boundary string for separating the parts of the requeset body
	   * @returns {Blob} A blob of the message and file, in the multi-part format
	   */
	  _getRequestBody: function _getRequestBody(_ref, boundary) {
	    var fileContent = _ref.fileContent;
	    var fileType = _ref.fileType;
	    var fileName = _ref.fileName;
	    var message = _ref.message;
	
	    var data = new Uint8Array(fileContent),
	        // Wrap in view to get data
	    type = fileType === 'application/json' ? 'text/plain' : fileType,
	        // with new API request can't contains two application/json parts.
	    before = _utf2.default.encode(['--' + boundary, '\r\n', 'Content-Type: application/json; charset=UTF-8', '\r\n', 'Content-Disposition: attachment; name="metadata"', '\r\n\r\n', (0, _stringify2.default)({ message: message }), '\r\n', '--' + boundary, '\r\n', 'Content-Type: ' + type, '\r\n', 'Content-Disposition: attachment; name="file"; filename="' + fileName + '"', '\r\n\r\n'].join('')),
	        after = '\r\n--' + boundary + '--',
	        size = before.length + data.byteLength + after.length,
	        arrayBuffer = new ArrayBuffer(size),
	        uint8array = new Uint8Array(arrayBuffer, 0),
	        i = 0,
	        j = 0;
	
	    // Append the string.
	    for (; i < before.length; i++) {
	      uint8array[i] = before.charCodeAt(i) & 0xff;
	    }
	
	    // Append the binary data.
	    for (j = 0; j < data.byteLength; i++, j++) {
	      uint8array[i] = data[j];
	    }
	
	    // Append the remaining string
	    for (j = 0; j < after.length; i++, j++) {
	      uint8array[i] = after.charCodeAt(j) & 0xff;
	    }
	
	    return new Blob([arrayBuffer]);
	  },
	
	
	  /**
	   * Returns the appropriate event source for XHR uploads. This is a cross-browser
	   * solution to capturing 'progress' events.
	   *
	   * @param {XMLHttpRequest} xhr The XHR instance to normalize
	   * @returns {EventTarget} The appropriate target for 'progress' events
	   */
	  _getXHREventSource: function _getXHREventSource(xhr) {
	    return xhr.upload || xhr;
	  },
	
	
	  /**
	   * Listens for events on the given `xhr` and translates them to events on the
	   * given `emitter`.
	   *
	   * @param {XMLHttpRequest} xhr The XHR instance to listen on
	   * @param {EventEmitter} emitter The EventEmitter instance to dispatch from
	   */
	  _registerXHREvents: function _registerXHREvents(xhr, emitter) {
	    var eventSource = this._getXHREventSource(xhr),
	        cleanup = void 0,
	        onProgress = void 0,
	        onReadyStateChange = void 0,
	        onError = void 0;
	
	    onProgress = function onProgress(e) {
	      var position = e.position || e.loaded,
	          total = e.totalSize || e.total,
	          percentage = position / total;
	
	      emitter.emit('progress', percentage);
	    };
	
	    onReadyStateChange = function onReadyStateChange() {
	      if (xhr.readyState !== 4) {
	        return;
	      }
	
	      if (xhr.status === 204) {
	        emitter.emit('success');
	      } else {
	        var error = {
	          code: xhr.status,
	          message: "Unexpected error!"
	        };
	
	        if (xhr.responseXML && xhr.responseXML.getElementsByTagName('error').length) {
	          error = xhr.responseXML.getElementsByTagName('error')[0].firstChild.nodeValue;
	        }
	
	        try {
	          var response = JSON.parse(xhr.response);
	          if (response.error) {
	            error = response.error;
	          }
	        } catch (e) {
	          _logger2.default.error(e);
	        }
	
	        emitter.emit('error', error);
	      }
	
	      cleanup();
	    };
	
	    onError = function onError(error) {
	      emitter.emit('error', error);
	      cleanup();
	    };
	
	    cleanup = function cleanup() {
	      eventSource.removeEventListener('progress', onProgress);
	      xhr.removeEventListener('readystatechange', onReadyStateChange);
	      xhr.removeEventListener('error', onError);
	      xhr.blob = null;
	      emitter.emit('complete');
	    };
	
	    eventSource.addEventListener('progress', onProgress);
	    xhr.addEventListener('readystatechange', onReadyStateChange);
	    xhr.addEventListener('error', onError);
	  },
	
	
	  /**
	   * Creates and configures the XHR to post the file message to the API.
	   *
	   * @param {object} messageData
	   * @param {String} config.fileName The name of the file
	   * @param {String} config.fileType The MIME type of the file
	   * @param {ArrayBuffer} config.fileContent The result of reading the file via FileReader::readAsArrayBuffer
	   * @param {String} config.message The message to be sent with the file
	   * @param {object} requestData
	   * @param {String} requestData.boundary The boundary delimiter for the multi-part request
	   * @param {String} requestData.token The API token to use for the request
	   * @param {String} conrequestDatafig.url The URL to post the request to
	   * @param {XMLHttpRequest} xhr The XHR instance to be sent
	   * @param {EventEmitter} emitter The EventEmitter to dispatch against
	   */
	  _sendRequest: function _sendRequest(messageData, requestData, xhr, emitter) {
	    xhr.open('POST', requestData.url, true);
	    xhr.setRequestHeader('Content-Type', 'multipart/related; boundary=' + requestData.boundary + '; charset=UTF-8');
	    xhr.setRequestHeader('Authorization', 'Bearer ' + requestData.token);
	    xhr.blob = this._getRequestBody(messageData, requestData.boundary);
	
	    this._registerXHREvents(xhr, emitter);
	
	    xhr.send(xhr.blob);
	  },
	
	
	  /**
	   * Uploads file with HipChat V2 API. Returns an EventEmitter that dispatches:
	   * - 'progress' : Fired as the XHR 'progress' event fires, passes along the percentage
	   *                of the file that has been uploaded
	   * - 'success'  : Fired if the upload is successful
	   * - 'error'    : Fired if the upload fails, passes along the error
	   * - 'complete' : Fired after the upload, whether it succeeded or failed
	   *
	   * @param {string} url Url for upload file
	   * @param {object} config Parameters
	   * @param {String} config.token Token for authorization
	   * @param {object} config.file File object
	   * @param {String} config.fileName File name
	   * @param {String} config.message Message sent with file
	   * @returns {EventEmitter} An emitter that dispatches events about the upload
	   */
	  uploadFile: function uploadFile(url, _ref2) {
	    var _this = this;
	
	    var token = _ref2.token;
	    var file = _ref2.file;
	    var fileName = _ref2.fileName;
	    var message = _ref2.message;
	
	    var emitter = new _events.EventEmitter(),
	        xhr = new XMLHttpRequest(),
	        boundary = 'hcb_' + Math.random().toString(36).substring(7);
	
	    this._readFile(file).then(function (fileContent) {
	      _this._sendRequest({
	        fileContent: fileContent,
	        fileName: fileName,
	        fileType: file.type,
	        message: message
	      }, {
	        boundary: boundary,
	        token: token,
	        url: url
	      }, xhr, emitter);
	    }).catch(function (error) {
	      emitter.emit('error', error);
	      emitter.emit('complete');
	    });
	
	    return emitter;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, its not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(104)(module), (function() { return this; }())))

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _dal = __webpack_require__(250);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _user = __webpack_require__(152);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Dictionary object of User models keyed by their id
	 * @typedef {Object.<string, User>} Roster
	 */
	
	/**
	 * XMPP representation of roster, as received by roster IQ and
	 * parsed via x2js
	 * @typedef {Object} XMPPRoster
	 * @property {Object} iq
	 * @property {Object} iq.query
	 * @property {Array<User>} iq.query.item
	 * @property {string} iq.query.xmlns - 'jabber:iq:roster'
	 * @property {string} iq.xmlns - 'jabber:client'
	 * @property {string} iq.type - 'result'
	 */
	
	/**
	 * @module DALUser
	 */
	var DALUser = {
	
	  /**
	   * Temporary method to get the roster in the expected structure of a
	   * "download the world" roster IQ XMPP request (ughh)
	   *
	   * @method getRosterAsXMPP
	   * @returns {Promise<XMPPRoster, DALError>}
	   */
	
	  getRosterAsXMPP: function getRosterAsXMPP() {
	    return this.getRoster().then(function (roster) {
	      return {
	        iq: {
	          query: {
	            item: (0, _keys2.default)(roster).map(function (id) {
	              return _user2.default.asX2JS(roster[id]);
	            }),
	            xmlns: NS.ROSTER
	          },
	          type: 'result',
	          xmlns: NS.JABBER
	        }
	      };
	    });
	  },
	
	
	  /**
	   * Gets the entire roster by either syncing or downloading the list
	   * from the server.
	   *
	   * @method getRoster
	   * @returns {Promise<Roster, DALError>}
	   */
	  getRoster: function getRoster() {
	    return _dal2.default.getRoster();
	  }
	};
	
	exports.default = DALUser;
	module.exports = exports['default'];

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray2 = __webpack_require__(127);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _constants = __webpack_require__(163);
	
	var Constants = _interopRequireWildcard(_constants);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _rest = __webpack_require__(220);
	
	var _rest2 = _interopRequireDefault(_rest);
	
	var _dal = __webpack_require__(144);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @module DALSync
	 */
	var DALSync = {
	
	  /**
	   * Gets the full roster. Will try to first sync
	   * @method getRoster
	   * @returns {Promise<Roster, DALError>}
	   */
	
	  getRoster: function getRoster() {
	    var _this = this;
	
	    var syncRoster = function syncRoster(cached) {
	      // Try to sync via Coral. If it fails, download the world via XMPP
	      return _this._tryToSync(_this._syncRosterViaREST.bind(_this), cached).catch(function (err) {
	        // console.error(err)
	        return _this._syncRosterViaXMPP();
	      });
	    };
	
	    return _dal2.default.get(_dal2.default.Keys.ROSTER).then(function (cached) {
	
	      // if it's been over 3 minutes, just go ahead and try to sync via Coral
	      if (!_connection_manager2.default.Connection.Cache.isReconnectedWithinSyncThreshold()) {
	        return syncRoster(cached);
	      }
	
	      // If it's been under 3 minutes, ask the server if our cached data is in sync.
	      // If so, resolve with the cache. Otherwise try to sync via Coral
	      return _connection_manager2.default.Connection.Cache.isResourceInSync(_dal2.default.Keys.ROSTER, cached).then(function (isSynced) {
	        if (isSynced) {
	          return cached;
	        }
	        return syncRoster(cached);
	      });
	    });
	  },
	
	
	  /**
	   * Gets the full list of rooms. Will try to first sync
	   *
	   * @method getRoomsList
	   * @returns {Promise<RoomsList, DALError>}
	   */
	  getRoomsList: function getRoomsList() {
	    var _this2 = this;
	
	    var syncRooms = function syncRooms(cached) {
	      // Try to sync via Coral. If it fails, download the world via XMPP
	      return _this2._tryToSync(_this2._syncRoomsViaREST.bind(_this2), cached).catch(function (err) {
	        //console.error(err)
	        return _this2._syncRoomsViaXMPP();
	      });
	    };
	
	    return _dal2.default.get(_dal2.default.Keys.ROOMS).then(function (cached) {
	
	      // if it's been over 3 minutes, just go ahead and try to sync via Coral
	      if (!_connection_manager2.default.Connection.Cache.isReconnectedWithinSyncThreshold()) {
	        return syncRooms(cached);
	      }
	
	      // If it's been under 3 minutes, ask the server if our cached data is in sync.
	      // If so, resolve with the cache. Otherwise try to sync via Coral
	      return _connection_manager2.default.Connection.Cache.isResourceInSync(_dal2.default.Keys.ROOMS, cached).then(function (isSynced) {
	        if (isSynced) {
	          return cached;
	        }
	        return syncRooms(cached);
	      });
	    });
	  },
	
	
	  /**
	   * Given the provided sync method (either this._syncRosterViaREST
	   * or this._syncRoomsViaREST) try to sync successfully. If the
	   * sync request fails with a 403 or 404 error, or if it's tried
	   * 5 times, then reject with appropriate error.
	   *
	   * @method _tryToSync
	   * @returns {Promise<*,DALError>}
	   * @private
	   */
	  _tryToSync: function _tryToSync(syncFn) {
	    for (var _len = arguments.length, syncArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      syncArgs[_key - 1] = arguments[_key];
	    }
	
	    return new _promise2.default(function (resolve, reject) {
	      var attempts = 1,
	          delay = Constants.RECONNECT_DELAY_MS,
	          tryAgain = void 0,
	          onError = void 0;
	
	      // If the sync function failed:
	      onError = function onError(dalError) {
	
	        // If we've tried 5 times, give up and reject
	        if (attempts >= 5) {
	          reject(_dalError2.default.ofType(_dalError2.default.Types.RATE_LIMITED));
	          return;
	        }
	
	        // If we get a 403 or 404 response we cannot recover, so reject
	        if (_.includes([403, 404], dalError.status)) {
	          reject(dalError);
	          return;
	        }
	
	        // otherwise, bump our "attempts" count, and try again after jittered backoff
	        attempts++;
	        delay = _utils2.default.decorrelatedJitter(Constants.RECONNECT_MAX_DELAY, Constants.RECONNECT_DELAY_MS, delay, Constants.RECONNECT_BACKOFF_FACTOR);
	        setTimeout(tryAgain, delay);
	      };
	
	      // Call the sync function. If it succeeds, resolve with the response
	      tryAgain = function tryAgain() {
	        syncFn.apply(undefined, syncArgs).then(resolve).catch(onError);
	      };
	
	      tryAgain();
	    });
	  },
	
	
	  /**
	   * Try the happy path to sync'ing the Roster. Will generate a version-map
	   * of the users in the cache and send that up to the server. The server will
	   * respond with a diff of the users that are different than what we sent up.
	   * We'll apply the diff, create an aggregate hash, and ask the server for their
	   * aggregate hash. If they match, we resolve with the updated roster. If any
	   * of the requests fail or if the hashes do not match, we reject with an
	   * appropriate error
	   *
	   * @method _syncRosterViaREST
	   * @returns {Promise<Roster, DALError>}
	   * @private
	   */
	  _syncRosterViaREST: function _syncRosterViaREST(cached) {
	    var syncedRoster = cached ? _.cloneDeep(cached) : {};
	    return _rest2.default.syncRoster(cached).then(function (serverDiff) {
	      serverDiff.forEach(function (user) {
	        syncedRoster[user.id] = user;
	      });
	      return _promise2.default.all([_dal2.default.updateRoster(serverDiff), _connection_manager2.default.Connection.Cache.isResourceInSync(_dal2.default.Keys.ROSTER, syncedRoster)]);
	    }).then(function (_ref) {
	      var _ref2 = (0, _slicedToArray3.default)(_ref, 2);
	
	      var isSynced = _ref2[1];
	
	      if (isSynced) {
	        return syncedRoster;
	      }
	      return _promise2.default.reject(_dalError2.default.ofType(_dalError2.default.Types.OUT_OF_SYNC));
	    });
	  },
	
	
	  /**
	   * Try the happy path to sync'ing the RoomsList. Will generate a version-map
	   * of the users in the cache and send that up to the server. The server will
	   * respond with a diff of the rooms that are different than what we sent up.
	   * We'll apply the diff, create an aggregate hash, and ask the server for their
	   * aggregate hash. If they match, we resolve with the updated data. If any
	   * of the requests fail or if the hashes do not match, we reject with an
	   * appropriate error
	   *
	   * @method _syncRoomsViaREST
	   * @returns {Promise<RoomsList, DALError>}
	   * @private
	   */
	  _syncRoomsViaREST: function _syncRoomsViaREST(cached) {
	    var syncedRooms = cached ? _.cloneDeep(cached) : {};
	    return _rest2.default.syncRooms(cached).then(function (serverDiff) {
	      serverDiff.forEach(function (room) {
	        syncedRooms[room.id] = room;
	      });
	      return _promise2.default.all([_dal2.default.updateRooms(serverDiff), _connection_manager2.default.Connection.Cache.isResourceInSync(_dal2.default.Keys.ROOMS, syncedRooms)]);
	    }).then(function (_ref3) {
	      var _ref4 = (0, _slicedToArray3.default)(_ref3, 2);
	
	      var isSynced = _ref4[1];
	
	      if (isSynced) {
	        return syncedRooms;
	      }
	      return _promise2.default.reject(_dalError2.default.ofType(_dalError2.default.Types.OUT_OF_SYNC));
	    });
	  },
	
	
	  /**
	   * Request the entire roster from XMPP. This is the fallback case if syncing fails.
	   *
	   * @returns {Promise<Roster, DALError>}
	   * @private
	   */
	  _syncRosterViaXMPP: function _syncRosterViaXMPP() {
	    var roster = void 0;
	    return _connection_manager2.default.Connection.Roster.getRoster().then(function (users) {
	      roster = users.reduce(function (result, user) {
	        result[user.id] = user;
	        return result;
	      }, {});
	      return _dal2.default.set(_dal2.default.Keys.ROSTER, roster).catch(_.noop);
	    }).then(function () {
	      return roster;
	    });
	  },
	
	
	  /**
	   * Request the entire room list from XMPP. This is the fallback case if syncing fails.
	   *
	   * @returns {Promise<RoomsList, DALError>}
	   * @private
	   */
	  _syncRoomsViaXMPP: function _syncRoomsViaXMPP() {
	    var roomsList = void 0;
	    return _connection_manager2.default.Connection.Rooms.getAll().then(function (rooms) {
	      roomsList = rooms.reduce(function (result, room) {
	        result[room.id] = room;
	        return result;
	      }, {});
	      return _dal2.default.set(_dal2.default.Keys.ROOMS, roomsList).catch(_.noop);
	    }).then(function () {
	      return roomsList;
	    });
	  }
	};
	
	exports.default = DALSync;
	module.exports = exports['default'];

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _dal = __webpack_require__(250);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _dal3 = __webpack_require__(144);
	
	var _dal4 = _interopRequireDefault(_dal3);
	
	var _xmppUtils = __webpack_require__(232);
	
	var _xmppUtils2 = _interopRequireDefault(_xmppUtils);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _rest = __webpack_require__(220);
	
	var _rest2 = _interopRequireDefault(_rest);
	
	var _apiV = __webpack_require__(246);
	
	var _apiV2 = _interopRequireDefault(_apiV);
	
	var _room = __webpack_require__(153);
	
	var _room2 = _interopRequireDefault(_room);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Dictionary object of User models keyed by their id
	 * @typedef {Object.<string, Room>} RoomsList
	 */
	
	/**
	 * XMPP representation of rooms list, as received by roster IQ and
	 * parsed via x2js
	 * @typedef {Object} XMPPRoomsList
	 * @property {Object} iq
	 * @property {Object} iq.query
	 * @property {Array<User>} iq.query.item
	 * @property {string} iq.query.xmlns - 'http://jabber.org/protocol/disco#items'
	 * @property {string} iq.xmlns - 'jabber:client'
	 * @property {string} iq.type - 'result'
	 */
	
	/**
	 * @module DALUser
	 */
	var DALRooms = {
	
	  /**
	   * Create a new room. Will attempt REST, but fallback
	   * to XMPP if the REST API requests fail
	   *
	   * @method createRoom
	   * @param {string} name
	   * @param {string} topic
	   * @param {string} privacy
	   * @returns {Promise<Room, DALError>}
	   */
	
	  create: function create(name, topic, privacy) {
	    var _this = this;
	
	    var createNewRoom = function createNewRoom() {
	      return _rest2.default.createRoom(name, topic, privacy).catch(function () {
	        return _connection_manager2.default.Connection.Rooms.create(name, topic, privacy);
	      });
	    };
	
	    var fetchRoomDetails = function fetchRoomDetails(entity) {
	      return _this.getById(entity.id).catch(function () {
	        return _this.getByJid(_xmppUtils2.default.createRoomJid(name));
	      });
	    };
	
	    // Putting room creation via Coral behind a feature flag until we're confident
	    // that this doesn't cause any unnecessary load on Coral
	    if (_.get(_configuration_store2.default.get('feature_flags'), 'web_client_coral_room_creation', false)) {
	      return createNewRoom().then(fetchRoomDetails);
	    }
	
	    return _connection_manager2.default.Connection.Rooms.create(name, topic, privacy).then(function () {
	      return _this.getByJid(_xmppUtils2.default.createRoomJid(name));
	    });
	  },
	
	
	  /**
	   * Delete a room
	   *
	   * @method deleteRoom
	   * @param {number} id
	   * @param {string} jid
	   * @returns {Promise<undefined, DALError>}
	   */
	  delete: function _delete(id, jid) {
	    return _rest2.default.deleteRoom(id).catch(function (err) {
	      _logger2.default.error('[REST:delete-room]', err);
	      return _connection_manager2.default.Connection.Rooms.delete(jid);
	    });
	  },
	
	
	  /**
	   * Fetch a room by it's id
	   *
	   * @method fetchRoomById
	   * @param {int} id
	   * @returns {Promise<Room, DALError>}
	   */
	  getById: function getById(id) {
	    return _rest2.default.fetchRoom(id).then(function (room) {
	      _dal4.default.updateRooms([room]);
	      return room;
	    });
	  },
	
	
	  /**
	   * Fetch a room by it's jid
	   *
	   * @method fetchRoomByJid
	   * @param {string} jid
	   * @returns {Promise<Room, DALError>}
	   */
	  getByJid: function getByJid(jid) {
	    return _connection_manager2.default.Connection.Rooms.fetch(jid).then(function (room) {
	      _dal4.default.updateRooms([room]);
	      return room;
	    });
	  },
	
	
	  /**
	   * Change a room's privacy setting
	   *
	   * @method setRoomPrivacy
	   * @param {string} jid
	   * @param {string} privacy
	   * @returns {Promise<undefined,DALError>}
	   */
	  setPrivacy: function setPrivacy(jid, privacy) {
	    return _connection_manager2.default.Connection.Rooms.setPrivacy(jid, privacy);
	  },
	
	
	  /**
	   * Change a room's name
	   *
	   * @method renameRoom
	   * @param {string} jid
	   * @param {string} name
	   * @returns {Promise<undefined,DALError>}
	   */
	  rename: function rename(jid, name) {
	    return _connection_manager2.default.Connection.Rooms.rename(jid, name);
	  },
	
	
	  /**
	   * Set room topic
	   *
	   * @method setTopic
	   * @param {string} jid
	   * @param {string} topic
	   * @returns {Promise<undefined, DALError>}
	   */
	  setTopic: function setTopic(jid, topic) {
	    return _connection_manager2.default.Connection.Rooms.setTopic(jid, topic);
	  },
	
	
	  /**
	   * Set guest access on a room
	   *
	   * @method setGuestAccess
	   * @param {string} jid
	   * @param {boolean} enabled
	   * @returns {Promise<undefined,DALError>}
	   */
	  setGuestAccess: function setGuestAccess(jid, enabled) {
	    return _connection_manager2.default.Connection.Rooms.setGuestAccess(jid, enabled);
	  },
	
	
	  /**
	   * Update room details via REST. Currently looks to only be
	   * used to archive/unarchive rooms - but could possibly be
	   * used to rename, change topic/privacy as well.
	   *
	   * @method updateRoom
	   * @param data
	   *
	   * @param callback
	   */
	  update: function update(data) {
	    var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	    _apiV2.default.room.update_room(data, callback);
	  },
	
	
	  /**
	   * Change a room's avatar
	   *
	   * @param {number} id
	   * @param {string} avatar - Base 64 encoded image string
	   * @return {promise}
	   */
	  uploadAvatar: function uploadAvatar(id, avatar) {
	    return _rest2.default.uploadRoomAvatar(id, avatar);
	  },
	
	
	  /**
	   * Temporary method to get the rooms list in the expected structure of a
	   * "download the world" disco#items IQ XMPP request (ughh)
	   *
	   * @method getRoomsAsXMPP
	   * @returns {Promise<XMPPRoster, DALError>}
	   */
	  getRoomsAsXMPP: function getRoomsAsXMPP() {
	    return this.getRoomsList().then(function (rooms) {
	      return {
	        iq: {
	          query: {
	            item: (0, _keys2.default)(rooms).map(function (id) {
	              return _room2.default.asX2JS(rooms[id]);
	            }),
	            xmlns: NS.DISCO_ITEMS
	          },
	          type: 'result',
	          xmlns: NS.JABBER
	        }
	      };
	    });
	  },
	
	
	  /**
	   * Gets the complete list of rooms. Attempts to sync using the cache
	   * so that it only downloads what it needs.
	   *
	   * @method getRoomsList
	   * @returns {Promise<RoomsList, DALError>}
	   */
	  getRoomsList: function getRoomsList() {
	    return _dal2.default.getRoomsList();
	  }
	};
	
	exports.default = DALRooms;
	module.exports = exports['default'];

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _dal = __webpack_require__(144);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _emoticon = __webpack_require__(155);
	
	var _emoticon2 = _interopRequireDefault(_emoticon);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _namespaces = __webpack_require__(154);
	
	var NS = _interopRequireWildcard(_namespaces);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Dictionary object of Emoticon models keyed by their id
	 * @typedef {Object.<string, Emoticon>} Emoticons
	 */
	
	/**
	 * XMPP representation of emoticons, as received by emoticon list IQ and
	 * parsed via x2js
	 * @typedef {Object} XMPPEmoticon
	 * @property {Object} iq
	 * @property {Object} iq.query
	 * @property {Array<Emoticon>} iq.query.item
	 * @property {string} iq.query.xmlns - 'jabber:iq:roster'
	 * @property {string} iq.xmlns - 'jabber:client'
	 * @property {string} iq.type - 'result'
	 */
	
	/**
	 * @module DALEmoticon
	 */
	var DALEmoticon = {
	
	  /**
	   * Temporary method to get the roster in the expected structure of a
	   * "download the world" roster IQ XMPP request (ughh)
	   *
	   * @method getEmoticonsAsXMPP
	   * @returns {Promise<XMPPEmoticons, DALError>}
	   */
	
	  getEmoticonsAsXMPP: function getEmoticonsAsXMPP(cached) {
	    var cached_ver = _.get(cached, 'query.ver', '');
	    return this.getEmoticons(cached_ver).then(function (_ref) {
	      var ver = _ref.ver;
	      var path_prefix = _ref.path_prefix;
	      var emoticons = _ref.emoticons;
	
	      var iq = {
	        query: {
	          ver: ver,
	          path_prefix: path_prefix,
	          item: (0, _keys2.default)(emoticons).map(function (id) {
	            return _emoticon2.default.asX2JS(emoticons[id]);
	          }),
	          xmlns: NS.HC_EMOTICONS
	        },
	        type: 'result',
	        xmlns: NS.JABBER
	      };
	
	      _dal2.default.updateEmoticons(iq);
	      return iq;
	    }).catch(function () {
	      return null;
	    });
	  },
	
	
	  /**
	   * Gets the full emoticon list.
	   * @method getEmoticons
	   * @returns {Promise<Emoticons, DALError>}
	   */
	  getEmoticons: function getEmoticons(ver) {
	    return _connection_manager2.default.Connection.Emoticons.getEmoticons(ver);
	  }
	};
	
	exports.default = DALEmoticon;
	module.exports = exports['default'];

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @module DALConnection
	 */
	var DALConnection = {
	
	  /**
	   * Gets the time remaining that we are still able recover the session in.
	   *
	   * @method getSessionRecoveryTime
	   * @returns {number}
	   */
	
	  getSessionRecoveryTime: function getSessionRecoveryTime() {
	    return _connection_manager2.default.Connection.allowedInactivityInterval - (_utils2.default.now() - _connection_manager2.default.Connection.last_BOSH_activity);
	  }
	};
	
	exports.default = DALConnection;
	module.exports = exports['default'];

/***/ },
/* 254 */
/***/ function(module, exports) {

	!function(){var a,b;a=function(){var a={},b={};return a.getLocalStorage=function(){return window.localStorage},a.getSessionStorage=function(){return window.sessionStorage},a.getInternalStorage=function(){return b.getItem=function(a){return b[a]},b.setItem=function(a,c){b[a]=c},b.clear=function(){b={}},b},a.getStorage=function(){var b;try{var c=a.getLocalStorage();b="undefined"!=typeof c?c:a.getSessionStorage()}catch(d){}return"undefined"==typeof b&&(b=a.getInternalStorage()),b},a.isCORSRequest=function(a){var b=document.createElement("a");return b.href=a,b.host!==window.location.host},a.useXDomainRequest=function(b){return a.isCORSRequest(b)&&!!window.XDomainRequest&&(-1!==navigator.appVersion.indexOf("MSIE 8.")||-1!==navigator.appVersion.indexOf("MSIE 9."))},a.getCookieValue=function(a){for(var b=a+"=",c=document.cookie.split(";"),d=0;d<c.length;d++){for(var e=c[d];" "===e.charAt(0);)e=e.substring(1,e.length);if(0===e.indexOf(b))return e.substring(b.length,e.length)}return null},a}(),b=function(a){function b(a){return d&&d.is_started?(d.stop(),d.config=d.parseConfig(a)):(d=new c(a),window["herment-gas-client"]=d),d}function c(b){return this.STORAGE_KEY_PREAMBLE="herment",this.MAXEVENTS=100,this.PUBLISH_INTERVAL=5e3,this.SAVE_INTERVAL=1e3,this.config=this.parseConfig(b),this.storage=a.getStorage(),this.is_started=!1,"undefined"!=typeof window.addEventListener?window.addEventListener("unload",function(){this.moveQueueToStorage()}.bind(this)):window.attachEvent("onunload",function(){this.moveQueueToStorage()}.bind(this)),this}var d=window["herment-gas-client"];return c.prototype={getAtlPath:function(){return a.getCookieValue("__atl_path")},getServerName:function(){var a;return"undefined"!=typeof document.location&&"undefined"!=typeof document.location.hostname&&(a=document.location.hostname),""===a&&(a="-"),a},getProductNameFromServerName:function(a){return"undefined"!=typeof a?a.replace(".com","").replace(".net","").replace(".org","").replace(".au","").replace(".io",""):"-"},getSubdomain:function(a){var b="-",c=a.match(/^([a-z0-9\.]*)[\-\.]{1}([a-z0-9]+)+\.([a-z]{2,6})$/i);if(c){var d=a.split(".");d=2===d[d.length-1].length?d.slice(0,d.length-3):d.slice(0,d.length-2),0!==d.length&&(b=d.join("."))}return b},generateRandomStorageKey:function(){var a=2,b=12,c=(Math.random()+"").slice(a,b),d=(Math.random()+"").slice(a,b);return c.concat(d)},ajaxPost:function(b,c){var d;if(a.useXDomainRequest(b))d=new window.XDomainRequest;else if(window.XMLHttpRequest)d=new XMLHttpRequest;else{if(!window.ActiveXObject)return;d=new window.ActiveXObject("Microsoft.XMLHTTP")}d.open("POST",b,!0),"undefined"!=typeof d.setRequestHeader&&(d.setRequestHeader("Content-Type","application/json"),d.setRequestHeader("Accept","application/json, text/javascript, */*;")),d.send(c)},parseConfig:function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;if("undefined"==typeof a||"undefined"==typeof a.queue){var t=window.AJS=window.AJS||{};t.EventQueue=t.EventQueue||[],b=t.EventQueue}else b=a.queue;return c="undefined"==typeof a||"undefined"==typeof a.analyticsscheme?"https":a.analyticsscheme,d="undefined"==typeof a||"undefined"==typeof a.analyticsserver?"analytics.atlassian.com":a.analyticsserver,e="undefined"==typeof a||"undefined"==typeof a.analyticsurl?"/analytics/events":a.analyticsurl,f="undefined"==typeof a||"undefined"==typeof a.server?this.getServerName():a.server,g="undefined"==typeof a||"undefined"==typeof a.product?this.getProductNameFromServerName(f):a.product,"undefined"==typeof a||"undefined"==typeof a.subproduct?(h=this.getSubdomain(f),"undefined"==typeof h&&(h="-")):h=a.subproduct,i="undefined"==typeof a||"undefined"==typeof a.version?null:a.version,j="undefined"==typeof a||"undefined"==typeof a.session?null:a.session,k="undefined"==typeof a||"undefined"==typeof a.sen?null:a.sen,l="undefined"==typeof a||"undefined"==typeof a.sourceip?null:a.sourceip,m="undefined"==typeof a||"undefined"==typeof a.atlpath?this.getAtlPath():a.atlpath,n="undefined"==typeof a||"undefined"==typeof a.ajax?this.ajaxPost:a.ajax,o="undefined"==typeof a||"undefined"==typeof a.maxevents?this.MAXEVENTS:a.maxevents,p="undefined"==typeof a||"undefined"==typeof a.storage_key?this.STORAGE_KEY_PREAMBLE+this.generateRandomStorageKey()+this.generateRandomStorageKey():a.storage_key,q="undefined"==typeof a||"undefined"==typeof a.user?"default":a.user,r="undefined"==typeof a||"undefined"==typeof a.publish_interval?this.PUBLISH_INTERVAL:a.publish_interval,s="undefined"==typeof a||"undefined"==typeof a.save_interval?this.SAVE_INTERVAL:a.save_interval,{queue:b,gasScheme:c,gasServer:d,gasUrl:e,serverName:f,productName:g,subProductName:h,version:i,session:j,sen:k,sourceIP:l,atlPath:m,post:n,maxevents:o,storageKey:p,user:q,publishInterval:r,saveInterval:s}},pushToServer:function(a,b){var c="undefined"!=typeof b?b:this.config.post,d=this.config.gasScheme+"://"+this.config.gasServer+this.config.gasUrl,e={events:a},f=JSON.stringify(e);c(d,f)},addEventsToArray:function(a,b,c){if("undefined"!=typeof c&&"undefined"!=typeof c.server&&"undefined"!=typeof c.product&&"undefined"!=typeof c.subproduct&&"undefined"!=typeof c.user)for(var d in a)if(a.hasOwnProperty(d)){var e=a[d];if(b.length>=this.config.maxevents)break;if(e.name&&e.properties){var f={name:e.name,properties:e.properties,serverTime:e.time||(new Date).getTime(),server:c.server,user:c.user,product:c.product,subproduct:c.subproduct,version:c.version,session:c.session,sen:c.sen,sourceIP:c.sourceIP,atlPath:c.atlPath};b.push(f)}}},publishFromQueueAndStorage:function(a){try{var b="undefined"!=typeof a?a:this.pushToServer.bind(this),c=[];if(this.config.queue.length<1&&("undefined"==typeof this.storage||this.storage.length<1))return;var d={server:this.config.serverName,user:this.config.user,product:this.config.productName,subproduct:this.config.subProductName,version:this.config.version,session:this.config.session,sen:this.config.sen,sourceIP:this.config.sourceIP,atlPath:this.config.atlPath};this.addEventsToArray(this.config.queue,c,d);var e=this.popEventsFromStorage();this.addEventsToArray(e,c,d),this.config.queue.length=0,c&&c.length&&b(c)}catch(f){}},serialiseEventsToString:function(a){return JSON.stringify(a)},deserialiseEvents:function(a){return JSON.parse(a)},storeEvents:function(a){if("undefined"!=typeof this.storage)try{if(this.storage[this.config.storageKey]){var b=this.deserialiseEvents(this.storage[this.config.storageKey])||[];b.length<this.config.maxevents&&b.push.apply(b,a),a=b}this.storage.setItem(this.config.storageKey,this.serialiseEventsToString(a))}catch(c){}},popEventsFromStorage:function(){if("undefined"==typeof this.storage)return[];try{if(this.storage[this.config.storageKey]){var a=this.deserialiseEvents(this.storage[this.config.storageKey]);return this.storage[this.config.storageKey]=this.serialiseEventsToString([]),a}}catch(b){}return[]},moveQueueToStorage:function(){0!==this.config.queue.length&&"undefined"!=typeof this.storage&&(this.storeEvents(this.config.queue),this.config.queue.length=0)},start:function(){this.is_started=!0;var a=Array.prototype.push;this.config.queue.push=function(b){b.time=(new Date).getTime(),a.call(this.config.queue,b)}.bind(this),this.initialSaveTimeout=setTimeout(this.publishFromQueueAndStorage.bind(this),this.config.saveInterval),this.publishInterval=setInterval(this.publishFromQueueAndStorage.bind(this),this.config.publishInterval),this.saveInterval=setInterval(this.moveQueueToStorage.bind(this),this.config.saveInterval)},stop:function(){this.is_started=!1,this.publishFromQueueAndStorage(),clearTimeout(this.initialSaveTimeout),clearInterval(this.saveInterval),clearInterval(this.publishInterval)},destroy:function(){this.stop(),window["herment-gas-client"]=b}},b}(a),window["herment-gas-client"]=b,window.define&&window.define("herment",[],function(){return b})}();

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray2 = __webpack_require__(127);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _idle_manager = __webpack_require__(256);
	
	var _idle_manager2 = _interopRequireDefault(_idle_manager);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	var _avatar_helper = __webpack_require__(258);
	
	var _avatar_helper2 = _interopRequireDefault(_avatar_helper);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _upload_file_helper = __webpack_require__(259);
	
	var _upload_file_helper2 = _interopRequireDefault(_upload_file_helper);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _network_status_helper = __webpack_require__(218);
	
	var _network_status_helper2 = _interopRequireDefault(_network_status_helper);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _presence_subscription_helper = __webpack_require__(290);
	
	var _presence_subscription_helper2 = _interopRequireDefault(_presence_subscription_helper);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _video_module = __webpack_require__(291);
	
	var _video_module2 = _interopRequireDefault(_video_module);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (config) {
	
	  var initialPresenceProcessed = false;
	  var outgoing_message_predicate = _utils2.default.createSafePredicate(_app_config2.default.outgoing_message_filter_predicate, _app_config2.default);
	  var upload_file_helper = new _upload_file_helper2.default();
	
	  var signOut = function signOut(data) {
	    $(window).off('beforeunload');
	    upload_file_helper.destroy();
	    _spi2.default.onSignOut(_dal2.default, data);
	  };
	
	  var onConnectFetchData = function onConnectFetchData() {
	    if (_configuration_store2.default.isGuest()) {
	      //The following block is to build a roster from the room participants,
	      //because guests shouldn't have access to the full roster
	      var roomId = _configuration_store2.default.get('room_id');
	
	      _dal2.default.Room.getById(roomId).then(function (room) {
	        return _app_dispatcher2.default.dispatch('DAL:handle-new-room', {
	          jid: room.jid,
	          name: room.name,
	          x: room
	        });
	      });
	      _dal2.default.Emoticon.getEmoticonsAsXMPP(function (data) {
	        _analytics_dispatcher2.default.dispatch('analytics-emoticons-loaded', { verbose: data });
	      });
	      _dal2.default.fetchParticipants(roomId).then(function (resp) {
	        return _app_dispatcher2.default.dispatch('DAL:guest-fetched-room-participants', resp);
	      }).catch(function (err) {
	        return _logger2.default.type('dal').error('[fetch-room-participants]', err.message);
	      });
	    } else {
	      (function () {
	        var cachedEmoticons = null;
	
	        _promise2.default.all([_dal2.default.Cache.getRosterAsXMPP(), _dal2.default.Cache.getRoomsAsXMPP(), _dal2.default.Cache.getEmoticonsAsXMPP()]).then(function (_ref) {
	          var _ref2 = (0, _slicedToArray3.default)(_ref, 3);
	
	          var roster = _ref2[0];
	          var rooms = _ref2[1];
	          var emoticons = _ref2[2];
	
	          if (roster) {
	            _app_dispatcher2.default.dispatch('server-data', roster);
	          }
	          if (rooms) {
	            _app_dispatcher2.default.dispatch('server-data', rooms);
	          }
	          if (emoticons) {
	            cachedEmoticons = emoticons;
	          }
	          return _promise2.default.all([_dal2.default.User.getRosterAsXMPP(), _dal2.default.Room.getRoomsAsXMPP(), _dal2.default.Emoticon.getEmoticonsAsXMPP(cachedEmoticons)]);
	        }).then(function (_ref3) {
	          var _ref4 = (0, _slicedToArray3.default)(_ref3, 3);
	
	          var roster = _ref4[0];
	          var rooms = _ref4[1];
	          var emoticons = _ref4[2];
	
	          _app_dispatcher2.default.dispatch('server-data', roster);
	          _app_dispatcher2.default.dispatch('server-data', rooms);
	          _app_dispatcher2.default.dispatch('server-data', emoticons || cachedEmoticons);
	          _analytics_dispatcher2.default.dispatch('analytics-roster-loaded', { verbose: roster });
	          _analytics_dispatcher2.default.dispatch('analytics-rooms-loaded', { verbose: rooms });
	          _analytics_dispatcher2.default.dispatch('analytics-emoticons-loaded', { verbose: emoticons });
	        }).catch(function (err) {
	          _logger2.default.type('dal').error('[fetch-roster/fetch-rooms/fetch-emoticons]', err.message);
	        });
	      })();
	    }
	  };
	
	  _app_dispatcher2.default.register({
	    'hipchat-client-configured': function hipchatClientConfigured() {
	      _dal2.default.attemptConnect();
	    },
	    'strophe-reconnecting': function stropheReconnecting() {
	      _analytics_dispatcher2.default.dispatch('analytics-hc-client-reconnection-start');
	      _idle_manager2.default.stop();
	    },
	    'strophe-authenticating': function stropheAuthenticating() {
	      if (_connection_manager2.default.isInitialConnect()) {
	        _analytics_dispatcher2.default.dispatch('analytics-initial-auth-start');
	      }
	    },
	    'strophe-disconnected': function stropheDisconnected() {
	      _analytics_dispatcher2.default.dispatch('analytics-event', {
	        name: 'hipchat.client.disconnected'
	      });
	      _idle_manager2.default.stop();
	    },
	    'strophe-connection-failed': function stropheConnectionFailed(stropheStatus, reason) {
	      _analytics_dispatcher2.default.dispatch('analytics-event', {
	        name: 'hipchat.client.' + (_connection_manager2.default.isInitialConnect() ? 'connection' : 'reconnection') + '.failed',
	        properties: { reason: reason }
	      });
	      if (!_connection_manager2.default.isInitialConnect()) {
	        _app_dispatcher2.default.dispatch('reconnect-fail');
	      }
	      _idle_manager2.default.stop();
	      var errorMsg = '[Connection Failure] ' + reason;
	      _logger2.default.error(errorMsg);
	      _logger2.default.type('strophe-connection-failed').error(reason);
	      _spi2.default.onStropheConnectionFailed(errorMsg);
	    },
	    'strophe-policy-violation': function strophePolicyViolation(stropheStatus, reason) {
	      var errorMsg = '[Authentication Failure] ' + reason;
	      _logger2.default.error(errorMsg);
	      _logger2.default.type('strophe-auth-failed').error(reason);
	      _spi2.default.onStrophePolicyViolation({ reason: reason, web_server: _configuration_store2.default.get('web_server') });
	    },
	    'strophe-auth-failed': function stropheAuthFailed(stropheStatus, reason) {
	      var errorMsg = '[Authentication Failure] ' + reason;
	      _logger2.default.error(errorMsg);
	      _logger2.default.type('strophe-auth-failed').error(reason);
	      _spi2.default.onStropheAuthFailed(errorMsg);
	    },
	    'reconnection-error': function reconnectionError(error) {
	      _spi2.default.onReconnectionError(error);
	    },
	    'strophe-connected': function stropheConnected() {
	      _analytics_dispatcher2.default.dispatch("analytics-hc-client-initial-connection");
	      // The following is an approximation; The difference between the actual auth success and this is about ~100+ms
	      // and may include other interactions. The proper solution would be embedding an event into
	      // hipchatAuthSuccessCallback in hipchat.js
	      _analytics_dispatcher2.default.dispatch("analytics-initial-auth-done");
	
	      var group_avatar_bg = _avatar_helper2.default.getGroupAvatarDefaultColor(_configuration_store2.default.get('group_id'));
	      var initialConfig = _.merge(_configuration_store2.default.getAll(), {
	        feature_flags: config.feature_flags,
	        group_avatar_bg: group_avatar_bg || _app_config2.default.default_group_avatar_bg
	      });
	
	      new _video_module2.default();
	
	      _app_dispatcher2.default.dispatch('hc-init', initialConfig);
	
	      _analytics_dispatcher2.default.dispatch('analytics-hc-init', {});
	
	      onConnectFetchData();
	      _presence_subscription_helper2.default.init();
	
	      _dal2.default.sendInitialPresence().then(function () {
	        _logger2.default.type('dal').log('[update-presence]', 'Successfully sent initial presence');
	      });
	      _idle_manager2.default.start();
	    },
	    'strophe-reconnected': function stropheReconnected() {
	      if (_configuration_store2.default.isGuest() && _configuration_store2.default.get('room_jid')) {
	        _dal2.default.joinRoom(_configuration_store2.default.get('room_jid')).then(function (room) {
	          return _app_dispatcher2.default.dispatch('DAL:handle-joined-rooms', room);
	        })
	        // TODO: probably need a generic flag component for throwing common errors. For now, the global trap
	        // TODO: will throw a flag if it sees a presence error, so any errs here should already be covered
	        .catch(function (err) {
	          return _logger2.default.error(err.message);
	        });
	      } else {
	        // wait till the config updates so we have the updated autoJoin list before sending up join presences
	        _app_dispatcher2.default.registerOnce('updated:config', function () {
	          _dal2.default.joinRooms(_preferences_store2.default.getAutoJoinRooms(), 0).then(function (chats) {
	            return _app_dispatcher2.default.dispatch('DAL:handle-joined-rooms', chats);
	          }).catch(function (err) {
	            return _logger2.default.type('dal').error('[join-rooms]', err.message);
	          });
	        });
	      }
	
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: "hipchat.client.reconnected"
	      });
	      _analytics_dispatcher2.default.dispatch("analytics-hc-client-reconnection-success");
	
	      onConnectFetchData();
	      _presence_subscription_helper2.default.resubscribe();
	
	      _idle_manager2.default.start();
	      _dal2.default.sendInitialPresence(_idle_manager2.default.isIdle() ? _presence2.default.IDLE : _presence2.default.AVAILABLE).then(function () {
	        _logger2.default.type('dal').log('[update-presence]', 'Successfully sent initial presence');
	        if (!_idle_manager2.default.isIdle()) {
	          _app_dispatcher2.default.dispatch('set-current-user-active');
	        }
	      });
	    },
	    'user-on-call': function userOnCall() {
	      _idle_manager2.default.stop();
	    },
	    'user-leave-call': function userLeaveCall() {
	      _idle_manager2.default.start();
	    },
	    'close-room': function closeRoom(data) {
	      if (!data.doNotNotifyHC) {
	        _dal2.default.leaveRoom(data.jid, data.type).catch(function (err) {
	          return _logger2.default.type('dal').error('[leave-room]', err.message);
	        });
	      }
	    },
	    'fetch-files': function fetchFiles(_ref5) {
	      var room = _ref5.room;
	      var before = _ref5.before;
	      var after = _ref5.after;
	
	      // TODO: Remove this default limit value once HC-28429 is fixed
	      _dal2.default.fetchFiles(room, before, after, _app_config2.default.fetching_files_limit).then(function (response) {
	        _app_dispatcher2.default.dispatch('DAL:handle-fetched-files', response);
	      }).catch(function (err) {
	        _logger2.default.type('dal').error('[fetch-files]', err.message);
	        _app_dispatcher2.default.dispatch('DAL:handle-fetched-files', { jid: room, files: [], end: true });
	      });
	    },
	    'fetch-links': function fetchLinks(_ref6) {
	      var room = _ref6.room;
	      var before = _ref6.before;
	      var after = _ref6.after;
	
	      // TODO: Remove this default limit value once HC-28429 is fixed
	      _dal2.default.fetchLinks(room, before, after, _app_config2.default.fetching_links_limit).then(function (response) {
	        _app_dispatcher2.default.dispatch('DAL:handle-fetched-links', response);
	      }).catch(function (err) {
	        _logger2.default.type('dal').error('[fetch-links]', err.message);
	        _app_dispatcher2.default.dispatch('DAL:handle-fetched-links', { jid: room, links: [], end: true });
	      });
	    },
	    'create-room': function createRoom(data, cb) {
	      _dal2.default.Room.create(data.name, data.topic, data.privacy).then(function (room) {
	        _app_dispatcher2.default.dispatch('DAL:handle-created-room', room);
	        if (room.privacy === "private") {
	          _dialog_actions2.default.showInviteUsersDialog();
	        } else {
	          _dialog_actions2.default.closeDialog();
	        }
	        cb(null, room);
	      }).catch(function (err) {
	        _logger2.default.type('dal').error('[create-room]', err.message);
	        cb(err);
	      });
	    },
	    'delete-room': function deleteRoom(data, callback) {
	      _dal2.default.Room.delete(data.id, data.jid).then(function () {
	        callback();
	      }).catch(function (err) {
	        _logger2.default.type('dal').error('[delete-room]', err.message);
	        callback(err);
	      });
	    },
	    'change-room-privacy': function changeRoomPrivacy(data, callback) {
	      _dal2.default.Room.setPrivacy(data.jid, data.privacy).then(callback).catch(function (err) {
	        _logger2.default.type('dal').error('[set-room-privacy]', err.message);
	        callback(err);
	      });
	    },
	    'change-room-name': function changeRoomName(data, callback) {
	      _dal2.default.Room.rename(data.jid, data.name).then(callback).catch(function (error) {
	        _logger2.default.type('dal').error('[rename-room]', error.message);
	        callback(error);
	      });
	    },
	    'update-presence': function updatePresence(presence) {
	      _spi2.default.onChangeUserStatus(presence.show);
	      _dal2.default.setPresence(presence.show, presence.status).then(function () {
	        _logger2.default.type('dal').log('[update-presence]', 'Successfully set presence to ' + presence.show + ', ' + presence.status);
	      });
	    },
	    'set-guest-access': function setGuestAccess(data) {
	      var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      _dal2.default.Room.setGuestAccess(data.jid, data.enable).then(function () {
	        callback();
	      }).catch(function (err) {
	        _logger2.default.type('dal').error('[set-guest-access]', err.message);
	        callback(err);
	      });
	    },
	    'guest-access-revoked': function guestAccessRevoked() {
	      signOut(_dal2.default, {});
	    },
	    'sync-preferences': function syncPreferences(data) {
	      _dal2.default.savePreferences(data, function () {
	        _app_dispatcher2.default.dispatch('preferences-saved', data);
	      });
	    },
	    'request-profile': function requestProfile(jid, cb) {
	      _dal2.default.fetchProfile(jid, cb);
	    },
	    'filter-presences': function filterPresences(ids) {
	      _dal2.default.filterPresences(ids).then(function () {
	        _logger2.default.type('dal').log('[filter-presence]', 'Updated presence filter to ' + ids.join(','));
	      });
	    },
	    'fetch-presences': function fetchPresences(ids) {
	      _dal2.default.fetchPresences(ids);
	    },
	    'attempt-reconnect': function attemptReconnect() {
	      _dal2.default.attemptReconnect();
	    },
	    'attempt-reconnect-without-reset': function attemptReconnectWithoutReset() {
	      _dal2.default.attemptReconnect(false);
	    },
	    'attempt-disconnect': function attemptDisconnect(should_reconnect) {
	      _dal2.default.terminateChatSession(should_reconnect);
	    },
	    'network-down': function networkDown() {},
	    'network-up': function networkUp() {
	      _dal2.default.attemptReconnect();
	    },
	    'fetch-previous': function fetchPrevious(data, cb) {
	      _dal2.default.fetchHistory(data.jid, data.oldest || null, _app_config2.default.message_retrieval_chunk_size, data.id, cb);
	    },
	    'upload-file': function uploadFile(data) {
	      var uploadParams = {
	        path: {
	          identifier: data.room_id
	        },
	        params: {
	          file: data.file,
	          fileName: data.fileName,
	          message: data.message
	        }
	      },
	          jid = data.jid,
	          emitter = _dal2.default.sendFileMessage(jid, uploadParams);
	      emitter.on('progress', function (percentage) {
	        _app_dispatcher2.default.dispatch('upload-progress-update', {
	          percentage: percentage,
	          jid: jid
	        });
	      }).on('success', function () {
	        _app_dispatcher2.default.dispatch('upload-successful', {
	          message: 'fileName: ' + data.fileName,
	          text: data.message,
	          jid: jid
	        });
	      }).on('error', function (error) {
	        _app_dispatcher2.default.dispatch('upload-failed', {
	          error: error,
	          jid: jid
	        });
	      }).on('complete', function () {
	        _app_dispatcher2.default.dispatch('upload-complete', {
	          jid: jid
	        });
	        emitter.removeAllListeners(); // Cleanup
	      });
	    },
	    'send-message': function sendMessage(data) {
	      if (!_network_status_helper2.default.isOnline()) {
	        _logger2.default.type('dal').warn('[send-message]', 'client appears to be offline, aborting send-message');
	        return;
	      } else if (!_dal2.default.isConnected()) {
	        _logger2.default.type('dal').warn('[send-message]', 'client appears to be disconnected, aborting send-message');
	        return;
	      }
	      if (outgoing_message_predicate(data)) {
	        _dal2.default.sendMessage(data);
	      }
	    },
	    'edit-message': function editMessage(data) {
	      _dal2.default.editMessage(data.jid, data.message, data.original_mid, data.ts);
	    },
	    'delete-message': function deleteMessage(message) {
	      _dal2.default.deleteMessage(message);
	    },
	    'resend-message': function resendMessage(data) {
	      if (outgoing_message_predicate(data)) {
	        _dal2.default.sendMessage(data);
	      }
	    },
	    'send-topic': function sendTopic(_ref7) {
	      var jid = _ref7.jid;
	      var topic = _ref7.topic;
	
	      _dal2.default.Room.setTopic(jid, topic).then(function () {
	        _app_dispatcher2.default.dispatch('DAL:handle-topic-updated', { jid: jid, topic: topic });
	      }).catch(function (err) {
	        return _logger2.default.type('dal').error('[set-topic]', err.message);
	      });
	    },
	    'fetch-room-participants': function fetchRoomParticipants(room) {
	      var includeOffline = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	      _dal2.default.fetchParticipants(room.id, includeOffline).then(function (resp) {
	        return _app_dispatcher2.default.dispatch('DAL:fetched-room-participants', resp);
	      }).catch(function (fetchParticipantsErr) {
	        _logger2.default.type('dal').error('[fetch-room-participants]', fetchParticipantsErr.message);
	        _logger2.default.type('dal').warn('[fetch-room-participants]', 'fallback to fetch participants via XMPP join without maxmemberpresences');
	        //Note: This joins the rooms a second time. Not ideal but is currently the only mechanism to request room participants via XMPP.
	        _app_dispatcher2.default.dispatch('set-room-participants-fully-initialized', room.jid);
	        _dal2.default.joinRoom(room.jid, 0, false).then(function (joinedRoom) {
	          return _app_dispatcher2.default.dispatch('DAL:handle-joined-rooms', joinedRoom);
	        }).catch(function (joinedRoomErr) {
	          return _logger2.default.type('dal').error('[join-room]', joinedRoomErr.message);
	        });
	      });
	    },
	    'fetch-room': function fetchRoom(jid, cb) {
	      _dal2.default.Room.getByJid(jid).then(function (room) {
	        return cb(null, room);
	      }).catch(function (err) {
	        _logger2.default.type('dal').error('[fetch-room-by-jid]', err.message);
	        cb(err);
	      });
	    },
	    'open-room': function openRoom(data) {
	      if (!_utils2.default.jid.is_private_chat(data.jid)) {
	        _dal2.default.Room.getByJid(data.jid).catch(function (err) {
	          _logger2.default.type('dal').error('[fetch-room-by-jid]', err.message);
	        });
	        _dal2.default.joinRoom(data.jid).then(function (room) {
	          return _app_dispatcher2.default.dispatch('DAL:handle-joined-rooms', room);
	        }).catch(function (err) {
	          return _logger2.default.type('dal').error('[join-room]', err.message);
	        });
	      } else {
	        _dal2.default.joinChat(data.jid);
	      }
	    },
	    'exit-app': function exitApp(data) {
	      signOut(_dal2.default, data);
	    },
	    'app-state-ready': function appStateReady() {
	      $(document).trigger("app-state-ready");
	      var chatToFocus = _preferences_store2.default.getChatToFocus();
	      if (chatToFocus && _utils2.default.jid.is_room(chatToFocus)) {
	        _app_dispatcher2.default.dispatch('initial-join-presence-sent', {
	          jid: chatToFocus,
	          with_history: false
	        });
	      }
	      _dal2.default.joinRooms(_preferences_store2.default.getAutoJoinRooms()).then(function (chats) {
	        return _app_dispatcher2.default.dispatch('DAL:handle-joined-rooms', chats);
	      }).catch(function (err) {
	        return _logger2.default.type('dal').error('[join-rooms]', err.message);
	      });
	
	      _spi2.default.onAppStateReady(_configuration_store2.default.getAll());
	
	      if (!console) {
	        return;
	      }
	      console.emote("Hey there  Trying to reverse engineer something? Why not join our team instead?");
	      console.emote("Apply at https://www.hipchat.com/jobs and mention this comment.");
	    },
	    'invite-users': function inviteUsers(data) {
	      _dal2.default.inviteUsersToRoom(data.room_jid, data.user_jids, data.reason);
	    },
	    'remove-users': function removeUsers(data, cb) {
	      _dal2.default.removeUsersFromRoom(data.room_jid, data.user_jids, cb);
	    },
	    'send-user-state-message': function sendUserStateMessage(data) {
	      _dal2.default.sendStateMessage(data.jid, data.type, data.state);
	    },
	    'send-video-message': function sendVideoMessage(data) {
	      _dal2.default.sendVideoMessage(data.jid, data.type, data.audio_only, data.url, data.service, data.callback, data.reason);
	    },
	    'request-addlive-credentials': function requestAddliveCredentials(data, cb) {
	      _dal2.default.requestAddliveCredentials(data.jid, cb);
	    },
	    'clear-web-cookies': function clearWebCookies() {
	      var cb = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	      _dal2.default.clearWebCookies(cb);
	    },
	    'revoke-oauth2-token': function revokeOauth2Token() {
	      var cb = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	      _dal2.default.revokeOauth2Token(cb);
	      _dal2.default.terminateChatSession(false);
	    },
	    'DAL:fetch-readstate': function DALFetchReadstate() {
	      _dal2.default.fetchReadstate();
	    },
	    'DAL:update-readstate': function DALUpdateReadstate(data) {
	      _dal2.default.updateReadstate(data);
	    },
	    'DAL:remove-readstate': function DALRemoveReadstate(data) {
	      _dal2.default.removeReadstate(data);
	    },
	    'DAL:retry-readstate': function DALRetryReadstate() {
	      _dal2.default.retryReadstate();
	    },
	    'DAL:reset-readstate': function DALResetReadstate() {
	      _dal2.default.resetReadstate();
	    },
	    'server-data': function serverData(data) {
	      if (!initialPresenceProcessed && 'presence' in data) {
	        initialPresenceProcessed = true;
	        _analytics_dispatcher2.default.dispatch("analytics-initial-presence-response-received", { verbose: data });
	      }
	    },
	    'apiv1-token-update-requested': function apiv1TokenUpdateRequested() {
	      _dal2.default.updateAPIV1Token();
	    },
	    'auth-token-update': function authTokenUpdate(data) {
	      if ('apiv1_token' in data) {
	        _logger2.default.debug("Updating API v1 auth token: ", _logger2.default.sanitize(data));
	        _spi2.default.onInternalTokenRefreshed(data.apiv1_token);
	      }
	    },
	    'before:new-active-chat': function beforeNewActiveChat(data) {
	      var isChat = _utils2.default.jid.is_chat(data.jid);
	      _spi2.default.onChangeActiveChat(isChat);
	      _analytics_dispatcher2.default.dispatch("analytics-new-active-chat", data);
	    },
	    'API:fetch-recent-history': function APIFetchRecentHistory(data) {
	      _dal2.default.fetchRecentHistory(data, function (_ref8) {
	        var error = _ref8.error;
	        var items = _ref8.items;
	
	        if (!error && items) {
	          _app_dispatcher2.default.dispatch('API:fetched-recent-history', {
	            jid: data.jid,
	            results: items,
	            mid: data.params['not-before']
	          });
	        } else {
	          _logger2.default.type('dal').error('[fetch-recent-history]', error);
	        }
	      });
	    },
	    'API:update-room': function APIUpdateRoom(data, cb) {
	      _dal2.default.Room.update(data, cb);
	    },
	    'API:sync-integrations': function APISyncIntegrations(data, cb) {
	      _dal2.default.syncIntegrations(data, cb);
	    },
	    'API:get-signed-url': function APIGetSignedUrl(data, parameters, cb) {
	      _dal2.default.getSignedUrl(data, parameters, cb);
	    },
	    'API:request-with-signed-url': function APIRequestWithSignedUrl(data, parameters, cb) {
	      _dal2.default.requestWithSignedUrl(data, parameters, cb);
	    },
	    'API:fetch-all-glances-for-room': function APIFetchAllGlancesForRoom(data, cb) {
	      _dal2.default.fetchAllGlancesForRoom(data, cb);
	    },
	
	    'API:fetch-signed-file': function APIFetchSignedFile(data) {
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	      var errCb = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	      _dal2.default.fetchSignedFile(data.url).then(cb).catch(errCb);
	    },
	    'API:upload-room-avatar': function APIUploadRoomAvatar(data) {
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      _dal2.default.Room.uploadAvatar(data.id, data.avatar).then(cb).catch(cb);
	    },
	    'API:fetch-signed-thumbnail': function APIFetchSignedThumbnail(file) {
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	      var errCb = arguments.length <= 2 || arguments[2] === undefined ? _.noop : arguments[2];
	
	      var featureFlags = _configuration_store2.default.get('feature_flags');
	      var multiGetThumbnails = featureFlags.web_client_secure_files_multi_get_for_thumbnails;
	      if (multiGetThumbnails) {
	        _file_helper2.default.fetchSignedThumbnail(file, cb, errCb);
	      } else {
	        _dal2.default.fetchSignedFile(file.thumb_url).then(cb).catch(errCb);
	      }
	    },
	    'API:fetch-signed-thumbnail-collection': function APIFetchSignedThumbnailCollection(fileObj) {
	      _dal2.default.fetchSignedThumbnailCollection(fileObj);
	    },
	    'API:fetch-last-message': function APIFetchLastMessage(data, cb) {
	      data.params = {
	        'max-results': 1
	      };
	      _dal2.default.fetchRecentHistory(data, function (response) {
	        cb({
	          jid: data.jid,
	          items: response.items
	        });
	      });
	    },
	    'API:fetch-alert-flag': function APIFetchAlertFlag() {
	      _dal2.default.fetchAlertFlag().then(function (data) {
	        _app_dispatcher2.default.dispatch('API:fetch-alert-flag-success', data);
	      }).catch(function (error) {
	        _logger2.default.type('dal').error('[API:fetch-alert-flag]', error);
	        _app_dispatcher2.default.dispatch('API:fetch-alert-flag-failure', error);
	      });
	    },
	    'API:dismiss-alert-flag': function APIDismissAlertFlag(_ref9) {
	      var id = _ref9.id;
	
	      _dal2.default.dismissAlertFlag({ id: id }).then(function () {
	        _app_dispatcher2.default.dispatch('API:dismiss-alert-flag-success');
	      }).catch(function (error) {
	        _logger2.default.type('dal').error('[API:dismiss-alert-flag]', error);
	        _app_dispatcher2.default.dispatch('API:dismiss-alert-flag-failure', error);
	      });
	    },
	    'API:fetch-read-only-content': function APIFetchReadOnlyContent() {
	      _dal2.default.fetchReadOnlyContent().then(function (data) {
	        _app_dispatcher2.default.dispatch('API:fetch-read-only-content-success', data);
	      }).catch(function (error) {
	        _logger2.default.type('dal').error('[API:fetch-read-only-content]', error);
	        _app_dispatcher2.default.dispatch('API:fetch-read-only-content-failure', error);
	      });
	    }
	  });
	};
	
	module.exports = exports['default'];

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _for = __webpack_require__(145);
	
	var _for2 = _interopRequireDefault(_for);
	
	var _timer = __webpack_require__(209);
	
	var _timer2 = _interopRequireDefault(_timer);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _connection_manager = __webpack_require__(208);
	
	var _connection_manager2 = _interopRequireDefault(_connection_manager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var STATE = (0, _for2.default)('HJC.Idle.Manager.State');
	
	/**
	 * Manage Idle for the web
	 */
	
	var IdleManager = function () {
	  function IdleManager() {
	    (0, _classCallCheck3.default)(this, IdleManager);
	
	
	    /**
	     * Internal state
	     */
	    this[STATE] = {
	      isIdle: false,
	      isRunning: false,
	      lastUserAction: new Date().getTime()
	    };
	
	    /**
	     * Timer to set the user to idle
	     */
	    this.idleTimer = new _timer2.default(this._onUserIdle.bind(this), _preferences_store2.default.get('idleMinutes') * 60 * 1000);
	
	    /**
	     * Timer to check for activity, in order to return from idle
	     */
	    this.activityTimer = new _timer2.default(this._checkForActivity.bind(this), 1000);
	  }
	
	  /**
	   * Bootstrap the idle stuff. Only do this on web, NOT in native
	   */
	
	
	  (0, _createClass3.default)(IdleManager, [{
	    key: 'start',
	    value: function start() {
	      var _this = this;
	
	      if (_configuration_store2.default.get('client_type') === 'web' && !this.isRunning()) {
	        var delay = _preferences_store2.default.get('idleMinutes') * 60 * 1000;
	        $(document).on('mousemove.idle keydown.idle DOMMouseScroll.idle mousewheel.idle mousedown.idle', function () {
	          _this[STATE].lastUserAction = new Date().getTime();
	        });
	        this.idleTimer.resetTime(delay).start();
	        this.activityTimer.start();
	        this[STATE].isRunning = true;
	        _logger2.default.info('[IdleManager] starting idle timers & events');
	      }
	    }
	
	    /**
	     * Stop idle management
	     */
	
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.idleTimer.clear();
	      this.activityTimer.clear();
	      $(document).off('mousemove.idle keydown.idle DOMMouseScroll.idle mousewheel.idle mousedown.idle');
	      this[STATE].isRunning = false;
	      _logger2.default.info('[IdleManager] stopping idle timers & events');
	    }
	
	    /**
	     * Ask if the user is idle
	     * @method isIdle
	     * @returns {boolean|IdleManager.isIdle}
	     */
	
	  }, {
	    key: 'isIdle',
	    value: function isIdle() {
	      return this[STATE].isIdle;
	    }
	
	    /**
	     * Check if the idle manager is already running
	     */
	
	  }, {
	    key: 'isRunning',
	    value: function isRunning() {
	      return this[STATE].isRunning;
	    }
	
	    /**
	     * Callback fired when the idle timer runs all the way down
	     * @private
	     */
	
	  }, {
	    key: '_onUserIdle',
	    value: function _onUserIdle() {
	      if (!_connection_manager2.default.isConnected()) {
	        return;
	      }
	
	      _logger2.default.info('[IdleManager] Going idle');
	      this[STATE].isIdle = true;
	      _current_user_actions2.default.goIdle();
	    }
	
	    /**
	     * Checks current time against last activity time to see if the
	     * user has taken action
	     * @private
	     */
	
	  }, {
	    key: '_userHasTakenActionInTheLastSecond',
	    value: function _userHasTakenActionInTheLastSecond() {
	      return new Date().getTime() - this[STATE].lastUserAction < 1000;
	    }
	
	    /**
	     * Fired every second to check when the last user activity was
	     * @private
	     */
	
	  }, {
	    key: '_checkForActivity',
	    value: function _checkForActivity() {
	      if (this._userHasTakenActionInTheLastSecond()) {
	        if (!_connection_manager2.default.isConnected()) {
	          return;
	        }
	
	        this.idleTimer.restart();
	        if (this.isIdle()) {
	          _logger2.default.info('[IdleManager] Returning from idle');
	          this[STATE].isIdle = false;
	          _current_user_actions2.default.returnToActive();
	        }
	      }
	      this.activityTimer.restart();
	    }
	
	    /**
	     * Used for testing
	     */
	
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this[STATE].isIdle = false;
	      this[STATE].lastUserAction = new Date().getTime();
	      this.stop();
	    }
	  }]);
	  return IdleManager;
	}();
	
	exports.default = new IdleManager();
	module.exports = exports['default'];

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  goIdle: function goIdle() {
	    _app_dispatcher2.default.dispatch('set-current-user-idle');
	    _analytics_dispatcher2.default.dispatch('analytics-update-presence', { show: _presence2.default.IDLE });
	  },
	  returnToActive: function returnToActive() {
	    _app_dispatcher2.default.dispatch('set-current-user-active');
	  },
	  changeStatus: function changeStatus() {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var _ref$show = _ref.show;
	    var show = _ref$show === undefined ? _presence2.default.AVAILABLE : _ref$show;
	    var _ref$status = _ref.status;
	    var status = _ref$status === undefined ? '' : _ref$status;
	    var _ref$type = _ref.type;
	    var type = _ref$type === undefined ? '' : _ref$type;
	
	    _app_dispatcher2.default.dispatch('set-current-user-status', { show: show, status: status });
	
	    if (type === 'show') {
	      _analytics_dispatcher2.default.dispatch('analytics-update-presence', { show: show });
	    } else if (type === 'status') {
	      _analytics_dispatcher2.default.dispatch('analytics-update-status-message', { status: status });
	    } else if (type === 'showAndStatus') {
	      _analytics_dispatcher2.default.dispatch('analytics-update-presence', { show: show });
	      _analytics_dispatcher2.default.dispatch('analytics-update-status-message', { status: status });
	    }
	  },
	  onCall: function onCall() {
	    _app_dispatcher2.default.dispatch('user-on-call');
	  },
	  leaveCall: function leaveCall() {
	    _app_dispatcher2.default.dispatch('user-leave-call');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AvatarHelper = {
	  defaultAvatarColors: _app_config2.default.default_avatar_colors,
	
	  createAvatarURL: function createAvatarURL(url) {
	    return 'http://' + url;
	  },
	
	  getHash: function getHash(str) {
	    var hash = 0,
	        chr;
	    for (var idx = 0, max = str.length; idx < max; idx++) {
	      chr = str.charCodeAt(idx);
	      hash = hash * 31 + chr;
	      hash &= hash;
	    }
	    return hash;
	  },
	
	  getGroupAvatarDefaultColor: function getGroupAvatarDefaultColor(str) {
	    var colors = this.defaultAvatarColors,
	        colorIndex;
	
	    if (_.isNumber(str)) {
	      str = str.toString();
	    }
	
	    colorIndex = Math.abs(this.getHash(str) % colors.length);
	    return colors[colorIndex];
	  },
	
	  getAvatarInitialsFromName: function getAvatarInitialsFromName(name) {
	    var _this = this;
	
	    var trimmedSpaceName = name.trim();
	    var result = this._trimNonAlphanumericChars(trimmedSpaceName).split(/\s+/i).map(function (el) {
	      var trimmedName = _this._trimNonAlphanumericChars(el);
	      return trimmedName.charAt(0);
	    }).join('').slice(0, 3).toUpperCase();
	
	    return result;
	  },
	  _trimNonAlphanumericChars: function _trimNonAlphanumericChars(str) {
	    var rule = /[=*\/\\+\-_'"`~\(\)\[\]\{\}@]+/i;
	    var result = str.replace(rule, '').split('').reverse().join('').replace(rule, '').split('').reverse().join('');
	
	    return result;
	  },
	
	
	  cleanAvatarURL: function cleanAvatarURL(avatarUrl) {
	    if (_.isString(avatarUrl) && avatarUrl.indexOf("http://") === -1 && avatarUrl.indexOf("https://") === -1) {
	      avatarUrl = this.createAvatarURL(avatarUrl);
	    }
	    return avatarUrl;
	  }
	};
	
	module.exports = AvatarHelper;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _link_utils = __webpack_require__(108);
	
	var _link_utils2 = _interopRequireDefault(_link_utils);
	
	var _file_uploader_actions = __webpack_require__(260);
	
	var _file_uploader_actions2 = _interopRequireDefault(_file_uploader_actions);
	
	var _chat_input_actions = __webpack_require__(261);
	
	var _chat_input_actions2 = _interopRequireDefault(_chat_input_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _chat_input_strings = __webpack_require__(263);
	
	var _chat_input_strings2 = _interopRequireDefault(_chat_input_strings);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _uri = __webpack_require__(142);
	
	var _uri2 = _interopRequireDefault(_uri);
	
	var _api = __webpack_require__(264);
	
	var _api2 = _interopRequireDefault(_api);
	
	var _regex_helpers = __webpack_require__(106);
	
	var _regex_helpers2 = _interopRequireDefault(_regex_helpers);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var UploadFileHelper = function () {
	  function UploadFileHelper() {
	    (0, _classCallCheck3.default)(this, UploadFileHelper);
	
	    this._registerListeners();
	    this._bindDOMEvents();
	    this._uploading_state = {};
	  }
	
	  (0, _createClass3.default)(UploadFileHelper, [{
	    key: "destroy",
	    value: function destroy() {
	      this._unregisterListeners();
	      this._unbindDOMEvents();
	    }
	  }, {
	    key: "_registerListeners",
	    value: function _registerListeners() {
	      var _this = this;
	
	      _app_dispatcher2.default.register({
	        'upload-file': function uploadFile(data) {
	          _this._uploading_state[data.jid] = true;
	        },
	        'upload-successful': function uploadSuccessful(data) {
	          _this._uploading_state[data.jid] = false;
	        },
	        'upload-failed': function uploadFailed(data) {
	          _this._handleUploadFailed(data);
	          _this._uploading_state[data.jid] = false;
	        },
	        'open-file-picker': function openFilePicker() {
	          _this._openFilePicker();
	        },
	        'file-pasted': function filePasted(e) {
	          _this._handleFilePasted(e);
	        },
	        'file-chosen': function fileChosen(e, source) {
	          _this._onFileChosen(e, source);
	        },
	        'add-file-for-upload-with-url': function addFileForUploadWithUrl(data) {
	          _this._handleUploadViaUrl(data);
	        },
	        'add-file-for-upload-with-base64': function addFileForUploadWithBase64(data) {
	          _this._handleUploadViaBase64(data);
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this.active_chat = jid;
	        }
	      });
	    }
	  }, {
	    key: "_unregisterListeners",
	    value: function _unregisterListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.unregister({
	        'upload-failed': function uploadFailed() {
	          _this2._handleUploadFailed();
	        },
	        'open-file-picker': function openFilePicker() {
	          _this2._openFilePicker();
	        },
	        'file-pasted': function filePasted() {
	          _this2._handleFilePasted();
	        },
	        'file-chosen': function fileChosen() {
	          _this2._onFileChosen();
	        },
	        'add-file-for-upload': function addFileForUpload() {
	          _this2._handleFileForUploadWithUrl();
	        },
	        'add-file-for-upload-with-base64': function addFileForUploadWithBase64() {
	          _this2._handleUploadViaBase64();
	        }
	      });
	    }
	  }, {
	    key: "_bindDOMEvents",
	    value: function _bindDOMEvents() {
	      document.addEventListener('dragenter', this._handleDragEnter.bind(this));
	      document.addEventListener('dragover', this._handleDragEnter.bind(this));
	      document.addEventListener('drop', this._handleDrop.bind(this));
	    }
	  }, {
	    key: "_unbindDOMEvents",
	    value: function _unbindDOMEvents() {
	      document.removeEventListener('dragenter', this._handleDragEnter);
	      document.removeEventListener('dragover', this._handleDragEnter);
	      document.removeEventListener('drop', this._handleDrop);
	    }
	  }, {
	    key: "_handleUploadViaUrl",
	    value: function _handleUploadViaUrl(data) {
	      if (data && data.fileUrl) {
	        this._handleFileForUploadWithUrl(data.fileUrl, data.source);
	      }
	    }
	  }, {
	    key: "_handleUploadViaBase64",
	    value: function _handleUploadViaBase64(data) {
	      if (data && data.base64) {
	        this._handleFileForUploadWithBase64(data.base64, data.fileName, data.source);
	      }
	    }
	  }, {
	    key: "_handleUploadFailed",
	    value: function _handleUploadFailed() {
	      var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      if (data.error && data.error.code === 503) {
	        this._dispatchError('service_unavailable', data.jid);
	      } else if (data.error && data.error.code === 400) {
	        this._dispatchError('unable_to_upload_image', data.jid);
	      } else {
	        this._dispatchError('unable_to_upload', data.jid);
	      }
	    }
	  }, {
	    key: "_handleDragEnter",
	    value: function _handleDragEnter(e) {
	      e.stopPropagation();
	      e.preventDefault();
	    }
	  }, {
	    key: "_handleDrop",
	    value: function _handleDrop(e) {
	      e.stopPropagation();
	      e.preventDefault();
	
	      if (this._uploading_state[this.active_chat]) {
	        return;
	      }
	
	      var url_regex = new RegExp(_regex_helpers2.default.url, "i");
	
	      var html = e.dataTransfer.getData('text/html'),
	          textOrUrl = e.dataTransfer.getData('text/plain'),
	          text = null,
	          url = null,
	          file = !!e.dataTransfer.files.length;
	
	      if (!file && textOrUrl !== '') {
	        if (url_regex.test(textOrUrl)) {
	          url = textOrUrl;
	        } else {
	          text = textOrUrl;
	        }
	      }
	
	      if (url) {
	        this._handleDropUrl(url);
	      } else if (text) {
	        this._handleDropText(text);
	      } else if (html) {
	        this._handleDropHtml(html);
	      } else {
	        this._handleDropFile(e);
	      }
	    }
	  }, {
	    key: "_handleDropHtml",
	    value: function _handleDropHtml(html) {
	      var url = '',
	          img = $('<div/>').html(html).find('img')[0],
	          a = $('<div/>').html(html).find('a')[0];
	
	      if (img && $(img).hasClass('remoticon')) {
	        this._handleDropText($(img).attr('alt'));
	      } else if (img) {
	        url = this._tryRemoveQuery($(img).attr('src'));
	        this._handleUrl(url);
	      } else if (a) {
	        url = this._tryRemoveQuery($(a).attr('href'));
	        this._handleUrl(url);
	      }
	    }
	  }, {
	    key: "_handleDropUrl",
	    value: function _handleDropUrl(url) {
	      this._handleUrl(url);
	    }
	  }, {
	    key: "_handleDropText",
	    value: function _handleDropText(text) {
	      _api2.default.focusChatInput();
	      _chat_input_actions2.default.appendMessage({ text: text });
	    }
	  }, {
	    key: "_handleDropFile",
	    value: function _handleDropFile(e) {
	      _spi2.default.focusApp();
	      this._onFileChosen(e, "dragndrop");
	    }
	  }, {
	    key: "_tryRemoveQuery",
	    value: function _tryRemoveQuery(urlForCheck) {
	      var withoutQuery = _link_utils2.default.remove_query_string(urlForCheck);
	
	      if (this._isAllowedUrlFileType(withoutQuery)) {
	        urlForCheck = withoutQuery;
	      }
	      return urlForCheck;
	    }
	  }, {
	    key: "_handleUrl",
	    value: function _handleUrl(url) {
	      _api2.default.focusChatInput();
	      if (this._isAllowedUrlFileType(url)) {
	        this._handleFileForUploadWithUrl(url, "dragndrop");
	      } else {
	        this._tryUrlByLoadingImage(url);
	      }
	    }
	  }, {
	    key: "_isAllowedUrlFileType",
	    value: function _isAllowedUrlFileType(url) {
	      var isBase64 = this.isBase64Image(url);
	      url = url.toLowerCase();
	      return _.endsWith(url, '.jpg') || _.endsWith(url, '.jpeg') || _.endsWith(url, '.png') || this.isGIF(url) || isBase64;
	    }
	  }, {
	    key: "isGIF",
	    value: function isGIF(url) {
	      return _.endsWith(url.toLowerCase(), '.gif');
	    }
	  }, {
	    key: "isBase64Image",
	    value: function isBase64Image(src) {
	      return (/^data:image\/[a-z+]{3,8};base64,(.|\n)+/.test(src)
	      );
	    }
	  }, {
	    key: "_handleFilePasted",
	    value: function _handleFilePasted(e) {
	      if (e.clipboardData && e.clipboardData.items) {
	        var dataTransferItem = e.clipboardData.items[0];
	        if (dataTransferItem && dataTransferItem.kind === "file") {
	          this._onFileChosen(e, "paste");
	        }
	      }
	    }
	  }, {
	    key: "_handleFileForUploadWithBase64",
	    value: function _handleFileForUploadWithBase64(base64, fileName, source) {
	      var blob = _utils2.default.file.base64_to_blob(base64, fileName);
	      if (blob) {
	        this._handleBlobLoaded(blob, fileName, source);
	      }
	    }
	  }, {
	    key: "_handleFileForUploadWithUrl",
	    value: function _handleFileForUploadWithUrl(fileUrl, source) {
	      this._getBlobFromUrl(fileUrl, this._handleBlobLoaded.bind(this), source);
	    }
	  }, {
	    key: "_getBlobFromUrl",
	    value: function _getBlobFromUrl(file_url, cb, source) {
	      var xhr = arguments.length <= 3 || arguments[3] === undefined ? new XMLHttpRequest() : arguments[3];
	      var reader = arguments.length <= 4 || arguments[4] === undefined ? new FileReader() : arguments[4];
	
	
	      if (!_.isFunction(cb)) {
	        _logger2.default.type('upload-file-helper').warn('Callback for _getBlobFromUrl function is not defined.');
	        return;
	      }
	
	      if (!file_url || !this._validateFileUrl(file_url)) {
	        _logger2.default.type('upload-file-helper').warn('File url is not valid: ', file_url);
	        return;
	      }
	
	      var file_name = this.isBase64Image(file_url) ? false : _utils2.default.file.get_file_name(file_url);
	
	      if (_uri2.default.getProtocol(file_url).length >= location.protocol.length - 1) {
	
	        this._getDataWithXHRRequest(xhr, reader, cb, source, file_name, file_url);
	      } else {
	
	        if (this.isBase64Image(file_url)) {
	
	          var blob = _utils2.default.file.base64_to_blob(file_url);
	
	          cb(blob, file_name, source);
	          _logger2.default.type('upload-file-helper').info('Blob from base64 image received.');
	        } else if (this.isGIF(file_url)) {
	
	          _logger2.default.type('upload-file-helper').info('GIF loading via canvas is skipped.');
	          _chat_input_actions2.default.appendMessage({ text: " " + file_url });
	        } else {
	
	          this._getDataByLoadingImage(cb, source, file_name, file_url);
	        }
	      }
	    }
	  }, {
	    key: "_getDataWithXHRRequest",
	    value: function _getDataWithXHRRequest(xhr, reader, cb, source, file_name, file_url) {
	
	      xhr.open("GET", file_url);
	      xhr.responseType = "blob";
	      xhr.onerror = function () {
	        _chat_input_actions2.default.appendMessage({ text: " " + file_url });
	        _logger2.default.type('upload-file-helper').warn('Image failed to load via xhr: ', file_url);
	      };
	      xhr.onload = function () {
	        var _this3 = this;
	
	        var response = xhr.response;
	        reader.readAsArrayBuffer(response);
	        reader.onerror = function () {
	          _this3._dispatchError('unable_to_upload');
	          _logger2.default.type('upload-file-helper').warn('Reader failed to read the file: ', file_url);
	        };
	        reader.onload = function (e) {
	          var blob = new Blob([e.srcElement.result], { type: response.type });
	          cb(blob, file_name, source);
	          _logger2.default.type('upload-file-helper').info('Blob from image received via xhr: ', file_url);
	        };
	      };
	
	      xhr.send();
	    }
	  }, {
	    key: "_getDataByLoadingImage",
	    value: function _getDataByLoadingImage(cb, source, file_name, file_url) {
	      var append_url = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];
	
	
	      var extension = _utils2.default.file.get_extension(file_url) || 'png',
	          mimeType = "image/" + extension;
	
	      var img = new Image();
	      img.setAttribute('crossOrigin', 'anonymous');
	      img.onload = function () {
	
	        var canvas = document.createElement("canvas");
	        canvas.width = img.naturalWidth;
	        canvas.height = img.naturalHeight;
	
	        var ctx = canvas.getContext("2d");
	        ctx.drawImage(img, 0, 0);
	
	        var imd = canvas.toDataURL(mimeType),
	            blob = _utils2.default.file.base64_to_blob(imd);
	
	        cb(blob, file_name, source);
	        _logger2.default.type('upload-file-helper').info('Blob from image received: ', file_url);
	      };
	
	      img.onerror = function () {
	        if (append_url) {
	          _logger2.default.type('upload-file-helper').warn('Image failed to load: ', file_url);
	          _chat_input_actions2.default.appendMessage({ text: "" + file_url });
	        } else {
	          _logger2.default.type('upload-file-helper').warn('Url failed to load: ', file_url);
	        }
	      };
	
	      img.src = file_url;
	    }
	  }, {
	    key: "_tryUrlByLoadingImage",
	    value: function _tryUrlByLoadingImage(url) {
	      this._getDataByLoadingImage(this._handleBlobLoaded.bind(this), "dragndrop", false, url, true);
	    }
	  }, {
	    key: "_handleBlobLoaded",
	    value: function _handleBlobLoaded(blob, name, source) {
	      if (blob) {
	        var file;
	        if (!name) {
	          name = _chat_input_strings2.default.upload_default_name + "." + _utils2.default.file.get_extension_for_mime_type(blob.type);
	        }
	
	        file = _utils2.default.file.blob_to_file(blob, name);
	        this._handleFileForChatInput(file, name, source);
	      }
	    }
	  }, {
	    key: "_onFileChosen",
	    value: function _onFileChosen(e) {
	      var source = arguments.length <= 1 || arguments[1] === undefined ? "browse" : arguments[1];
	
	      var file, name;
	
	      if (e.type === 'change') {
	        file = e.target.files[0];
	        name = _.get(file, "name");
	      } else if (e.type === 'drop') {
	        file = e.dataTransfer.files[0];
	        name = _.get(file, "name");
	      } else if (e.type === 'paste') {
	        var dataTransferItem = e.clipboardData.items[0];
	        if (dataTransferItem) {
	          file = dataTransferItem.getAsFile();
	          var ext = _utils2.default.file.get_extension_for_mime_type(dataTransferItem.type);
	          if (ext) {
	            name = _chat_input_strings2.default.upload_default_name + "." + ext;
	          }
	        }
	      }
	
	      if (file && name && source) {
	        this._handleFileForChatInput(file, name, source);
	      }
	      _api2.default.focusChatInput();
	    }
	  }, {
	    key: "_handleFileForChatInput",
	    value: function _handleFileForChatInput(file, name, source) {
	      if (file) {
	        file.file_obj = null;
	        _chat_input_actions2.default.expandAttachment({
	          jid: this.active_chat,
	          file_name: name,
	          file: file,
	          file_selection_source: source
	        });
	        this._processFile(file, name, source);
	      }
	    }
	  }, {
	    key: "_openTooltip",
	    value: function _openTooltip(file, name, source, fileObj) {
	      file.file_obj = fileObj;
	
	      _chat_input_actions2.default.openTooltip({
	        type: 'upload_preview',
	        data: {
	          file: fileObj
	        }
	      });
	
	      _chat_input_actions2.default.expandAttachment({
	        jid: this.active_chat,
	        file_name: name,
	        file: file,
	        file_selection_source: source
	      });
	    }
	  }, {
	    key: "_processFile",
	    value: function _processFile(file, name, source) {
	      var _this4 = this;
	
	      var fileTypeBreakdown = _utils2.default.file.get_selected_file_type(file),
	          file_type = fileTypeBreakdown.major,
	          subtype = fileTypeBreakdown.minor,
	          client_subtype = _configuration_store2.default.get("client_subtype"),
	          isQT = _utils2.default.clientSubType.isQT(client_subtype),
	          isWindows = _utils2.default.platform.isWindows(),
	          isSafari = _utils2.default.browser.is.safari();
	
	      file_type = this._determineFileType(file_type, subtype);
	
	      if (this._validateFile(file) && this._shouldOpenFilePreview(file_type)) {
	        (function () {
	          var fileObj = {
	            file_type: file_type
	          };
	
	          fileObj.src = window.URL.createObjectURL(file);
	
	          if (file_type === 'image') {
	            _utils2.default.image.resizeImage(fileObj.src).then(function (processedFile) {
	              fileObj.src_processed = window.URL.createObjectURL(processedFile);
	              _this4._openTooltip(file, name, source, fileObj);
	            });
	          } else if (file_type === 'video') {
	            if (!(isWindows && isQT) && (subtype === 'mp4' || subtype === 'quicktime' && isSafari)) {
	              _this4._openTooltip(file, name, source, fileObj);
	            }
	          } else {
	            _this4._openTooltip(file, name, source, fileObj);
	          }
	        })();
	      }
	    }
	  }, {
	    key: "_validateFile",
	    value: function _validateFile(file) {
	      var max_upload_size = arguments.length <= 1 || arguments[1] === undefined ? _app_config2.default.max_upload_size : arguments[1];
	
	      var result = void 0;
	      if (file.size && file.size / 1024 / 1024 > max_upload_size) {
	        this._dispatchError('file_too_large');
	        result = false;
	      } else {
	        this._readFile(file);
	        result = true;
	      }
	      return result;
	    }
	  }, {
	    key: "_validateFileUrl",
	    value: function _validateFileUrl(url) {
	      var result = void 0;
	      if (_.isString(url) && _utils2.default.file.get_file_name(url) && url.slice(-1) !== "/") {
	        result = true;
	      } else {
	        this._dispatchError('file_is_folder');
	        result = false;
	      }
	      return result;
	    }
	  }, {
	    key: "_readFile",
	    value: function _readFile(file) {
	      var _this5 = this;
	
	      var reader = arguments.length <= 1 || arguments[1] === undefined ? new FileReader() : arguments[1];
	
	      reader.onload = function () {
	        _this5._clearErrors();
	      };
	      reader.onerror = function () {
	        _this5._dispatchError('file_is_folder');
	      };
	      reader.readAsText(file);
	    }
	  }, {
	    key: "_shouldOpenFilePreview",
	    value: function _shouldOpenFilePreview(file_type) {
	      return _.includes(['image', 'video', 'audio'], file_type);
	    }
	  }, {
	    key: "_determineFileType",
	    value: function _determineFileType(file_type, subtype) {
	      if (subtype) {
	        if (subtype === 'pdf') {
	          file_type = 'text';
	        } else if (_.includes(['xml', 'html', 'rtf'], subtype) || _.includes(subtype, 'photoshop')) {
	          file_type = 'application';
	        }
	      }
	      return file_type;
	    }
	  }, {
	    key: "_openFilePicker",
	    value: function _openFilePicker() {
	      var node = document.getElementById('fileInput');
	      if (node) {
	        node.click();
	      }
	      _spi2.default.showFileChooser();
	    }
	  }, {
	    key: "_clearErrors",
	    value: function _clearErrors() {
	      _file_uploader_actions2.default.clearFileErrors({ jid: this.active_chat });
	    }
	  }, {
	    key: "_dispatchError",
	    value: function _dispatchError(key, jid) {
	      _file_uploader_actions2.default.dispatchFileError({ jid: jid || this.active_chat, key: key });
	    }
	  }]);
	  return UploadFileHelper;
	}();
	
	module.exports = UploadFileHelper;

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = {
	
	  dispatchFileError: function dispatchFileError(data) {
	    _app_dispatcher2.default.dispatch('file-error', data);
	  },
	
	  clearFileErrors: function clearFileErrors(data) {
	    _app_dispatcher2.default.dispatch('clear-errors', data);
	  },
	
	  openFilePicker: function openFilePicker() {
	    _analytics_dispatcher2.default.dispatch('analytics-input-actions-upload-invoke');
	    _app_dispatcher2.default.dispatch('open-file-picker');
	  },
	
	  filePasted: function filePasted(e) {
	    _app_dispatcher2.default.dispatch('file-pasted', e);
	  },
	
	  fileChosen: function fileChosen(e, source) {
	    _app_dispatcher2.default.dispatch('file-chosen', e, source);
	  },
	
	  changeFileName: function changeFileName(data) {
	    _app_dispatcher2.default.dispatch('change-filename', data);
	  },
	
	  /**
	   * Upload's a file to the currently active chat
	   * @param {object} data
	   * @param {string} data.jid JID of the currently active chat
	   * @param {string} data.fileName Name of the file
	   */
	  uploadFile: function uploadFile(data) {
	    _app_dispatcher2.default.dispatch('upload-file', data);
	  }
	
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Used to trigger actions on the chat message input
	 * @module actions/ChatInputActions
	 */
	exports.default = {
	
	  /**
	   * Sends a message to the currently active chat
	   * @param {object} data
	   * @param {string} data.id Message ID
	   * @param {string} data.jid JID of the currently active chat
	   * @param {string} data.text Text of the message
	   */
	
	  sendMessage: function sendMessage(data) {
	    _app_dispatcher2.default.dispatch('send-message', data);
	    _analytics_dispatcher2.default.dispatch('analytics-send-message', data);
	  },
	  clearChat: function clearChat(data) {
	    _app_dispatcher2.default.dispatch('clear-messages', data);
	  },
	  closeChat: function closeChat(data) {
	    _app_dispatcher2.default.dispatch('close-room', data);
	  },
	
	
	  /**
	   * Join room
	   * @param {object} data
	   * @param {string} data.room Name of room or user mention
	   */
	  joinChat: function joinChat(data) {
	    _app_dispatcher2.default.dispatch('join-room', data);
	  },
	  clearChatInput: function clearChatInput() {
	    _app_dispatcher2.default.dispatch('clear-chat-input');
	  },
	
	
	  /**
	   * Sets the chat input field's text value
	   * @param {object} data
	   * @param {string} data.text Text value of the message
	   */
	  setMsgValue: function setMsgValue(data) {
	    _app_dispatcher2.default.dispatch('set-message-value', data.text);
	  },
	  appendMessage: function appendMessage(data) {
	    _app_dispatcher2.default.dispatch('append-message-value', data.text);
	  },
	  setCaretPosition: function setCaretPosition(data) {
	    _app_dispatcher2.default.dispatch('set-chat-caret-position', data);
	  },
	  resetNewForcedCaretPosition: function resetNewForcedCaretPosition() {
	    _app_dispatcher2.default.dispatch('reset-new-forced-caret-position');
	  },
	  expandAttachment: function expandAttachment(data) {
	    _app_dispatcher2.default.dispatch('expand-attachment', data);
	  },
	  closeAttachment: function closeAttachment(data) {
	    _app_dispatcher2.default.dispatch('close-attachment', data);
	  },
	  toggleTooltip: function toggleTooltip(data) {
	    _app_dispatcher2.default.dispatch('toggle-tooltip', data);
	  },
	  openTooltip: function openTooltip(data) {
	    _app_dispatcher2.default.dispatch('open-tooltip', data);
	  },
	  closeTooltip: function closeTooltip(data) {
	    _app_dispatcher2.default.dispatch('close-tooltip', data);
	  },
	  showMessageLengthError: function showMessageLengthError() {
	    _app_dispatcher2.default.dispatch('show-flag', {
	      type: "error",
	      body: _forms_strings2.default.fail.message_too_long,
	      close: "auto"
	    });
	  },
	  showFileDescriptionLengthError: function showFileDescriptionLengthError() {
	    _app_dispatcher2.default.dispatch('show-flag', {
	      type: "error",
	      body: _forms_strings2.default.fail.file_description_too_long,
	      close: "auto"
	    });
	  },
	  setUserState: function setUserState(data) {
	    _app_dispatcher2.default.dispatch('set-user-state', {
	      jid: data.jid,
	      type: data.type,
	      state: data.state
	    });
	  },
	  dismissActionsDropDown: function dismissActionsDropDown() {
	    _app_dispatcher2.default.dispatch('dismiss-active-actions-dropdown');
	  },
	
	
	  getLastMessageSentByCurrentUser: function getLastMessageSentByCurrentUser(jid, cb) {
	    _app_dispatcher2.default.dispatch('get-last-message-sent-by-current-user', {
	      jid: jid,
	      cb: cb
	    });
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  description: {
	    create_room_description: 'Name your room after your team, project, or anything really.',
	    create_room_topic: 'Tell people what this room is about.',
	    privacy: 'Everyone already here will still have access. To add more people, you\'ll have to invite them.',
	    public_room: 'Anyone on your team can join this room and invite others.',
	    private_room: 'Only people invited to this room may join.',
	    choose_people_to_remove: 'Choose people to remove from this room:',
	    notif_header_prefix: 'Customize notifications for: ',
	    notif_settings_info_prefix: 'You can also change your ',
	    notif_settings_link: 'default settings',
	    notif_settings_info_suffix: ' for all rooms.',
	    notif_default: 'Change your default in Settings',
	    notif_loud: 'For every message',
	    notif_normal: function notif_normal(mention) {
	      return 'For @all, @here, and @' + mention + ' mentions only';
	    },
	    notif_quiet: function notif_quiet(mention) {
	      return 'For @' + mention + ' mentions only';
	    }
	  },
	  label: {
	    room_name: 'Room name:',
	    room_topic: 'Topic:',
	    these_people: 'These people:',
	    message: 'Message:',
	    new_room_name: 'New room name:',
	    public_room: 'Open room',
	    private_room: 'Private room',
	    global: 'Global',
	    default_text: 'Default:',
	    custom: 'Custom',
	    loud: _common_strings2.default.loud,
	    normal: _common_strings2.default.normal,
	    quiet: _common_strings2.default.quiet
	  },
	  button: {
	    try_again: 'Try again'
	  },
	  success: {
	    users_invited: 'People invited.',
	    users_removed: 'People removed.',
	    rename_flag: 'Room renamed.',
	    privacy_changed: function privacy_changed(room, privacy) {
	      return room + ' is now ' + privacy + '.';
	    },
	    room_created: function room_created(name) {
	      return name + ' created.';
	    }
	  },
	  fail: {
	    invite_fail: 'Couldn\'t invite people.',
	    remove_users: 'Couldn\'t remove people.',
	    no_users_flag: 'Choose someone to remove.',
	    rename_flag: 'Couldn\'t rename the room.',
	    create_room: 'Couldn\'t create the room.',
	    change_privacy_flag: 'Couldn\'t change the room privacy.',
	    sent_message_in_archived_room: 'Messages cannot be sent in archived rooms.',
	    message_too_long: 'Message too long.',
	    file_description_too_long: 'Message too long. It can\'t be more than 1000 characters.',
	    oto_chats_disabled: '1-1 (private) chats are disabled by the administrator.'
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 263 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  attachment: "Attachment",
	  upload_file: "Upload a file",
	  edit_message: "Edit",
	  delete_message: "Delete",
	  upload_default_name: "upload"
	};
	module.exports = exports['default'];

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof2 = __webpack_require__(23);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _layout_actions = __webpack_require__(266);
	
	var _layout_actions2 = _interopRequireDefault(_layout_actions);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _chat_header_store = __webpack_require__(267);
	
	var _chat_header_store2 = _interopRequireDefault(_chat_header_store);
	
	var _chat_input_store = __webpack_require__(270);
	
	var _chat_input_store2 = _interopRequireDefault(_chat_input_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _chat_input_actions = __webpack_require__(261);
	
	var _chat_input_actions2 = _interopRequireDefault(_chat_input_actions);
	
	var _chat_header_actions = __webpack_require__(285);
	
	var _chat_header_actions2 = _interopRequireDefault(_chat_header_actions);
	
	var _room_dropdown_actions = __webpack_require__(287);
	
	var _room_dropdown_actions2 = _interopRequireDefault(_room_dropdown_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _room_nav_actions = __webpack_require__(288);
	
	var _room_nav_actions2 = _interopRequireDefault(_room_nav_actions);
	
	var _connection_actions = __webpack_require__(215);
	
	var _connection_actions2 = _interopRequireDefault(_connection_actions);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _sentry_helper = __webpack_require__(289);
	
	var _sentry_helper2 = _interopRequireDefault(_sentry_helper);
	
	var _network_status_actions = __webpack_require__(219);
	
	var _network_status_actions2 = _interopRequireDefault(_network_status_actions);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _file_uploader_actions = __webpack_require__(260);
	
	var _file_uploader_actions2 = _interopRequireDefault(_file_uploader_actions);
	
	var _video_actions = __webpack_require__(172);
	
	var _video_actions2 = _interopRequireDefault(_video_actions);
	
	var _video_service_keys = __webpack_require__(174);
	
	var _video_service_keys2 = _interopRequireDefault(_video_service_keys);
	
	var _dalError = __webpack_require__(147);
	
	var _dalError2 = _interopRequireDefault(_dalError);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The HipChat web client's top level API,
	 * for use by native wrappers and experiments.
	 *
	 * @module API
	 */
	
	
	function _isVideoEnabled() {
	  var jid = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	
	  var isChat = _utils2.default.jid.is_chat(jid);
	  var isRoom = _utils2.default.jid.is_room(jid);
	
	  if (!isChat) {
	    return false;
	  }
	
	  var video_enabled = _chat_header_store2.default.get('video_enabled');
	  var enso_enabled = _chat_header_store2.default.get('web_client_enso_video_enabled');
	  var room_enabled = _chat_header_store2.default.get('web_client_enso_room_video_enabled');
	
	  if (isRoom) {
	    return video_enabled && enso_enabled && room_enabled;
	  }
	  return video_enabled;
	}
	
	var API = function () {
	  function API() {
	    (0, _classCallCheck3.default)(this, API);
	
	
	    /**
	     * @type {object}
	     * @property {number} ConnectionStatus.CONNECTED 1
	     * @property {number} ConnectionStatus.CONNECTING 2
	     * @property {number} ConnectionStatus.DISCONNECTED 3
	     * @property {number} ConnectionStatus.DISCONNECTING 4
	     * @property {number} ConnectionStatus.NETWORK_DOWN 5
	     * @property {number} ConnectionStatus.NETWORK_UP 6
	     * @property {number} ConnectionStatus.ERROR 0
	     *
	     * @constant ConnectionStatus
	    */
	    this.ConnectionStatus = {
	      CONNECTED: 1,
	      CONNECTING: 2,
	      DISCONNECTED: 3,
	      DISCONNECTING: 4,
	      NETWORK_DOWN: 5,
	      NETWORK_UP: 6,
	      SUSPEND: 7,
	      ERROR: 0
	    };
	
	    /**
	     * @type {object}
	     * @property {string} FileUploaderErrors.FILE_TOO_LARGE 'file_too_large'
	     * @property {string} FileUploaderErrors.FILE_IS_FOLDER 'file_is_folder'
	     * @property {string} FileUploaderErrors.UNABLE_TO_UPLOAD 'unable_to_upload'
	     *
	     * @constant FileUploaderErrors
	     */
	    this.FileUploaderErrors = {
	      FILE_TOO_LARGE: 'file_too_large',
	      FILE_IS_FOLDER: 'file_is_folder',
	      UNABLE_TO_UPLOAD: 'unable_to_upload'
	    };
	  }
	
	  /**
	   * Gets the init data received by the web client
	   * from the server on initial connect. Filtered
	   * to data pertinente to native clients
	   * @param {object} initData the web client's initialization data
	   * @param {string} initData.user_jid the jid of the current user
	   * @param {string} initData.user_id the user id of the current user
	   * @param {string} initData.group_id the group id of the current group
	   * @param {string} initData.group_name the name of the current group
	   * @param {string} initData.photo_large a large version of the current users avatar image
	   * @param {string} initData.photo_small a small version of the current users avatar image
	   * @param {string} initData.oauth_token the oauth2_token for the currently logged in user
	   * @param {object} initData.apiv1_token the api token information for the currently logged in user
	   * @returns {object|false} returns false if init data not received by web client
	   *
	   * @method getInitData
	   * @static
	   */
	
	
	  (0, _createClass3.default)(API, [{
	    key: 'getInitData',
	    value: function getInitData() {
	      if (!_application_store2.default.local.initialized) {
	        return false;
	      }
	
	      var current_user = _application_store2.default.get("current_user");
	      return _.merge({}, {
	        user_jid: current_user.user_jid,
	        user_id: current_user.user_id,
	        photo_large: current_user.photo_large,
	        photo_small: current_user.photo_small,
	        oauth_token: _configuration_store2.default.getOAuthToken(),
	        apiv1_token: _configuration_store2.default.getApiV1Token(),
	        group_id: _application_store2.default.get("group_id"),
	        group_name: _application_store2.default.get("group_name")
	      });
	    }
	
	    /**
	     * Gets the current user's server and client preferences
	     * see {@link prefs} for keys
	     * @returns {Object} prefs the user/client prefs
	     *
	     * @method getPreferences
	     * @static
	     */
	
	  }, {
	    key: 'getPreferences',
	    value: function getPreferences() {
	      return _preferences_store2.default.getAll();
	    }
	
	    /**
	     * Get a user object by name
	     *
	     * @param {string} name user name query
	     * @returns {Object} the found user object or undefined if not found
	     *
	     * @method getUserByName
	     * @static
	     */
	
	  }, {
	    key: 'getUserByName',
	    value: function getUserByName(name) {
	      if (_.isString(name)) {
	        var roster = _application_store2.default.get("roster");
	        var result = _.find(roster, function (user) {
	          if (_.has(user, "name")) {
	            return name.toLowerCase() === user.name.toLowerCase();
	          }
	        });
	        return result;
	      }
	    }
	
	    /**
	     * Get a user object by @mention
	     *
	     * @param {string} mention user mention query
	     * @returns {Object} the found user object or undefined if not found
	     *
	     * @method getUserByMention
	     * @static
	     */
	
	  }, {
	    key: 'getUserByMention',
	    value: function getUserByMention(mention) {
	      if (_.isString(mention)) {
	        mention = mention.charAt(0) === "@" ? mention.slice(1) : mention;
	        var roster = _application_store2.default.get("roster");
	        var result = _.find(roster, function (user) {
	          if (_.has(user, "mention_name")) {
	            return mention.toLowerCase() === user.mention_name.toLowerCase();
	          }
	        });
	        return result;
	      }
	    }
	
	    /**
	     * Request Addlive credentials from the server
	     *
	     * @method requestAddLiveCredentials
	     * @returns {Promise<AddLiveCredentials, AddLiveCredentialsError>}
	     */
	
	  }, {
	    key: 'requestAddLiveCredentials',
	    value: function requestAddLiveCredentials() {
	      return new _promise2.default(function (resolve, reject) {
	        _app_actions2.default.requestAddLiveCredentials(_configuration_store2.default.get('jid'), function (error, data) {
	          if (error) {
	            /**
	             * @typedef {object} AddLiveCredentialsError
	             * @property {integer} code
	             * @property {string} message
	             */
	            return reject({
	              message: _.get(error, 'text.__text', ''),
	              code: parseInt(error.code, 10)
	            });
	          }
	          /**
	           * @typedef {object} AddLiveCredentials
	           * @property {integer} app_id
	           * @property {integer} user_id
	           * @property {string} scope_id
	           * @property {string} salt
	           * @property {number} expires
	           * @property {string} signature
	           */
	          resolve({
	            app_id: parseInt(data.app_id, 10),
	            user_id: parseInt(data.user_id, 10),
	            scope_id: data.scope_id,
	            salt: data.salt,
	            expires: parseInt(data.expires, 10),
	            signature: data.signature
	          });
	        });
	      });
	    }
	
	    /**
	     * Joins an AddLive video call
	     *
	     * @param {String} jid The JID that the call is connecting to
	     * @param {Boolean} audio_only Whether or not to exclude video
	     */
	
	  }, {
	    key: 'joinAddLiveCall',
	    value: function joinAddLiveCall(jid) {
	      var audio_only = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      _video_actions2.default.joinAddLiveCall({
	        jid: jid,
	        audio_only: audio_only
	      });
	    }
	
	    /**
	     * Leaves an AddLive video call
	     *
	     * @param {String} jid The JID that the call is connecting to
	     */
	
	  }, {
	    key: 'leaveAddLiveCall',
	    value: function leaveAddLiveCall(jid) {
	      _video_actions2.default.endAddLiveVideoSession(jid);
	      _video_actions2.default.leaveAddLiveCall(jid);
	    }
	
	    /**
	     * Notifies the web app that the connection has changed
	     *
	     * @param {number} connectionStatus see {@link module:API~ConnectionStatus} for values
	     * @param {function} [callback=noop]
	     *
	     * @example
	     *  // onConnectionChanged(HC.api.ConnectionStatus.CONNECTED)
	     * @method onConnectionChanged
	     * @static
	     */
	
	  }, {
	    key: 'onConnectionChanged',
	    value: function onConnectionChanged(ConnectionStatus) {
	      var callback = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      switch (ConnectionStatus) {
	        case this.ConnectionStatus.CONNECTED:
	          _app_dispatcher2.default.registerOnce('after:strophe-reconnected', callback);
	          _connection_actions2.default.reconnect();
	          break;
	        case this.ConnectionStatus.CONNECTING:
	          break;
	        case this.ConnectionStatus.DISCONNECTED:
	          _connection_actions2.default.disconnect(true);
	          break;
	        case this.ConnectionStatus.DISCONNECTING:
	          break;
	        case this.ConnectionStatus.ERROR:
	          _logger2.default.error("Connection error");
	          break;
	        case this.ConnectionStatus.NETWORK_DOWN:
	          _network_status_actions2.default.onNetworkDown();
	          break;
	        case this.ConnectionStatus.NETWORK_UP:
	          _network_status_actions2.default.onNetworkUp();
	          break;
	        case this.ConnectionStatus.SUSPEND:
	          _app_dispatcher2.default.registerOnce('after:strophe-disconnected', callback);
	          _connection_actions2.default.disconnect(false);
	          break;
	        default:
	          _logger2.default.error("Connection status invalid");
	          break;
	      }
	    }
	
	    /**
	     * Sets preferences
	     * User/server preferences will be automatically sorted and synced appropriately
	     * User preferences are synced to localStorage, while server preferences are
	     * synced via the /preferences api
	     *
	     * @param {Object.<key, value>} prefs see {@link prefs} for accepted keys
	     *
	     * @method setPreferences
	     * @static
	     */
	
	  }, {
	    key: 'setPreferences',
	    value: function setPreferences(prefs) {
	      _preferences_actions2.default.savePreferences(prefs);
	    }
	
	    /**
	     * Sets user idle status
	     * Supports {"idle": boolean} and {"show": string} currently.
	     *
	     * @param {Object.<key, value>} - {"idle": true} or {"idle": false} or {"show": "chat|away|xa|dnd|unavailable"}
	     *
	     * @method setUserStatus
	     * @static
	     */
	
	  }, {
	    key: 'setUserStatus',
	    value: function setUserStatus(userStatus) {
	      if ((typeof userStatus === 'undefined' ? 'undefined' : (0, _typeof3.default)(userStatus)) !== "object") {
	        return _logger2.default.error("API: setUserStatus: object expected");
	      }
	
	      if (userStatus.show) {
	        _current_user_actions2.default.changeStatus(userStatus);
	      } else if (userStatus.idle) {
	        _current_user_actions2.default.goIdle();
	      } else {
	        _current_user_actions2.default.returnToActive();
	      }
	    }
	
	    /**
	     * Open the lobby
	     *
	     * @method openLobby
	     * @static
	     */
	
	  }, {
	    key: 'openLobby',
	    value: function openLobby() {
	      _room_nav_actions2.default.openLobby();
	    }
	
	    /**
	     * Open the quick switcher
	     *
	     * @method openQuickSwitcher
	     * @static
	     */
	
	  }, {
	    key: 'openQuickSwitcher',
	    value: function openQuickSwitcher() {
	      _dialog_actions2.default.showQuickSwitcherDialog();
	    }
	
	    /**
	     * Open a chat - room or 1-to-1
	     *
	     * @param {Object.<key, value>} - {"jid": "jid"}
	     *
	     * @method openChat
	     * @static
	     */
	
	  }, {
	    key: 'openChat',
	    value: function openChat(data) {
	      _app_actions2.default.openChatByJID(data);
	      this.focusChatInput();
	    }
	
	    /**
	     * Places focus in the chat input
	     *
	     * @method focusChatInput
	     * @static
	     */
	
	  }, {
	    key: 'focusChatInput',
	    value: function focusChatInput() {
	      var chatInput = document.getElementById(_app_config2.default.chat_input_id);
	
	      if (chatInput) {
	        chatInput.focus();
	      }
	    }
	
	    /**
	     * Open the create room dialog
	     *
	     * @param {Object.<key, value>} - {"room_name": "room name", "room_topic": "topic", "privacy": "private" || "public"}
	     *
	     * @method createRoom
	     * @static
	     */
	
	  }, {
	    key: 'createRoom',
	    value: function createRoom(data) {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.create_new_room) {
	        _dialog_actions2.default.showCreateRoomDialog(data);
	      }
	    }
	
	    /**
	     * Open the delete room dialog
	     *
	     * @method deleteRoom
	     */
	
	  }, {
	    key: 'deleteRoom',
	    value: function deleteRoom() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	
	      var _ChatHeaderStore$get = _chat_header_store2.default.get('chat');
	
	      var jid = _ChatHeaderStore$get.jid;
	      var name = _ChatHeaderStore$get.name;
	
	      if (actions.delete_room) {
	        _dialog_actions2.default.showDeleteRoomDialog({ jid: jid, name: name });
	      }
	    }
	
	    /**
	     * Open the invite users dialog
	     *
	     * @method inviteUsersToRoom
	     * @static
	     */
	
	  }, {
	    key: 'inviteUsersToRoom',
	    value: function inviteUsersToRoom() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.invite_users) {
	        _dialog_actions2.default.showInviteUsersDialog();
	      }
	    }
	
	    /**
	     * Open the remove users dialog
	     *
	     * @method removeUsersFromRoom
	     */
	
	  }, {
	    key: 'removeUsersFromRoom',
	    value: function removeUsersFromRoom() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.remove_users) {
	        _dialog_actions2.default.showRemoveUsersDialog();
	      }
	    }
	
	    /**
	     * blur the app
	     *
	     * @method blurApp
	     * @static
	     */
	
	  }, {
	    key: 'blurApp',
	    value: function blurApp() {
	      _app_dispatcher2.default.dispatch("application-blurred");
	    }
	
	    /**
	     * focus the app
	     *
	     * @method focusApp
	     * @static
	     */
	
	  }, {
	    key: 'focusApp',
	    value: function focusApp() {
	      _app_dispatcher2.default.dispatch("application-focused");
	    }
	
	    /**
	     * Focus the search input
	     *
	     * @method focusSearch
	     * @static
	     */
	
	  }, {
	    key: 'focusSearch',
	    value: function focusSearch() {
	      _app_dispatcher2.default.dispatch("focus-search");
	    }
	
	    /**
	     * Gets information about the active chat - room or 1-to-1
	     * @returns {Object}
	     *
	     * @method getActiveChat
	     * @static
	     */
	
	  }, {
	    key: 'getActiveChat',
	    value: function getActiveChat() {
	      var jid = _application_store2.default.get("active_chat");
	      var activeChat = _application_store2.default.data.activeRooms[jid];
	
	      return activeChat;
	    }
	
	    /**
	     * Get the list of actions that can be taken on the currently active room
	     *
	     * @method getCurrentRoomActions
	     * @return {object}
	     */
	
	  }, {
	    key: 'getCurrentRoomActions',
	    value: function getCurrentRoomActions() {
	      return _chat_header_store2.default.getCurrentRoomActions();
	    }
	
	    /**
	     * Open a new external window pointed to the integrations url for current user/room
	     *
	     * @method openIntegrationsWindow
	     */
	
	  }, {
	    key: 'openIntegrationsWindow',
	    value: function openIntegrationsWindow() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.integrations) {
	        _spi2.default.openExternalWindow(_integration_helper2.default.getIntegrationsUrl(_configuration_store2.default.get('web_server'), _chat_header_store2.default.get('chat').id, _configuration_store2.default.get('user_id'), _integration_helper2.default.API_SOURCE_ID));
	      }
	    }
	
	    /**
	     * Opens room notifications dialog, if you are in a group chat
	     * and room notifications are enabled
	     *
	     * @method openRoomNotificationsDialog
	     */
	
	  }, {
	    key: 'openRoomNotifications',
	    value: function openRoomNotifications() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	
	      var _ChatHeaderStore$get2 = _chat_header_store2.default.get('chat');
	
	      var jid = _ChatHeaderStore$get2.jid;
	      var room_name = _ChatHeaderStore$get2.name;
	
	      if (actions.room_notifications) {
	        _dialog_actions2.default.showRoomNotificationsDialog({ jid: jid, room_name: room_name });
	      }
	    }
	
	    /**
	     * Archive the currently open room
	     *
	     * @method archiveRoom
	     */
	
	  }, {
	    key: 'archiveRoom',
	    value: function archiveRoom() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.archive_room) {
	        _dialog_actions2.default.showArchiveRoomDialog({ archive: true });
	      }
	    }
	
	    /**
	     * Unarchive the currently open room
	     *
	     * @method unarchiveRoom
	     */
	
	  }, {
	    key: 'unarchiveRoom',
	    value: function unarchiveRoom() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.unarchive_room) {
	        _dialog_actions2.default.showArchiveRoomDialog({ archive: false });
	      }
	    }
	
	    /**
	     * Open the edit room topic input in the chat header
	     *
	     * @method changeRoomTopic
	     */
	
	  }, {
	    key: 'changeRoomTopic',
	    value: function changeRoomTopic() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.change_topic) {
	        _room_dropdown_actions2.default.editTopic();
	      }
	    }
	
	    /**
	     * Open the change room privacy dialog
	     *
	     * @method changeRoomPrivacy
	     */
	
	  }, {
	    key: 'changeRoomPrivacy',
	    value: function changeRoomPrivacy() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	
	      var _ChatHeaderStore$get3 = _chat_header_store2.default.get('chat');
	
	      var jid = _ChatHeaderStore$get3.jid;
	      var name = _ChatHeaderStore$get3.name;
	      var privacy = _ChatHeaderStore$get3.privacy;
	
	      if (actions.change_privacy) {
	        _dialog_actions2.default.showRoomPrivacyDialog({ jid: jid, name: name, privacy: privacy });
	      }
	    }
	
	    /**
	     * Open the rename room dialog
	     *
	     * @method renameRoom
	     */
	
	  }, {
	    key: 'renameRoom',
	    value: function renameRoom() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	
	      var _ChatHeaderStore$get4 = _chat_header_store2.default.get('chat');
	
	      var jid = _ChatHeaderStore$get4.jid;
	      var name = _ChatHeaderStore$get4.name;
	
	      if (actions.rename_room) {
	        _dialog_actions2.default.showRenameRoomDialog({ jid: jid, name: name });
	      }
	    }
	
	    /**
	     * Enable guest access in the current room
	     *
	     * @method enableGuestAccess
	     */
	
	  }, {
	    key: 'enableGuestAccess',
	    value: function enableGuestAccess() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	
	      var _ChatHeaderStore$get5 = _chat_header_store2.default.get('chat');
	
	      var jid = _ChatHeaderStore$get5.jid;
	
	      if (actions.enable_guest_access) {
	        _room_dropdown_actions2.default.enableGuestAccess({ jid: jid });
	      }
	    }
	
	    /**
	     * Show disable guest access dialog
	     *
	     * @method disableGuestAccess
	     */
	
	  }, {
	    key: 'disableGuestAccess',
	    value: function disableGuestAccess() {
	      var actions = _chat_header_store2.default.getCurrentRoomActions();
	      if (actions.disable_guest_access) {
	        _dialog_actions2.default.showDisableGuestAccessDialog();
	      }
	    }
	
	    /**
	     * Close the currently open chat (if it can be)
	     *
	     * @method closeActiveChat
	     * @static
	     */
	
	  }, {
	    key: 'closeActiveChat',
	    value: function closeActiveChat() {
	      var jid = _application_store2.default.get("active_chat");
	      if (_utils2.default.jid.is_chat(jid)) {
	        _room_nav_actions2.default.close(jid, _utils2.default.room.detect_chat_type(jid));
	      } else if (_utils2.default.jid.is_search(jid)) {
	        this.closeSearchResults();
	      }
	    }
	
	    /**
	     * Close the currently open search results (if it can be)
	     *
	     * @method closeSearchResults
	     * @static
	     */
	
	  }, {
	    key: 'closeSearchResults',
	    value: function closeSearchResults() {
	      _room_nav_actions2.default.closeSearchResults();
	    }
	
	    /**
	     * Gets information about the active chat - room or 1-to-1
	     * @returns {Object}
	     *
	     * @method getActiveChat
	     * @static
	     */
	
	  }, {
	    key: 'getActiveChats',
	    value: function getActiveChats() {
	      return _application_store2.default.data.activeRooms;
	    }
	
	    /**
	     * Navigate to the chat opened above this one,
	     * if this is the first chat, navigate to the last
	     *
	     * @method navigateChatUp
	     * @static
	     */
	
	  }, {
	    key: 'navigateChatUp',
	    value: function navigateChatUp() {
	      _app_dispatcher2.default.dispatch('navigate-rooms', {
	        direction: "up"
	      });
	    }
	
	    /**
	     * Navigate to the chat opened below this one,
	     * if this is the last chat, navigate to the first
	     *
	     * @method navigateChatDown
	     * @static
	     */
	
	  }, {
	    key: 'navigateChatDown',
	    value: function navigateChatDown() {
	      _app_dispatcher2.default.dispatch('navigate-rooms', {
	        direction: "down"
	      });
	    }
	
	    /**
	     * Navigate to the chat at the top of your list.  If you are at the top chat,
	     * or there are no chats open, this will do nothing.
	     *
	     * @method navigateToTopChat
	     * @static
	     */
	
	  }, {
	    key: 'navigateToTopChat',
	    value: function navigateToTopChat() {
	      _app_dispatcher2.default.dispatch('navigate-rooms', {
	        direction: "top"
	      });
	    }
	
	    /**
	     * Navigate to the chat at the bottom of your list.  If you are at the bottom chat,
	     * or there are no chats open, this will do nothing.
	     *
	     * @method navigateToBottomChat
	     * @static
	     */
	
	  }, {
	    key: 'navigateToBottomChat',
	    value: function navigateToBottomChat() {
	      _app_dispatcher2.default.dispatch('navigate-rooms', {
	        direction: "bottom"
	      });
	    }
	
	    /**
	     * Navigate to the chat at the index specified.  If no chat is found at that index
	     * this will do nothing.
	     *
	     * @method navigateToChatAtIndex
	     * @static
	     */
	
	  }, {
	    key: 'navigateToChatAtIndex',
	    value: function navigateToChatAtIndex(index) {
	      _app_dispatcher2.default.dispatch('navigate-rooms', {
	        direction: "index",
	        index: index
	      });
	    }
	
	    /**
	     * Open the modal preferences dialog
	     *
	     * @method showPreferencesDialog
	     * @static
	     */
	
	  }, {
	    key: 'showPreferencesDialog',
	    value: function showPreferencesDialog() {
	      _dialog_actions2.default.showSettingDialog();
	    }
	
	    /**
	     * Toggle sound notifications
	     *
	     * @method toggleSoundNotifications
	     * @static
	     */
	
	  }, {
	    key: 'toggleSoundNotifications',
	    value: function toggleSoundNotifications() {
	      _app_dispatcher2.default.dispatch('toggle-sound-notifications');
	    }
	
	    /**
	     * Clear unread message counts
	     *
	     * @method markChatsAsRead
	     * @static
	     */
	
	  }, {
	    key: 'markChatsAsRead',
	    value: function markChatsAsRead() {
	      _app_dispatcher2.default.dispatch('mark-chats-as-read');
	    }
	
	    /**
	     * Clear unread message counts for rooms only
	     *
	     * @method markRoomsAsRead
	     * @static
	     */
	
	  }, {
	    key: 'markRoomsAsRead',
	    value: function markRoomsAsRead() {
	      _app_dispatcher2.default.dispatch('mark-rooms-as-read');
	    }
	
	    /**
	     * Clear unread message counts for people only
	     *
	     * @method markPeopleAsRead
	     * @static
	     */
	
	  }, {
	    key: 'markPeopleAsRead',
	    value: function markPeopleAsRead() {
	      _app_dispatcher2.default.dispatch('mark-people-as-read');
	    }
	
	    /**
	     * Send a message
	     *
	     * @param {Object.<key, value>} - {"text": "text message", "jid": "jid"}
	     *
	     * @method sendMessage
	     * @static
	     */
	
	  }, {
	    key: 'sendMessage',
	    value: function sendMessage(data) {
	      data.id = data.id || _chat_input_store2.default.get("message_id");
	      data.text = _utils2.default.strings.stripHiddenCharacters(data.text);
	      data.source = "api";
	      _chat_input_actions2.default.sendMessage(data);
	    }
	
	    /**
	     * Append text to the current message
	     *
	     * @param data Expects the parameter data.text, which should be the text to append
	     */
	
	  }, {
	    key: 'appendMessage',
	    value: function appendMessage(data) {
	      var text = data.text;
	
	      _chat_input_actions2.default.appendMessage({ text: text });
	    }
	
	    /**
	     * Open the invite a teammate dialog
	     *
	     * @method showInviteTeammatesDialog
	     * @static
	     */
	
	  }, {
	    key: 'showInviteTeammatesDialog',
	    value: function showInviteTeammatesDialog() {
	      _dialog_actions2.default.showInviteTeammatesDialog();
	    }
	
	    /**
	     * Reopen the last closed chat
	     *
	     * @method reopenLastChat
	     * @static
	     */
	
	  }, {
	    key: 'reopenLastChat',
	    value: function reopenLastChat() {
	      var last_chat_jid = _application_store2.default.getLastClosedChat();
	
	      if (last_chat_jid) {
	        _app_actions2.default.navigateToChat(last_chat_jid);
	        _app_actions2.default.restoreRoomOrder(last_chat_jid);
	      }
	    }
	
	    /**
	     * Recall older message from input history
	     *
	     * @method recallOlderInputHistory
	     * @static
	     */
	
	  }, {
	    key: 'recallOlderInputHistory',
	    value: function recallOlderInputHistory(e) {
	      _app_dispatcher2.default.dispatch('recall-older-message', e);
	    }
	
	    /**
	     * Recall newer message from input history
	     *
	     * @method recallNewerInputHistory
	     * @static
	     */
	
	  }, {
	    key: 'recallNewerInputHistory',
	    value: function recallNewerInputHistory(e) {
	      _app_dispatcher2.default.dispatch('recall-newer-message', e);
	    }
	
	    /**
	     * Show the Desktop 4.0 release dialog - content provided
	     * by wrappers via api or config.release_dialog_content
	     *
	     * @param {object} dialogData
	     * @param {boolean} dialogData.bgDismiss allow the modal to be dismissed by a background click
	     * @param {boolean} dialogData.assetBaseUri the asset base uri
	     * @param {object} dialogData.content the content for the release dialog
	     * @param {string} dialogData.content.title the title for the dialog
	     * @param {string} dialogData.content.intro the intro text
	     * @param {array} dialogData.content.bullets the bullet points for the dialog
	     * @param {string} dialogData.content.outro the outro text
	     * @param {string} dialogData.content.cta the call to action button text
	     *
	     * @method showDesktop4Dialog
	     * @static
	     */
	
	  }, {
	    key: 'showDesktop4Dialog',
	    value: function showDesktop4Dialog(dialogData) {
	      var content = _.isObject(_.get(dialogData, "content")) ? dialogData.content : _application_store2.default.get("release_dialog_content") || {},
	          bgDismiss = _.has(dialogData, "bgDismiss") ? dialogData.bgDismiss : true,
	          data = {
	        bgDismiss: bgDismiss,
	        content: content
	      };
	      _dialog_actions2.default.showDesktop4Dialog(data);
	    }
	
	    /**
	     * Add a file to the chat input for uploading via fileUrl
	     *
	     * @param fileUrl
	     * @param source dragndrop or paste
	     *
	     * @method addFileForUploadWithUrl
	     * @static
	     */
	
	  }, {
	    key: 'addFileForUploadWithUrl',
	    value: function addFileForUploadWithUrl(fileUrl, source) {
	      if (fileUrl) {
	        _app_actions2.default.addFileForUploadWithUrl(fileUrl, source);
	      }
	    }
	
	    /**
	     * Add a file to the chat input for uploading via base64 string
	     *
	     * @param base64 valid base64 string
	     * @param {string|null} [fileName]
	     * @param {string} source - paste or dragndrop
	     *
	     * @method addFileForUploadWithBase64
	     * @static
	     */
	
	  }, {
	    key: 'addFileForUploadWithBase64',
	    value: function addFileForUploadWithBase64(base64) {
	      var fileName = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      var source = arguments[2];
	
	      if (_chat_input_store2.default.get('uploading')) {
	        return false;
	      }
	
	      if (_.includes(['paste', 'dragndrop'], fileName)) {
	        source = fileName;
	        fileName = null;
	      }
	      if (base64) {
	        _app_actions2.default.addFileForUploadWithBase64(base64, fileName, source);
	      }
	    }
	
	    /**
	     * Trigger a file uploader error message
	     *
	     * @method showFileUploadError
	     * @param {string} [file_name] - UI will show blank if not provided
	     * @param {string} key - one of the HC.api.FileUploaderErrors enums
	     * @static
	     */
	
	  }, {
	    key: 'showFileUploadError',
	    value: function showFileUploadError(file_name, key) {
	      var jid = _application_store2.default.get('active_chat');
	      _chat_input_actions2.default.expandAttachment({ jid: jid, file_name: file_name });
	      _file_uploader_actions2.default.dispatchFileError({ jid: jid, key: key });
	    }
	
	    /**
	     * Open the file chooser dialog
	     *
	     * @method openFilePicker
	     * @static
	     */
	
	  }, {
	    key: 'openFilePicker',
	    value: function openFilePicker() {
	      _file_uploader_actions2.default.openFilePicker();
	    }
	
	    /**
	     * Clear active web cookies
	     *
	     * @param cb callback to be executed on success or failure
	     *
	     * @method clearWebCookies
	     */
	
	  }, {
	    key: 'clearWebCookies',
	    value: function clearWebCookies() {
	      var cb = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	      _app_actions2.default.clearWebCookies(cb);
	    }
	
	    /**
	     * Revoke Oauth2 token
	     *
	     * @param cb callback to be executed on success or failure
	     *
	     * @method revokeOauth2Token
	     */
	
	  }, {
	    key: 'revokeOauth2Token',
	    value: function revokeOauth2Token() {
	      var cb = arguments.length <= 0 || arguments[0] === undefined ? _.noop : arguments[0];
	
	      _app_actions2.default.revokeOauth2Token(cb);
	    }
	
	    /**
	     * Sanitize Sentry errors
	     *
	     * @param data Sentry error objects
	     * @returns {Object} sanitized error object for Sentry
	     *
	     * @method sanitizeError
	     */
	
	  }, {
	    key: 'sanitizeError',
	    value: function sanitizeError(data) {
	      if (data) {
	        return _sentry_helper2.default.sanitize(data);
	      }
	    }
	
	    /**
	     * Toggles the left sidebar
	     *
	     * @method toggleLeftSidebar
	     * @static
	     */
	
	  }, {
	    key: 'toggleLeftSidebar',
	    value: function toggleLeftSidebar() {
	      var toggle = !_preferences_store2.default.shouldShowNavigationSidebar();
	      _layout_actions2.default.setLeftSidebarVisibility(toggle);
	    }
	
	    /**
	     * Toggles the right sidebar for the active chat type
	     *
	     * @method toggleRightSidebar
	     * @static
	     */
	
	  }, {
	    key: 'toggleRightSidebar',
	    value: function toggleRightSidebar() {
	      var active_chat = _application_store2.default.get("active_chat"),
	          chat_type = _utils2.default.room.detect_chat_type(active_chat),
	          visibility = false;
	
	      if (chat_type === "chat") {
	        visibility = !_preferences_store2.default.shouldShowChatSidebar();
	        _layout_actions2.default.setRightChatSidebarVisibility(visibility);
	      } else if (chat_type === "groupchat") {
	        visibility = !_preferences_store2.default.shouldShowGroupChatSidebar();
	        _layout_actions2.default.setRightGroupChatSidebarVisibility(visibility);
	      }
	    }
	
	    /**
	     * Gets the temporary signed url and download url for the specified file
	     * @param fileUrl
	     */
	
	  }, {
	    key: 'getFileUrls',
	    value: function getFileUrls(fileUrl) {
	      return new _promise2.default(function (resolve, reject) {
	        var fetchSignedFile = function fetchSignedFile(url) {
	          _app_dispatcher2.default.dispatch('API:fetch-signed-file', {
	            url: url
	          }, function (resp) {
	            if (resp instanceof _dalError2.default) {
	              reject(resp);
	            } else {
	              resolve({
	                url: url,
	                signedUrl: resp.temp_url,
	                downloadUrl: resp.temp_download_url
	              });
	            }
	          });
	        };
	
	        if (_roster_store2.default.isSignedFile(fileUrl)) {
	          var url = fileUrl;
	          if (!_roster_store2.default.isFileUrlAuthenticated(url)) {
	            url = _roster_store2.default.getPublicUrlFromThumbnail(url);
	          }
	
	          fetchSignedFile(url);
	        } else {
	          resolve({
	            url: fileUrl,
	            signedUrl: fileUrl,
	            downloadUrl: fileUrl
	          });
	        }
	      });
	    }
	
	    /**
	     * Lets the app know that the user is on a call
	     */
	
	  }, {
	    key: 'onVideoConferenceJoined',
	    value: function onVideoConferenceJoined() {
	      _app_dispatcher2.default.dispatch('enso.video-conference-joined');
	    }
	
	    /**
	     * Lets the app know that the user has left the call
	     */
	
	  }, {
	    key: 'onVideoConferenceLeft',
	    value: function onVideoConferenceLeft() {
	      _app_dispatcher2.default.dispatch('enso.video-conference-left');
	    }
	  }, {
	    key: 'startVideoCall',
	    value: function startVideoCall() {
	      var jid = _application_store2.default.get('active_chat');
	
	      if (!_isVideoEnabled(jid)) {
	        return;
	      }
	
	      var chat = _application_store2.default.get('activeRooms')[jid];
	      var enso_enabled = _chat_header_store2.default.get('web_client_enso_video_enabled');
	      var data = {
	        jid: jid,
	        name: chat.name,
	        service: enso_enabled ? _video_service_keys2.default.ENSO : _video_service_keys2.default.ADDLIVE
	      };
	
	      if (_utils2.default.jid.is_room(jid)) {
	        data.room_id = chat.id;
	        _chat_header_actions2.default.startEnsoRoomVideo(data);
	      } else {
	        data.audio_only = false;
	        _chat_header_actions2.default.startCall(data);
	      }
	    }
	  }, {
	    key: 'isVideoEnabled',
	    value: function isVideoEnabled() {
	      var jid = _application_store2.default.get('active_chat');
	      return _isVideoEnabled(jid);
	    }
	  }, {
	    key: 'isFileSharingEnabled',
	    value: function isFileSharingEnabled() {
	      var jid = _application_store2.default.get('active_chat');
	
	      if (!_utils2.default.jid.is_chat(jid)) {
	        return false;
	      }
	
	      return _chat_input_store2.default.get('can_share_files');
	    }
	
	    /**
	     * Lets the app know that the user  is on addlive call
	     */
	
	  }, {
	    key: 'onAddLiveCall',
	    value: function onAddLiveCall() {
	      _current_user_actions2.default.onCall();
	    }
	
	    /**
	     * Scrolls down in chat on zoom
	     */
	
	  }, {
	    key: 'scrollDownOnZoom',
	    value: function scrollDownOnZoom() {
	      _app_dispatcher2.default.dispatch('scroll-down-on-zoom');
	    }
	  }]);
	  return API;
	}();
	
	exports.default = new API();
	module.exports = exports['default'];

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var AppDispatcher = __webpack_require__(9);
	
	module.exports = {
	
	  savePreferences: function savePreferences(data) {
	    AppDispatcher.dispatch("save-preferences", data);
	  },
	
	  addRoomToIntegrationDiscoveryIgnoreList: function addRoomToIntegrationDiscoveryIgnoreList(roomId) {
	    AppDispatcher.dispatch("add-room-integration-discovery-ignore-list", roomId);
	  }
	};

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * MainLayoutActions
	 */
	
	exports.default = {
	
	  setLeftSidebarVisibility: function setLeftSidebarVisibility(visibility) {
	    var data = (0, _defineProperty3.default)({}, _client_preferences_keys2.default.SHOW_NAVIGATION_SIDEBAR, visibility);
	    _app_dispatcher2.default.dispatch("save-preferences", data);
	    _app_dispatcher2.default.dispatch("left-column-width-updated");
	  },
	
	  setRightChatSidebarVisibility: function setRightChatSidebarVisibility(visibility) {
	    var data = (0, _defineProperty3.default)({}, _client_preferences_keys2.default.SHOW_CHAT_SIDEBAR, visibility);
	    _app_dispatcher2.default.dispatch("save-preferences", data);
	  },
	
	  setRightGroupChatSidebarVisibility: function setRightGroupChatSidebarVisibility(visibility) {
	    var data = (0, _defineProperty3.default)({}, _client_preferences_keys2.default.SHOW_GROUPCHAT_SIDEBAR, visibility);
	    _app_dispatcher2.default.dispatch("save-preferences", data);
	  },
	
	  saveLeftColumnWidth: function saveLeftColumnWidth(width) {
	    var data = (0, _defineProperty3.default)({}, _client_preferences_keys2.default.LEFT_COLUMN_WIDTH, width);
	    _app_dispatcher2.default.dispatch("save-preferences", data);
	    _app_dispatcher2.default.dispatch("left-column-width-updated");
	  },
	
	  saveRightColumnWidth: function saveRightColumnWidth(width) {
	    var data = (0, _defineProperty3.default)({}, _client_preferences_keys2.default.RIGHT_COLUMN_WIDTH, width);
	    _app_dispatcher2.default.dispatch("save-preferences", data);
	    _app_dispatcher2.default.dispatch("right-column-width-updated");
	  },
	
	  setRightColumnWidthIsChanging: function setRightColumnWidthIsChanging(changing) {
	    _app_dispatcher2.default.dispatch("set-right-sidebar-visible-width-is-changing", changing);
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _permissions_store = __webpack_require__(269);
	
	var _permissions_store2 = _interopRequireDefault(_permissions_store);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ChatHeaderStore = function (_Store) {
	  (0, _inherits3.default)(ChatHeaderStore, _Store);
	
	  function ChatHeaderStore() {
	    (0, _classCallCheck3.default)(this, ChatHeaderStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ChatHeaderStore).call(this));
	
	    _this.default_profile = {
	      email: '',
	      mention_name: '',
	      name: '',
	      photo_large: '',
	      photo_small: '',
	      timezone: false,
	      title: ''
	    };
	
	    _this.local = {
	      profiles: {}
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(ChatHeaderStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        initialized: false,
	        active_chat: null,
	        path_prefix: '',
	        type: '',
	        rooms: {},
	        topic_editing: false,
	        chat: {
	          jid: '',
	          name: '',
	          topic: null,
	          photo_large: '',
	          title: '',
	          status: '',
	          privacy: '',
	          is_archived: '0',
	          email: '',
	          presence: {},
	          time: '',
	          loading_profile: true
	        },
	        video_enabled: false,
	        user_is_admin: false,
	        current_user: {},
	        per_room_notifications_enabled: false
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(config) {
	          _this2.handleConfig(config);
	        }
	      });
	      _app_dispatcher2.default.register({
	        'app-state-ready': function appStateReady() {
	          _this2.set('initialized', true);
	        },
	        'updated:emoticons': function updatedEmoticons(_ref) {
	          var path_prefix = _ref.path_prefix;
	
	          _this2.set({ path_prefix: path_prefix });
	        },
	        'updated:config': function updatedConfig(config) {
	          _this2.handleConfig(config);
	        },
	        'updated:current_user': function updatedCurrent_user(user) {
	          _this2.local.profiles[user.user_jid] = _.assign({
	            name: user.user_name,
	            mention_name: user.mention
	          }, user);
	          _this2.set({
	            current_user: user
	          });
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          _this2.handleRoomsUpdate(rooms);
	          _spi2.default.onRoomActionsChanged(_this2.getCurrentRoomActions());
	        },
	        'updated:profiles': function updatedProfiles(profiles) {
	          _this2.handleProfilesUpdate(profiles);
	        },
	        'updated:roster': function updatedRoster(roster) {
	          _this2.handleRosterUpdate(roster);
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.data.active_chat = jid;
	          _this2.updateRoomHeaderState(jid);
	        },
	        'after:updated:active_chat': function afterUpdatedActive_chat() {
	          _spi2.default.onRoomActionsChanged(_this2.getCurrentRoomActions());
	        },
	        'before:set-route': function beforeSetRoute(data) {
	          if (data.jid !== _this2.data.active_chat) {
	            _this2.resetChat(data.jid);
	          }
	        },
	        'edit-topic': function editTopic() {
	          _this2.set('topic_editing', true);
	        },
	        'dismiss-topic-edit': function dismissTopicEdit() {
	          _this2.set({
	            'topic_editing': false
	          });
	        },
	        'set-topic': function setTopic(topic) {
	          _this2.handleSetTopic(topic);
	        },
	        'updated:preferences': function updatedPreferences() {
	          var jid = _this2.data.active_chat;
	          if (_utils2.default.jid.is_private_chat(jid) && _this2.data.rooms[jid]) {
	            _this2._updateChatTime(_this2.data.rooms[jid]);
	            _this2.set('chat', _this2.data.chat);
	          }
	        }
	      });
	    }
	  }, {
	    key: 'handleRoomsUpdate',
	    value: function handleRoomsUpdate(updatedRooms) {
	      var currentRooms = this.data.rooms,
	          activeChat = this.data.active_chat,
	          deleted = _.difference(_.keys(currentRooms), _.keys(updatedRooms));
	
	      if (deleted.length) {
	        currentRooms = _.omit(currentRooms, deleted);
	      }
	
	      var update = {
	        rooms: _.merge(currentRooms, updatedRooms)
	      };
	
	      if (updatedRooms[activeChat]) {
	        update.chat = _.merge(this.data.chat, updatedRooms[activeChat]);
	      }
	
	      this.set(update);
	      this.updateRoomHeaderState(activeChat);
	    }
	  }, {
	    key: 'handleProfilesUpdate',
	    value: function handleProfilesUpdate(profiles) {
	      var _this3 = this;
	
	      _.map(profiles, function (profile, jid) {
	        _this3.local.profiles[jid] = profile;
	        if (_this3.data.rooms[jid]) {
	          _this3.data.rooms[jid] = _.merge(_this3.data.rooms[jid], profile);
	        }
	      });
	      this.updateRoomHeaderState(this.data.active_chat);
	    }
	  }, {
	    key: 'updateProfile',
	    value: function updateProfile(jid, profile) {
	      var _this4 = this;
	
	      var keys = _.keys(this.default_profile);
	      _.forEach(keys, function (key) {
	        if (profile[key]) {
	          _this4.local.profiles[jid][key] = profile[key];
	        }
	      });
	    }
	  }, {
	    key: 'handleRosterUpdate',
	    value: function handleRosterUpdate(roster) {
	      var rooms = _.cloneDeep(this.data.rooms);
	      var profiles = this.local.profiles;
	      var updateProfile = this.updateProfile.bind(this);
	
	      _.forEach(rooms, function (room, jid) {
	        if (room && roster[jid]) {
	          var presence = roster[jid].presence;
	
	          room.presence = (0, _extends3.default)({}, presence);
	          room.name = roster[jid].name;
	          if (profiles[jid]) {
	            updateProfile(jid, room);
	          }
	        }
	      });
	
	      this.handleRoomsUpdate(rooms);
	    }
	  }, {
	    key: 'resetChat',
	    value: function resetChat(jid) {
	      var chat = _.assign({}, this.data.chat, this.data.rooms[jid]);
	      chat.loading_profile = true;
	      this.set("chat", chat);
	    }
	  }, {
	    key: 'updateRoomHeaderState',
	    value: function updateRoomHeaderState(jid) {
	      var _this5 = this;
	
	      clearTimeout(this.timeout);
	
	      if (!jid || _utils2.default.jid.is_lobby(jid) || !this.data.rooms[jid]) {
	        return;
	      }
	
	      var updatedChat = this.data.rooms[jid];
	      var currentChat = this.data.chat;
	      var updatedChatType = this.data.rooms[jid].type;
	      var currentChatType = this.data.type;
	      var localProfile = this.local.profiles[jid];
	      var defaultPanel = {
	        chat: 'files',
	        groupchat: 'roster'
	      };
	
	      if (currentChatType !== updatedChatType) {
	        this.data.active_panel = defaultPanel[updatedChatType];
	      }
	      if (updatedChatType === 'chat' && updatedChat) {
	        if (localProfile) {
	          updatedChat.loading_profile = false;
	        }
	        _.merge(updatedChat, _.clone(this.default_profile), localProfile);
	        this._updateChatTime(updatedChat);
	        this.timeout = setTimeout(function () {
	          _this5.updateRoomHeaderState(jid);
	        }, 60000);
	      }
	
	      var chat = _.assign({}, currentChat, updatedChat);
	      this.set({
	        active_chat: jid,
	        type: chat.type,
	        chat: chat,
	        active_panel: this.data.active_panel
	      });
	    }
	  }, {
	    key: '_updateChatTime',
	    value: function _updateChatTime(chat) {
	      var format = _preferences_store2.default.shouldUse24HrTime() ? 'ddd HH:mm' : 'ddd h:mm A';
	      if (chat.timezone) {
	        var timezone_offset = parseFloat(chat.timezone.utc_offset);
	        this.data.chat.time = (0, _moment2.default)().utcOffset(timezone_offset).format(format);
	      } else {
	        this.data.chat.time = (0, _moment2.default)().format(format);
	      }
	    }
	  }, {
	    key: 'getCurrentRoomActions',
	    value: function getCurrentRoomActions() {
	      var chat = this.data.chat,
	          activeJid = this.data.active_chat,
	          isLobby = activeJid === 'lobby',
	          isSearch = activeJid === 'search',
	          isRoom = this.data.type === 'groupchat' && !isLobby && !isSearch,
	          isAdmin = _permissions_store2.default.get('user_is_room_admin'),
	          isPublic = chat.privacy === 'public',
	          isArchived = _utils2.default.room.is_archived(chat);
	
	      if (isRoom) {
	        return {
	          room_notifications: !!this.data.per_room_notifications_enabled,
	          integrations: _permissions_store2.default.canManageRoomIntegrations() && !isArchived,
	          create_new_room: _permissions_store2.default.canCreateRoom(),
	          invite_users: (isPublic || !isPublic && isAdmin) && !isArchived,
	          remove_users: !isPublic && isAdmin && !isArchived,
	          enable_guest_access: _permissions_store2.default.canToggleGuestAccess() && !chat.guest_url,
	          disable_guest_access: _permissions_store2.default.canToggleGuestAccess() && !!chat.guest_url,
	          archive_room: isAdmin && !isArchived,
	          unarchive_room: isAdmin && isArchived,
	          change_topic: !isArchived,
	          change_privacy: isAdmin && !isArchived,
	          delete_room: isAdmin && !isArchived,
	          rename_room: isAdmin && !isArchived
	        };
	      }
	
	      return {
	        room_notifications: false,
	        integrations: false,
	        create_new_room: _permissions_store2.default.canCreateRoom(),
	        invite_users: false,
	        remove_users: false,
	        enable_guest_access: false,
	        disable_guest_access: false,
	        archive_room: false,
	        unarchive_room: false,
	        change_topic: false,
	        change_privacy: false,
	        delete_room: false,
	        rename_room: false
	      };
	    }
	  }, {
	    key: 'handleSetTopic',
	    value: function handleSetTopic(topic) {
	      topic = topic.trim();
	
	      if (topic.length > _app_config2.default.max_topic_text_length) {
	        _flag_actions2.default.showFlag({
	          type: "error",
	          body: this._flagBody(_chat_header_strings2.default.topic_length_error(_app_config2.default.max_topic_text_length)),
	          close: "auto"
	        });
	        topic = topic.substring(0, _app_config2.default.max_topic_text_length);
	      }
	
	      this.data.chat.topic = topic;
	
	      _app_dispatcher2.default.dispatch('send-topic', {
	        jid: this.data.chat.jid,
	        topic: topic
	      });
	      this.data.topic_editing = false;
	    }
	  }, {
	    key: '_flagBody',
	    value: function _flagBody(error_msg) {
	      return function () {
	        return React.createElement(
	          'div',
	          null,
	          React.createElement(
	            'p',
	            { className: 'hc-message-body' },
	            error_msg
	          )
	        );
	      };
	    }
	  }, {
	    key: 'handleConfig',
	    value: function handleConfig(config) {
	      this.set({
	        active_chat: _preferences_store2.default.get('chatToFocus') || this.data.active_chat,
	        video_enabled: _.get(config, "video_chat_enabled") && _.get(config, 'feature_flags.web_client_video_chat'),
	        per_room_notifications_enabled: _.get(config, 'feature_flags.web_client_per_room_notifications'),
	        web_client_integrations_enabled: _integration_helper2.default.isFeatureEnabled(config),
	
	        // Defaulting this feature flag to true because existing deployments of HCS don't include this flag
	        web_client_addlive_video_enabled: _.get(config, 'feature_flags.web_client_addlive_video', true),
	
	        web_client_enso_video_enabled: _.get(config, 'feature_flags.web_client_enso_video', false),
	        web_client_enso_room_video_enabled: _.get(config, 'feature_flags.web_client_enso_room_video', false)
	      });
	    }
	  }]);
	  return ChatHeaderStore;
	}(_store2.default);
	
	module.exports = new ChatHeaderStore();

/***/ },
/* 268 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  default_topic: "This is the room topic. Double click to change it.",
	  loading: "Loading",
	  beta: function beta(feature) {
	    return "Still baking! The " + feature + " feature is not in the beta, but will be soon.";
	  },
	  enso_video: "HipChat Video",
	  room_notifications: "Room Notifications",
	  integrations: "Integrations",
	  create_new_room: "Create New Room",
	  invite_users: "Invite People",
	  remove_users: "Remove People",
	  disable_guest: "Disable Guest Access",
	  guest_enabled: "Guest Access Enabled",
	  guest_disabled: "Guest Access Disabled",
	  guest_access_on: "Guest Access On",
	  enable_guest: "Enable Guest Access",
	  archive: "Archive",
	  unarchive: "Unarchive",
	  change_topic: "Change Topic",
	  change_privacy: "Change Privacy",
	  delete: "Delete",
	  rename: "Rename",
	  files: "Files",
	  links: "Links",
	  people: "People",
	  room_actions: "Room actions",
	  show_roster: "Show people",
	  hide_roster: "Hide people",
	  show_files: "Show files",
	  hide_files: "Hide files",
	  show_links: "Show links",
	  hide_links: "Hide links",
	  show_integrations: "Show integrations",
	  hide_integrations: "Hide integrations",
	  show_sidebar: "Show sidebar",
	  hide_sidebar: "Hide sidebar",
	  video_call: "Make a video call",
	  audio_call: "Make an audio call",
	  hipchat_video: "AddLive",
	  topic_length_error: function topic_length_error(maxlength) {
	    return "Maximum topic length is " + maxlength + ".";
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(47);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PermissionsStore = function (_Store) {
	  (0, _inherits3.default)(PermissionsStore, _Store);
	
	  function PermissionsStore() {
	    (0, _classCallCheck3.default)(this, PermissionsStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(PermissionsStore).call(this));
	
	    _this._hasRoomPermissionCheck = _.memoize(_this._hasRoomPermission);
	    return _this;
	  }
	
	  (0, _createClass3.default)(PermissionsStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        permissions: {},
	        room_roles: {},
	        room_permissions: {},
	        current_room: null,
	        user_is_admin: false,
	        user_is_room_admin: false,
	        current_user: {},
	        invite_url: false
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(data) {
	          _this2._init(data);
	        }
	      });
	
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(data) {
	          _this2._init(data);
	        },
	        'updated:permissions': function updatedPermissions(perms) {
	          _this2.set('permissions', perms);
	        },
	        'updated:current_user': function updatedCurrent_user(user) {
	          _this2.set('current_user', user);
	          _this2._updateCurrentRoomRoles();
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          var roomRolesInformation = _.mapValues(rooms, function (room) {
	            return { admins: room.admins, owner: room.owner };
	          });
	          var updatedRoomRoles = _.merge(_this2.data.room_roles, roomRolesInformation);
	
	          _this2.set('room_roles', updatedRoomRoles);
	          _this2._updateCurrentRoomRoles();
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2._clearPermissionsCache();
	          _this2.data.current_room = jid;
	          _this2._updateCurrentRoomRoles();
	        },
	        'DAL:handle-joined-rooms': function DALHandleJoinedRooms(rooms) {
	          _this2._updateRoomPermissions(rooms);
	        }
	      });
	    }
	  }, {
	    key: '_init',
	    value: function _init(data) {
	      this.set({
	        user_is_admin: data.is_admin,
	        invite_url: data.invite_url
	      });
	    }
	  }, {
	    key: 'canCreateRoom',
	    value: function canCreateRoom() {
	      var permissions = this.data.permissions;
	      return permissions.create_rooms === "all" || permissions.create_rooms === "admins" && this.data.user_is_admin;
	    }
	  }, {
	    key: 'canInviteUsersToGroup',
	    value: function canInviteUsersToGroup() {
	      return !_configuration_store2.default.get('feature_flags').hide_invite_your_team_button && (this.data.user_is_admin === true || this.data.invite_url);
	    }
	  }, {
	    key: 'canViewGuestAccess',
	    value: function canViewGuestAccess() {
	      return this._hasRoomPermissionCheck('room:view_guest_access');
	    }
	  }, {
	    key: 'canToggleGuestAccess',
	    value: function canToggleGuestAccess() {
	      return this._hasRoomPermissionCheck('room:toggle_guest_access');
	    }
	  }, {
	    key: '_hasRoomPermission',
	    value: function _hasRoomPermission(permission) {
	      var user_jid = _.get(this.data.current_user, "jid"),
	          current_room_permissions = this.data.room_permissions[this.data.current_room] || {},
	          current_user_room_permissions = current_room_permissions[user_jid] || [];
	
	      return current_user_room_permissions.indexOf(permission) !== -1;
	    }
	  }, {
	    key: 'canManageRoomIntegrations',
	    value: function canManageRoomIntegrations() {
	      return this.data.user_is_admin === true || this.data.user_is_room_admin === true || this.data.permissions.manage_room_integrations === 'all';
	    }
	  }, {
	    key: 'canUpdateRoomIntegrations',
	    value: function canUpdateRoomIntegrations() {
	      return this.data.user_is_admin === true || this.data.user_is_room_admin === true;
	    }
	  }, {
	    key: '_updateRoomPermissions',
	    value: function _updateRoomPermissions(rooms) {
	      var _this3 = this;
	
	      var user_jid = this.data.current_user.jid;
	      _utils2.default.toArray(rooms).forEach(function (room) {
	        _.set(_this3.data.room_permissions, [room.jid, user_jid], room.permissions);
	      });
	      this._clearPermissionsCache();
	      this.set('room_permissions', this.data.room_permissions);
	    }
	  }, {
	    key: '_updateCurrentRoomRoles',
	    value: function _updateCurrentRoomRoles() {
	      var current_room_admins = _.get(this.data.room_roles, [this.data.current_room, 'admins'], []);
	      var current_room_owner = _.get(this.data.room_roles, [this.data.current_room, 'owner'], null);
	      var user_is_room_admin = _utils2.default.user.is_admin(current_room_admins, current_room_owner, this.data.current_user);
	
	      this.set({
	        user_is_room_admin: user_is_room_admin
	      });
	    }
	  }, {
	    key: '_clearPermissionsCache',
	    value: function _clearPermissionsCache() {
	      this._hasRoomPermissionCheck.cache.clear();
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      (0, _get3.default)((0, _getPrototypeOf2.default)(PermissionsStore.prototype), 'clear', this).call(this);
	      this._clearPermissionsCache();
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      (0, _get3.default)((0, _getPrototypeOf2.default)(PermissionsStore.prototype), 'reset', this).call(this);
	      this._clearPermissionsCache();
	    }
	  }]);
	  return PermissionsStore;
	}(_store2.default);
	
	module.exports = new PermissionsStore();

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getIterator2 = __webpack_require__(114);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _chat_search = __webpack_require__(273);
	
	var _file_input_errors = __webpack_require__(274);
	
	var _file_input_errors2 = _interopRequireDefault(_file_input_errors);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _slash_command_helper = __webpack_require__(275);
	
	var _user_utils = __webpack_require__(126);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _keyboard_shortcuts = __webpack_require__(279);
	
	var _keyboard_shortcuts2 = _interopRequireDefault(_keyboard_shortcuts);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ChatInputStore = function (_Store) {
	  (0, _inherits3.default)(ChatInputStore, _Store);
	
	  function ChatInputStore() {
	    (0, _classCallCheck3.default)(this, ChatInputStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ChatInputStore).call(this));
	
	    _this.local = {
	      unsentText: {}, // map of last input text value
	      uploadingStatus: {}, // map of jid to uploading status
	      allRooms: {}, // map of allRooms to get active chat data needed for store
	      guests: [], // local property for mention autocomplete, should not trigger a render
	      members: [], // local property for mention autocomplete, should not trigger a render
	      users: {}, // local property for mention autocomplete, should not trigger a render
	      room_privacy: '', // local property for mention autocomplete, should not trigger a render
	      caret_position: 0, // current caret position of the input, should not trigger a render
	      input_history: {}, // map of chat input text history
	      input_history_index: {}, // map of current index of chat input history in use
	      unsent_text_before_recall: {}, // map of unsent text in input typed before recalling input history
	      upload_progress: {}
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(ChatInputStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        active_autocomplete: null,
	        active_chat: null,
	        active_chat_id: null,
	        attachment_expanded: false,
	        can_share_files: true,
	        can_use_oto_chats: true,
	        chat_type: '',
	        default_mentions: _.map(_app_config2.default.core_mentions, function (mention) {
	          return {
	            jid: mention.jid,
	            name: mention.name,
	            mention_name: mention.mention_name,
	            presence: {
	              show: _presence2.default.AVAILABLE
	            }
	          };
	        }),
	        emoticon_list: [],
	        emoticon_text: '',
	        emoticon_selected_item: 0,
	        emoticon_results_count: 0,
	        emoticon_regex: _app_config2.default.emoticon_regex,
	        file: null,
	        file_error: false,
	        file_error_message: '',
	        file_name: '',
	        mention_list: [],
	        mention_text: '',
	        mention_selected_item: 0,
	        mention_results_count: 0,
	        mention_regex: _app_config2.default.mention_regex,
	        message_id: 0,
	        new_forced_caret_position: 0,
	        path_prefix: '',
	        post_emoticon_text: '',
	        post_mention_text: '',
	        pre_emoticon_text: '',
	        pre_mention_text: '',
	        room_is_archived: true,
	        should_animate_avatar: true,
	        slash_command_list: [],
	        slash_command_results_count: 0,
	        slash_command_selected_item: 0,
	        smileys: {},
	        text: '',
	        uploading: false,
	        upload_progress: null,
	        user_is_admin: false,
	        user_is_guest: false,
	        user_state: 'active',
	        video_enabled: false,
	        keyboard_shortcuts: null,
	        keyboard_shortcuts_initialized: false,
	        web_server: ''
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(config) {
	          _this2.handleConfig(config);
	        }
	      });
	
	      _app_dispatcher2.default.register({
	        'app-state-ready': function appStateReady() {
	          _this2.set('initialized', true);
	
	          if (!_this2.data.keyboard_shortcuts_initialized) {
	            _this2.set('keyboard_shortcuts_initialized', true);
	            _keyboard_shortcuts2.default.init(_this2.data.keyboard_shortcuts);
	          }
	        },
	        'updated:config': function updatedConfig(config) {
	          _this2.handleConfig(config);
	        },
	        'updated:preferences': function updatedPreferences() {
	          _this2.handlePreferences();
	        },
	        'updated:current_user': function updatedCurrent_user(data) {
	          _this2.data.user_is_admin = !!data.is_admin;
	          _this2.data.user_is_guest = !!data.is_guest;
	        },
	        'updated:web_server': function updatedWeb_server(server) {
	          _this2.data.web_server = server;
	        },
	        'updated:permissions': function updatedPermissions(perms) {
	          _this2.set({
	            can_share_files: perms.file_sharing === 'all',
	            can_use_oto_chats: perms.oto_chat === 'all'
	          });
	        },
	        'close-room': function closeRoom(data) {
	          _this2.deleteInputHistory(data.jid);
	          _this2.deleteUnsentText(data.jid);
	          _this2.deleteUploadingStatus(data.jid);
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          _this2.handleActiveRoomsUpdate(rooms);
	        },
	        'send-message': function sendMessage(data) {
	          _this2.saveInputHistory(data);
	          _this2.resetHistoryIndex(data.jid);
	          _this2.data.message_id++;
	          if (data.source !== 'api') {
	            _this2.set({
	              text: '',
	              message_id: _this2.data.message_id,
	              user_state: 'active'
	            });
	          }
	        },
	        'initiate-edit-message': function initiateEditMessage(msg) {
	          var isExpired = Date.now() - msg.time * 1000 > _app_config2.default.edit_message_threshold;
	          if (isExpired) {
	            _dialog_actions2.default.showNotEditableDialog({ action: 'edit' });
	          } else if (!msg.is_deleted) {
	            _dialog_actions2.default.showEditMessageDialog(msg);
	          }
	        },
	        'initiate-delete-message': function initiateDeleteMessage(msg) {
	          var isExpired = Date.now() - msg.time * 1000 > _app_config2.default.edit_message_threshold;
	          if (isExpired) {
	            _dialog_actions2.default.showNotEditableDialog({ action: 'delete' });
	          } else if (!msg.is_deleted) {
	            _dialog_actions2.default.showDeleteMessageDialog(msg);
	          }
	        },
	        'clear-messages': function clearMessages() {
	          _this2.clearText();
	        },
	        'clear-chat-input': function clearChatInput() {
	          _this2.clearText();
	        },
	        'recall-newer-message': function recallNewerMessage(e) {
	          if (_this2.isFocused()) {
	            _this2.recallNewerMessage();
	            e.preventDefault();
	          }
	        },
	        'recall-older-message': function recallOlderMessage(e) {
	          if (_this2.isFocused()) {
	            _this2.recallOlderMessage();
	            e.preventDefault();
	          }
	        },
	        'updated:smileys': function updatedSmileys(data) {
	          var smileys = _.keyBy(_.keyBy(data, 'file'), 'shortcut');
	          _this2.set({ smileys: smileys });
	        },
	        'updated:emoticons': function updatedEmoticons(data) {
	          _this2.set({
	            path_prefix: data.path_prefix,
	            emoticons: data.icons
	          });
	        },
	        'before:updated:active_chat': function beforeUpdatedActive_chat() {
	          _this2.setUnsentText(_this2.data.active_chat);
	          _this2.setUploadingStatus(_this2.data.active_chat);
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          var data = _.assign({}, {
	            active_chat: jid,
	            active_chat_id: _this2._getActiveChatId(jid),
	            chat_type: _utils2.default.room.detect_chat_type(jid),
	            room_is_archived: _utils2.default.room.is_archived(_this2.local.allRooms[jid]),
	            text: _this2.getUnsentText(jid),
	            upload_progress: _this2.getUploadProgress(jid)
	          }, _this2.getUploadingStatus(jid));
	
	          _this2.set(data);
	
	          if (_this2.data.file && _this2.data.attachment_expanded && _this2.data.file.file_obj && !_this2.data.file_error && !_this2.data.uploading) {
	            _app_dispatcher2.default.dispatch('open-tooltip', {
	              type: 'upload_preview',
	              data: {
	                file: _this2.data.file.file_obj
	              }
	            });
	          } else {
	            _app_dispatcher2.default.dispatch('close-tooltip', {
	              type: 'upload_preview'
	            });
	          }
	        },
	        'upload-file': function uploadFile() {
	          _this2.set({
	            uploading: true
	          });
	        },
	        'upload-successful': function uploadSuccessful(_ref) {
	          var jid = _ref.jid;
	          var text = _ref.text;
	
	          _this2.updateUploadingStatus(jid, {
	            uploading: false,
	            attachment_expanded: false,
	            file: null,
	            file_extension: '',
	            file_name: ''
	          });
	          if (jid === _this2.data.active_chat && text === _this2.data.text) {
	            _this2.clearText();
	          }
	          if (jid !== _this2.data.active_chat && text === _this2.local.unsentText[jid]) {
	            delete _this2.local.unsentText[jid];
	          }
	        },
	        'upload-failed': function uploadFailed(data) {
	          _this2.updateUploadingStatus(data.jid, {
	            uploading: false
	          });
	        },
	        'upload-progress-update': function uploadProgressUpdate(_ref2) {
	          var jid = _ref2.jid;
	          var percentage = _ref2.percentage;
	
	          _this2.local.upload_progress[jid] = percentage;
	          _this2.updateUploadProgress(jid);
	        },
	        'upload-complete': function uploadComplete(_ref3) {
	          var jid = _ref3.jid;
	
	          delete _this2.local.upload_progress[jid];
	          _this2.updateUploadProgress(jid);
	        },
	        'set-message-value': function setMessageValue(text) {
	          _this2.set('text', text);
	          _this2.resetHistoryIndex(_this2.data.active_chat);
	        },
	        'append-message-value': function appendMessageValue(text) {
	          _this2.set('text', _.get(_this2.data, 'text', '') + text);
	        },
	        'expand-attachment': function expandAttachment(data) {
	          _this2.updateUploadingStatus(data.jid, {
	            attachment_expanded: true,
	            file: data.file,
	            file_name: data.file_name,
	            file_error: false,
	            file_extension: _utils2.default.file.get_extension(data.file_name),
	            file_selection_source: data.file_selection_source
	          });
	        },
	        'close-attachment': function closeAttachment(data) {
	          _this2.updateUploadingStatus(data.jid, {
	            attachment_expanded: false,
	            file: null,
	            file_name: '',
	            file_error: false,
	            file_extension: ''
	          });
	        },
	        'set-chat-caret-position': function setChatCaretPosition(caretPosition) {
	          _this2.local.caret_position = caretPosition;
	        },
	        'reset-new-forced-caret-position': function resetNewForcedCaretPosition() {
	          _this2.set('new_forced_caret_position', 0);
	        },
	        'sender-clicked': function senderClicked(data) {
	          var text = _this2.data.text,
	              caret_position = _this2.local.caret_position;
	
	          if (text.indexOf(data.mention + ' ') === -1) {
	            _this2.local.caret_position = caret_position + data.mention.length + 1;
	            _this2.resetHistoryIndex(_this2.data.active_chat);
	            _this2.set({
	              text: '' + text.substr(0, caret_position) + data.mention + ' ' + text.substr(caret_position),
	              new_forced_caret_position: _this2.local.caret_position
	            });
	          }
	        },
	        'change-filename': function changeFilename(data) {
	          _this2.set('file_name', data.file_name);
	        },
	        'smiley-chosen': function smileyChosen(data) {
	          _this2.handleSmileyChosen(data);
	        },
	        'set-user-state': function setUserState(data) {
	          if (_this2.data.user_state !== data.state) {
	            _this2.data.user_state = data.state;
	          }
	        },
	        'file-error': function fileError(data) {
	          _this2.updateUploadingStatus(data.jid, {
	            'file_error': true,
	            'file_error_message': _file_input_errors2.default[data.key]
	          });
	        },
	        'clear-errors': function clearErrors(data) {
	          _this2.updateUploadingStatus(data.jid, {
	            'file_error': false,
	            'file_error_message': ''
	          });
	        },
	        'dismiss-emoticon-autocomplete': function dismissEmoticonAutocomplete() {
	          _this2.dismissEmoticonAutoComplete();
	        },
	        'process-emoticon-text': function processEmoticonText(data) {
	          _this2.processEmoticonText(data.text, data.caret_position);
	        },
	        'emoticon-selected': function emoticonSelected() {
	          _this2.handleEmoticonSelected();
	        },
	        'dismiss-mention-autocomplete': function dismissMentionAutocomplete() {
	          _this2.dismissMentionAutoComplete();
	        },
	        'process-mention-text': function processMentionText(data) {
	          _this2.processMentionText(data.text, data.caret_position);
	        },
	        'process-slash-command-text': function processSlashCommandText(_ref4) {
	          var text = _ref4.text;
	          var caret_position = _ref4.caret_position;
	
	          _this2.processSlashCommandText(text, caret_position);
	        },
	        'navigate-autocomplete': function navigateAutocomplete(data) {
	          _this2.navigateAutoComplete(data.autocomplete, data.direction);
	        },
	        'mention-selected': function mentionSelected() {
	          _this2.handleMentionSelected();
	        },
	        'menu-item-hovered': function menuItemHovered(data) {
	          _this2.updateActiveMenuItem(data);
	        },
	        'slash-command-selected': function slashCommandSelected() {
	          _this2.handleSlashCommandSelected();
	        }
	      });
	    }
	  }, {
	    key: 'updateUploadProgress',
	    value: function updateUploadProgress(jid) {
	      if (jid === this.data.active_chat) {
	        this.set('upload_progress', this.getUploadProgress(jid));
	      }
	    }
	  }, {
	    key: 'getUploadProgress',
	    value: function getUploadProgress(jid) {
	      var percentage = this.local.upload_progress[jid];
	      return percentage !== undefined ? percentage : null;
	    }
	  }, {
	    key: 'handleActiveRoomsUpdate',
	    value: function handleActiveRoomsUpdate(rooms) {
	      var active_chat, room_is_archived, active_chat_id;
	
	      this.local.allRooms = rooms;
	      active_chat = this.local.allRooms[this.data.active_chat];
	
	      if (active_chat) {
	        room_is_archived = _utils2.default.room.is_archived(active_chat);
	        active_chat_id = this._getActiveChatId(active_chat.jid);
	        if (active_chat.type !== this.data.chat_type || room_is_archived !== this.data.room_is_archived || this.data.active_chat_id !== active_chat_id) {
	          // We only want the store updated if these values have changed
	          this.set({
	            active_chat_id: active_chat_id,
	            chat_type: active_chat.type,
	            room_is_archived: room_is_archived
	          });
	        }
	      }
	    }
	  }, {
	    key: 'processEmoticonText',
	    value: function processEmoticonText(text, caret_position) {
	      var pre_emoticon = text.substring(0, caret_position),
	          post_emoticon = text.substring(caret_position),
	          emoticon_text = pre_emoticon.split(this.data.emoticon_regex).slice(-1)[0],
	          filtered_list,
	          sliced_list;
	
	      if (emoticon_text.indexOf('(') === 0 && emoticon_text !== '(') {
	        this.data.emoticon_text = emoticon_text.toLowerCase();
	        filtered_list = this.filterEmoticonList(this.data.emoticon_text);
	        sliced_list = filtered_list.slice(0, 40);
	        this.set({
	          emoticon_text: emoticon_text,
	          emoticon_selected_item: 0,
	          pre_emoticon_text: pre_emoticon,
	          post_emoticon_text: post_emoticon,
	          path_prefix: this.data.path_prefix,
	          emoticon_list: sliced_list,
	          emoticon_results_count: sliced_list.length,
	          active_autocomplete: 'emoticon'
	        });
	      } else {
	        if (this.data.active_autocomplete === 'emoticon') {
	          this.dismissEmoticonAutoComplete();
	        }
	      }
	    }
	  }, {
	    key: 'filterEmoticonList',
	    value: function filterEmoticonList(text) {
	      var filtered,
	          query = text.slice(1),
	          wrap = function wrap(match) {
	        return '<strong>' + match + '</strong>';
	      };
	      filtered = _.filter(this.getEmoticons(), function (emoticon) {
	        return emoticon.shortcut.indexOf(query) !== -1;
	      });
	
	      filtered = _.sortBy(filtered, function (emoticon) {
	        return emoticon.shortcut.indexOf(query);
	      });
	      filtered = _.forEach(filtered, function (emoticon) {
	        emoticon.match_markup = emoticon.shortcut.split(query).join(wrap(query));
	      });
	      return filtered;
	    }
	  }, {
	    key: 'getEmoticons',
	    value: function getEmoticons() {
	      var emoticons = _.toArray(this.data.emoticons),
	          default_emoticons = _.filter(_.toArray(this.data.smileys), function (smileys) {
	        return smileys.shortcut.indexOf('(') === 0;
	      });
	      return _.sortBy(emoticons.concat(default_emoticons), 'shortcut');
	    }
	  }, {
	    key: 'handleEmoticonSelected',
	    value: function handleEmoticonSelected() {
	      var emoticon = this.data.emoticon_list[this.data.emoticon_selected_item],
	          new_pre_text = this.getPreEmoticonOnSelect(emoticon.shortcut),
	          new_post_text = this.data.post_emoticon_text,
	          first_space = this.data.post_emoticon_text.indexOf(' ');
	
	      if (first_space !== 0) {
	        new_post_text = this.data.post_emoticon_text.slice(first_space + 1);
	      }
	
	      this.set({
	        text: new_pre_text + new_post_text,
	        new_forced_caret_position: new_pre_text.length
	      });
	      this.dismissEmoticonAutoComplete();
	    }
	  }, {
	    key: 'handleSlashCommandSelected',
	    value: function handleSlashCommandSelected() {
	      var slash_command = this.data.slash_command_list[this.data.slash_command_selected_item];
	
	      var command = void 0;
	
	      if (slash_command.name.indexOf(this.data.text) === 0) {
	        command = slash_command.name;
	      } else {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = (0, _getIterator3.default)(slash_command.aliases), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var alias = _step.value;
	
	            if (alias.indexOf(this.data.text) === 0) {
	              command = alias;
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	
	      _analytics_actions2.default.slashCommandUsedInAutocomplete({
	        room: _utils2.default.jid.is_room(this.data.active_chat) ? this.data.active_chat_id : null,
	        slashUsed: command
	      });
	
	      var text = command + ' ';
	
	      this.set({
	        text: text,
	        new_forced_caret_position: text.length
	      });
	      this.dismissSlashCommandAutoComplete();
	    }
	  }, {
	    key: 'getPreEmoticonOnSelect',
	    value: function getPreEmoticonOnSelect(shortcut) {
	      return this.data.pre_emoticon_text.slice(0, -this.data.emoticon_text.length) + shortcut + ' ';
	    }
	  }, {
	    key: 'dismissEmoticonAutoComplete',
	    value: function dismissEmoticonAutoComplete() {
	      this.set({
	        emoticon_text: '',
	        emoticon_selected_item: 0,
	        emoticon_results_count: 0,
	        emoticon_list: [],
	        active_autocomplete: null
	      });
	    }
	  }, {
	    key: 'clearText',
	    value: function clearText() {
	      this.resetHistoryIndex(this.data.active_chat);
	      this.set({
	        text: ''
	      });
	    }
	  }, {
	    key: 'handleSmileyChosen',
	    value: function handleSmileyChosen(data) {
	      var caret = this.local.caret_position;
	      var text = this.data.text;
	
	      var position;
	
	      if (caret === 0 || !text) {
	        text = data.shortcut + ' ' + text.trim();
	        position = data.shortcut.length + 1;
	      } else if (caret === text.length) {
	        text = text.trim() + (' ' + data.shortcut + ' ');
	        position = text.length;
	      } else {
	        text = text.substr(0, caret).trim() + (' ' + data.shortcut + ' ') + text.substr(caret).trim();
	        position = caret + data.shortcut.length + 1;
	      }
	
	      this.set({
	        text: text,
	        new_forced_caret_position: position
	      });
	    }
	  }, {
	    key: 'setUnsentText',
	    value: function setUnsentText(jid) {
	      if (_utils2.default.jid.is_chat(jid)) {
	        this.local.unsentText[jid] = this.data.text;
	      }
	    }
	  }, {
	    key: 'getUnsentText',
	    value: function getUnsentText(jid) {
	      return this.local.unsentText[jid] || '';
	    }
	  }, {
	    key: 'deleteUnsentText',
	    value: function deleteUnsentText(jid) {
	      delete this.local.unsentText[jid];
	    }
	  }, {
	    key: 'updateUploadingStatus',
	    value: function updateUploadingStatus(jid, data) {
	      if (this.data.active_chat === jid) {
	        this.set(data);
	      } else {
	        this.setUploadingStatus(jid, data);
	      }
	    }
	  }, {
	    key: 'setUploadingStatus',
	    value: function setUploadingStatus(jid, data) {
	      if (_utils2.default.jid.is_chat(jid)) {
	        if (data) {
	          this.local.uploadingStatus[jid] = _.assign({}, this.local.uploadingStatus[jid], data);
	        } else {
	          this.local.uploadingStatus[jid] = _.pick(this.data, ['uploading', 'attachment_expanded', 'file', 'file_error', 'file_error_message', 'file_extension', 'file_name', 'file_selection_source']);
	        }
	      }
	    }
	  }, {
	    key: 'getUploadingStatus',
	    value: function getUploadingStatus(jid) {
	      return this.local.uploadingStatus[jid] || {
	        uploading: false,
	        attachment_expanded: false,
	        file: null,
	        file_error: '',
	        file_error_message: '',
	        file_extension: '',
	        file_name: '',
	        file_selection_source: null
	      };
	    }
	  }, {
	    key: 'deleteUploadingStatus',
	    value: function deleteUploadingStatus(jid) {
	      delete this.local.uploadingStatus[jid];
	    }
	  }, {
	    key: 'updateRoomData',
	    value: function updateRoomData() {
	      var room = _roster_store2.default.getAll();
	      this.local.guests = room.participants.guests;
	      this.local.members = room.participants.members;
	      this.local.users = room.users;
	      this.local.room_privacy = room.active_chat_privacy;
	    }
	  }, {
	    key: 'processMentionText',
	    value: function processMentionText(text, caret_position) {
	      var pre_mention = text.substring(0, caret_position),
	          post_mention = text.substring(caret_position),
	          mention_text = pre_mention.split(/\s/).slice(-1)[0];
	
	      if (mention_text.indexOf('@') === 0) {
	        this.updateRoomData();
	        var giving_out = this.getMentionList(mention_text).slice(0, 25);
	        var results = (0, _user_utils.sort_users)(giving_out, mention_text.slice(1), 'mention_name');
	
	        this.set({
	          mention_list: results,
	          mention_results_count: results.length,
	          mention_text: mention_text,
	          mention_selected_item: 0,
	          pre_mention_text: pre_mention,
	          post_mention_text: post_mention,
	          active_autocomplete: 'mention'
	        });
	      } else {
	        if (this.data.active_autocomplete === 'mention') {
	          this.dismissMentionAutoComplete();
	        }
	      }
	    }
	  }, {
	    key: 'getMentionList',
	    value: function getMentionList(mention_text) {
	      var query = mention_text.slice(1),
	          room = this.local.allRooms[this.data.active_chat],
	          participants_fully_initialized = room && room.participants_fully_initialized,
	          people_in_this_room = this.local.members.concat(this.local.guests).concat(this.data.default_mentions),
	          priorities,
	          results;
	
	      if (query === '') {
	        priorities = _.map(this.data.default_mentions, 'jid');
	        results = (0, _chat_search.chatSearch)(people_in_this_room, query, priorities);
	      } else if (this.local.room_privacy === 'private' && participants_fully_initialized || this.data.user_is_guest) {
	        results = (0, _chat_search.chatSearch)(people_in_this_room, query);
	      } else {
	        var people_to_search = this.removeGuests(this.local.users).concat(this.local.guests).concat(this.data.default_mentions);
	        priorities = _.map(people_in_this_room, 'jid');
	        results = (0, _chat_search.chatSearch)(people_to_search, query, priorities);
	      }
	
	      return results;
	    }
	  }, {
	    key: 'processSlashCommandText',
	    value: function processSlashCommandText(text, caret_position) {
	      var _this3 = this;
	
	      if (!this.data.web_client_slash_command_autocomplete_enabled) {
	        return;
	      }
	
	      if (/^\/(\w*)$/.test(text) && caret_position > 0) {
	        var filtered = _.filter(_slash_command_helper.commands, function (_ref5) {
	          var name = _ref5.name;
	          var aliases = _ref5.aliases;
	          var members_only = _ref5.members_only;
	          var oto_only = _ref5.oto_only;
	          var room_only = _ref5.room_only;
	          var filter = _ref5.filter;
	
	          if (oto_only && !_utils2.default.jid.is_private_chat(_this3.data.active_chat) || room_only && !_utils2.default.jid.is_room(_this3.data.active_chat) || members_only && _this3.data.user_is_guest || filter && !filter({ video_enabled: _this3.data.video_enabled })) {
	            return false;
	          }
	
	          if (name.indexOf(text) === 0) {
	            return true;
	          }
	
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;
	
	          try {
	            for (var _iterator2 = (0, _getIterator3.default)(aliases), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var alias = _step2.value;
	
	              if (alias.indexOf(text) === 0) {
	                return true;
	              }
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }
	        });
	
	        var sorted = _.sortBy(filtered, 'name');
	        var normalized = sorted.map(function (_ref6) {
	          var name = _ref6.name;
	          var usage = _ref6.usage;
	          var description = _ref6.description;
	          var aliases = _ref6.aliases;
	          return { name: name, usage: usage, description: description, aliases: aliases };
	        });
	
	        this.set({
	          active_autocomplete: "slash_command",
	          slash_command_list: normalized,
	          slash_command_selected_item: 0,
	          slash_command_results_count: normalized.length
	        });
	      } else if (this.data.active_autocomplete === 'slash_command') {
	        this.dismissSlashCommandAutoComplete();
	      }
	    }
	  }, {
	    key: 'dismissSlashCommandAutoComplete',
	    value: function dismissSlashCommandAutoComplete() {
	      this.set({
	        slash_command_list: [],
	        slash_command_selected_item: 0,
	        slash_command_results_count: 0,
	        active_autocomplete: null
	      });
	    }
	  }, {
	    key: 'removeGuests',
	    value: function removeGuests(users) {
	      // Remove guests in the roster
	      return _.reject(_.toArray(users), _utils2.default.user.is_guest);
	    }
	  }, {
	    key: 'navigateAutoComplete',
	    value: function navigateAutoComplete(autocomplete, direction) {
	      if (autocomplete === 'mention' || autocomplete === 'emoticon' || autocomplete === 'slash_command') {
	        if (direction === 'up') {
	          this.navigateAutocompleteUp(autocomplete);
	        } else if (direction === 'down') {
	          this.navigateAutocompleteDown(autocomplete);
	        }
	      }
	    }
	  }, {
	    key: 'navigateAutocompleteUp',
	    value: function navigateAutocompleteUp(type) {
	      var selected_item = this.data[type + '_selected_item'],
	          results_count = this.data[type + '_results_count'],
	          new_index;
	
	      if (selected_item > 0) {
	        new_index = selected_item - 1;
	      } else {
	        new_index = results_count - 1;
	      }
	      this.set((0, _defineProperty3.default)({}, type + '_selected_item', new_index));
	    }
	  }, {
	    key: 'navigateAutocompleteDown',
	    value: function navigateAutocompleteDown(type) {
	      var selected_item = this.data[type + '_selected_item'],
	          results_count = this.data[type + '_results_count'],
	          new_index;
	
	      if (selected_item < results_count - 1) {
	        new_index = selected_item + 1;
	      } else {
	        new_index = 0;
	      }
	      this.set((0, _defineProperty3.default)({}, type + '_selected_item', new_index));
	    }
	  }, {
	    key: 'handleMentionSelected',
	    value: function handleMentionSelected() {
	      var user = this.data.mention_list[this.data.mention_selected_item],
	          new_pre_text = this.getPreMentionOnSelect(user.mention_name),
	          new_post_text = this.data.post_mention_text;
	      this.set({
	        text: new_pre_text + new_post_text,
	        new_forced_caret_position: new_pre_text.length
	      });
	      this.dismissMentionAutoComplete();
	    }
	  }, {
	    key: 'getPreMentionOnSelect',
	    value: function getPreMentionOnSelect(mention_name) {
	      return this.data.pre_mention_text.slice(0, -this.data.mention_text.length) + '@' + mention_name + ' ';
	    }
	  }, {
	    key: 'updateActiveMenuItem',
	    value: function updateActiveMenuItem(data) {
	      this.set(data.type + '_selected_item', data.index);
	    }
	  }, {
	    key: 'dismissMentionAutoComplete',
	    value: function dismissMentionAutoComplete() {
	      this.set({
	        active_autocomplete: null,
	        mention_list: [],
	        mention_text: '',
	        pre_mention_text: '',
	        post_mention_text: '',
	        mention_selected_item: 0,
	        mention_results_count: 0
	      });
	    }
	  }, {
	    key: 'recallOlderMessage',
	    value: function recallOlderMessage() {
	      var jid = this.data.active_chat,
	          index = this.local.input_history_index[jid];
	
	      if (_.isEmpty(this.local.input_history[jid])) {
	        return;
	      }
	
	      if (_.isNull(index) || _.isUndefined(index)) {
	        this.local.unsent_text_before_recall[jid] = this.data.text;
	        index = 0;
	        this.local.input_history_index[jid] = index;
	        this.set('text', this.local.input_history[jid][index]);
	        return;
	      }
	
	      if (index < this.local.input_history[jid].length - 1) {
	        index++;
	        this.local.input_history_index[jid] = index;
	        this.set('text', this.local.input_history[jid][index]);
	      }
	    }
	  }, {
	    key: 'recallNewerMessage',
	    value: function recallNewerMessage() {
	      var jid = this.data.active_chat,
	          index = this.local.input_history_index[jid];
	
	      if (_.isNull(index) || _.isUndefined(index)) {
	        return;
	      }
	
	      if (index) {
	        index = --this.local.input_history_index[jid];
	        this.set('text', this.local.input_history[jid][index]);
	      } else {
	        this.resetHistoryIndex(jid);
	        this.set('text', this.local.unsent_text_before_recall[jid]);
	      }
	    }
	
	    /**
	     * Saves sent message to chat input history and manages stack
	     *
	     * Input history is saved per room, using messages sent within this client during this session.
	     * The input history arrays are queues, wherein new messages are added to the front of the array
	     * and older messages removed from the end of the array.
	     *
	     * @method saveInputHistory
	     */
	
	  }, {
	    key: 'saveInputHistory',
	    value: function saveInputHistory(message) {
	      var text = message.text.trim(),
	          jid = message.jid;
	
	      if (!this.local.input_history[jid]) {
	        this.local.input_history[jid] = [];
	      }
	
	      if (this.local.input_history[jid].length === _app_config2.default.input_history_max) {
	        this.local.input_history[jid].pop();
	      }
	
	      this.local.input_history[jid].unshift(text);
	    }
	  }, {
	    key: 'deleteInputHistory',
	    value: function deleteInputHistory(jid) {
	      delete this.local.input_history[jid];
	      delete this.local.input_history_index[jid];
	      delete this.local.unsent_text_before_recall[jid];
	    }
	  }, {
	    key: 'resetHistoryIndex',
	    value: function resetHistoryIndex(jid) {
	      this.local.input_history_index[jid] = null;
	    }
	  }, {
	    key: 'isFocused',
	    value: function isFocused() {
	      return _.get(document.activeElement, 'id') === _app_config2.default.chat_input_id;
	    }
	  }, {
	    key: '_getActiveChatId',
	    value: function _getActiveChatId(jid) {
	
	      var active_chat_id = null;
	
	      if (!_utils2.default.jid.is_lobby(jid)) {
	        if (_utils2.default.jid.is_private_chat(jid)) {
	          active_chat_id = _utils2.default.jid.user_id(jid);
	        } else {
	          if (this.local.allRooms[jid]) {
	            active_chat_id = parseInt(this.local.allRooms[jid].id);
	          }
	        }
	      }
	
	      return active_chat_id;
	    }
	  }, {
	    key: 'handlePreferences',
	    value: function handlePreferences() {
	      this.set({
	        should_animate_avatar: _preferences_store2.default.shouldAnimateAvatars()
	      });
	    }
	  }, {
	    key: 'handleConfig',
	    value: function handleConfig(config) {
	      this.set({
	        video_enabled: _.get(config, 'video_chat_enabled') && _.get(config, 'feature_flags.web_client_video_chat'),
	        keyboard_shortcuts: _.get(config, 'keyboard_shortcuts'),
	        // Defaulting this feature flag to true because existing deployments of HCS don't include this flag
	        web_client_addlive_video_enabled: _.get(config, 'feature_flags.web_client_addlive_video', true),
	
	        web_client_enso_video_enabled: _.get(config, 'feature_flags.web_client_enso_video', false),
	        web_client_enso_room_video_enabled: _.get(config, 'feature_flags.web_client_enso_room_video', false),
	        web_client_slash_command_autocomplete_enabled: _.get(config, 'feature_flags.web_client_slash_command_autocomplete_enabled'),
	        message_editing_enabled: _.get(config, 'feature_flags.web_client_message_editing')
	
	      });
	    }
	  }]);
	  return ChatInputStore;
	}(_store2.default);
	
	exports.default = new ChatInputStore();
	module.exports = exports['default'];

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _layout_actions = __webpack_require__(266);
	
	var _layout_actions2 = _interopRequireDefault(_layout_actions);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _room_size = __webpack_require__(272);
	
	var _room_size2 = _interopRequireDefault(_room_size);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RosterStore = function (_Store) {
	  (0, _inherits3.default)(RosterStore, _Store);
	
	  function RosterStore() {
	    (0, _classCallCheck3.default)(this, RosterStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RosterStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(RosterStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        admins: [],
	        current_user: {},
	        users: {},
	        rooms: {},
	        files: [],
	        links: [],
	        loading: false,
	        participants: {
	          members: [],
	          guests: []
	        },
	        initialized: false,
	        size: _room_size2.default.MEDIUM,
	        active_chat: null,
	        active_chat_privacy: null,
	        guest_url: '',
	        chat_type: '',
	        invite_url: false,
	        user_is_admin: false,
	        active_integration: null,
	        active_integration_data_template_values: null,
	        can_share_files: true,
	        panels_scroll_top: {}
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(data) {
	          _this2.handleConfig(data);
	        }
	      });
	
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(config) {
	          _this2.handleConfig(config);
	        },
	        'updated:current_user': function updatedCurrent_user(user) {
	          _this2.data.current_user = user;
	        },
	        'updated:roster': function updatedRoster(roster) {
	          _this2.handleRosterUpdate(roster);
	        },
	        'updated:permissions': function updatedPermissions(perms) {
	          _this2.set({
	            can_share_files: perms.file_sharing === 'all'
	          });
	        },
	        'app-state-ready': function appStateReady() {
	          _this2.data.initialized = true;
	          _this2.fetchPanelContent(_this2.data.active_chat);
	        },
	        'app-state-reconnected': function appStateReconnected() {
	          _app_dispatcher2.default.dispatch('fetch-recent-files');
	          _app_dispatcher2.default.dispatch('fetch-recent-links');
	        },
	        'fetch-files-history': function fetchFilesHistory() {
	          var room = _this2.data.active_chat;
	          if (_utils2.default.jid.is_chat(room)) {
	            var lastFile = _.last(_this2.data.files);
	            var before = lastFile ? lastFile.date : _utils2.default.format_time_for_history(new Date());
	
	            _app_dispatcher2.default.dispatch('fetch-files', { room: room, before: before });
	          }
	        },
	        'fetch-links-history': function fetchLinksHistory() {
	          var room = _this2.data.active_chat;
	          if (_utils2.default.jid.is_chat(room)) {
	            var lastLink = _.last(_this2.data.links);
	            var before = lastLink ? lastLink.date : _utils2.default.format_time_for_history(new Date());
	
	            _app_dispatcher2.default.dispatch('fetch-links', { room: room, before: before });
	          }
	        },
	        'fetch-recent-files': function fetchRecentFiles() {
	          var room = _this2.data.active_chat;
	          if (_utils2.default.jid.is_chat(room)) {
	            var firstFile = _.first(_this2.data.files);
	            var after = firstFile ? firstFile.date : null;
	
	            _app_dispatcher2.default.dispatch('fetch-files', { room: room, after: after });
	          }
	        },
	        'fetch-recent-links': function fetchRecentLinks() {
	          var room = _this2.data.active_chat;
	          if (_utils2.default.jid.is_chat(room)) {
	            var firstLink = _.first(_this2.data.links);
	            var after = firstLink ? firstLink.date : null;
	
	            _app_dispatcher2.default.dispatch('fetch-links', { room: room, after: after });
	          }
	        },
	        'DAL:handle-created-room': function DALHandleCreatedRoom(room) {
	          _this2.handleNewRoom(room);
	        },
	        'mark-participant-unknown': function markParticipantUnknown(data) {
	          _this2.markParticipantForPrivateRoom(data);
	        },
	        'unmark-participant': function unmarkParticipant(data) {
	          _this2.unmarkParticipantForPrivateRoom(data);
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.handleSelectRoom(jid);
	          _this2.fetchPanelContent(jid);
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          _this2.handleActiveRoomsUpdate(rooms);
	        },
	        'select-panel': function selectPanel(data) {
	          _this2.selectPanel(data);
	        },
	        'fetch-panel-content-for-internal-glances': function fetchPanelContentForInternalGlances(data) {
	          if (data.activeIntegration) {
	            _this2.fetchPanelContent(_this2.data.active_chat);
	          }
	        },
	        'toggle-right-sidebar': function toggleRightSidebar() {
	          _this2.toggleSidebar(_this2.data.chat_type);
	        },
	        'set-right-sidebar-panel-scrolltop': function setRightSidebarPanelScrolltop(_ref) {
	          var room = _ref.room;
	          var type = _ref.type;
	          var scroll_top = _ref.scroll_top;
	
	          if (_utils2.default.jid.is_chat(room)) {
	            if (!_this2.data.panels_scroll_top[room]) {
	              _this2.data.panels_scroll_top[room] = {};
	            }
	            _this2.data.panels_scroll_top[room][type] = scroll_top;
	            _this2.set('panels_scroll_top', _this2.data.panels_scroll_top);
	          }
	        }
	      });
	    }
	  }, {
	    key: 'updateLoadingSpinner',
	    value: function updateLoadingSpinner() {
	
	      if (!_utils2.default.jid.is_chat(this.data.active_chat)) {
	        return;
	      }
	
	      var chat = this.data.rooms[this.data.active_chat];
	
	      if (!chat) {
	        return;
	      }
	
	      if (chat.files_fetching && !chat.files_fetched) {
	        this.showLoadingSpinnerOnPanel("files");
	      } else {
	        this.hideLoadingSpinnerOnPanel("files");
	      }
	      if (chat.links_fetching && !chat.links_fetched) {
	        this.showLoadingSpinnerOnPanel("links");
	      } else {
	        this.hideLoadingSpinnerOnPanel("links");
	      }
	    }
	  }, {
	    key: 'showLoadingSpinnerOnPanel',
	    value: function showLoadingSpinnerOnPanel(type) {
	      if (this.getActivePanel(this.data.chat_type) === type) {
	        this.set('loading', true);
	      }
	    }
	  }, {
	    key: 'hideLoadingSpinnerOnPanel',
	    value: function hideLoadingSpinnerOnPanel(type) {
	      if (this.getActivePanel(this.data.chat_type) === type) {
	        this.set('loading', false);
	      }
	    }
	  }, {
	    key: 'handleConfig',
	    value: function handleConfig(config) {
	      this.data.active_chat = this.data.active_chat || _preferences_store2.default.getChatToFocus();
	      this.set({
	        user_is_admin: config.is_admin,
	        invite_url: config.invite_url,
	        web_client_integrations_enabled: _integration_helper2.default.isFeatureEnabled(config)
	      });
	      this.fetchPanelContent(this.data.active_chat);
	    }
	  }, {
	    key: 'selectPanel',
	    value: function selectPanel(data) {
	      if (this.shouldToggleSidebar(data.activePanel)) {
	        this.toggleSidebar(this.data.chat_type);
	      }
	      this.setPanel(data.activePanel);
	      this.fetchPanelContent(this.data.active_chat);
	    }
	  }, {
	    key: 'setPanel',
	    value: function setPanel(panel) {
	      if (this.data.chat_type === "chat") {
	        _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _client_preferences_keys2.default.CHAT_ACTIVE_PANEL, panel));
	      } else if (this.data.chat_type === "groupchat") {
	        _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _client_preferences_keys2.default.GROUPCHAT_ACTIVE_PANEL, panel));
	      }
	    }
	  }, {
	    key: 'shouldToggleSidebar',
	    value: function shouldToggleSidebar(panel) {
	      var result = false;
	      if (this.data.chat_type === "chat") {
	        result = panel === _preferences_store2.default.getChatActivePanel() || !_preferences_store2.default.shouldShowChatSidebar();
	      } else if (this.data.chat_type === "groupchat") {
	        result = panel === _preferences_store2.default.getGroupChatActivePanel() || !_preferences_store2.default.shouldShowGroupChatSidebar();
	      }
	      return result;
	    }
	  }, {
	    key: 'toggleSidebar',
	    value: function toggleSidebar(chat_type) {
	      var visibility;
	      if (chat_type === "chat") {
	        visibility = !_preferences_store2.default.shouldShowChatSidebar();
	        _layout_actions2.default.setRightChatSidebarVisibility(visibility);
	      } else if (chat_type === "groupchat") {
	        visibility = !_preferences_store2.default.shouldShowGroupChatSidebar();
	        _layout_actions2.default.setRightGroupChatSidebarVisibility(visibility);
	      }
	    }
	  }, {
	    key: 'sidebarShowing',
	    value: function sidebarShowing(jid) {
	      return _utils2.default.room.detect_chat_type(jid) === "chat" && _preferences_store2.default.shouldShowChatSidebar() || _utils2.default.room.detect_chat_type(jid) === "groupchat" && _preferences_store2.default.shouldShowGroupChatSidebar();
	    }
	  }, {
	    key: 'getActivePanel',
	    value: function getActivePanel(chat_type) {
	      if (!this.data.web_client_integrations_enabled) {
	        if (chat_type === "chat") {
	          return _preferences_store2.default.getChatActivePanel();
	        } else if (chat_type === "groupchat") {
	          return _preferences_store2.default.getGroupChatActivePanel();
	        }
	      } else {
	        var key = null;
	
	        if (chat_type === "chat") {
	          key = _.get(_preferences_store2.default.getActiveChatIntegration(), 'key');
	        } else if (chat_type === "groupchat") {
	          key = _.get(_preferences_store2.default.getActiveGroupchatIntegration(), 'key');
	        }
	
	        if (_integration_helper2.default.isInternalIntegrationKey(key)) {
	          return _integration_helper2.default.split_full_key(key)[1];
	        }
	      }
	    }
	  }, {
	    key: 'fetchPanelContent',
	    value: function fetchPanelContent(jid) {
	      // Only fetch if sidebar is visible
	      if (this.data.initialized && _utils2.default.jid.is_chat(jid) && this.sidebarShowing(jid) && !this.data.current_user.is_guest) {
	        var activePanel = this.getActivePanel(this.data.chat_type);
	
	        if (activePanel === 'files' || activePanel === 'links') {
	          if (this._shouldFetchPanelContent(jid, activePanel)) {
	            _app_dispatcher2.default.dispatch('fetch-' + activePanel, { room: jid });
	          }
	        }
	      }
	    }
	  }, {
	    key: '_shouldFetchPanelContent',
	    value: function _shouldFetchPanelContent(jid, panel) {
	      var room = this.data.rooms[jid];
	
	      var fetching = _.get(room, panel + '_fetching', false);
	      var fetched = _.get(room, panel + '_fetched', false);
	
	      return !(fetching || fetched);
	    }
	  }, {
	    key: 'isSignedFile',
	    value: function isSignedFile(url) {
	      return this.isFileUrlAuthenticated(url) || this.getPublicUrlFromThumbnail(url);
	    }
	  }, {
	    key: 'isFileUrlAuthenticated',
	    value: function isFileUrlAuthenticated(url) {
	      var file = _.find(this.data.files, { url: url });
	      return _.get(file, 'is_authenticated', false);
	    }
	  }, {
	    key: 'getPublicUrlFromThumbnail',
	    value: function getPublicUrlFromThumbnail(url) {
	      var publicUrl = null;
	      var jid = this.data.active_chat;
	
	      _app_dispatcher2.default.dispatch('get-public-url-from-thumbnail', url, jid, function (fileUrl) {
	        return publicUrl = fileUrl;
	      });
	      return publicUrl;
	    }
	  }, {
	    key: 'markParticipantForPrivateRoom',
	    value: function markParticipantForPrivateRoom(data) {
	      var user = this.data.users[data.user];
	
	      if (user) {
	        if (user['not_present_in']) {
	          user['not_present_in'].push(data.room);
	        } else {
	          user['not_present_in'] = [data.room];
	        }
	      }
	    }
	  }, {
	    key: 'unmarkParticipantForPrivateRoom',
	    value: function unmarkParticipantForPrivateRoom(data) {
	      var user = this.data.users[data.user];
	      if (_.includes(_.get(user, 'not_present_in'), data.room)) {
	        user['not_present_in'] = _.without(user['not_present_in'], data.room);
	      }
	    }
	  }, {
	    key: 'sortRoster',
	    value: function sortRoster(roster) {
	      return _.sortBy(roster, 'name');
	    }
	  }, {
	    key: 'sortRosterByPresenceAndName',
	    value: function sortRosterByPresenceAndName(roster) {
	      return roster.sort(RosterStore.comparePeople);
	    }
	  }, {
	    key: 'sortRosterByName',
	    value: function sortRosterByName(roster) {
	      return roster.sort(RosterStore.compareName);
	    }
	  }, {
	    key: 'getSortedRosterByPresenceAndName',
	    value: function getSortedRosterByPresenceAndName(roles) {
	      var _this3 = this;
	
	      var all_people = [].concat.apply([], _.map(roles, function (role) {
	        return _this3.get('participants')[role];
	      }));
	      return this.sortRosterByPresenceAndName(all_people);
	    }
	  }, {
	    key: 'getSortedRoster',
	    value: function getSortedRoster(roles) {
	      var _this4 = this;
	
	      var all_people = [].concat.apply([], _.map(roles, function (role) {
	        return _this4.get('participants')[role];
	      })),
	          size = this.getRoomSize();
	
	      if (size === _room_size2.default.XLARGE) {
	        return [];
	      } else if (size === _room_size2.default.LARGE) {
	        return this.sortRosterByName(all_people);
	      }
	      return this.sortRosterByPresenceAndName(all_people);
	    }
	  }, {
	    key: 'insertAlphaHeadings',
	    value: function insertAlphaHeadings() {
	      var users = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	
	      var roster = [],
	          letter = '';
	
	      _.forEach(users, function (user) {
	        var initial = user.name.substr(0, 1).toUpperCase();
	        if (initial !== letter) {
	          letter = initial.toUpperCase();
	          roster.push({ letter: letter });
	        }
	        roster.push(user);
	      });
	
	      return roster;
	    }
	  }, {
	    key: 'getRoomSize',
	    value: function getRoomSize() {
	      var count = this.getRosterCount(['members', 'guests']).total,
	          breakpoints = _app_config2.default.roster_panel.breakpoints;
	
	      if (count < breakpoints.small) {
	        return _room_size2.default.SMALL;
	      } else if (count < breakpoints.medium) {
	        return _room_size2.default.MEDIUM;
	      } else if (count < breakpoints.large) {
	        return _room_size2.default.LARGE;
	      }
	      return _room_size2.default.XLARGE;
	    }
	  }, {
	    key: 'getRoster',
	    value: function getRoster() {
	      var size = this.getRoomSize(),
	          roster = [];
	
	      if (size === _room_size2.default.XLARGE) {
	        return roster;
	      }
	
	      var members = this.getSortedRoster(['members']),
	          guests = this.getSortedRoster(['guests']),
	          hasMembers = members.length > 0,
	          hasGuests = guests.length > 0;
	
	      if (hasMembers) {
	        if (size === _room_size2.default.LARGE) {
	          members = this.insertAlphaHeadings(members);
	        }
	        roster = roster.concat(members);
	      }
	
	      if (hasGuests) {
	        roster.push({ group_title: 'guests' });
	        roster = roster.concat(guests);
	      }
	
	      return roster;
	    }
	  }, {
	    key: 'countRoster',
	    value: function countRoster(roster) {
	      var total_members = 0,
	          online_members = 0,
	          room = this.data.rooms[this.data.active_chat];
	
	      if (_.get(room, 'roster_size') && !room.participants_fully_initialized) {
	        total_members = room.roster_size;
	        online_members = 0;
	      } else {
	        _.each(roster, function (user) {
	          total_members++;
	          if (user.presence && user.presence.show === "chat") {
	            online_members++;
	          }
	        });
	      }
	
	      return {
	        online: online_members,
	        total: total_members
	      };
	    }
	  }, {
	    key: 'getRosterCount',
	    value: function getRosterCount(roles) {
	      var _this5 = this;
	
	      var all_people = [].concat.apply([], _.map(roles, function (role) {
	        return _this5.get('participants')[role];
	      }));
	      return this.countRoster(all_people);
	    }
	  }, {
	    key: 'handleActiveRoomsUpdate',
	    value: function handleActiveRoomsUpdate(rooms) {
	      var deleted = _.difference(_.keys(this.data.rooms), _.keys(rooms));
	      if (deleted.length) {
	        this.data.rooms = _.omit(this.data.rooms, deleted);
	      } else {
	        this.data.rooms = _.merge(this.data.rooms, rooms);
	      }
	      if (this.data.active_chat && _utils2.default.jid.is_chat(this.data.active_chat)) {
	        this.data.rooms[this.data.active_chat] = rooms[this.data.active_chat];
	        this.handleSelectRoom(this.data.active_chat);
	      }
	    }
	  }, {
	    key: 'handleRosterUpdate',
	    value: function handleRosterUpdate(roster) {
	      var _this6 = this;
	
	      _.map(this.data.participants, function (group, role) {
	        if (_this6.data.participants[role].length) {
	          _this6.sortRoster(_this6.data.participants[role]);
	        }
	      });
	      this.data.users = roster;
	      this.handleSelectRoom(this.data.active_chat);
	    }
	  }, {
	    key: 'handleNewRoom',
	    value: function handleNewRoom(room) {
	      this.set({
	        active_chat: room.jid,
	        chat_type: _utils2.default.room.detect_chat_type(room.jid)
	      });
	    }
	  }, {
	    key: 'handleSelectRoom',
	    value: function handleSelectRoom(jid) {
	      var _this7 = this;
	
	      if (!jid || !_utils2.default.jid.is_chat(jid)) {
	        return;
	      }
	
	      var type = _utils2.default.room.detect_chat_type(jid),
	          room_privacy,
	          files = [],
	          links = [],
	          admins,
	          owner,
	          guest_url;
	
	      this.data.participants = {
	        members: [],
	        guests: []
	      };
	
	      if (this.data.rooms[jid]) {
	        room_privacy = this.data.rooms[jid].privacy;
	        guest_url = this.data.rooms[jid].guest_url;
	        files = this.data.rooms[jid].files;
	        links = this.data.rooms[jid].links;
	        admins = this.data.rooms[jid].admins;
	        owner = this.data.rooms[jid].owner;
	        type = this.data.rooms[jid].type;
	        _.map(this.data.rooms[jid].participants, function (group, role) {
	          _.each(group, function (user_jid) {
	            if (_this7.data.users[user_jid]) {
	              if (_this7.data.rooms[jid].privacy === 'private' && _this7.data.users[user_jid].not_present_in && _this7.data.users[user_jid].not_present_in.indexOf(jid) !== -1) {
	                _this7.data.participants[role].push(_.assign({}, _this7.data.users[user_jid], {
	                  presence: {
	                    show: 'unknown',
	                    status: '',
	                    idleTime: false
	                  }
	                }));
	              } else {
	                _this7.data.participants[role].push(_.cloneDeep(_this7.data.users[user_jid]));
	              }
	            }
	          });
	          _this7.data.participants[role] = _this7.sortRoster(_.compact(_this7.data.participants[role]));
	        });
	      }
	
	      this.set({
	        admins: admins,
	        owner: owner,
	        users: this.data.users,
	        participants: this.data.participants,
	        active_chat: jid,
	        active_chat_privacy: room_privacy,
	        chat_type: type,
	        size: this.getRoomSize(),
	        files: files,
	        links: links,
	        guest_url: guest_url
	      });
	
	      this.updateLoadingSpinner();
	    }
	  }], [{
	    key: 'compareStatus',
	    value: function compareStatus(x, y) {
	      if (x === y) {
	        return 0;
	      }
	      var x_rank = RosterStore.status_sorting_order[x] || 7;
	      var y_rank = RosterStore.status_sorting_order[y] || 7;
	      return x_rank > y_rank ? 1 : -1;
	    }
	  }, {
	    key: 'compareName',
	    value: function compareName(x, y) {
	      if (x === y) {
	        return 0;
	      }
	      return x.name.toLowerCase() > y.name.toLowerCase() ? 1 : -1;
	    }
	  }, {
	    key: 'comparePeople',
	    value: function comparePeople(x, y) {
	      if (x === y) {
	        return 0;
	      }
	      if (!x.presence || !y.presence) {
	        return !y.presence ? 1 : !x.presence ? -1 : 0;
	      }
	
	      var status_comparison = RosterStore.compareStatus(x.presence.show, y.presence.show);
	      if (status_comparison !== 0) {
	        return status_comparison;
	      }
	      return RosterStore.compareName(x, y);
	    }
	  }]);
	  return RosterStore;
	}(_store2.default);
	
	RosterStore.status_sorting_order = {
	  "chat": 1,
	  "away": 2,
	  "xa": 2,
	  "dnd": 3,
	  "mobile": 4,
	  "unavailable": 5,
	  "unknown": 6
	};
	
	exports.default = new RosterStore();
	module.exports = exports['default'];

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _freeze2.default)({
	  SMALL: 'small',
	  MEDIUM: 'medium',
	  LARGE: 'large',
	  XLARGE: 'xlarge'
	});
	module.exports = exports['default'];

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.chatSearch = chatSearch;
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getContainsMultipartQueryRegExp(query) {
	  var split_query = query.replace(/\s/g, '|');
	  return new RegExp('' + split_query, 'gi');
	}
	
	function getStartsWithRegExp(query) {
	  return new RegExp('^' + query, 'i');
	}
	
	function getOtherWordsStartWithRegExp(query) {
	  return new RegExp('\\s' + query, 'i');
	}
	
	function getAnyWordStartsWithRegExp(query) {
	  return new RegExp('^' + query + '|\\s' + query, 'i');
	}
	
	function getMentionStartsWithRegExp(query) {
	  if (query.indexOf('@') === 0) {
	    query = query.slice(1);
	  }
	  return new RegExp('^' + query, 'i');
	}
	
	function getMentionContainsRegExp(query) {
	  if (query.indexOf('@') === 0) {
	    query = query.slice(1);
	  }
	  return new RegExp('' + query, 'i');
	}
	
	function getContainsRegExp(query) {
	  return new RegExp('' + query, 'i');
	}
	
	function lowerCaseMentionHelper(item) {
	  return _.isString(item.mention_name) ? item.mention_name.toLocaleLowerCase() : null;
	}
	
	function isValidChat(item) {
	  // If a room or person, has a valid name, and if-is-a-person-then-has-a-mention-name
	  return (_utils2.default.jid.is_private_chat(item.jid) || _utils2.default.jid.is_room(item.jid)) && _.isString(item.name) && _utils2.default.jid.is_private_chat(item.jid) === _.isString(item.mention_name);
	}
	
	function containsAllMatches(name, queries) {
	  return queries.split(' ').every(function (query) {
	    var query_re = getContainsRegExp(query);
	    return query_re.test(name);
	  });
	}
	
	function getMatches(chats, query) {
	  var number_of_query_parts = query ? _.size(query.match(/\s/g)) + 1 : 0,
	      multipart_query = number_of_query_parts > 1,
	      any_word_starts_with = getAnyWordStartsWithRegExp(query),
	      contains = getContainsRegExp(query),
	      global_contains = getContainsMultipartQueryRegExp(query),
	      mention_starts_with = getMentionStartsWithRegExp(query),
	      mention_contains = getMentionContainsRegExp(query);
	
	  return _.reduce(chats, function (matches, chat_item) {
	    if (!isValidChat(chat_item)) {
	      // Continues to next item
	      return matches;
	    }
	
	    var default_name_match_markup = _.escape(chat_item.name),
	        default_mention_match_markup = _.escape(chat_item.mention_name);
	
	    if (!query) {
	      // If no query, we want to update each item's markup to its default (the actual name/mention_name)
	      //  and send all chats along to sort
	      if (chat_item.mention_name) {
	        chat_item.mention_match_markup = default_mention_match_markup;
	      }
	      chat_item.name_match_markup = default_name_match_markup;
	      matches.push(chat_item);
	      return matches;
	    }
	    var name_match = void 0,
	        mention_match = void 0,
	        name_match_origin = void 0,
	        mention_match_origin = void 0;
	
	    if (chat_item.mention_name) {
	      chat_item.mention_name = chat_item.mention_name;
	    }
	
	    if (multipart_query) {
	      // If multipart query, chats must matches all parts of query
	      var all_matches = chat_item.name.match(global_contains);
	
	      if (all_matches && all_matches.length >= number_of_query_parts) {
	        // No need to check further if chat doesn't have at least as many matches as parts of query
	
	        // Check if name contains every part of query, even if queries are equal or have some equal part
	        if (containsAllMatches(chat_item.name, query)) {
	          name_match = all_matches;
	        }
	      }
	    } else if (query.length === 1) {
	      // If query is only one letter, only match on word starts with for name and mention
	      name_match = chat_item.name.match(any_word_starts_with);
	
	      if (chat_item.mention_name) {
	        mention_match = chat_item.mention_name.match(mention_starts_with);
	      }
	    } else {
	      // If single-part query longer than one letter, match on word starts with or contains
	      name_match = chat_item.name.match(any_word_starts_with) || chat_item.name.match(contains);
	
	      // "starts_with" matches take priority in match markup
	
	      if (chat_item.mention_name) {
	        mention_match = chat_item.mention_name.match(mention_contains);
	      }
	    }
	
	    if (name_match) {
	      name_match_origin = name_match.map(function (item) {
	        var idx = chat_item.name.indexOf(item);
	        return chat_item.name.slice(idx, idx + item.length);
	      });
	    }
	    if (mention_match) {
	      mention_match_origin = mention_match.map(function (item) {
	        var idx = chat_item.mention_name.indexOf(item);
	        return chat_item.mention_name.slice(idx, idx + item.length);
	      });
	    }
	    // We want all chats regardless of match to get updated markup
	    chat_item.name_match_markup = name_match ? _utils2.default.highlight_matches(chat_item.name, name_match_origin) : default_name_match_markup;
	    chat_item.mention_match_markup = mention_match ? _utils2.default.highlight_matches(chat_item.mention_name, mention_match_origin) : default_mention_match_markup;
	
	    if (name_match || mention_match) {
	      matches.push(chat_item);
	    }
	
	    return matches;
	  }, []);
	}
	
	function priorityCompare(lhs, rhs, priorities) {
	  var rhs_is_priority = _.includes(priorities, rhs.jid);
	
	  if (_.includes(priorities, lhs.jid) === rhs_is_priority) {
	    // If both active or both not active
	    return 0;
	  }
	  return rhs_is_priority ? 1 : -1;
	}
	
	function nameCompare(lhs, rhs, query) {
	  var lhs_name = lhs.name.toLocaleLowerCase(),
	      rhs_name = rhs.name.toLocaleLowerCase(),
	      lhs_mention = lowerCaseMentionHelper(lhs),
	      rhs_mention = lowerCaseMentionHelper(rhs),
	      starts_with = getStartsWithRegExp(query),
	      other_word_starts_with = getOtherWordsStartWithRegExp(query),
	      mention_starts_with = getMentionStartsWithRegExp(query),
	      lhs_full_name_equals = query === lhs_name,
	      rhs_full_name_equals = query === rhs_name,
	      lhs_first_word_starts_with = starts_with.test(lhs_name),
	      rhs_first_word_starts_with = starts_with.test(rhs_name),
	      lhs_other_word_starts_with = other_word_starts_with.test(lhs_name),
	      rhs_other_word_starts_with = other_word_starts_with.test(rhs_name),
	      equal_comparsion_query = query.indexOf('@') === 0 ? query.slice(1) : query,
	      lhs_mention_equals = equal_comparsion_query === lhs_mention,
	      rhs_mention_equals = equal_comparsion_query === rhs_mention,
	      lhs_mention_starts_with = lhs_mention ? mention_starts_with.test(lhs_mention) : false,
	      rhs_mention_starts_with = rhs_mention ? mention_starts_with.test(rhs_mention) : false;
	
	  if (lhs_full_name_equals === rhs_full_name_equals) {
	    // If both first words equal to query or both do not
	
	    if (lhs_mention_equals === rhs_mention_equals) {
	      // If both mentions equal to with query or both do not
	
	      if (lhs_first_word_starts_with === rhs_first_word_starts_with) {
	        // If both first words start with query or both do not
	
	        if (lhs_other_word_starts_with === rhs_other_word_starts_with) {
	
	          if (lhs_mention && rhs_mention) {
	
	            if (lhs_mention_starts_with === rhs_mention_starts_with) {
	              // If both mentions start with query or both do not
	              return 0;
	            }
	            // If only one mention starts with query
	            return rhs_mention_starts_with ? 1 : -1;
	          }
	          // If both have other words that start with the query or both do not
	          return 0;
	        }
	        // If only one item's other name starts with query
	        return rhs_other_word_starts_with ? 1 : -1;
	      }
	      // If only one item's name starts with query
	      // First word prioritized over others
	      return rhs_first_word_starts_with ? 1 : -1;
	    }
	
	    return rhs_mention_equals ? 1 : -1;
	  }
	
	  return rhs_full_name_equals ? 1 : -1;
	}
	
	function alphaCompare(lhs, rhs) {
	  var lhs_name = lhs.name.toLocaleLowerCase(),
	      rhs_name = rhs.name.toLocaleLowerCase();
	
	  return lhs_name.localeCompare(rhs_name);
	}
	
	function sortMatches(matches, priorities, query) {
	  // All chats are separated into two groups: priorities and non-priority.
	  // Within these groups, names and mention names are compared for "starts with,"
	  //  "other words start with," and "contains" matches.
	  // If two chats match the query equally, they are then sorted alphabetically by name.
	
	  function comparator(lhs, rhs) {
	    if (!query) {
	      // If no query, no need to sort based on name matches
	      return alphaCompare(lhs, rhs);
	    }
	
	    var comparison = priorities.length ? priorityCompare(lhs, rhs, priorities) : 0;
	
	    if (comparison === 0) {
	      comparison = nameCompare(lhs, rhs, query);
	    }
	
	    if (comparison === 0) {
	      comparison = alphaCompare(lhs, rhs);
	    }
	
	    return comparison;
	  }
	
	  // This is where we finally kick off the sort
	  return matches.sort(comparator);
	}
	
	/**
	 * Filters and sorts chats using search string
	 * @param {array|object} all_chats - List of chats (rooms and users)
	 * @param {string} query - User input
	 * @param {array|object} priorities - List of chats (rooms and users) to prioritize
	 * @returns {array} Filtered and sorted list of chats
	 */
	function chatSearch() {
	  var all_chats = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	  var query = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	  var priorities = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
	
	  if (_.isEmpty(all_chats)) {
	    return [];
	  }
	
	  query = _utils2.default.escapeRegEx(query.trim().toLocaleLowerCase()).replace(/\s+/g, ' ');
	
	  try {
	    /*eslint-disable */
	    var regex_test = new RegExp(query);
	    /*eslint-enable */
	  } catch (e) {
	    return [];
	  }
	
	  // Filter and return sorted list of chats
	  var matches = getMatches(all_chats, query);
	  return sortMatches(matches, priorities, query);
	}

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  file_too_large: 'This file is too large. Try a file that\'s ' + _app_config2.default.max_upload_size + ' MB or smaller.',
	  file_is_folder: 'This looks like a folder; zip it up and try again.',
	  unable_to_upload: 'Couldn\'t upload the file',
	  unable_to_upload_image: 'This image is too large',
	  service_unavailable: 'The service for uploading files is unavailable. Try again later.'
	};
	module.exports = exports['default'];

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.commands = undefined;
	
	var _getIterator2 = __webpack_require__(114);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	exports.matchCommand = matchCommand;
	exports.executeCommand = executeCommand;
	exports.clearAction = clearAction;
	exports.partAction = partAction;
	exports.topicAction = topicAction;
	exports.renameAction = renameAction;
	exports.joinAction = joinAction;
	exports.shortcutsAction = shortcutsAction;
	exports.settingsAction = settingsAction;
	exports.callAction = callAction;
	exports.presenceAction = presenceAction;
	
	var _chat_input_actions = __webpack_require__(261);
	
	var _chat_input_actions2 = _interopRequireDefault(_chat_input_actions);
	
	var _app_header_actions = __webpack_require__(276);
	
	var _app_header_actions2 = _interopRequireDefault(_app_header_actions);
	
	var _keyboard_shortcuts = __webpack_require__(279);
	
	var _keyboard_shortcuts2 = _interopRequireDefault(_keyboard_shortcuts);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _chat_header_actions = __webpack_require__(285);
	
	var _chat_header_actions2 = _interopRequireDefault(_chat_header_actions);
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function matchCommand() {
	  var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var is_private_chat = _utils2.default.jid.is_private_chat(data.jid);
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = (0, _getIterator3.default)(commands), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var command = _step.value;
	
	      if (command.matcher.test(data.text) && (command.members_only && !data.is_guest || !command.members_only) && (command.oto_only && is_private_chat || !command.oto_only) && (command.room_only && !is_private_chat || !command.room_only) && (command.filter && command.filter(data) || !command.filter)) {
	        return command;
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	}
	
	function executeCommand(command) {
	  var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  if (command && command.action) {
	    command.action(data);
	    _logger2.default.type('slash-commands').log('Action executed for command: ', command.name);
	  }
	}
	
	function clearAction(_ref) {
	  var jid = _ref.jid;
	
	  _chat_input_actions2.default.clearChat({ jid: jid });
	}
	
	function partAction(_ref2) {
	  var jid = _ref2.jid;
	
	  _chat_input_actions2.default.closeChat({ jid: jid });
	  _chat_input_actions2.default.clearChatInput();
	}
	
	function topicAction(_ref3) {
	  var text = _ref3.text;
	
	  var topic = text.replace(this.matcher, "").trim();
	  _chat_header_actions2.default.changeTopic(topic);
	  _chat_input_actions2.default.clearChatInput();
	}
	
	function renameAction(_ref4) {
	  var jid = _ref4.jid;
	  var text = _ref4.text;
	
	  var roomName = text.replace(this.matcher, "").trim();
	
	  _form_actions2.default.changeRoomName({
	    jid: jid,
	    name: roomName
	  }, function (error) {
	    if (error) {
	      var error_msg = error.message || _forms_strings2.default.fail.rename_flag;
	      _flag_actions2.default.showFlag({
	        type: "error",
	        body: error_msg,
	        close: "auto"
	      });
	    } else {
	      _flag_actions2.default.showFlag({
	        type: "success",
	        body: _forms_strings2.default.success.rename_flag,
	        close: "auto"
	      });
	    }
	  });
	  _chat_input_actions2.default.clearChatInput();
	}
	
	function joinAction(_ref5) {
	  var text = _ref5.text;
	
	  var room = text.replace(this.matcher, "").trim();
	  _chat_input_actions2.default.clearChatInput();
	  _chat_input_actions2.default.joinChat({ room: room });
	}
	
	function shortcutsAction() {
	  var commands = _keyboard_shortcuts2.default.getKeyCommands();
	  _dialog_actions2.default.showKeyboardShortcutsDialog(commands);
	  _chat_input_actions2.default.clearChatInput();
	}
	
	function settingsAction() {
	  _app_header_actions2.default.requestPreferencesDialog();
	  _chat_input_actions2.default.clearChatInput();
	}
	
	function callAction(_ref6) {
	  var jid = _ref6.jid;
	  var videoService = _ref6.videoService;
	  var room_id = _ref6.room_id;
	  var room_is_archived = _ref6.room_is_archived;
	
	  if (_utils2.default.jid.is_room(jid) && !room_is_archived) {
	    _chat_header_actions2.default.startEnsoRoomVideo({
	      jid: jid,
	      room_id: room_id
	    });
	  } else {
	    _chat_header_actions2.default.startCall({
	      jid: jid,
	      service: videoService
	    });
	  }
	  _chat_input_actions2.default.clearChatInput();
	}
	
	function presenceAction(_ref7) {
	  var text = _ref7.text;
	
	  var index = text.indexOf(' '),
	      show_type = text,
	      payload = {
	    type: 'showAndStatus'
	  },
	      status;
	
	  if (_.includes(text, ' ')) {
	    status = text.substr(index).trim();
	    if (status) {
	      payload.status = status;
	    }
	    show_type = show_type.substr(0, index);
	  }
	
	  switch (show_type.substr(1)) {
	    case 'available':
	    case 'here':
	    case 'back':
	      payload.show = _presence2.default.AVAILABLE;
	      break;
	
	    case 'away':
	      payload.show = _presence2.default.AWAY;
	      break;
	
	    case 'dnd':
	      payload.show = _presence2.default.DND;
	      break;
	  }
	
	  _current_user_actions2.default.changeStatus(payload);
	  _chat_input_actions2.default.clearChatInput();
	}
	
	var commands = exports.commands = [{
	  name: '/topic',
	  aliases: [],
	  description: 'Change chat topic',
	  usage: '[new topic]',
	  members_only: true,
	  room_only: true,
	  matcher: /^\/(topic)\s/,
	  action: topicAction
	}, {
	  name: '/rename',
	  aliases: [],
	  description: 'Rename a room',
	  usage: '[new name]',
	  members_only: true,
	  room_only: true,
	  matcher: /^\/(rename)\s/,
	  action: renameAction
	}, {
	  name: '/clear',
	  aliases: [],
	  description: 'Locally clears history for chat',
	  usage: null,
	  matcher: /^\/clear\s?$/,
	  action: clearAction
	}, {
	  name: '/join',
	  aliases: ['/enter'],
	  description: 'Join a room or 1-1 chat',
	  usage: '[or /enter] [room name/user mention]',
	  members_only: true,
	  matcher: /^\/(join|enter)\s/,
	  action: joinAction
	}, {
	  name: '/part',
	  aliases: ['/close', '/leave'],
	  description: 'Leave a room or 1-1 chat',
	  usage: '[or /close, /leave]',
	  members_only: true,
	  matcher: /^\/(part|leave|close)\s?$/,
	  action: partAction
	}, {
	  name: '/me',
	  aliases: ['/em'],
	  description: 'Display action text',
	  usage: '[or /em] your message',
	  members_only: true,
	  matcher: /^\/(me|em)\s/,
	  should_send_message: true
	}, {
	  name: '/quote',
	  aliases: [],
	  description: 'Display quote message',
	  usage: 'your message',
	  matcher: /^\/(quote)\s\w/,
	  should_send_message: true
	}, {
	  name: '/code',
	  aliases: [],
	  description: 'Display code snippet',
	  usage: 'some code',
	  matcher: /^\/(code)\s\w/,
	  should_send_message: true
	}, {
	  name: '/pre',
	  aliases: ['/monospace'],
	  description: 'Display text in monospaced font',
	  usage: '[or /monospace] some text',
	  matcher: /^\/(pre|monospace)\s\w/,
	  should_send_message: true
	}, {
	  name: '/here',
	  aliases: ['/available', '/back'],
	  description: 'Set presence to available',
	  usage: '[or /available, /back] [your status]',
	  matcher: /^\/(here|available|back)\s?/,
	  action: presenceAction
	}, {
	  name: '/away',
	  aliases: [],
	  description: 'Set presence to away',
	  usage: '[your status]',
	  matcher: /^\/(away)\s?/,
	  action: presenceAction
	}, {
	  name: '/dnd',
	  aliases: [],
	  description: 'Set presence to do not disturb',
	  usage: '[your status]',
	  matcher: /^\/(dnd)\s?/,
	  action: presenceAction
	}, {
	  name: '/shortcuts',
	  aliases: ['/keys'],
	  description: 'Open the keyboard shortcuts dialog',
	  usage: '[or /keys]',
	  members_only: true,
	  matcher: /^\/(shortcuts|keys)\s?$/,
	  action: shortcutsAction
	}, {
	  name: '/settings',
	  aliases: ["/prefs"],
	  description: 'Open the settings dialog',
	  usage: '[or /prefs]',
	  members_only: true,
	  matcher: /^\/(prefs|settings)\s?$/,
	  action: settingsAction
	}, {
	  name: '/videocall',
	  aliases: ['/call'],
	  description: 'Start video call',
	  usage: '[or /call]',
	  members_only: true,
	  oto_only: false,
	  matcher: /^\/(videocall|call)\s?$/,
	  action: callAction,
	  filter: function filter(_ref8) {
	    var jid = _ref8.jid;
	    var video_enabled = _ref8.video_enabled;
	    var room_video_enabled = _ref8.room_video_enabled;
	
	    return _utils2.default.jid.is_room(jid) ? room_video_enabled : video_enabled;
	  }
	}];

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Used to trigger actions on the application header
	 * @module actions/AppHeaderActions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	var AnalyticsDispatcher = __webpack_require__(173);
	var DialogActions = __webpack_require__(95);
	var InlineDialogActions = __webpack_require__(277);
	var spi = __webpack_require__(93);
	
	module.exports = {
	
	  requestReleaseNotesDialog: function requestReleaseNotesDialog() {
	    DialogActions.showReleaseNotesDialog();
	  },
	
	  /**
	   * Displays settings dialog
	   */
	  requestPreferencesDialog: function requestPreferencesDialog() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.profile.settings.clicked"
	    });
	
	    spi.showPreferencesDialog();
	  },
	
	  /**
	   * Hides inline dialog for status message update
	   */
	  hideStatusMessageForm: function hideStatusMessageForm() {
	    InlineDialogActions.hideInlineDialog();
	  },
	
	  /**
	   * Analytics event
	   * @private
	   */
	  helpButtonClicked: function helpButtonClicked() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.help.clicked"
	    });
	  },
	
	  /**
	   * Analytics event
	   * @private
	   */
	  userProfileDropdownClicked: function userProfileDropdownClicked() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.profile.clicked"
	    });
	  },
	
	  /**
	   * Sets focus to search box
	   * @param jid JID of the currently selected chat
	   */
	  searchHistory: function searchHistory(jid, text) {
	    AppDispatcher.dispatch('set-route', { jid: 'search' });
	    AppDispatcher.dispatch("search-history", { jid: jid, text: text });
	  },
	
	  /**
	   * Executes search in external HipChat search page by launching a new tab/window
	   * @param jid JID of the currently selected chat
	   */
	  searchHistoryExternally: function searchHistoryExternally(jid, text) {
	    AppDispatcher.dispatch("search-history-externally", { jid: jid, text: text });
	  },
	
	  /**
	   * Sets the search text inside the search input field
	   * @param {object} data
	   * @param {string} data.text Search query
	   */
	  setSearchText: function setSearchText(data) {
	    AppDispatcher.dispatch('set-search-text', data);
	  },
	
	  /**
	   * Remove focus from search input field
	   */
	  searchBlurred: function searchBlurred() {
	    AppDispatcher.dispatch("blur-search");
	  },
	
	  /**
	   * Dismiss the notification permission banner that appears when the user
	   * first uses the chat client. This method just dismisses it temporarily.
	   * If you want to dismiss it forever, use the dismissNotificationBannerForever()
	   * method.
	   */
	  dismissNotificationBanner: function dismissNotificationBanner() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.banner.notification.dismiss.once"
	    });
	    AppDispatcher.dispatch('dismiss-notification-banner');
	  },
	
	  /**
	   * Dismiss the notification permission banner that appears when the user
	   * first uses the chat client. This method just dismisses it forever.
	   * If you want to dismiss it temporarily, use the dismissNotificationBanner()
	   * method.
	   */
	  dismissNotificationBannerForever: function dismissNotificationBannerForever() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.banner.notification.dismiss.forever"
	    });
	    AppDispatcher.dispatch('dismiss-notification-banner-forever');
	  },
	
	  /**
	   * Triggers the HTML5 notification permission prompt
	   */
	  requestNotificationPermission: function requestNotificationPermission() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.banner.notification.request.permission"
	    });
	    AppDispatcher.dispatch('request-notification-permission');
	  },
	
	  /**
	   * Dispatch event to reposition active dialogs in the app header
	   */
	  positionDialogs: function positionDialogs() {
	    AppDispatcher.dispatch('position-app-header-dialogs');
	  }
	
	};

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _inline_dialog_store = __webpack_require__(278);
	
	var _inline_dialog_store2 = _interopRequireDefault(_inline_dialog_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  hideInlineDialog: function hideInlineDialog() {
	    _app_dispatcher2.default.dispatch('hide-inline-dialog', {
	      dialog_type: _inline_dialog_store2.default.getCurrentInlineDialog()
	    });
	  },
	
	  toggleInlineDialog: function toggleInlineDialog(dialogType, data) {
	    _app_dispatcher2.default.dispatch('toggle-inline-dialog', {
	      dialog_type: dialogType,
	      current_dialog_type: _inline_dialog_store2.default.getCurrentInlineDialog(),
	      dialog_data: data
	    });
	  },
	
	  showUserStatusMessage: function showUserStatusMessage(data) {
	    _app_dispatcher2.default.dispatch("show-inline-dialog", {
	      dialog_type: "user-status-message-inline-dialog",
	      dialog_data: data
	    });
	  },
	
	  showConnectionStatusMessage: function showConnectionStatusMessage(data) {
	    _app_dispatcher2.default.dispatch("show-inline-dialog", {
	      dialog_type: "connection-status-message-inline-dialog",
	      dialog_data: data
	    });
	  },
	
	  showGuestAccessInformation: function showGuestAccessInformation(data) {
	    _app_dispatcher2.default.dispatch("show-inline-dialog", {
	      dialog_type: "guest-access-information-inline-dialog",
	      dialog_data: data
	    });
	  },
	
	  showAddIntegrationsHelperDialog: function showAddIntegrationsHelperDialog(data) {
	    _app_dispatcher2.default.dispatch("show-inline-dialog", {
	      dialog_type: "add-integrations-help-dialog",
	      dialog_data: data
	    });
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var InlineDialogStore = function (_Store) {
	  (0, _inherits3.default)(InlineDialogStore, _Store);
	
	  function InlineDialogStore() {
	    (0, _classCallCheck3.default)(this, InlineDialogStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(InlineDialogStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(InlineDialogStore, [{
	    key: "getDefaults",
	    value: function getDefaults() {
	      return {
	        activeDialog: false,
	        bannerShown: false,
	        dialogData: false,
	        web_server: _app_config2.default.default_web_server,
	        current_user_id: ''
	      };
	    }
	  }, {
	    key: "registerListeners",
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'show-inline-dialog': function showInlineDialog(data) {
	          _this2._showInlineDialog(data);
	        },
	        'hide-inline-dialog': function hideInlineDialog() {
	          _this2._hideInlineDialog();
	        },
	        'toggle-inline-dialog': function toggleInlineDialog(data) {
	          _this2._toggleInlineDialog(data);
	        },
	        'updated:web_server': function updatedWeb_server(web_server) {
	          _this2.set("web_server", web_server);
	        },
	        'notification-banner-status': function notificationBannerStatus(data) {
	          _this2.set('bannerShown', data.shown);
	        },
	        'updated:current_user': function updatedCurrent_user(data) {
	          _this2.set('current_user_id', data.user_id);
	        }
	      });
	    }
	  }, {
	    key: "_toggleInlineDialog",
	    value: function _toggleInlineDialog(data) {
	      // Show a new dialog if it is different to the current one
	      if (data.dialog_type !== this.getCurrentInlineDialog()) {
	        this._showInlineDialog(data);
	      } else {
	        // Otherwise the new and current are the same so we hide it
	        this._hideInlineDialog();
	      }
	    }
	  }, {
	    key: "_showInlineDialog",
	    value: function _showInlineDialog(data) {
	      this.set({
	        activeDialog: data.dialog_type,
	        dialogData: data.dialog_data
	      });
	    }
	  }, {
	    key: "_hideInlineDialog",
	    value: function _hideInlineDialog() {
	      if (this.getCurrentInlineDialog() !== false) {
	        this.set({
	          activeDialog: false,
	          dialogData: false
	        });
	      }
	    }
	  }, {
	    key: "getCurrentInlineDialog",
	    value: function getCurrentInlineDialog() {
	      return this.get("activeDialog");
	    }
	  }]);
	  return InlineDialogStore;
	}(_store2.default);
	
	exports.default = new InlineDialogStore();
	module.exports = exports['default'];

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _mousetrap = __webpack_require__(280);
	
	var _mousetrap2 = _interopRequireDefault(_mousetrap);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _keyboard_shortcut_actions = __webpack_require__(281);
	
	var _keyboard_shortcut_actions2 = _interopRequireDefault(_keyboard_shortcut_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _keyboard_shortcut_strings = __webpack_require__(282);
	
	var _keyboard_shortcut_strings2 = _interopRequireDefault(_keyboard_shortcut_strings);
	
	var _keyboard_shortcut_action_keys = __webpack_require__(283);
	
	var _keyboard_shortcut_action_keys2 = _interopRequireDefault(_keyboard_shortcut_action_keys);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _modal_dialog_store = __webpack_require__(284);
	
	var _modal_dialog_store2 = _interopRequireDefault(_modal_dialog_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var KeyboardShortcuts = {
	
	  /**
	   * This method initializes the key commands. Pass an optional array of key commands.
	   * If no key commands are provided defaults will be used.
	   *
	   * Simple example:
	   * [{
	   *   "keys": "command+j", // see https://craig.is/killing/mice for available options
	   *   "action": "New chat" // default title and display will show in key commands dialog
	   * }]
	   *
	   * Advanced example:
	   * [{
	   *   "keys": ["command+j", "command+n"], // array for multiple commands to single action
	   *   "action": function(){ alert("example") }, // custom action
	   *   "title": "New action!", // overwrite default title
	   *   "display": "Cmd + J or Cmd + N" // overwrite default key display
	   * }]
	   */
	
	  init: function init(keyCommands) {
	    this.commands = [];
	    this.processCommands(keyCommands || this.getDefaults());
	  },
	  processCommands: function processCommands(keyCommands) {
	    var _this = this;
	
	    keyCommands.forEach(function (command) {
	      // must have keys and an associated action (string or function)
	      // keys can be a string or array (for multiple commands with the same action)
	      if (command.keys && command.action) {
	        _this.bindHandler(command);
	      }
	
	      // all key commands will be added to the visible list unless the property
	      // display: false is passed. The default display is the "keys" property
	      // but you can set this to anything with display: "example+any+key". If you
	      // pass an array into the "keys" prop only the first will be use for display.
	      if (command.display !== false) {
	        _this.addDisplayItem(command);
	      }
	    });
	  },
	  bindHandler: function bindHandler(command) {
	    var _this2 = this;
	
	    var actionHandler = typeof command.action === "function" ? command.action : this.getHandler(command.action);
	
	    _mousetrap2.default.bind(command.keys, function (e) {
	      _this2.dispatchAnalyticsEvent(command);
	      return actionHandler.apply(_this2, [command, e]);
	    });
	  },
	  dispatchAnalyticsEvent: function dispatchAnalyticsEvent(command) {
	    if (typeof command.action === 'function') {
	      command.action = '[Function]';
	    }
	    _analytics_dispatcher2.default.dispatch('analytics-keyboard-shortcut-used', command);
	  },
	  addDisplayItem: function addDisplayItem(command) {
	    var title = command.title ? command.title : this.getTitle(command.action);
	    var keys = this.formatDisplay(command.display || command.keys);
	
	    this.commands.push({
	      title: title,
	      keys: keys
	    });
	  },
	  getTitle: function getTitle(action) {
	    var title = void 0;
	
	    switch (action) {
	      case _keyboard_shortcut_action_keys2.default.NEW_CHAT:
	        title = _keyboard_shortcut_strings2.default.new_chat;
	        break;
	      case _keyboard_shortcut_action_keys2.default.INVITE_TO_ROOM:
	        title = _keyboard_shortcut_strings2.default.room_invite_users;
	        break;
	      case _keyboard_shortcut_action_keys2.default.CLOSE_ROOM:
	        title = _keyboard_shortcut_strings2.default.close_room;
	        break;
	      case _keyboard_shortcut_action_keys2.default.CREATE_ROOM:
	        title = _keyboard_shortcut_strings2.default.create_room;
	        break;
	      case _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_UP:
	        title = _keyboard_shortcut_strings2.default.navigate_rooms_up;
	        break;
	      case _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_DOWN:
	        title = _keyboard_shortcut_strings2.default.navigate_rooms_down;
	        break;
	      case _keyboard_shortcut_action_keys2.default.SEARCH_HISTORY:
	        title = _keyboard_shortcut_strings2.default.search_history;
	        break;
	      case _keyboard_shortcut_action_keys2.default.TOGGLE_SOUND_NOTIFICATIONS:
	        title = _keyboard_shortcut_strings2.default.toggle_sound_notifications;
	        break;
	      case _keyboard_shortcut_action_keys2.default.MARK_ROOMS_AS_READ:
	        title = _keyboard_shortcut_strings2.default.mark_rooms_as_read;
	        break;
	      case _keyboard_shortcut_action_keys2.default.MARK_CHATS_AS_READ:
	        title = _keyboard_shortcut_strings2.default.mark_chats_as_read;
	        break;
	      case _keyboard_shortcut_action_keys2.default.RECALL_OLDER_INPUT_HISTORY:
	        title = _keyboard_shortcut_strings2.default.recall_older_input_history;
	        break;
	      case _keyboard_shortcut_action_keys2.default.RECALL_NEWER_INPUT_HISTORY:
	        title = _keyboard_shortcut_strings2.default.recall_newer_input_history;
	        break;
	      case _keyboard_shortcut_action_keys2.default.VIEW_SHORTCUTS:
	        title = _keyboard_shortcut_strings2.default.view_shortcuts;
	        break;
	      default:
	        title = "";
	    }
	    return title;
	  },
	  getHandler: function getHandler(action) {
	    var result = void 0;
	
	    switch (action) {
	      case _keyboard_shortcut_action_keys2.default.NEW_CHAT:
	        result = this.openQuickSwitcher.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.INVITE_TO_ROOM:
	        result = this.inviteUsersToRoom.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.CLOSE_ROOM:
	        result = this.closeRoom.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.CREATE_ROOM:
	        result = this.createRoom.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_UP:
	        result = this.navigateRoomsUp.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_DOWN:
	        result = this.navigateRoomsDown.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.SEARCH_HISTORY:
	        result = this.searchHistory.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.TOGGLE_SOUND_NOTIFICATIONS:
	        result = this.toggleSoundNotifications.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.MARK_ROOMS_AS_READ:
	        result = this.markRoomsAsRead.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.MARK_CHATS_AS_READ:
	        result = this.markChatsAsRead.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.VIEW_SHORTCUTS:
	        result = this.showKeyboardShortcutsDialog.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.REOPEN_LAST_CHAT:
	        result = this.reopenLastChat.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.RECALL_OLDER_INPUT_HISTORY:
	        result = this.recallOlderInputHistory.bind(this);
	        break;
	      case _keyboard_shortcut_action_keys2.default.RECALL_NEWER_INPUT_HISTORY:
	        result = this.recallNewerInputHistory.bind(this);
	        break;
	      default:
	        result = null;
	    }
	    return result;
	  },
	  formatDisplay: function formatDisplay() {
	    var display = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
	
	    display = _utils2.default.toArray(display)[0];
	
	    var keys = _.forEach(display.split("+"), function (val, index, arr) {
	      val = val.toLowerCase();
	      var type = val === "command" ? "modifier" : "normal";
	      var keyName = "";
	
	      switch (val) {
	        case "ctrl":
	          keyName = _keyboard_shortcut_strings2.default.control;
	          break;
	        case "alt":
	          keyName = _keyboard_shortcut_strings2.default.alt;
	          break;
	        case "shift":
	          keyName = _keyboard_shortcut_strings2.default.shift;
	          break;
	        case "option":
	          keyName = _keyboard_shortcut_strings2.default.option;
	          break;
	        case "command":
	          keyName = _keyboard_shortcut_strings2.default.command;
	          break;
	        case "esc":
	          keyName = _keyboard_shortcut_strings2.default.esc;
	          break;
	        case "tab":
	          keyName = _keyboard_shortcut_strings2.default.tab;
	          break;
	        case "up":
	          keyName = _keyboard_shortcut_strings2.default.up_arrow;
	          break;
	        case "down":
	          keyName = _keyboard_shortcut_strings2.default.down_arrow;
	          break;
	        case "left":
	          keyName = _keyboard_shortcut_strings2.default.left_arrow;
	          break;
	        case "right":
	          keyName = _keyboard_shortcut_strings2.default.right_arrow;
	          break;
	        default:
	          keyName = val;
	      }
	
	      arr[index] = {
	        type: type,
	        name: keyName
	      };
	    });
	    return keys;
	  },
	  getDefaults: function getDefaults() {
	    var defaults = _utils2.default.platform.isMac() ? this.getDefaultsMac() : this.getDefaultsWindows();
	    return defaults;
	  },
	  getDefaultsMac: function getDefaultsMac() {
	    return [{
	      "keys": "command+j",
	      "action": _keyboard_shortcut_action_keys2.default.NEW_CHAT
	    }, {
	      "keys": "command+i",
	      "action": _keyboard_shortcut_action_keys2.default.INVITE_TO_ROOM
	    }, {
	      "keys": "command+option+w",
	      "action": _keyboard_shortcut_action_keys2.default.CLOSE_ROOM
	    }, {
	      "keys": "command+option+up",
	      "action": _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_UP
	    }, {
	      "keys": "command+option+down",
	      "action": _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_DOWN
	    }, {
	      "keys": "command+option+f",
	      "action": _keyboard_shortcut_action_keys2.default.SEARCH_HISTORY
	    }, {
	      "keys": "command+shift+s",
	      "action": _keyboard_shortcut_action_keys2.default.TOGGLE_SOUND_NOTIFICATIONS
	    }, {
	      "keys": "command+option+m",
	      "action": _keyboard_shortcut_action_keys2.default.MARK_ROOMS_AS_READ
	    }, {
	      "keys": "command+option+shift+m",
	      "action": _keyboard_shortcut_action_keys2.default.MARK_CHATS_AS_READ
	    }, {
	      "keys": "option+up",
	      "action": _keyboard_shortcut_action_keys2.default.RECALL_OLDER_INPUT_HISTORY
	    }, {
	      "keys": "option+down",
	      "action": _keyboard_shortcut_action_keys2.default.RECALL_NEWER_INPUT_HISTORY
	    }, {
	      "keys": "command+/",
	      "action": _keyboard_shortcut_action_keys2.default.VIEW_SHORTCUTS
	    }];
	  },
	  getDefaultsWindows: function getDefaultsWindows() {
	    return [{
	      "keys": "ctrl+j",
	      "action": _keyboard_shortcut_action_keys2.default.NEW_CHAT
	    }, {
	      "keys": "ctrl+i",
	      "action": _keyboard_shortcut_action_keys2.default.INVITE_TO_ROOM
	    }, {
	      "keys": "ctrl+alt+w",
	      "action": _keyboard_shortcut_action_keys2.default.CLOSE_ROOM
	    }, {
	      "keys": "ctrl+alt+up",
	      "action": _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_UP
	    }, {
	      "keys": "ctrl+alt+down",
	      "action": _keyboard_shortcut_action_keys2.default.NAVIGATE_ROOMS_DOWN
	    }, {
	      "keys": "ctrl+alt+f",
	      "action": _keyboard_shortcut_action_keys2.default.SEARCH_HISTORY
	    }, {
	      "keys": "ctrl+shift+s",
	      "action": _keyboard_shortcut_action_keys2.default.TOGGLE_SOUND_NOTIFICATIONS
	    }, {
	      "keys": "ctrl+alt+m",
	      "action": _keyboard_shortcut_action_keys2.default.MARK_ROOMS_AS_READ
	    }, {
	      "keys": "ctrl+alt+shift+m",
	      "action": _keyboard_shortcut_action_keys2.default.MARK_CHATS_AS_READ
	    }, {
	      "keys": "ctrl+up",
	      "action": _keyboard_shortcut_action_keys2.default.RECALL_OLDER_INPUT_HISTORY
	    }, {
	      "keys": "ctrl+down",
	      "action": _keyboard_shortcut_action_keys2.default.RECALL_NEWER_INPUT_HISTORY
	    }, {
	      "keys": "ctrl+/",
	      "action": _keyboard_shortcut_action_keys2.default.VIEW_SHORTCUTS
	    }];
	  },
	  getKeyCommands: function getKeyCommands() {
	    return this.commands;
	  },
	  getCommandByTitle: function getCommandByTitle(title) {
	    var command = _.find(this.commands, { 'title': title });
	
	    if (command) {
	      return command.keys.map(function (key) {
	        return key.name;
	      });
	    }
	  },
	  openQuickSwitcher: function openQuickSwitcher() {
	    if (_modal_dialog_store2.default.getCurrentModalDialog()) {
	      return false;
	    }
	
	    _dialog_actions2.default.showQuickSwitcherDialog(true); //true param to hide hint
	    return false;
	  },
	  inviteUsersToRoom: function inviteUsersToRoom() {
	    _keyboard_shortcut_actions2.default.inviteUsersToRoom();
	    return false;
	  },
	  createRoom: function createRoom() {
	    _keyboard_shortcut_actions2.default.createRoom();
	    return false;
	  },
	  searchHistory: function searchHistory() {
	    _keyboard_shortcut_actions2.default.searchHistory();
	    return false;
	  },
	  closeRoom: function closeRoom() {
	    _keyboard_shortcut_actions2.default.closeRoom();
	    return false;
	  },
	  navigateRoomsUp: function navigateRoomsUp() {
	    _keyboard_shortcut_actions2.default.navigateRoomsUp();
	    return false;
	  },
	  navigateRoomsDown: function navigateRoomsDown() {
	    _keyboard_shortcut_actions2.default.navigateRoomsDown();
	    return false;
	  },
	  openSettings: function openSettings() {
	    _keyboard_shortcut_actions2.default.openSettings();
	    return false;
	  },
	  toggleSoundNotifications: function toggleSoundNotifications() {
	    _keyboard_shortcut_actions2.default.toggleSoundNotifications();
	    return false;
	  },
	  markRoomsAsRead: function markRoomsAsRead() {
	    _keyboard_shortcut_actions2.default.markRoomsAsRead();
	    return false;
	  },
	  markChatsAsRead: function markChatsAsRead() {
	    _keyboard_shortcut_actions2.default.markChatsAsRead();
	    return false;
	  },
	  showKeyboardShortcutsDialog: function showKeyboardShortcutsDialog() {
	    _dialog_actions2.default.showKeyboardShortcutsDialog(this.commands);
	    return false;
	  },
	  reopenLastChat: function reopenLastChat() {
	    _keyboard_shortcut_actions2.default.reopenLastChat();
	    return false;
	  },
	  recallOlderInputHistory: function recallOlderInputHistory(command, e) {
	    _keyboard_shortcut_actions2.default.recallOlderInputHistory(e);
	    return false;
	  },
	  recallNewerInputHistory: function recallNewerInputHistory(command, e) {
	    _keyboard_shortcut_actions2.default.recallNewerInputHistory(e);
	    return false;
	  }
	};
	
	exports.default = KeyboardShortcuts;
	module.exports = exports['default'];

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
	/**
	 * Copyright 2015 Craig Campbell
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * Mousetrap is a simple keyboard shortcut library for Javascript with
	 * no external dependencies
	 *
	 * @version 1.5.3
	 * @url craig.is/killing/mice
	 */
	(function(window, document, undefined) {
	
	    /**
	     * mapping of special keycodes to their corresponding keys
	     *
	     * everything in this dictionary cannot use keypress events
	     * so it has to be here to map to the correct keycodes for
	     * keyup/keydown events
	     *
	     * @type {Object}
	     */
	    var _MAP = {
	        8: 'backspace',
	        9: 'tab',
	        13: 'enter',
	        16: 'shift',
	        17: 'ctrl',
	        18: 'alt',
	        20: 'capslock',
	        27: 'esc',
	        32: 'space',
	        33: 'pageup',
	        34: 'pagedown',
	        35: 'end',
	        36: 'home',
	        37: 'left',
	        38: 'up',
	        39: 'right',
	        40: 'down',
	        45: 'ins',
	        46: 'del',
	        91: 'meta',
	        93: 'meta',
	        224: 'meta'
	    };
	
	    /**
	     * mapping for special characters so they can support
	     *
	     * this dictionary is only used incase you want to bind a
	     * keyup or keydown event to one of these keys
	     *
	     * @type {Object}
	     */
	    var _KEYCODE_MAP = {
	        106: '*',
	        107: '+',
	        109: '-',
	        110: '.',
	        111 : '/',
	        186: ';',
	        187: '=',
	        188: ',',
	        189: '-',
	        190: '.',
	        191: '/',
	        192: '`',
	        219: '[',
	        220: '\\',
	        221: ']',
	        222: '\''
	    };
	
	    /**
	     * this is a mapping of keys that require shift on a US keypad
	     * back to the non shift equivelents
	     *
	     * this is so you can use keyup events with these keys
	     *
	     * note that this will only work reliably on US keyboards
	     *
	     * @type {Object}
	     */
	    var _SHIFT_MAP = {
	        '~': '`',
	        '!': '1',
	        '@': '2',
	        '#': '3',
	        '$': '4',
	        '%': '5',
	        '^': '6',
	        '&': '7',
	        '*': '8',
	        '(': '9',
	        ')': '0',
	        '_': '-',
	        '+': '=',
	        ':': ';',
	        '\"': '\'',
	        '<': ',',
	        '>': '.',
	        '?': '/',
	        '|': '\\'
	    };
	
	    /**
	     * this is a list of special strings you can use to map
	     * to modifier keys when you specify your keyboard shortcuts
	     *
	     * @type {Object}
	     */
	    var _SPECIAL_ALIASES = {
	        'option': 'alt',
	        'command': 'meta',
	        'return': 'enter',
	        'escape': 'esc',
	        'plus': '+',
	        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
	    };
	
	    /**
	     * variable to store the flipped version of _MAP from above
	     * needed to check if we should use keypress or not when no action
	     * is specified
	     *
	     * @type {Object|undefined}
	     */
	    var _REVERSE_MAP;
	
	    /**
	     * loop through the f keys, f1 to f19 and add them to the map
	     * programatically
	     */
	    for (var i = 1; i < 20; ++i) {
	        _MAP[111 + i] = 'f' + i;
	    }
	
	    /**
	     * loop through to map numbers on the numeric keypad
	     */
	    for (i = 0; i <= 9; ++i) {
	        _MAP[i + 96] = i;
	    }
	
	    /**
	     * cross browser add event method
	     *
	     * @param {Element|HTMLDocument} object
	     * @param {string} type
	     * @param {Function} callback
	     * @returns void
	     */
	    function _addEvent(object, type, callback) {
	        if (object.addEventListener) {
	            object.addEventListener(type, callback, false);
	            return;
	        }
	
	        object.attachEvent('on' + type, callback);
	    }
	
	    /**
	     * takes the event and returns the key character
	     *
	     * @param {Event} e
	     * @return {string}
	     */
	    function _characterFromEvent(e) {
	
	        // for keypress events we should return the character as is
	        if (e.type == 'keypress') {
	            var character = String.fromCharCode(e.which);
	
	            // if the shift key is not pressed then it is safe to assume
	            // that we want the character to be lowercase.  this means if
	            // you accidentally have caps lock on then your key bindings
	            // will continue to work
	            //
	            // the only side effect that might not be desired is if you
	            // bind something like 'A' cause you want to trigger an
	            // event when capital A is pressed caps lock will no longer
	            // trigger the event.  shift+a will though.
	            if (!e.shiftKey) {
	                character = character.toLowerCase();
	            }
	
	            return character;
	        }
	
	        // for non keypress events the special maps are needed
	        if (_MAP[e.which]) {
	            return _MAP[e.which];
	        }
	
	        if (_KEYCODE_MAP[e.which]) {
	            return _KEYCODE_MAP[e.which];
	        }
	
	        // if it is not in the special map
	
	        // with keydown and keyup events the character seems to always
	        // come in as an uppercase character whether you are pressing shift
	        // or not.  we should make sure it is always lowercase for comparisons
	        return String.fromCharCode(e.which).toLowerCase();
	    }
	
	    /**
	     * checks if two arrays are equal
	     *
	     * @param {Array} modifiers1
	     * @param {Array} modifiers2
	     * @returns {boolean}
	     */
	    function _modifiersMatch(modifiers1, modifiers2) {
	        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
	    }
	
	    /**
	     * takes a key event and figures out what the modifiers are
	     *
	     * @param {Event} e
	     * @returns {Array}
	     */
	    function _eventModifiers(e) {
	        var modifiers = [];
	
	        if (e.shiftKey) {
	            modifiers.push('shift');
	        }
	
	        if (e.altKey) {
	            modifiers.push('alt');
	        }
	
	        if (e.ctrlKey) {
	            modifiers.push('ctrl');
	        }
	
	        if (e.metaKey) {
	            modifiers.push('meta');
	        }
	
	        return modifiers;
	    }
	
	    /**
	     * prevents default for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _preventDefault(e) {
	        if (e.preventDefault) {
	            e.preventDefault();
	            return;
	        }
	
	        e.returnValue = false;
	    }
	
	    /**
	     * stops propogation for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _stopPropagation(e) {
	        if (e.stopPropagation) {
	            e.stopPropagation();
	            return;
	        }
	
	        e.cancelBubble = true;
	    }
	
	    /**
	     * determines if the keycode specified is a modifier key or not
	     *
	     * @param {string} key
	     * @returns {boolean}
	     */
	    function _isModifier(key) {
	        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
	    }
	
	    /**
	     * reverses the map lookup so that we can look for specific keys
	     * to see what can and can't use keypress
	     *
	     * @return {Object}
	     */
	    function _getReverseMap() {
	        if (!_REVERSE_MAP) {
	            _REVERSE_MAP = {};
	            for (var key in _MAP) {
	
	                // pull out the numeric keypad from here cause keypress should
	                // be able to detect the keys from the character
	                if (key > 95 && key < 112) {
	                    continue;
	                }
	
	                if (_MAP.hasOwnProperty(key)) {
	                    _REVERSE_MAP[_MAP[key]] = key;
	                }
	            }
	        }
	        return _REVERSE_MAP;
	    }
	
	    /**
	     * picks the best action based on the key combination
	     *
	     * @param {string} key - character for key
	     * @param {Array} modifiers
	     * @param {string=} action passed in
	     */
	    function _pickBestAction(key, modifiers, action) {
	
	        // if no action was picked in we should try to pick the one
	        // that we think would work best for this key
	        if (!action) {
	            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
	        }
	
	        // modifier keys don't work as expected with keypress,
	        // switch to keydown
	        if (action == 'keypress' && modifiers.length) {
	            action = 'keydown';
	        }
	
	        return action;
	    }
	
	    /**
	     * Converts from a string key combination to an array
	     *
	     * @param  {string} combination like "command+shift+l"
	     * @return {Array}
	     */
	    function _keysFromString(combination) {
	        if (combination === '+') {
	            return ['+'];
	        }
	
	        combination = combination.replace(/\+{2}/g, '+plus');
	        return combination.split('+');
	    }
	
	    /**
	     * Gets info for a specific key combination
	     *
	     * @param  {string} combination key combination ("command+s" or "a" or "*")
	     * @param  {string=} action
	     * @returns {Object}
	     */
	    function _getKeyInfo(combination, action) {
	        var keys;
	        var key;
	        var i;
	        var modifiers = [];
	
	        // take the keys from this pattern and figure out what the actual
	        // pattern is all about
	        keys = _keysFromString(combination);
	
	        for (i = 0; i < keys.length; ++i) {
	            key = keys[i];
	
	            // normalize key names
	            if (_SPECIAL_ALIASES[key]) {
	                key = _SPECIAL_ALIASES[key];
	            }
	
	            // if this is not a keypress event then we should
	            // be smart about using shift keys
	            // this will only work for US keyboards however
	            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
	                key = _SHIFT_MAP[key];
	                modifiers.push('shift');
	            }
	
	            // if this key is a modifier then add it to the list of modifiers
	            if (_isModifier(key)) {
	                modifiers.push(key);
	            }
	        }
	
	        // depending on what the key combination is
	        // we will try to pick the best event for it
	        action = _pickBestAction(key, modifiers, action);
	
	        return {
	            key: key,
	            modifiers: modifiers,
	            action: action
	        };
	    }
	
	    function _belongsTo(element, ancestor) {
	        if (element === null || element === document) {
	            return false;
	        }
	
	        if (element === ancestor) {
	            return true;
	        }
	
	        return _belongsTo(element.parentNode, ancestor);
	    }
	
	    function Mousetrap(targetElement) {
	        var self = this;
	
	        targetElement = targetElement || document;
	
	        if (!(self instanceof Mousetrap)) {
	            return new Mousetrap(targetElement);
	        }
	
	        /**
	         * element to attach key events to
	         *
	         * @type {Element}
	         */
	        self.target = targetElement;
	
	        /**
	         * a list of all the callbacks setup via Mousetrap.bind()
	         *
	         * @type {Object}
	         */
	        self._callbacks = {};
	
	        /**
	         * direct map of string combinations to callbacks used for trigger()
	         *
	         * @type {Object}
	         */
	        self._directMap = {};
	
	        /**
	         * keeps track of what level each sequence is at since multiple
	         * sequences can start out with the same sequence
	         *
	         * @type {Object}
	         */
	        var _sequenceLevels = {};
	
	        /**
	         * variable to store the setTimeout call
	         *
	         * @type {null|number}
	         */
	        var _resetTimer;
	
	        /**
	         * temporary state where we will ignore the next keyup
	         *
	         * @type {boolean|string}
	         */
	        var _ignoreNextKeyup = false;
	
	        /**
	         * temporary state where we will ignore the next keypress
	         *
	         * @type {boolean}
	         */
	        var _ignoreNextKeypress = false;
	
	        /**
	         * are we currently inside of a sequence?
	         * type of action ("keyup" or "keydown" or "keypress") or false
	         *
	         * @type {boolean|string}
	         */
	        var _nextExpectedAction = false;
	
	        /**
	         * resets all sequence counters except for the ones passed in
	         *
	         * @param {Object} doNotReset
	         * @returns void
	         */
	        function _resetSequences(doNotReset) {
	            doNotReset = doNotReset || {};
	
	            var activeSequences = false,
	                key;
	
	            for (key in _sequenceLevels) {
	                if (doNotReset[key]) {
	                    activeSequences = true;
	                    continue;
	                }
	                _sequenceLevels[key] = 0;
	            }
	
	            if (!activeSequences) {
	                _nextExpectedAction = false;
	            }
	        }
	
	        /**
	         * finds all callbacks that match based on the keycode, modifiers,
	         * and action
	         *
	         * @param {string} character
	         * @param {Array} modifiers
	         * @param {Event|Object} e
	         * @param {string=} sequenceName - name of the sequence we are looking for
	         * @param {string=} combination
	         * @param {number=} level
	         * @returns {Array}
	         */
	        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
	            var i;
	            var callback;
	            var matches = [];
	            var action = e.type;
	
	            // if there are no events related to this keycode
	            if (!self._callbacks[character]) {
	                return [];
	            }
	
	            // if a modifier key is coming up on its own we should allow it
	            if (action == 'keyup' && _isModifier(character)) {
	                modifiers = [character];
	            }
	
	            // loop through all callbacks for the key that was pressed
	            // and see if any of them match
	            for (i = 0; i < self._callbacks[character].length; ++i) {
	                callback = self._callbacks[character][i];
	
	                // if a sequence name is not specified, but this is a sequence at
	                // the wrong level then move onto the next match
	                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
	                    continue;
	                }
	
	                // if the action we are looking for doesn't match the action we got
	                // then we should keep going
	                if (action != callback.action) {
	                    continue;
	                }
	
	                // if this is a keypress event and the meta key and control key
	                // are not pressed that means that we need to only look at the
	                // character, otherwise check the modifiers as well
	                //
	                // chrome will not fire a keypress if meta or control is down
	                // safari will fire a keypress if meta or meta+shift is down
	                // firefox will fire a keypress if meta or control is down
	                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {
	
	                    // when you bind a combination or sequence a second time it
	                    // should overwrite the first one.  if a sequenceName or
	                    // combination is specified in this call it does just that
	                    //
	                    // @todo make deleting its own method?
	                    var deleteCombo = !sequenceName && callback.combo == combination;
	                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
	                    if (deleteCombo || deleteSequence) {
	                        self._callbacks[character].splice(i, 1);
	                    }
	
	                    matches.push(callback);
	                }
	            }
	
	            return matches;
	        }
	
	        /**
	         * actually calls the callback function
	         *
	         * if your callback function returns false this will use the jquery
	         * convention - prevent default and stop propogation on the event
	         *
	         * @param {Function} callback
	         * @param {Event} e
	         * @returns void
	         */
	        function _fireCallback(callback, e, combo, sequence) {
	
	            // if this event should not happen stop here
	            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
	                return;
	            }
	
	            if (callback(e, combo) === false) {
	                _preventDefault(e);
	                _stopPropagation(e);
	            }
	        }
	
	        /**
	         * handles a character key event
	         *
	         * @param {string} character
	         * @param {Array} modifiers
	         * @param {Event} e
	         * @returns void
	         */
	        self._handleKey = function(character, modifiers, e) {
	            var callbacks = _getMatches(character, modifiers, e);
	            var i;
	            var doNotReset = {};
	            var maxLevel = 0;
	            var processedSequenceCallback = false;
	
	            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
	            for (i = 0; i < callbacks.length; ++i) {
	                if (callbacks[i].seq) {
	                    maxLevel = Math.max(maxLevel, callbacks[i].level);
	                }
	            }
	
	            // loop through matching callbacks for this key event
	            for (i = 0; i < callbacks.length; ++i) {
	
	                // fire for all sequence callbacks
	                // this is because if for example you have multiple sequences
	                // bound such as "g i" and "g t" they both need to fire the
	                // callback for matching g cause otherwise you can only ever
	                // match the first one
	                if (callbacks[i].seq) {
	
	                    // only fire callbacks for the maxLevel to prevent
	                    // subsequences from also firing
	                    //
	                    // for example 'a option b' should not cause 'option b' to fire
	                    // even though 'option b' is part of the other sequence
	                    //
	                    // any sequences that do not match here will be discarded
	                    // below by the _resetSequences call
	                    if (callbacks[i].level != maxLevel) {
	                        continue;
	                    }
	
	                    processedSequenceCallback = true;
	
	                    // keep a list of which sequences were matches for later
	                    doNotReset[callbacks[i].seq] = 1;
	                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
	                    continue;
	                }
	
	                // if there were no sequence matches but we are still here
	                // that means this is a regular match so we should fire that
	                if (!processedSequenceCallback) {
	                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
	                }
	            }
	
	            // if the key you pressed matches the type of sequence without
	            // being a modifier (ie "keyup" or "keypress") then we should
	            // reset all sequences that were not matched by this event
	            //
	            // this is so, for example, if you have the sequence "h a t" and you
	            // type "h e a r t" it does not match.  in this case the "e" will
	            // cause the sequence to reset
	            //
	            // modifier keys are ignored because you can have a sequence
	            // that contains modifiers such as "enter ctrl+space" and in most
	            // cases the modifier key will be pressed before the next key
	            //
	            // also if you have a sequence such as "ctrl+b a" then pressing the
	            // "b" key will trigger a "keypress" and a "keydown"
	            //
	            // the "keydown" is expected when there is a modifier, but the
	            // "keypress" ends up matching the _nextExpectedAction since it occurs
	            // after and that causes the sequence to reset
	            //
	            // we ignore keypresses in a sequence that directly follow a keydown
	            // for the same character
	            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
	            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
	                _resetSequences(doNotReset);
	            }
	
	            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
	        };
	
	        /**
	         * handles a keydown event
	         *
	         * @param {Event} e
	         * @returns void
	         */
	        function _handleKeyEvent(e) {
	
	            // normalize e.which for key events
	            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
	            if (typeof e.which !== 'number') {
	                e.which = e.keyCode;
	            }
	
	            var character = _characterFromEvent(e);
	
	            // no character found then stop
	            if (!character) {
	                return;
	            }
	
	            // need to use === for the character check because the character can be 0
	            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
	                _ignoreNextKeyup = false;
	                return;
	            }
	
	            self.handleKey(character, _eventModifiers(e), e);
	        }
	
	        /**
	         * called to set a 1 second timeout on the specified sequence
	         *
	         * this is so after each key press in the sequence you have 1 second
	         * to press the next key before you have to start over
	         *
	         * @returns void
	         */
	        function _resetSequenceTimer() {
	            clearTimeout(_resetTimer);
	            _resetTimer = setTimeout(_resetSequences, 1000);
	        }
	
	        /**
	         * binds a key sequence to an event
	         *
	         * @param {string} combo - combo specified in bind call
	         * @param {Array} keys
	         * @param {Function} callback
	         * @param {string=} action
	         * @returns void
	         */
	        function _bindSequence(combo, keys, callback, action) {
	
	            // start off by adding a sequence level record for this combination
	            // and setting the level to 0
	            _sequenceLevels[combo] = 0;
	
	            /**
	             * callback to increase the sequence level for this sequence and reset
	             * all other sequences that were active
	             *
	             * @param {string} nextAction
	             * @returns {Function}
	             */
	            function _increaseSequence(nextAction) {
	                return function() {
	                    _nextExpectedAction = nextAction;
	                    ++_sequenceLevels[combo];
	                    _resetSequenceTimer();
	                };
	            }
	
	            /**
	             * wraps the specified callback inside of another function in order
	             * to reset all sequence counters as soon as this sequence is done
	             *
	             * @param {Event} e
	             * @returns void
	             */
	            function _callbackAndReset(e) {
	                _fireCallback(callback, e, combo);
	
	                // we should ignore the next key up if the action is key down
	                // or keypress.  this is so if you finish a sequence and
	                // release the key the final key will not trigger a keyup
	                if (action !== 'keyup') {
	                    _ignoreNextKeyup = _characterFromEvent(e);
	                }
	
	                // weird race condition if a sequence ends with the key
	                // another sequence begins with
	                setTimeout(_resetSequences, 10);
	            }
	
	            // loop through keys one at a time and bind the appropriate callback
	            // function.  for any key leading up to the final one it should
	            // increase the sequence. after the final, it should reset all sequences
	            //
	            // if an action is specified in the original bind call then that will
	            // be used throughout.  otherwise we will pass the action that the
	            // next key in the sequence should match.  this allows a sequence
	            // to mix and match keypress and keydown events depending on which
	            // ones are better suited to the key provided
	            for (var i = 0; i < keys.length; ++i) {
	                var isFinal = i + 1 === keys.length;
	                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
	                _bindSingle(keys[i], wrappedCallback, action, combo, i);
	            }
	        }
	
	        /**
	         * binds a single keyboard combination
	         *
	         * @param {string} combination
	         * @param {Function} callback
	         * @param {string=} action
	         * @param {string=} sequenceName - name of sequence if part of sequence
	         * @param {number=} level - what part of the sequence the command is
	         * @returns void
	         */
	        function _bindSingle(combination, callback, action, sequenceName, level) {
	
	            // store a direct mapped reference for use with Mousetrap.trigger
	            self._directMap[combination + ':' + action] = callback;
	
	            // make sure multiple spaces in a row become a single space
	            combination = combination.replace(/\s+/g, ' ');
	
	            var sequence = combination.split(' ');
	            var info;
	
	            // if this pattern is a sequence of keys then run through this method
	            // to reprocess each pattern one key at a time
	            if (sequence.length > 1) {
	                _bindSequence(combination, sequence, callback, action);
	                return;
	            }
	
	            info = _getKeyInfo(combination, action);
	
	            // make sure to initialize array if this is the first time
	            // a callback is added for this key
	            self._callbacks[info.key] = self._callbacks[info.key] || [];
	
	            // remove an existing match if there is one
	            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);
	
	            // add this call back to the array
	            // if it is a sequence put it at the beginning
	            // if not put it at the end
	            //
	            // this is important because the way these are processed expects
	            // the sequence ones to come first
	            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
	                callback: callback,
	                modifiers: info.modifiers,
	                action: info.action,
	                seq: sequenceName,
	                level: level,
	                combo: combination
	            });
	        }
	
	        /**
	         * binds multiple combinations to the same callback
	         *
	         * @param {Array} combinations
	         * @param {Function} callback
	         * @param {string|undefined} action
	         * @returns void
	         */
	        self._bindMultiple = function(combinations, callback, action) {
	            for (var i = 0; i < combinations.length; ++i) {
	                _bindSingle(combinations[i], callback, action);
	            }
	        };
	
	        // start!
	        _addEvent(targetElement, 'keypress', _handleKeyEvent);
	        _addEvent(targetElement, 'keydown', _handleKeyEvent);
	        _addEvent(targetElement, 'keyup', _handleKeyEvent);
	    }
	
	    /**
	     * binds an event to mousetrap
	     *
	     * can be a single key, a combination of keys separated with +,
	     * an array of keys, or a sequence of keys separated by spaces
	     *
	     * be sure to list the modifier keys first to make sure that the
	     * correct key ends up getting bound (the last key in the pattern)
	     *
	     * @param {string|Array} keys
	     * @param {Function} callback
	     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
	     * @returns void
	     */
	    Mousetrap.prototype.bind = function(keys, callback, action) {
	        var self = this;
	        keys = keys instanceof Array ? keys : [keys];
	        self._bindMultiple.call(self, keys, callback, action);
	        return self;
	    };
	
	    /**
	     * unbinds an event to mousetrap
	     *
	     * the unbinding sets the callback function of the specified key combo
	     * to an empty function and deletes the corresponding key in the
	     * _directMap dict.
	     *
	     * TODO: actually remove this from the _callbacks dictionary instead
	     * of binding an empty function
	     *
	     * the keycombo+action has to be exactly the same as
	     * it was defined in the bind method
	     *
	     * @param {string|Array} keys
	     * @param {string} action
	     * @returns void
	     */
	    Mousetrap.prototype.unbind = function(keys, action) {
	        var self = this;
	        return self.bind.call(self, keys, function() {}, action);
	    };
	
	    /**
	     * triggers an event that has already been bound
	     *
	     * @param {string} keys
	     * @param {string=} action
	     * @returns void
	     */
	    Mousetrap.prototype.trigger = function(keys, action) {
	        var self = this;
	        if (self._directMap[keys + ':' + action]) {
	            self._directMap[keys + ':' + action]({}, keys);
	        }
	        return self;
	    };
	
	    /**
	     * resets the library back to its initial state.  this is useful
	     * if you want to clear out the current keyboard shortcuts and bind
	     * new ones - for example if you switch to another page
	     *
	     * @returns void
	     */
	    Mousetrap.prototype.reset = function() {
	        var self = this;
	        self._callbacks = {};
	        self._directMap = {};
	        return self;
	    };
	
	    /**
	     * should we stop this event before firing off callbacks
	     *
	     * @param {Event} e
	     * @param {Element} element
	     * @return {boolean}
	     */
	    Mousetrap.prototype.stopCallback = function(e, element) {
	        var self = this;
	
	        // if the element has the class "mousetrap" then no need to stop
	        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
	            return false;
	        }
	
	        if (_belongsTo(element, self.target)) {
	            return false;
	        }
	
	        // stop for input, select, and textarea
	        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
	    };
	
	    /**
	     * exposes _handleKey publicly so it can be overwritten by extensions
	     */
	    Mousetrap.prototype.handleKey = function() {
	        var self = this;
	        return self._handleKey.apply(self, arguments);
	    };
	
	    /**
	     * Init the global mousetrap functions
	     *
	     * This method is needed to allow the global mousetrap functions to work
	     * now that mousetrap is a constructor function.
	     */
	    Mousetrap.init = function() {
	        var documentMousetrap = Mousetrap(document);
	        for (var method in documentMousetrap) {
	            if (method.charAt(0) !== '_') {
	                Mousetrap[method] = (function(method) {
	                    return function() {
	                        return documentMousetrap[method].apply(documentMousetrap, arguments);
	                    };
	                } (method));
	            }
	        }
	    };
	
	    Mousetrap.init();
	
	    // expose mousetrap to the global object
	    window.Mousetrap = Mousetrap;
	
	    // expose as a common js module
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = Mousetrap;
	    }
	
	    // expose mousetrap as an AMD module
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return Mousetrap;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	}) (window, document);


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _api = __webpack_require__(264);
	
	var _api2 = _interopRequireDefault(_api);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * KeyboardShortcutActions
	 */
	
	exports.default = {
	
	  openLobby: function openLobby() {
	    _api2.default.openLobby();
	    _analytics_actions2.default.lobbyFocusedWithKeyboardShortcut();
	  },
	
	  createRoom: function createRoom() {
	    _api2.default.createRoom();
	    _analytics_actions2.default.createRoomClickedEvent("keyboard.shortcut");
	  },
	
	  inviteUsersToRoom: function inviteUsersToRoom() {
	    _api2.default.inviteUsersToRoom();
	  },
	
	  searchHistory: function searchHistory() {
	    _api2.default.focusSearch();
	  },
	
	  closeRoom: function closeRoom() {
	    _api2.default.closeActiveChat();
	  },
	
	  navigateRoomsUp: function navigateRoomsUp() {
	    _api2.default.navigateChatUp();
	  },
	
	  navigateRoomsDown: function navigateRoomsDown() {
	    _api2.default.navigateChatDown();
	  },
	
	  openSettings: function openSettings() {
	    _api2.default.openSettings();
	  },
	
	  markChatsAsRead: function markChatsAsRead() {
	    _api2.default.markChatsAsRead();
	  },
	
	  markRoomsAsRead: function markRoomsAsRead() {
	    _api2.default.markRoomsAsRead();
	  },
	
	  toggleSoundNotifications: function toggleSoundNotifications() {
	    _api2.default.toggleSoundNotifications();
	  },
	
	  reopenLastChat: function reopenLastChat() {
	    _api2.default.reopenLastChat();
	  },
	
	  recallOlderInputHistory: function recallOlderInputHistory(e) {
	    _api2.default.recallOlderInputHistory(e);
	  },
	
	  recallNewerInputHistory: function recallNewerInputHistory(e) {
	    _api2.default.recallNewerInputHistory(e);
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 282 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  separator: "+",
	  control: "Ctrl",
	  alt: "Alt",
	  option: "Option",
	  shift: "Shift",
	  space: "Space",
	  esc: "Esc",
	  tab: "Tab",
	  command: "",
	  up_arrow: "",
	  down_arrow: "",
	  left_arrow: "",
	  right_arrow: "",
	  new_chat: "New chat",
	  room_invite_users: "Invite to room",
	  search_history: "Search chat history",
	  close_room: "Close room",
	  create_room: "Create room",
	  navigate_rooms_up: "Navigate rooms up",
	  navigate_rooms_down: "Navigate rooms down",
	  toggle_sound_notifications: "Toggle sound notifications",
	  mark_chats_as_read: "Mark all chats as read",
	  mark_rooms_as_read: "Mark all rooms as read",
	  recall_older_input_history: "Navigate up through sent messages",
	  recall_newer_input_history: "Navigate down through sent messages",
	  view_shortcuts: "View shortcuts"
	};
	module.exports = exports['default'];

/***/ },
/* 283 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @typedef {{name: string, key: string}} keyboard_shortcut_strings
	 * @type {Object.<string, string>}
	 */
	module.exports = {
	  NEW_CHAT: "newChat",
	  INVITE_TO_ROOM: "inviteUsersToRoom",
	  CLOSE_ROOM: "closeRoom",
	  CREATE_ROOM: "createRoom",
	  NAVIGATE_ROOMS_UP: "navigateRoomsUp",
	  NAVIGATE_ROOMS_DOWN: "navigateRoomsDown",
	  SEARCH_HISTORY: "searchHistory",
	  TOGGLE_SOUND_NOTIFICATIONS: "toggleSoundNotifications",
	  MARK_CHATS_AS_READ: "markChatsAsRead",
	  MARK_ROOMS_AS_READ: "markRoomsAsRead",
	  VIEW_SHORTCUTS: "viewShortcuts",
	  REOPEN_LAST_CHAT: "reopenLastChat",
	  RECALL_OLDER_INPUT_HISTORY: "recallOlderInputHistory",
	  RECALL_NEWER_INPUT_HISTORY: "recallNewerInputHistory"
	};

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ModalDialogStore = function (_Store) {
	  (0, _inherits3.default)(ModalDialogStore, _Store);
	
	  function ModalDialogStore() {
	    (0, _classCallCheck3.default)(this, ModalDialogStore);
	
	
	    // Allowance for animation
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ModalDialogStore).call(this));
	
	    _this.delayDuration = _app_config2.default.modal_transition_allowance;
	    _this.delayTimeout = null;
	
	    _this.activationDelay = 100;
	
	    _this.local = {
	      fileViewerOpened: false
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(ModalDialogStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        activeDialog: false,
	        dialogData: false,
	        dialogVisible: false,
	        btnLoading: false,
	        bgDismiss: true,
	        web_server: _app_config2.default.default_web_server,
	        dialogs_queue: []
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'show-modal-dialog': function showModalDialog(data) {
	          var dialogData = {
	            activeDialog: data.dialog_type,
	            dialogVisible: false,
	            dialogData: data.dialog_data,
	            btnLoading: false
	          };
	
	          if (!_this2.isQueueableDialog(dialogData) && _this2.isDialogActive(dialogData)) {
	            return;
	          }
	
	          // If I'm in the middle of the closing animation from one dialog, and I'm told to
	          // show another, clear that animation timeout and wipe out the old dialog data
	          if (_this2.deactivateTimeout) {
	            clearTimeout(_this2.deactivateTimeout);
	            _this2.deactivateTimeout = null;
	            _this2.data.dialogData = null;
	            _this2.data.activeDialog = null;
	          }
	
	          if (_this2.isQueueableDialog(dialogData) && _this2.shouldDialogQueue()) {
	            _this2.data.dialogs_queue.push(dialogData);
	          } else {
	            _this2.showDialog(dialogData);
	          }
	        },
	        'hide-modal-dialog': function hideModalDialog() {
	          // If I'm in the middle of the opening animation from one dialog, and I'm told
	          // to close it, clear that animation timeout and shut it down
	          if (_this2.activateTimeout) {
	            clearTimeout(_this2.activateTimeout);
	            _this2.activateTimeout = null;
	          }
	
	          // Set dialog invisible
	          _this2.set({
	            dialogVisible: false,
	            btnLoading: false
	          });
	
	          // after animation timeout, wipe out dialog data
	          _this2.deactivateDialog();
	
	          if (_this2.data.dialogs_queue.length) {
	            var nextDialog = _this2.data.dialogs_queue.shift();
	            _this2.showDialog(nextDialog);
	          }
	        },
	        'modal-dialog-btn-loading': function modalDialogBtnLoading(data) {
	          _this2.set('btnLoading', !!data.loading);
	        },
	        'updated:web_server': function updatedWeb_server(web_server) {
	          _this2.set("web_server", web_server);
	        },
	        'open-in-file-viewer': function openInFileViewer() {
	          _this2.local.fileViewerOpened = true;
	        },
	        'file-viewer-closed': function fileViewerClosed() {
	          _this2.local.fileViewerOpened = false;
	
	          if (_this2.data.dialogs_queue.length) {
	            var nextDialog = _this2.data.dialogs_queue.shift();
	            _this2.showDialog(nextDialog);
	          }
	        }
	      });
	    }
	  }, {
	    key: 'showDialog',
	    value: function showDialog(data) {
	      // Init dialog data
	      this.set({
	        activeDialog: data.activeDialog,
	        dialogVisible: data.dialogVisible,
	        dialogData: data.dialogData,
	        btnLoading: data.btnLoading
	      });
	
	      // Set dialog visible after animation to trigger focus hooks
	      this.activateDialog();
	    }
	  }, {
	    key: 'activateDialog',
	    value: function activateDialog() {
	      var _this3 = this;
	
	      var activate = function activate() {
	        _this3.set('dialogVisible', true);
	        _this3.activateTimeout = null;
	      };
	
	      if (this.activationDelay) {
	        this.activateTimeout = setTimeout(activate, this.activationDelay);
	      } else {
	        activate();
	      }
	    }
	  }, {
	    key: 'deactivateDialog',
	    value: function deactivateDialog() {
	      var _this4 = this;
	
	      var deactivate = function deactivate() {
	        _this4.set({
	          activeDialog: null,
	          dialogData: false
	        });
	      };
	
	      if (this.delayDuration) {
	        this.deactivateTimeout = setTimeout(function () {
	          if (!_this4.get('dialogVisible')) {
	            deactivate();
	            _this4.delayTimeout = null;
	          }
	        }, this.delayDuration);
	      } else {
	        deactivate();
	      }
	    }
	  }, {
	    key: 'getCurrentModalDialog',
	    value: function getCurrentModalDialog() {
	      return this.get("activeDialog");
	    }
	  }, {
	    key: 'isDialogActive',
	    value: function isDialogActive(dialog) {
	      return this.get('activeDialog') === dialog.activeDialog;
	    }
	  }, {
	    key: 'isQueueableDialog',
	    value: function isQueueableDialog(dialog) {
	      return !!_.get(dialog, 'dialogData.should_queue');
	    }
	  }, {
	    key: 'shouldDialogQueue',
	    value: function shouldDialogQueue() {
	      return this.data.dialogVisible || this.local.fileViewerOpened;
	    }
	  }]);
	  return ModalDialogStore;
	}(_store2.default);
	
	exports.default = new ModalDialogStore();
	module.exports = exports['default'];

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	exports.startAddliveCall = startAddliveCall;
	exports.startEnsoCall = startEnsoCall;
	exports.startEnsoRoomVideo = startEnsoRoomVideo;
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _video_service_keys = __webpack_require__(174);
	
	var _video_service_keys2 = _interopRequireDefault(_video_service_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEBOUNCE_DELAY = 500;
	
	var DEBOUNCE_OPTIONS = (0, _freeze2.default)({
	  leading: true,
	  trailing: false
	});
	
	/**
	 * Opens the video UI and calls a user
	 * @param {object} data
	 * @param {string} data.jid the jid of the user to call
	 * @param {bool} data.audio_only whether or not this is an audio-only call
	 */
	function startAddliveCall(data) {
	  _analytics_dispatcher2.default.dispatch("analytics-event", {
	    name: "hipchat.client.user.oto.video.call",
	    properties: {
	      service: _video_service_keys2.default.ADDLIVE
	    }
	  });
	  _app_dispatcher2.default.dispatch('addlive.start-video-call', {
	    jid: data.jid,
	    audio_only: data.audio_only,
	    type: 'call',
	    name: data.name || ''
	  });
	}
	
	/**
	 * Opens the video UI and calls a user
	 * @param {object} data
	 * @param {string} data.jid the jid of the user to call
	 * @param {bool} data.audio_only whether or not this is an audio-only call
	 */
	function startEnsoCall(data) {
	  _analytics_dispatcher2.default.dispatch("analytics-event", {
	    name: "hipchat.client.user.oto.video.call",
	    properties: {
	      service: _video_service_keys2.default.ENSO
	    }
	  });
	  _app_dispatcher2.default.dispatch('enso.start-video-call', {
	    jid: data.jid,
	    audio_only: data.audio_only,
	    type: 'call',
	    name: data.name || ''
	  });
	}
	
	/**
	 * Sends a notification to the room for users to join a room call
	 * @param {object} data
	 * @param {string} data.jid the jid of the room to call
	 */
	function startEnsoRoomVideo(data) {
	  _analytics_dispatcher2.default.dispatch("analytics-event", {
	    name: "hipchat.client.user.room.video.call",
	    properties: {
	      room: data.room_id
	    }
	  });
	  _app_dispatcher2.default.dispatch('enso.start-room-video', {
	    jid: data.jid,
	    room_id: data.room_id,
	    audio_only: false,
	    type: 'call',
	    name: data.name || ''
	  });
	}
	
	/**
	 * Used to trigger actions on the chat header
	 * @module actions/ChatHeaderActions
	 */
	exports.default = {
	
	  /**
	   *
	   * @param {object} data
	   * @param {string} data.room JID of current chat
	   * @param {string} data.type Panel type. Valid values: files, links, roster.
	   */
	
	  handlePanelSelect: function handlePanelSelect(data) {
	    _app_dispatcher2.default.dispatch('select-panel', {
	      activePanel: data.type
	    });
	  },
	
	
	  /**
	   * Initiates edit mode for the topic in the chat header
	   */
	  editTopicInChatHeader: function editTopicInChatHeader() {
	    _app_dispatcher2.default.dispatch('edit-topic');
	  },
	
	
	  /**
	   * Cancels the inline edit mode for the topic in the chat header
	   */
	  dismissTopicEdit: function dismissTopicEdit() {
	    _app_dispatcher2.default.dispatch('dismiss-topic-edit');
	  },
	
	
	  /**
	   * Updates the topic value in the chat header
	   * @param {string} newTopic New topic
	   */
	  changeTopic: function changeTopic(newTopic) {
	    _app_dispatcher2.default.dispatch('set-topic', newTopic);
	  },
	
	
	  startAddliveCall: _.debounce(startAddliveCall, DEBOUNCE_DELAY, DEBOUNCE_OPTIONS),
	  startEnsoCall: _.debounce(startEnsoCall, DEBOUNCE_DELAY, DEBOUNCE_OPTIONS),
	  startEnsoRoomVideo: _.debounce(startEnsoRoomVideo, DEBOUNCE_DELAY, DEBOUNCE_OPTIONS),
	
	  startCall: function startCall(data) {
	    if (data.service === _video_service_keys2.default.ENSO) {
	      this.startEnsoCall(data);
	    } else if (data.service === _video_service_keys2.default.ADDLIVE) {
	      this.startAddliveCall(data);
	    }
	  }
	};

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  changeRoomPrivacy: function changeRoomPrivacy(submit_data, callback) {
	    _app_dispatcher2.default.dispatch("change-room-privacy", submit_data, callback);
	  },
	
	  changeRoomName: function changeRoomName(submit_data, callback) {
	    _app_dispatcher2.default.dispatch("change-room-name", submit_data, callback);
	  },
	
	  createRoom: function createRoom(submit_data, callback) {
	    _app_dispatcher2.default.dispatch("create-room", submit_data, callback);
	    _analytics_dispatcher2.default.dispatch("analytics-create-room", submit_data);
	  },
	
	  inviteUsers: function inviteUsers(submit_data) {
	    _app_dispatcher2.default.dispatch('invite-users', submit_data);
	  },
	
	  removeUsers: function removeUsers(submit_data, callback) {
	    _app_dispatcher2.default.dispatch('remove-users', submit_data, callback);
	  },
	
	  editMessage: function editMessage(submit_data) {
	    _app_dispatcher2.default.dispatch('edit-message', submit_data);
	  },
	
	  deleteMessage: function deleteMessage(submit_data) {
	    _app_dispatcher2.default.dispatch('delete-message', submit_data);
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Room Dropdown Actions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	
	module.exports = {
	
	  editTopic: function editTopic() {
	    AppDispatcher.dispatch('edit-topic');
	  },
	
	  deleteRoom: function deleteRoom(data, cb) {
	    AppDispatcher.dispatch('delete-room', {
	      jid: data.jid,
	      id: data.id
	    }, cb);
	  },
	
	  closeRoom: function closeRoom(jid) {
	    AppDispatcher.dispatch('close-room', {
	      jid: jid,
	      doNotNotifyHC: true
	    });
	  },
	
	  archiveRoom: function archiveRoom(data, cb) {
	    AppDispatcher.dispatch('archive-room', {
	      jid: data.jid,
	      id: data.id
	    }, cb);
	  },
	
	  unarchiveRoom: function unarchiveRoom(data, cb) {
	    AppDispatcher.dispatch('unarchive-room', {
	      jid: data.jid,
	      id: data.id
	    }, cb);
	  },
	
	  enableGuestAccess: function enableGuestAccess(data, cb) {
	    AppDispatcher.dispatch('set-guest-access', {
	      jid: data.jid,
	      enable: true
	    }, cb);
	  },
	
	  disableGuestAccess: function disableGuestAccess(data, cb) {
	    AppDispatcher.dispatch('set-guest-access', {
	      jid: data.jid,
	      enable: false
	    }, cb);
	  }
	
	};

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * RoomNavActions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	var AnalyticsDispatcher = __webpack_require__(173);
	
	var RoomNavActions = {
	
	  /**
	   * @param  {string} jid
	   */
	  select: function select(jid, type) {
	    var data = {
	      jid: jid,
	      type: type
	    };
	    AppDispatcher.dispatch('set-route', data);
	    AnalyticsDispatcher.dispatch('analytics-select-room', data);
	  },
	
	  /**
	   * @param  {string} jid
	   */
	  close: function close(jid, type) {
	    AppDispatcher.dispatch('close-room', {
	      jid: jid,
	      type: type
	    });
	  },
	
	  closeSearchResults: function closeSearchResults() {
	    AppDispatcher.dispatch('close-room', { jid: "search" });
	    AppDispatcher.dispatch('remove-search-nav-item');
	  },
	
	  openSearchResults: function openSearchResults() {
	    AppDispatcher.dispatch('set-route', {
	      jid: "search"
	    });
	  },
	
	  openLobby: function openLobby() {
	    var data = {
	      jid: "lobby"
	    };
	    AppDispatcher.dispatch('set-route', { jid: 'lobby' });
	    AnalyticsDispatcher.dispatch('analytics-select-room', data);
	  },
	
	  update_room_order: function update_room_order(room_jids) {
	    AppDispatcher.dispatch('update-room-order', room_jids);
	  },
	
	  dragStart: function dragStart(data) {
	    AppDispatcher.dispatch('rooms-nav-drag-start', {
	      target: data.target
	    });
	  },
	
	  dragOver: function dragOver(data) {
	    AppDispatcher.dispatch('rooms-nav-drag-over', {
	      event: data.event
	    });
	  },
	
	  dragEnd: function dragEnd() {
	    AppDispatcher.dispatch('rooms-nav-drag-end');
	  }
	
	};
	
	module.exports = RoomNavActions;

/***/ },
/* 289 */
/***/ function(module, exports) {

	"use strict";
	
	/* Helper used to sanitize Sentry error objects on native */
	module.exports = {
	
	  constants: {
	    fileKey: "file://",
	    splitKey: "/",
	    fallback: "Unknown"
	  },
	
	  containsKey: function containsKey(string, key) {
	    if (!_.isString(string) || !_.isString(key)) {
	      return false;
	    }
	    return string.indexOf(key) !== -1;
	  },
	  returnLastItem: function returnLastItem(splitArray, fallback) {
	    if (!_.isArray(splitArray) || _.isArray(splitArray) && !splitArray.length) {
	      return fallback;
	    }
	    return splitArray[splitArray.length - 1];
	  },
	  sanitizePath: function sanitizePath(string) {
	    var splitString = void 0,
	        key = this.constants.splitKey,
	        fallback = this.constants.fallback,
	        response = void 0;
	
	    if (string && this.containsKey(string, key)) {
	      splitString = string.split(key);
	      response = this.returnLastItem(splitString, fallback);
	    } else {
	      response = fallback;
	    }
	    return response;
	  },
	  sanitizeStackTrace: function sanitizeStackTrace(data, frames) {
	    var key = this.constants.splitKey,
	        fileKey = this.constants.fileKey,
	        fallback = this.constants.fallback;
	
	    for (var i = 0; i < frames.length; i++) {
	      var filename = frames[i] && frames[i].filename ? frames[i].filename : false;
	      if (filename && this.containsKey(filename, fileKey)) {
	        var filenameSplit = filename.split(key);
	        data.stacktrace.frames[i].filename = this.returnLastItem(filenameSplit, fallback);
	      }
	    }
	  },
	  sanitize: function sanitize(data) {
	    if (_.isObject(data)) {
	      if (data.culprit) {
	        data.culprit = this.sanitizePath(data.culprit);
	      }
	
	      if (_.has(data, "request.url")) {
	        data.request.url = this.sanitizePath(data.request.url);
	      }
	
	      if (_.has(data, "request.headers.Referer")) {
	        data.request.headers.Referer = this.sanitizePath(data.request.headers.Referer);
	      }
	
	      if (_.has(data, "stacktrace.frames")) {
	        this.sanitizeStackTrace(data, data.stacktrace.frames);
	      }
	    }
	    return data;
	  }
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PresenceSubscriptionHelperClass = undefined;
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PresenceSubscriptionHelper = function () {
	  function PresenceSubscriptionHelper(config) {
	    (0, _classCallCheck3.default)(this, PresenceSubscriptionHelper);
	
	
	    this.initialized = false;
	
	    this.current_filter_list = [];
	
	    /** Object keyed by user id representing how many components we have on the screen that care about this user's presence
	     *
	     * @type {{}}
	     */
	    this.subscribed = {};
	
	    /** list of user ids that we still haven't fetched presence for yet
	     *
	     * @type {Array}
	     */
	    this.pending_presence_fetch = [];
	
	    this.debouncedFilterPresences = _.debounce(this._filterPresences, config.filter_participant_presences_timeout, {
	      leading: false,
	      trailing: true
	    });
	
	    this.throttledRequestPresences = _.throttle(this._requestPresences, config.request_participant_presences_timeout, {
	      leading: false,
	      trailing: true
	    });
	  }
	
	  /**
	   * Initialize the subscription helper
	   *
	   * @method init
	   */
	
	
	  (0, _createClass3.default)(PresenceSubscriptionHelper, [{
	    key: 'init',
	    value: function init() {
	      this.initialized = true;
	      this.resubscribe();
	    }
	
	    /**
	     * Add one or more UIDs to the presence subscription object
	     *
	     * @method addUsers
	     * @param {Array} uids
	     */
	
	  }, {
	    key: 'subscribeToPresence',
	    value: function subscribeToPresence(uids) {
	
	      var uids_array = _utils2.default.toArray(uids);
	
	      this._incrementSubscriptionCounts(uids_array);
	
	      this.throttledRequestPresences();
	      this.debouncedFilterPresences();
	    }
	
	    /**
	     * Remove one or more UIDs from the presence subscription object
	     *
	     * @method removeUsers
	     * @param {Array} uids
	     */
	
	  }, {
	    key: 'unsubscribeFromPresence',
	    value: function unsubscribeFromPresence(uids) {
	
	      var uids_array = _utils2.default.toArray(uids);
	
	      this._decrementSubscriptionCounts(uids_array);
	
	      this.debouncedFilterPresences();
	    }
	
	    /**
	     * Resubscribe to presence changes
	     *
	     * @method resubscribe
	     */
	
	  }, {
	    key: 'resubscribe',
	    value: function resubscribe() {
	      this.pending_presence_fetch = _.keys(this.subscribed);
	      this.throttledRequestPresences();
	      this.debouncedFilterPresences();
	    }
	  }, {
	    key: '_incrementSubscriptionCounts',
	    value: function _incrementSubscriptionCounts(uids) {
	      var _this = this;
	
	      _.forEach(uids, function (uid) {
	        uid = uid.toString();
	        if (_this.subscribed[uid]) {
	          _this.subscribed[uid]++;
	        } else {
	          _this.subscribed[uid] = 1;
	
	          // we don't want to explicitly fetch a presence if we're already listening for changes
	          if (!_.includes(_this.current_filter_list, uid) && !_.includes(_this.pending_presence_fetch, uid)) {
	            _this.pending_presence_fetch.push(uid);
	          }
	        }
	      });
	    }
	  }, {
	    key: '_decrementSubscriptionCounts',
	    value: function _decrementSubscriptionCounts(uids) {
	      var _this2 = this;
	
	      _.forEach(uids, function (uid) {
	        uid = uid.toString();
	        if (_this2.subscribed[uid] > 1) {
	          _this2.subscribed[uid]--;
	        } else {
	          _this2.subscribed = _.omit(_this2.subscribed, uid);
	          _.pull(_this2.pending_presence_fetch, uid);
	        }
	      });
	    }
	  }, {
	    key: '_filterPresences',
	    value: function _filterPresences() {
	
	      // get the list of users who've been added or removed
	      var filter = _.keys(this.subscribed),
	          changeset = _.xor(this.current_filter_list, filter),
	          changed = !_.isEmpty(changeset);
	
	      // only make the request if there are changes, we're initialized, and there's a uid list to filter on
	      if (changed && this.initialized && filter.length) {
	        this.current_filter_list = filter;
	        _app_dispatcher2.default.dispatch('filter-presences', this.current_filter_list);
	      }
	    }
	  }, {
	    key: '_requestPresences',
	    value: function _requestPresences() {
	
	      var uniq = _.uniq(this.pending_presence_fetch);
	
	      // only fetch if we are initialized and we have a uid list
	      if (uniq.length && this.initialized) {
	        _app_dispatcher2.default.dispatch('fetch-presences', uniq);
	
	        // clear out the list so that it's built fresh the next time the throttled call executes
	        this.pending_presence_fetch = [];
	      }
	    }
	  }]);
	  return PresenceSubscriptionHelper;
	}();
	
	exports.PresenceSubscriptionHelperClass = PresenceSubscriptionHelper;
	exports.default = new PresenceSubscriptionHelper(_app_config2.default);

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof2 = __webpack_require__(23);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _slicedToArray2 = __webpack_require__(127);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _video_actions = __webpack_require__(172);
	
	var _video_actions2 = _interopRequireDefault(_video_actions);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _notifier = __webpack_require__(180);
	
	var _notifier2 = _interopRequireDefault(_notifier);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	var _video_service_keys = __webpack_require__(174);
	
	var _video_service_keys2 = _interopRequireDefault(_video_service_keys);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var VideoModule = function () {
	
	  /**
	   * Create a VideoModule
	   */
	
	  function VideoModule() {
	    (0, _classCallCheck3.default)(this, VideoModule);
	
	    this.data = this.getDefaults();
	    this.registerListeners();
	  }
	
	  /**
	   *
	   * @returns {{
	   *            video_session: null,
	   *            incoming_invites: Array,
	   *            roster: {},
	   *            video_chat_uri: null,
	   *            asset_base_uri: null
	   *          }}
	   */
	
	
	  (0, _createClass3.default)(VideoModule, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        video_session: {},
	        incoming_invites: [],
	        roster: {},
	        feature_flags: {},
	        group_id: null,
	        video_chat_uri: null,
	        asset_base_uri: null,
	        is_native: _utils2.default.clientSubType.isNative(_configuration_store2.default.get('client_subtype'))
	      };
	    }
	
	    /**
	     * register callbacks on the AppDispatcher
	     */
	
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this = this;
	
	      this.handlerMap = {
	        'updated:config': this._handleConfig,
	        'updated:roster': this._handleRoster,
	        'enso.start-video-call': this.initiateVideoCall,
	        'enso.start-screen-share': this.initiateVideoCall,
	        'enso.start-room-video': this.initiateRoomVideoCall,
	        'enso.join-room-video': this.joinRoomVideoCall,
	        'enso.invite-to-audio-video-call': this.handleVideoCallInvite,
	        'enso.answer-audio-video-call': this.answerIncomingVideoCall,
	        'enso.audio-video-call-accepted': this.videoCallAcceptedByRemoteUser,
	        'enso.audio-video-call-declined': this.handleDeclinedMessage,
	        'enso.decline-audio-video-call': this.declineIncomingVideoCall,
	        'enso.audio-video-call-hung-up': this.handleHangupMessage,
	        'enso.focus-video-window': this._focusVideoWindow,
	        'enso.video-conference-joined': this.handleVideoConferenceJoined,
	        'enso.video-conference-left': this.handleVideoConferenceLeft,
	        'enso.video-session-destroyed': this.handleVideoSessionDestroy
	      };
	
	      _.mapValues(this.handlerMap, function (fn, evt, map) {
	        map[evt] = _.bind(fn, _this);
	      });
	
	      _app_dispatcher2.default.register(this.handlerMap);
	    }
	  }, {
	    key: 'cleanupListeners',
	    value: function cleanupListeners() {
	      _app_dispatcher2.default.unregister(this.handlerMap);
	    }
	  }, {
	    key: '_handleConfig',
	    value: function _handleConfig(config) {
	      if (config.group_id) {
	        this.data.group_id = config.group_id;
	      }
	      if (config.asset_base_uri) {
	        this.data.asset_base_uri = config.asset_base_uri;
	      }
	      if (config.video_base_url) {
	        this.data.video_base_url = config.video_base_url;
	      }
	      if (_.has(config, 'feature_flags') && _.isObject(config.feature_flags)) {
	        this.data.feature_flags = _.assign({}, this.data.feature_flags, config.feature_flags);
	      }
	    }
	  }, {
	    key: '_handleRoster',
	    value: function _handleRoster(roster) {
	      this.data.roster = roster;
	    }
	  }, {
	    key: '_focusVideoWindow',
	    value: function _focusVideoWindow() {
	      var _this2 = this;
	
	      return this.hasVideoSession().then(function (hasSession) {
	        if (hasSession) {
	          _this2.data.video_session.window.focus();
	        }
	      });
	    }
	  }, {
	    key: '_generateConferenceId',
	    value: function _generateConferenceId() {
	      var group = this.data.group_id ? this.data.group_id.toString() : '';
	      var hash = _utils2.default.alphaNumeric(14);
	      return _.padStart(group, 6, '0') + hash;
	    }
	  }, {
	    key: '_getConferenceIdFromURL',
	    value: function _getConferenceIdFromURL(url) {
	      var path = url.split('?')[0];
	      return path.slice(path.lastIndexOf('/') + 1, path.length);
	    }
	  }, {
	    key: '_addTokenToUrl',
	    value: function _addTokenToUrl(url, token) {
	      if (!token) {
	        return url;
	      }
	      return _utils2.default.appendQueryParameter(url, 'jwt', token);
	    }
	  }, {
	    key: '_addRingToUrl',
	    value: function _addRingToUrl(url) {
	      // If we should play_ring_sound_in_client, than we should not ring in Video Window
	      if (this.data.feature_flags.web_client_play_ring_sound_in_client) {
	        url = _utils2.default.setHashFragment(url, {
	          'interfaceConfig.DISABLE_RINGING': 'true'
	        });
	      }
	      return url;
	    }
	
	    /**
	     * Initiate a video call
	     * @param data
	     * @returns {boolean}
	     * TODO: refactor this so it's easier to follow and test
	     */
	
	  }, {
	    key: 'initiateVideoCall',
	    value: function initiateVideoCall(data) {
	      var _this3 = this;
	
	      var start = Date.now();
	
	      // if there's no active video session
	      return this.hasVideoSession().then(function (hasSession) {
	        if (hasSession) {
	          _this3.determineVideoWindowAction(data, _this3.initiateVideoCall);
	        } else {
	          (function () {
	            // create a new video session
	            var is_outgoing = data.type === 'call';
	            var callee_id = is_outgoing ? _utils2.default.jid.user_id(data.jid) : null;
	            var conference_id = is_outgoing ? _this3._generateConferenceId() : _this3._getConferenceIdFromURL(data.url);
	            var optionallyPreparedWindow = _this3.prepareCallSession();
	
	            _this3.showConnectingFlag();
	            _dal2.default.fetchVideoToken(callee_id, conference_id).then(function (response) {
	              data.url = data.url || _this3.data.video_base_url + '/' + conference_id + '?';
	              if (is_outgoing) {
	                clearTimeout(_this3.data.connecting_timer);
	                return _this3.sendInvitation(data).then(function () {
	                  data.url = _this3._addRingToUrl(data.url);
	                  data.url = _this3._addTokenToUrl(data.url, response.token);
	                  return _this3.createCallSession(data, optionallyPreparedWindow).then(function (video_window) {
	                    _this3.data.video_session.start_time = start;
	                    if (video_window.window || _this3.data.is_native) {
	                      _this3.notifyForOutgoingCall();
	                    } else {
	                      _this3.notifyForPopupBlocked(data);
	                    }
	                  });
	                }).catch(function (action, reason) {
	                  _logger2.default.debug('[ENSO]', action, reason);
	                });
	              } else if (data.type === 'accept') {
	                data.url = _this3._addTokenToUrl(data.url, response.token);
	                return _this3.createCallSession(data, optionallyPreparedWindow).then(function (video_window) {
	                  _this3.data.video_session.start_time = start;
	                  if (!video_window.window && !_this3.data.is_native) {
	                    _this3.notifyForPopupBlocked(data);
	                  }
	                });
	              }
	            }).catch(function (error) {
	              _logger2.default.debug('[ENSO JWT]', error);
	              //TODO: Display an error to the user somehow
	            });
	          })();
	        }
	      });
	    }
	  }, {
	    key: 'initiateRoomVideoCall',
	    value: function initiateRoomVideoCall(data) {
	      var _this4 = this;
	
	      var start = Date.now();
	      var conference_id = this._generateConferenceId();
	
	      data.url = this.data.video_base_url + '/' + conference_id + '?';
	
	      return this.hasVideoSession().then(function (hasSession) {
	        if (hasSession) {
	          _this4.determineVideoWindowAction(data, _this4.initiateRoomVideoCall);
	        } else {
	          return _this4.sendRoomInvitation({
	            jid: data.jid,
	            url: data.url.replace('/join/', '/call/')
	          }).then(function () {
	            _this4._joinRoomVideoCall(data, start);
	          });
	        }
	      });
	    }
	  }, {
	    key: 'joinRoomVideoCall',
	    value: function joinRoomVideoCall() {
	      var _this5 = this;
	
	      var data = arguments.length <= 0 || arguments[0] === undefined ? { url: '' } : arguments[0];
	
	      var start = Date.now();
	      var protocol = this.data.video_base_url.split(':')[0] || 'https';
	
	      data.url = data.url.replace(/^https?:\/\//, protocol + '://').replace('/call/', '/join/');
	
	      return this.hasVideoSession().then(function (hasSession) {
	        if (hasSession) {
	          _this5.determineVideoWindowAction(data, _this5.joinRoomVideoCall);
	        } else {
	          _this5._joinRoomVideoCall(data, start);
	        }
	      });
	    }
	  }, {
	    key: '_joinRoomVideoCall',
	    value: function _joinRoomVideoCall(data, start) {
	      var _this6 = this;
	
	      var conference_id = this._getConferenceIdFromURL(data.url);
	      var optionallyPreparedWindow = this.prepareCallSession();
	
	      this.showConnectingFlag();
	      return _dal2.default.fetchVideoToken(null, conference_id).then(function (response) {
	        data.url = _this6._addTokenToUrl(data.url, response.token);
	
	        _this6.createCallSession(data, optionallyPreparedWindow).then(function (video_window) {
	          _this6.data.video_session.start_time = start;
	          if (!video_window.window && !_this6.data.is_native) {
	            _this6.notifyForPopupBlocked(data);
	          }
	        }).catch(function (action, reason) {
	          _logger2.default.debug('[ENSO]', action, reason);
	        });
	      }).catch(function (error) {
	        _logger2.default.debug('[ENSO JWT]', error);
	        //TODO: Display an error to the user somehow
	      });
	    }
	  }, {
	    key: 'determineVideoWindowAction',
	    value: function determineVideoWindowAction(data) {
	      var _this7 = this;
	
	      var next = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];
	
	      var session = this.data.video_session,
	          startNewConference = function startNewConference() {
	        _this7.handleVideoSessionDestroy().then(function () {
	          next.call(_this7, data);
	        });
	      };
	
	      // if there is an active video session
	      if (data.jid === session.jid) {
	        // focus call window if connected or rejoin the conference if not
	        if (session.connected || session.connecting) {
	          session.window.focus();
	        } else {
	          startNewConference();
	        }
	      } else if (session.connected) {
	        // ask the user to confirm before leaving the current active conference
	        if (confirm(_video_call_strings2.default.confirm_leave)) {
	          startNewConference();
	        } else {
	          // if they choose not to leave the active conference, do nothing
	          return true;
	        }
	      } else {
	        // if they have a video window open but it's not connected, start a new session
	        startNewConference();
	      }
	    }
	  }, {
	    key: 'showConnectingFlag',
	    value: function showConnectingFlag() {
	      if (this.data.feature_flags.web_client_video_connecting_flag && this.data.is_native) {
	        _flag_actions2.default.showFlag({
	          type: 'info',
	          body: _video_call_strings2.default.connecting,
	          close: 'auto',
	          delay: 10000
	        });
	      }
	    }
	  }, {
	    key: 'sendInvitation',
	    value: function sendInvitation(data) {
	      var _this8 = this;
	
	      return new _promise2.default(function (resolve, reject) {
	        _video_actions2.default.sendVideoInviteMessage({
	          jid: data.jid,
	          url: data.url,
	          callback: _.bind(_this8.handleResponseToSentInvitation, _this8, resolve, reject)
	        });
	      });
	    }
	  }, {
	    key: 'sendRoomInvitation',
	    value: function sendRoomInvitation(data) {
	      return new _promise2.default(function (resolve, reject) {
	        _video_actions2.default.sendVideoInviteMessage({
	          jid: data.jid,
	          url: data.url
	        });
	        resolve();
	      });
	    }
	  }, {
	    key: 'handleResponseToSentInvitation',
	    value: function handleResponseToSentInvitation(success, fail, message) {
	      var messageInfo = _.get(message, 'x');
	
	      var _$transform = _.transform(messageInfo, function (arr, val, key) {
	        if (key !== 'xmlns') {
	          arr.push(key, val.reason);
	        }
	        return arr;
	      }, []);
	
	      var _$transform2 = (0, _slicedToArray3.default)(_$transform, 2);
	
	      var action = _$transform2[0];
	      var reason = _$transform2[1];
	
	
	      switch (action) {
	        case 'decline':
	        case 'hangup':
	          fail(action, reason);
	          break;
	        case 'trying':
	        case 'ringing':
	          success();
	          break;
	        default:
	          fail('Error handling message ', message);
	      }
	    }
	
	    /**
	     * handle an invitation to a video conference
	     * @param {Object} data
	     * @returns {boolean}
	     * TODO: refactor this so it's easier to follow and test
	     */
	
	  }, {
	    key: 'handleVideoCallInvite',
	    value: function handleVideoCallInvite(data) {
	      var _this9 = this;
	
	      var jid = _utils2.default.jid.bare_jid(data.sender.jid);
	
	      if (jid !== _current_user_store2.default.get('jid')) {
	        var _ret2 = function () {
	          var user = _this9.getCaller(jid),
	              session = _this9.data.video_session,
	              invite_flag_id = void 0;
	
	          return {
	            v: _this9.hasVideoSession().then(function (hasSession) {
	              if (hasSession) {
	                if (session.jid !== jid && session.connected) {
	                  // the user is currently in an active video conference: decline the invite
	                  _video_actions2.default.sendVideoInviteDeclineMessage({
	                    jid: jid,
	                    reason: 'on_a_call'
	                  });
	                  return true;
	                } else if (session.jid !== jid && !session.connected) {
	                  // the user has the video window open but is disconnected from the conference: show the invite flag
	                  invite_flag_id = 'video-flag-' + _utils2.default.now();
	                } else if (session.jid === jid && session.connected) {
	                  // the invite message is coming from the current session: take no action
	                  return true;
	                }
	              } else {
	                invite_flag_id = 'video-flag-' + _utils2.default.now();
	              }
	
	              // there's no current session
	              _video_actions2.default.showInviteFlag({
	                id: invite_flag_id,
	                sender: data.sender.name,
	                photo_url: user.photo_url,
	                message: data.message
	              });
	              _this9.notifyForIncomingCall(user);
	              var invite = {
	                invite_flag_id: invite_flag_id,
	                caller: user,
	                missed_timer: setTimeout(function () {
	                  _this9.handleMissedCall(user);
	                }, _app_config2.default.missed_video_call_timeout)
	              };
	              _this9.data.incoming_invites.push(invite);
	              _spi2.default.handleVideoCallInvite(_this9.answerIncomingVideoCall.bind(_this9, data.message), _this9.declineIncomingVideoCall.bind(_this9, data.message), {
	                id: invite_flag_id,
	                name: data.sender.name,
	                avatar: user.photo_url
	              });
	            })
	          };
	        }();
	
	        if ((typeof _ret2 === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret2)) === "object") return _ret2.v;
	      }
	    }
	
	    /**
	     * remove an invitation flag
	     * @param {String} jid
	     */
	
	  }, {
	    key: 'removeInvite',
	    value: function removeInvite(jid) {
	      var invite = _.find(this.data.incoming_invites, {
	        caller: { jid: jid }
	      });
	
	      if (invite) {
	        clearTimeout(invite.missed_timer);
	        this.stopAllSounds();
	        _.pull(this.data.incoming_invites, invite);
	        _video_actions2.default.removeInviteFlag({
	          index: invite.invite_flag_id
	        });
	        _spi2.default.dismissVideoCallInvite(invite.invite_flag_id);
	      }
	    }
	
	    /**
	     * answer an incoming invitation
	     * @param {Object} data
	     */
	
	  }, {
	    key: 'answerIncomingVideoCall',
	    value: function answerIncomingVideoCall(data) {
	      var url = _.get(data, 'x.call.url', ''),
	          jid = _utils2.default.jid.bare_jid(data.from);
	
	      this.stopAllSounds();
	      this.stopIncomingNotification(jid);
	      this.removeInvite(jid);
	      _video_actions2.default.sendVideoInviteAcceptMessage({
	        jid: jid
	      });
	      this.initiateVideoCall({
	        jid: jid,
	        type: 'accept',
	        url: url,
	        service: _video_service_keys2.default.ENSO
	      });
	    }
	
	    /**
	     * decline an incoming invitation
	     * @param {Object} data
	     */
	
	  }, {
	    key: 'declineIncomingVideoCall',
	    value: function declineIncomingVideoCall(data) {
	      var jid = _utils2.default.jid.bare_jid(data.from);
	      this.stopAllSounds();
	      this.stopIncomingNotification(jid);
	      this.removeInvite(jid);
	      _video_actions2.default.sendVideoInviteDeclineMessage({
	        jid: jid,
	        reason: 'decline'
	      });
	    }
	
	    /**
	     * handle a missed call
	     * @param {Object} caller
	     */
	
	  }, {
	    key: 'handleMissedCall',
	    value: function handleMissedCall(caller) {
	      this.stopAllSounds();
	      this.stopIncomingNotification(caller.jid);
	      var msg = {
	        body: _video_call_strings2.default.missed_call_message(caller.name),
	        type: "missed-call",
	        from: caller.jid,
	        delay: false,
	        sender: " "
	      };
	      _video_actions2.default.generateMissedCallMessage({
	        message: msg
	      });
	    }
	
	    /**
	     * handle a missed call
	     * @param {Object} caller
	     */
	
	  }, {
	    key: 'handleDeclinedCall',
	    value: function handleDeclinedCall(actor, reason) {
	      this.stopAllSounds();
	      var msg = {
	        body: _video_call_strings2.default.call_declined[reason](actor.name),
	        type: "system",
	        from: actor.jid,
	        delay: false,
	        sender: 'HipChat',
	        sender_avatar: []
	      };
	      _video_actions2.default.handleRemoteDeclinedMessage({
	        message: msg
	      });
	    }
	
	    /**
	     * prepare a call session
	     */
	
	  }, {
	    key: 'prepareCallSession',
	    value: function prepareCallSession() {
	      var props = _utils2.default.video.get_video_window_props();
	      return _spi2.default.prepareVideoWindow('HipChatVideoConference', props);
	    }
	
	    /**
	     * create a call session
	     * @param {String} jid
	     * @param {String} url
	     */
	
	  }, {
	    key: 'createCallSession',
	    value: function createCallSession(_ref, optionallyPreparedWindow) {
	      var _this10 = this;
	
	      var jid = _ref.jid;
	      var room_id = _ref.room_id;
	      var url = _ref.url;
	
	      var props = _utils2.default.video.get_video_window_props();
	      return _spi2.default.initializeVideoWindow(url, 'HipChatVideoConference', props, optionallyPreparedWindow).then(function (videoWindow) {
	        _this10.data.video_session = {
	          jid: jid,
	          connecting: true,
	          connected: false,
	          window: videoWindow
	        };
	        return videoWindow;
	      });
	    }
	
	    /**
	     * handle the remote decline message
	     * @param {Object} data
	     */
	
	  }, {
	    key: 'handleDeclinedMessage',
	    value: function handleDeclinedMessage(data) {
	      var jid = _utils2.default.jid.bare_jid(data.message.from),
	          reason = _.get(data.message, 'x.decline.reason', '');
	
	      this.stopAllSounds();
	      clearTimeout(this.data.connecting_timer);
	      this.data.video_session.connecting = false;
	      if (jid !== _current_user_store2.default.get('jid') && reason) {
	        this.handleDeclinedCall(data.sender, reason);
	        _current_user_actions2.default.leaveCall();
	      }
	      if (reason === 'on_a_call') {
	        try {
	          var videoWindow = _.get(this.data, 'video_session.window');
	          videoWindow.close.call(videoWindow);
	        } catch (err) {
	          _logger2.default.debug('[ENSO]', 'handleDeclinedMessage() attempted to close a video window and failed');
	        }
	      }
	    }
	
	    /**
	     * handle the remote hangup message
	     * @param {Object} data
	     */
	
	  }, {
	    key: 'handleHangupMessage',
	    value: function handleHangupMessage(data) {
	      var _this11 = this;
	
	      return this.hasVideoSession().then(function (hasSession) {
	        if (hasSession && _this11.data.video_session.jid !== _utils2.default.jid.bare_jid(data.sender.jid)) {
	          return;
	        }
	        _this11.stopAllSounds();
	        _this11.removeInvite(_utils2.default.jid.bare_jid(data.message.from));
	        _current_user_actions2.default.leaveCall();
	      });
	    }
	
	    /**
	     * handle the remote accept message
	     */
	
	  }, {
	    key: 'videoCallAcceptedByRemoteUser',
	    value: function videoCallAcceptedByRemoteUser() {
	      clearTimeout(this.data.connecting_timer);
	      this.stopAllSounds();
	    }
	
	    /**
	     * destroy the video conference session
	     */
	
	  }, {
	    key: 'destroyVideoSession',
	    value: function destroyVideoSession() {
	      var _this12 = this;
	
	      _.attempt(function () {
	        return _this12.data.video_session.window.close();
	      });
	      this.data.video_session = {};
	    }
	
	    /**
	     * handle video session destroyed
	     */
	
	  }, {
	    key: 'handleVideoSessionDestroy',
	    value: function handleVideoSessionDestroy() {
	      var _this13 = this;
	
	      return this.handleVideoConferenceLeft().then(function () {
	        _this13.destroyVideoSession();
	      });
	    }
	
	    /**
	     * get the roster item for a user's jid
	     * @param {String} jid
	     * @returns {Object} - roster item
	     */
	
	  }, {
	    key: 'getCaller',
	    value: function getCaller(jid) {
	      return _.find(this.data.roster, { jid: jid });
	    }
	
	    /**
	     * notify the user of an incoming call invite
	     * @param {Object} caller
	     * @param {bool} doNotification
	     * @param {bool} playSound
	     */
	
	  }, {
	    key: 'notifyForIncomingCall',
	    value: function notifyForIncomingCall(caller) {
	      _notifier2.default.setTitleNotification({
	        id: caller.jid,
	        text: _video_call_strings2.default.incoming_call_notification(caller.name)
	      });
	
	      var notifyWhenDND = _preferences_store2.default.getNotifyForVideoWhenDND() || _preferences_store2.default.getNotifyWhenDND();
	      var isDND = _current_user_store2.default.get('show') === _presence2.default.DND;
	      var shouldNotify = notifyWhenDND && isDND || !isDND;
	
	      if (shouldNotify) {
	        _app_actions2.default.showNotification({
	          group_id: _configuration_store2.default.get('group_id'),
	          group_name: _configuration_store2.default.get('group_name'),
	          jid: caller.jid,
	          title: caller.name,
	          body: _video_call_strings2.default.incoming_call_notification(caller.name),
	          icon: this.data.asset_base_uri + _app_config2.default.notification_icon,
	          type: 'incoming_call'
	        });
	      }
	      _notifier2.default.playSound('incoming_call', true);
	    }
	
	    /**
	     * notify the user that they're calling another user
	     */
	
	  }, {
	    key: 'notifyForOutgoingCall',
	    value: function notifyForOutgoingCall() {
	      var _this14 = this;
	
	      if (this.data.feature_flags.web_client_play_ring_sound_in_client) {
	        _notifier2.default.playSound('outgoing_call', true);
	      }
	      clearTimeout(this.data.connecting_timer);
	      this.data.connecting_timer = setTimeout(function () {
	        _this14.handleUnansweredCall();
	      }, _app_config2.default.missed_video_call_timeout);
	    }
	  }, {
	    key: 'handleUnansweredCall',
	    value: function handleUnansweredCall() {
	      this.stopAllSounds();
	      this.data.video_session.connected = false;
	      this.data.video_session.connecting = false;
	    }
	
	    /**
	     * notify the user that the browser is preventing the video window from opening
	     */
	
	  }, {
	    key: 'notifyForPopupBlocked',
	    value: function notifyForPopupBlocked(data) {
	      var _this15 = this;
	
	      _video_actions2.default.showPopupsDisabledFlag({
	        flag_id: 'popups_disabled_flag',
	        message: 'Please enable popups and try again',
	        promise: _.bind(function () {
	          return _this15.createCallSession(data);
	        }, this)
	      });
	    }
	
	    /**
	     * check if there's a session
	     * @returns {boolean}
	     */
	
	  }, {
	    key: 'hasVideoSession',
	    value: function hasVideoSession() {
	      var _this16 = this;
	
	      return _spi2.default.hasActiveVideoSession().then(function (active_session) {
	        return active_session || !!_this16.data.video_session.jid;
	      });
	    }
	
	    /**
	     * stop all ringing sounds
	     */
	
	  }, {
	    key: 'stopAllSounds',
	    value: function stopAllSounds() {
	      _notifier2.default.stopSounds();
	    }
	
	    /**
	     * stop the incoming call notification
	     * @param {String} caller_jid
	     */
	
	  }, {
	    key: 'stopIncomingNotification',
	    value: function stopIncomingNotification(caller_jid) {
	      _notifier2.default.unsetTitleNotification(caller_jid);
	    }
	
	    /**
	     * take action when the video conference is joined
	     */
	
	  }, {
	    key: 'handleVideoConferenceJoined',
	    value: function handleVideoConferenceJoined() {
	      var _this17 = this;
	
	      var done = Date.now();
	      return this.hasVideoSession().then(function (hasSession) {
	        if (hasSession) {
	          _this17.data.video_session.connected = true;
	          _this17.data.video_session.connecting = false;
	          _video_actions2.default.videoCallConnected({
	            jid: _this17.data.video_session.jid,
	            start: _this17.data.video_session.start_time,
	            done: done
	          });
	          _current_user_actions2.default.onCall();
	        }
	      });
	    }
	
	    /**
	     * take action when the video conference is left
	     */
	
	  }, {
	    key: 'handleVideoConferenceLeft',
	    value: function handleVideoConferenceLeft() {
	      var _this18 = this;
	
	      this.stopAllSounds();
	      return this.hasVideoSession().then(function (hasSession) {
	        var shouldHangup = _this18.data.video_session.connected || _this18.data.video_session.connecting;
	        if (hasSession && shouldHangup) {
	          _this18.data.video_session.connected = false;
	          _this18.data.video_session.connecting = false;
	          var jid = _this18.data.video_session.jid;
	          var room_id = _this18.data.video_session.room_id;
	          _video_actions2.default.sendHangupMessage({ jid: jid, room_id: room_id });
	          _current_user_actions2.default.leaveCall();
	        }
	      });
	    }
	  }]);
	  return VideoModule;
	}();
	
	exports.default = VideoModule;
	module.exports = exports['default'];

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(47);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _model_store = __webpack_require__(162);
	
	var _model_store2 = _interopRequireDefault(_model_store);
	
	var _current_user_model = __webpack_require__(293);
	
	var _current_user_model2 = _interopRequireDefault(_current_user_model);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ON_CALL_PRESENCE = {
	  show: _presence2.default.DND,
	  status: _video_call_strings2.default.call_status
	};
	
	var CurrentUserStore = function (_ModelStore) {
	  (0, _inherits3.default)(CurrentUserStore, _ModelStore);
	
	  function CurrentUserStore() {
	    (0, _classCallCheck3.default)(this, CurrentUserStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(CurrentUserStore).call(this));
	
	    _this.local = {
	      manual_presence: {
	        show: _presence2.default.AVAILABLE,
	        status: ''
	      }
	    };
	    return _this;
	  }
	
	  /**
	   * @override
	   */
	
	
	  (0, _createClass3.default)(CurrentUserStore, [{
	    key: 'getModel',
	    value: function getModel() {
	      return _current_user_model2.default;
	    }
	  }, {
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        email: '',
	        guest_key: null,
	        is_admin: false,
	        is_guest: false,
	        jid: '',
	        mention: '',
	        photo_large: '',
	        photo_small: '',
	        title: '',
	        user_created_utc: null,
	        id: null,
	        user_name: '',
	        show: _presence2.default.AVAILABLE,
	        status: '' // user set presence text
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'updated:current_user': function updatedCurrent_user(user) {
	          _this2.setIfNotEqual(user);
	        },
	        'updated:roster': function updatedRoster(roster) {
	          var user = roster[_this2.data.jid];
	          if (user && user.presence) {
	            _this2.setIfNotEqual({
	              show: user.presence.show,
	              status: user.presence.status
	            });
	          }
	        },
	        'set-current-user-status': function setCurrentUserStatus(presence) {
	          _this2._saveManualPresence(presence);
	          _this2._updatePresence(presence);
	        },
	        'set-current-user-idle': function setCurrentUserIdle() {
	          if (!_this2._checkIfOnCall()) {
	            _this2._setIdle();
	          }
	        },
	        'set-current-user-active': function setCurrentUserActive() {
	          if (!_this2._checkIfOnCall()) {
	            _this2._setActive();
	          }
	        },
	        'user-on-call': function userOnCall() {
	          _this2._setOnCall();
	        },
	        'user-leave-call': function userLeaveCall() {
	          _this2._setLeaveCall();
	        },
	        'application-focused': function applicationFocused() {
	          // Only restore the presence if the user is idle.
	          if (_this2.data.show === _presence2.default.IDLE) {
	            _this2._setActive();
	          }
	        }
	      });
	    }
	  }, {
	    key: '_setIdle',
	    value: function _setIdle() {
	      this._updatePresence({ show: _presence2.default.IDLE });
	    }
	  }, {
	    key: '_setActive',
	    value: function _setActive() {
	      this._updatePresence(this.local.manual_presence);
	    }
	  }, {
	    key: '_checkIfOnCall',
	    value: function _checkIfOnCall() {
	      return this.data.status === ON_CALL_PRESENCE.status && this.data.show === ON_CALL_PRESENCE.show;
	    }
	  }, {
	    key: '_setOnCall',
	    value: function _setOnCall() {
	      this._updatePresence(ON_CALL_PRESENCE);
	    }
	  }, {
	    key: '_setLeaveCall',
	    value: function _setLeaveCall() {
	      this._updatePresence(this.local.manual_presence);
	    }
	  }, {
	    key: '_saveManualPresence',
	    value: function _saveManualPresence(presence) {
	      // Don't save the current presence if the user is idle.
	      // This is a safeguard as you can't manually set yourself as idle.
	      if (presence.show !== _presence2.default.IDLE) {
	        this.local.manual_presence = (0, _extends3.default)({}, presence);
	      }
	    }
	  }, {
	    key: '_resetManualPresence',
	    value: function _resetManualPresence() {
	      this.local.manual_presence = {
	        show: _presence2.default.AVAILABLE,
	        status: ''
	      };
	    }
	  }, {
	    key: '_updatePresence',
	    value: function _updatePresence() {
	      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var _ref$show = _ref.show;
	      var show = _ref$show === undefined ? this.data.show : _ref$show;
	      var _ref$status = _ref.status;
	      var status = _ref$status === undefined ? this.data.status : _ref$status;
	
	      var presence = { show: show, status: status },
	          current = { show: this.data.show, status: this.data.status };
	
	      if (!_.isEqual(presence, current)) {
	        presence.status = presence.status.trim();
	
	        if (presence.status.length > _app_config2.default.max_presence_text_length) {
	          presence.status = presence.status.substring(0, _app_config2.default.max_presence_text_length);
	        }
	
	        this.set(presence);
	        _app_dispatcher2.default.dispatch('update-presence', presence);
	      }
	    }
	
	    /**
	     * @override
	     */
	
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this._resetManualPresence();
	      (0, _get3.default)((0, _getPrototypeOf2.default)(CurrentUserStore.prototype), 'reset', this).call(this);
	    }
	  }]);
	  return CurrentUserStore;
	}(_model_store2.default);
	
	exports.default = new CurrentUserStore();
	module.exports = exports['default'];

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(148);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class CurrentUserModel
	 *
	 * @property {string} email
	 * @property {string} guest_key
	 * @property {boolean} is_admin
	 * @property {boolean} is_guest
	 * @property {string} jid
	 * @property {string} mention
	 * @property {string} photo_large
	 * @property {string} photo_small
	 * @property {string} title
	 * @property {number} user_created_utc
	 * @property {number} user_id
	 * @property {string} user_name
	 * @property {string} show
	 * @property {string} status
	 */
	
	function normalizeCurrentUser(input) {
	  return _.transform(input, function (result, val, key) {
	    switch (key) {
	
	      case 'email':
	      case 'guest_key':
	      case 'mention':
	      case 'photo_large':
	      case 'photo_small':
	      case 'title':
	      case 'show':
	      case 'status':
	      case 'is_in_welcome_range':
	        result[key] = val;
	        break;
	
	      case 'user_name':
	      case 'name':
	        result.user_name = val;
	        break;
	
	      case 'jid':
	      case 'user_jid':
	        result.jid = val;
	        break;
	
	      case 'user_created_utc':
	        result[key] = !_.isNaN(val) ? parseInt(val, 10) : null;
	        break;
	
	      case 'user_id':
	      case 'id':
	        result.id = !_.isNaN(val) ? parseInt(val, 10) : null;
	        break;
	
	      case 'is_admin':
	      case 'is_guest':
	        result[key] = _utils2.default.coerceBoolean(val, false);
	        break;
	
	      case 'presence':
	        result.show = val.show;
	        result.status = val.status;
	        break;
	    }
	  });
	}
	
	var CurrentUserModel = function CurrentUserModel() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	  (0, _classCallCheck3.default)(this, CurrentUserModel);
	
	  (0, _assign2.default)(this, normalizeCurrentUser(input));
	};
	
	exports.default = CurrentUserModel;
	module.exports = exports['default'];

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _link_utils = __webpack_require__(108);
	
	var _link_utils2 = _interopRequireDefault(_link_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var HCGlobal = function () {
	  function HCGlobal(data) {
	    (0, _classCallCheck3.default)(this, HCGlobal);
	
	    if (data) {
	      this.buildForHC(data);
	    }
	    this.Actions = __webpack_require__(295);
	    this.AppDispatcher = __webpack_require__(9);
	    this.AnalyticsDispatcher = __webpack_require__(173);
	    this.ApplicationStore = __webpack_require__(190);
	    this.AppConfig = __webpack_require__(121);
	    this.utils = __webpack_require__(99);
	    this.Emoticons = __webpack_require__(110);
	    this.Rehacked = __webpack_require__(299);
	    this.ENV = ("production");
	    this.api = __webpack_require__(264);
	    this.resolution = Math.ceil(window.devicePixelRatio);
	    this.emoticon_resolution_helper = function (img) {
	      img.onerror = null;
	      img.src = _link_utils2.default.remove_resolution(img.src);
	    };
	
	    if (false) {
	      this.DAL = require('core/dal');
	    }
	  }
	
	  (0, _createClass3.default)(HCGlobal, [{
	    key: 'buildForHC',
	    value: function buildForHC(data) {
	      var _this = this;
	
	      _.forOwn(data, function (value, key) {
	        _this[key] = value;
	      });
	    }
	  }]);
	  return HCGlobal;
	}(); /*global ENV*/
	
	
	module.exports = HCGlobal;

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	module.exports = {
	  "AppActions": __webpack_require__(195),
	  "ChatHeaderActions": __webpack_require__(285),
	  "ChatInputActions": __webpack_require__(261),
	  "ChatWindowActions": __webpack_require__(178),
	  "ConnectionActions": __webpack_require__(215),
	  "AppHeaderActions": __webpack_require__(276),
	  "DialogActions": __webpack_require__(95),
	  "FlagActions": __webpack_require__(204),
	  "FormActions": __webpack_require__(286),
	  "InlineDialogActions": __webpack_require__(277),
	  "LobbyActions": __webpack_require__(296),
	  "PreferenceActions": __webpack_require__(265),
	  "RoomDropdownActions": __webpack_require__(287),
	  "RoomNavActions": __webpack_require__(288),
	  "RosterActions": __webpack_require__(297),
	  "TooltipActions": __webpack_require__(298)
	};

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * LobbyActions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	var AnalyticsDispatcher = __webpack_require__(173);
	var AnalyticsActions = __webpack_require__(196);
	
	var LobbyActions = {
	
	  /**
	   * @param  {object} data
	   */
	  applyFilter: function applyFilter(data) {
	    AppDispatcher.dispatch('filter-lobby', data);
	    AnalyticsDispatcher.dispatch('analytics-filter-lobby', data);
	  },
	
	  openChat: function openChat(data) {
	    AppDispatcher.dispatch('set-route', { jid: data.jid });
	    data.source = "lobby";
	    AnalyticsDispatcher.dispatch('analytics-open-room', data);
	  },
	
	  resetFilter: function resetFilter() {
	    AppDispatcher.dispatch('set-lobby-filter-text', { text: '' });
	    AppDispatcher.dispatch('filter-lobby', {
	      query: "",
	      scope: "all"
	    });
	  },
	
	  showCreateRoomDialog: function showCreateRoomDialog() {
	    // Old inconsistent event.
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.lobby.create.room.dialog.open"
	    });
	    AnalyticsActions.createRoomClickedEvent("lobby");
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "create-room-dialog",
	      dialog_data: false
	    });
	  },
	
	  lobbyMounted: function lobbyMounted() {
	    AnalyticsDispatcher.dispatch('analytics-lobby-mount', { id: 'lobby' });
	  },
	
	  setInputText: function setInputText(text) {
	    AppDispatcher.dispatch('set-lobby-filter-text', { text: text });
	  },
	
	  resetSelectedItem: function resetSelectedItem() {
	    AppDispatcher.dispatch('lobby-reset-selected-item');
	  },
	
	  itemHovered: function itemHovered(data) {
	    AppDispatcher.dispatch('lobby-item-hover', {
	      index: data.index
	    });
	  },
	
	  selectedNextItem: function selectedNextItem() {
	    AppDispatcher.dispatch('lobby-select-next-item');
	  },
	
	  selectedPrevItem: function selectedPrevItem() {
	    AppDispatcher.dispatch('lobby-select-prev-item');
	  }
	};
	
	module.exports = LobbyActions;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * LobbyRosterActions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	
	var LobbyRosterActions = {
	
	  fetchPresence: function fetchPresence() {
	    AppDispatcher.dispatch('fetch-presence');
	  }
	
	};
	
	module.exports = LobbyRosterActions;

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * TooltipActions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	var AnalyticsDispatcher = __webpack_require__(173);
	
	var TooltipActions = {
	
	  showTooltip: function showTooltip(data) {
	    AppDispatcher.dispatch('show-tooltip', data);
	  },
	
	  smileyChosen: function smileyChosen(data) {
	    AppDispatcher.dispatch('smiley-chosen', data);
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.emoticon.dialog.emoticon.clicked",
	      properties: {
	        emoticonString: data.shortcut
	      }
	    });
	  },
	
	  moreEmoticonsChosen: function moreEmoticonsChosen() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.emoticon.dialog.more.clicked"
	    });
	  },
	
	  customEmoticonsChosen: function customEmoticonsChosen() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.emoticon.dialog.custom.clicked"
	    });
	  }
	
	};
	
	module.exports = TooltipActions;

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Rehacked = __webpack_require__(300)(__webpack_require__(305));
	var rehackedPlaceholderBuilder = __webpack_require__(306);
	
	var _before = Rehacked.before;
	var _after = Rehacked.after;
	var _on = Rehacked.on;
	
	function createPlaceholder(opts) {
	  var node = opts.node || 'div';
	  return rehackedPlaceholderBuilder(node, opts.props, opts.lifecycle);
	}
	
	Rehacked.on = function (componentName, selector, element /*, arguments */) {
	  if (_.isPlainObject(element)) {
	    Array.prototype.splice.call(arguments, 2, 1, createPlaceholder(element));
	  }
	  return _on.apply(Rehacked, arguments);
	};
	
	Rehacked.before = function (componentName, selector, element /*, arguments */) {
	  if (_.isPlainObject(element)) {
	    Array.prototype.splice.call(arguments, 2, 1, createPlaceholder(element));
	  }
	  return _before.apply(Rehacked, arguments);
	};
	
	Rehacked.after = function (componentName, selector, element /*, arguments */) {
	  if (_.isPlainObject(element)) {
	    Array.prototype.splice.call(arguments, 2, 1, createPlaceholder(element));
	  }
	  return _after.apply(Rehacked, arguments);
	};
	
	module.exports = Rehacked;

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Rehacked = __webpack_require__(301);
	var ElementMatcher = __webpack_require__(304);
	var _ = __webpack_require__(303);
	
	module.exports = function (React) {
	  function search(expression, idx, nodeChildren, hack) {
	    var theEnd = expression.length === idx + 1;
	    var matcher = new ElementMatcher(expression[idx]);
	    var foundChildren = [];
	    _.compact(nodeChildren).forEach(function (child) {
	      if (_.isArray(child)) {
	        search(expression, idx, child, hack);
	      } else {
	        var matches = matcher.test(child);
	        var hasChildren = child.props && child.props.children;
	        if (!matches && hasChildren && matcher.shouldTraverse()) {
	          child.props.children = _.asArray(child.props.children);
	          search(expression, idx, child.props.children, hack);
	        } else if (matches && !theEnd && hasChildren) {
	          child.props.children = _.asArray(child.props.children);
	          search(expression, idx + 1, child.props.children, hack);
	        } else if (matches && theEnd) {
	          foundChildren.push(child);
	        }
	      }
	    });
	    foundChildren.forEach(function (foundChild) {
	      var idx = nodeChildren.indexOf(foundChild);
	      var hackElement = React.createElement(hack.reactClass, { reference: foundChild });
	      if (hack.location === -1) {
	        nodeChildren.splice(idx, 0, hackElement);
	      } else if (hack.location === 1) {
	        nodeChildren.splice(idx + 1, 0, hackElement);
	      } else if (hack.location === 0) {
	        nodeChildren.splice(idx, 1, hackElement);
	      }
	    });
	  }
	
	  var inst = new Rehacked();
	  var _createClass = React.createClass;
	  React.createClass = function (spec /*, arguments*/) {
	    var _render = spec.render;
	    var componentName = spec.displayName;
	    spec.render = function () /* arguments */{
	      var renderedComponent = _render.apply(this, arguments);
	      if (inst.isAnythingBeingHacked() && inst.isBeingHacked(componentName)) {
	        var hacks = inst._getEntry(componentName);
	        hacks.forEach(function (hack) {
	          var expressions = hack.selector.expressions;
	          expressions && expressions.forEach(function (expression) {
	            search(expression, 0, [renderedComponent], hack);
	          });
	        });
	      }
	      return renderedComponent;
	    };
	    return _createClass.apply(React, arguments);
	  };
	
	  return inst;
	};

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var parse = __webpack_require__(302).Slick.parse;
	var _ = __webpack_require__(303);
	
	function Rehacked() {
	  this._hackRegistry = {};
	}
	
	var _assert = function _assert(condition, message) {
	  if (!condition) throw message;
	};
	
	/**
	 * Returns if any hacks are registered with Rehacked
	 * @returns {boolean} if any hacks are registered
	 */
	Rehacked.prototype.isAnythingBeingHacked = function () {
	  return this._hackRegistry.length !== 0;
	};
	
	/**
	 * Returns if a specific component is being hacked with Rehacked
	 * @param {string} componentName the display name of the component
	 * @returns {boolean} if any hacks are registered for the specified component
	 */
	Rehacked.prototype.isBeingHacked = function (componentName) {
	  return typeof this._hackRegistry[componentName] !== 'undefined';
	};
	
	/**
	 * Render an element before a selector in a components DOM tree
	 * @param {string} componentName the display name of the component
	 * @param {string} selector a CSS3 selector specifying which elements to hack
	 * @param {Object} reactClass a React.js element to render before the found elements
	 * @param {Object=} opts an optional options hash
	 */
	Rehacked.prototype.before = function (componentName, selector, reactClass, opts) {
	  this._hack(componentName, selector, reactClass, _.extend({ location: -1 }, opts));
	};
	
	/**
	 * Render an element after a selector in a components DOM tree
	 * @param {string} componentName the display name of the component
	 * @param {string} selector a CSS3 selector specifying which elements to hack
	 * @param {Object} reactClass a React.js element to render before the found elements
	 * @param {Object=} opts an optional options hash
	 */
	Rehacked.prototype.after = function (componentName, selector, reactClass, opts) {
	  this._hack(componentName, selector, reactClass, _.extend({ location: 1 }, opts));
	};
	
	/**
	 * Render an element in place of a selector in a components DOM tree (experimental)
	 * @param {string} componentName the display name of the component
	 * @param {string} selector a CSS3 selector specifying which elements to hack
	 * @param {Object} reactClass a React.js element to render before the found elements
	 * @param {Object=} opts an optional options hash
	 */
	Rehacked.prototype.on = function (componentName, selector, reactClass, opts) {
	  this._hack(componentName, selector, reactClass, _.extend({ location: 0 }, opts));
	};
	
	Rehacked.prototype._getEntry = function (componentName) {
	  return this._hackRegistry[componentName];
	};
	
	Rehacked.prototype._hack = function (componentName, selector, reactClass, opts) {
	  _assert(componentName, "You must specify a component type to hack");
	  _assert(selector, "You must specify a selector");
	  _assert(reactClass, "You must provide an element to render");
	  _assert(opts.location !== -1 || opts.location !== 0 || opts.location !== 1, "You must specify a place for the hack to appear");
	
	  var isComponentBeingHacked = this.isBeingHacked(componentName);
	  var entry = {
	    selector: parse(selector),
	    location: opts.location,
	    reactClass: reactClass
	  };
	
	  if (isComponentBeingHacked) {
	    this._hackRegistry[componentName].push(entry);
	  } else {
	    this._hackRegistry[componentName] = [entry];
	  }
	};
	
	Rehacked.prototype._clear = function () {
	  this._hackRegistry = {};
	};
	
	module.exports = Rehacked;

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*
	---
	name: Slick.Parser
	description: Standalone CSS3 Selector parser
	provides: Slick.Parser
	...
	*/
	
	;(function () {
	
		var parsed,
		    separatorIndex,
		    combinatorIndex,
		    reversed,
		    cache = {},
		    reverseCache = {},
		    reUnescape = /\\/g;
	
		var parse = function parse(expression, isReversed) {
			if (expression == null) return null;
			if (expression.Slick === true) return expression;
			expression = ('' + expression).replace(/^\s+|\s+$/g, '');
			reversed = !!isReversed;
			var currentCache = reversed ? reverseCache : cache;
			if (currentCache[expression]) return currentCache[expression];
			parsed = {
				Slick: true,
				expressions: [],
				raw: expression,
				reverse: function reverse() {
					return parse(this.raw, true);
				}
			};
			separatorIndex = -1;
			while (expression != (expression = expression.replace(regexp, parser))) {}
			parsed.length = parsed.expressions.length;
			return currentCache[parsed.raw] = reversed ? reverse(parsed) : parsed;
		};
	
		var reverseCombinator = function reverseCombinator(combinator) {
			if (combinator === '!') return ' ';else if (combinator === ' ') return '!';else if (/^!/.test(combinator)) return combinator.replace(/^!/, '');else return '!' + combinator;
		};
	
		var reverse = function reverse(expression) {
			var expressions = expression.expressions;
			for (var i = 0; i < expressions.length; i++) {
				var exp = expressions[i];
				var last = { parts: [], tag: '*', combinator: reverseCombinator(exp[0].combinator) };
	
				for (var j = 0; j < exp.length; j++) {
					var cexp = exp[j];
					if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
					cexp.combinator = cexp.reverseCombinator;
					delete cexp.reverseCombinator;
				}
	
				exp.reverse().push(last);
			}
			return expression;
		};
	
		var escapeRegExp = function escapeRegExp(string) {
			// Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
			return string.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, function (match) {
				return '\\' + match;
			});
		};
	
		var regexp = new RegExp(
		/*
	 #!/usr/bin/env ruby
	 puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
	 __END__
	 	"(?x)^(?:\
	 	  \\s* ( , ) \\s*               # Separator          \n\
	 	| \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
	 	|      ( \\s+ )                 # CombinatorChildren \n\
	 	|      ( <unicode>+ | \\* )     # Tag                \n\
	 	| \\#  ( <unicode>+       )     # ID                 \n\
	 	| \\.  ( <unicode>+       )     # ClassName          \n\
	 	|                               # Attribute          \n\
	 	\\[  \
	 		\\s* (<unicode1>+)  (?:  \
	 			\\s* ([*^$!~|]?=)  (?:  \
	 				\\s* (?:\
	 					([\"']?)(.*?)\\9 \
	 				)\
	 			)  \
	 		)?  \\s*  \
	 	\\](?!\\]) \n\
	 	|   :+ ( <unicode>+ )(?:\
	 	\\( (?:\
	 		(?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
	 	) \\)\
	 	)?\
	 	)"
	 */
		"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)".replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']').replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])').replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])'));
	
		function parser(rawMatch, separator, combinator, combinatorChildren, tagName, id, className, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {
			if (separator || separatorIndex === -1) {
				parsed.expressions[++separatorIndex] = [];
				combinatorIndex = -1;
				if (separator) return '';
			}
	
			if (combinator || combinatorChildren || combinatorIndex === -1) {
				combinator = combinator || ' ';
				var currentSeparator = parsed.expressions[separatorIndex];
				if (reversed && currentSeparator[combinatorIndex]) currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
				currentSeparator[++combinatorIndex] = { combinator: combinator, tag: '*' };
			}
	
			var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];
	
			if (tagName) {
				currentParsed.tag = tagName.replace(reUnescape, '');
			} else if (id) {
				currentParsed.id = id.replace(reUnescape, '');
			} else if (className) {
				className = className.replace(reUnescape, '');
	
				if (!currentParsed.classList) currentParsed.classList = [];
				if (!currentParsed.classes) currentParsed.classes = [];
				currentParsed.classList.push(className);
				currentParsed.classes.push({
					value: className,
					regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
				});
			} else if (pseudoClass) {
				pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
				pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;
	
				if (!currentParsed.pseudos) currentParsed.pseudos = [];
				currentParsed.pseudos.push({
					key: pseudoClass.replace(reUnescape, ''),
					value: pseudoClassValue,
					type: pseudoMarker.length == 1 ? 'class' : 'element'
				});
			} else if (attributeKey) {
				attributeKey = attributeKey.replace(reUnescape, '');
				attributeValue = (attributeValue || '').replace(reUnescape, '');
	
				var test, regexp;
	
				switch (attributeOperator) {
					case '^=':
						regexp = new RegExp('^' + escapeRegExp(attributeValue));break;
					case '$=':
						regexp = new RegExp(escapeRegExp(attributeValue) + '$');break;
					case '~=':
						regexp = new RegExp('(^|\\s)' + escapeRegExp(attributeValue) + '(\\s|$)');break;
					case '|=':
						regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');break;
					case '=':
						test = function test(value) {
							return attributeValue == value;
						};break;
					case '*=':
						test = function test(value) {
							return value && value.indexOf(attributeValue) > -1;
						};break;
					case '!=':
						test = function test(value) {
							return attributeValue != value;
						};break;
					default:
						test = function test(value) {
							return !!value;
						};
				}
	
				if (attributeValue == '' && /^[*$^]=$/.test(attributeOperator)) test = function test() {
					return false;
				};
	
				if (!test) test = function test(value) {
					return value && regexp.test(value);
				};
	
				if (!currentParsed.attributes) currentParsed.attributes = [];
				currentParsed.attributes.push({
					key: attributeKey,
					operator: attributeOperator,
					value: attributeValue,
					test: test
				});
			}
	
			return '';
		};
	
		// Slick NS
	
		var Slick = this.Slick || {};
	
		Slick.parse = function (expression) {
			return parse(expression);
		};
	
		Slick.escapeRegExp = escapeRegExp;
	
		if (!this.Slick) this.Slick = Slick;
	}).apply( /*<CommonJS>*/ true ? exports : /*</CommonJS>*/undefined);

/***/ },
/* 303 */
/***/ function(module, exports) {

	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = {
	  extend: function extend(obj, source) {
	    var prop;
	    for (prop in source) {
	      if (hasOwnProperty.call(source, prop)) {
	        obj[prop] = source[prop];
	      }
	    }
	    return obj;
	  },
	  isArray: function isArray(obj) {
	    return toString.call(obj) === '[object Array]';
	  },
	  pluck: function pluck(arr, key) {
	    var output = [];
	    arr.forEach(function (item) {
	      output.push(item[key]);
	    });
	    return output;
	  },
	  every: function every(arr, predicate, ctx) {
	    var matching = true;
	    arr.forEach(function (item) {
	      matching = matching && predicate.call(ctx, item);
	    });
	    return matching;
	  },
	  compact: function compact(arr) {
	    var results = [];
	    arr.forEach(function (item) {
	      if (item) results.push(item);
	    });
	    return results;
	  },
	  asArray: function asArray(val) {
	    return this.isArray(val) ? val : [val];
	  }
	};

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(303);
	
	function ElementMatcher(selector) {
	  this._selector = selector;
	}
	
	ElementMatcher.prototype.test = function (node) {
	  var matching = true;
	  if (matching && this._selector.tag && this._selector.tag !== "*") {
	    matching = node.type === this._selector.tag || node.type && node.type.displayName === this._selector.tag;
	  }
	
	  if (matching && this._selector.classes) {
	    matching = node.props && node.props.className && _.every(_.pluck(this._selector.classes, 'regexp'), function (regexp) {
	      return regexp.test(node.props.className);
	    });
	  }
	
	  if (matching && this._selector.id) {
	    matching = node.props.id === this._selector.id;
	  }
	
	  if (matching && this._selector.pseudos) {
	    throw "rehacked doesn't understand pseudo classes (yet)";
	  }
	
	  if (matching && this._selector.attributes) {
	    matching = _.every(this._selector.attributes, function (attribute) {
	      var value = node.props[attribute.key];
	      return value && attribute.test(value);
	    });
	  }
	
	  return matching;
	};
	
	ElementMatcher.prototype.shouldTraverse = function () {
	  return this._selector.combinator !== '>';
	};
	
	module.exports = ElementMatcher;

/***/ },
/* 305 */
/***/ function(module, exports) {

	module.exports = React;

/***/ },
/* 306 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (node, props, lifecycle) {
	  var lifecycleAwareMethods = ['componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount'];
	
	  var base = {
	    displayName: "RehackedPlaceholder",
	
	    render: function render() {
	      return React.createElement(node, props);
	    }
	  };
	
	  var proxyLifecycleMethods = function proxyLifecycleMethods(data) {
	    var lifecycleMethods = lifecycleAwareMethods.map(function (method) {
	      return function () /* arguments */{
	        var requested = lifecycle[method];
	        if (requested) {
	          requested.apply(this, arguments);
	        }
	      };
	    });
	    return _.extend(_.fromPairs(lifecycleAwareMethods, lifecycleMethods), data);
	  };
	
	  return React.createClass(proxyLifecycleMethods(base));
	};

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _header = __webpack_require__(308);
	
	var _header2 = _interopRequireDefault(_header);
	
	var _inline_dialog_manager_mixin = __webpack_require__(338);
	
	var _inline_dialog_manager_mixin2 = _interopRequireDefault(_inline_dialog_manager_mixin);
	
	var _modal_dialog_container = __webpack_require__(339);
	
	var _modal_dialog_container2 = _interopRequireDefault(_modal_dialog_container);
	
	var _inline_dialog_container = __webpack_require__(465);
	
	var _inline_dialog_container2 = _interopRequireDefault(_inline_dialog_container);
	
	var _read_only_container = __webpack_require__(472);
	
	var _read_only_container2 = _interopRequireDefault(_read_only_container);
	
	var _flags_container = __webpack_require__(475);
	
	var _flags_container2 = _interopRequireDefault(_flags_container);
	
	var _main_body_layout = __webpack_require__(481);
	
	var _main_body_layout2 = _interopRequireDefault(_main_body_layout);
	
	var _file_viewer = __webpack_require__(620);
	
	var _file_viewer2 = _interopRequireDefault(_file_viewer);
	
	var _tipsify = __webpack_require__(621);
	
	var _tipsify2 = _interopRequireDefault(_tipsify);
	
	__webpack_require__(622);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "MainLayout",
	
	  mixins: [_inline_dialog_manager_mixin2.default],
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { id: 'page' },
	      React.createElement(_header2.default, { is_guest: this.props.is_guest }),
	      React.createElement(_main_body_layout2.default, { is_guest: this.props.is_guest }),
	      React.createElement(_modal_dialog_container2.default, null),
	      React.createElement(_inline_dialog_container2.default, null),
	      React.createElement(_flags_container2.default, null),
	      React.createElement(_file_viewer2.default, { ref: 'fileViewer', items: this.props.files }),
	      React.createElement(_read_only_container2.default, null),
	      React.createElement(_tipsify2.default, null)
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _user_status = __webpack_require__(309);
	
	var _user_status2 = _interopRequireDefault(_user_status);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _app_header_store = __webpack_require__(96);
	
	var _app_header_store2 = _interopRequireDefault(_app_header_store);
	
	var _read_only_store = __webpack_require__(334);
	
	var _read_only_store2 = _interopRequireDefault(_read_only_store);
	
	var _notification_banner = __webpack_require__(336);
	
	var _notification_banner2 = _interopRequireDefault(_notification_banner);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _app_header_strings = __webpack_require__(319);
	
	var _app_header_strings2 = _interopRequireDefault(_app_header_strings);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _analytics_keys = __webpack_require__(197);
	
	var _analytics_keys2 = _interopRequireDefault(_analytics_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "AppHeader",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  _getState: function _getState() {
	    var state = _.assign({}, _app_header_store2.default.getAll(), {
	      read_only_mode: _read_only_store2.default.get('read_only_mode')
	    });
	    return state;
	  },
	
	  componentDidMount: function componentDidMount() {
	    _app_header_store2.default.on("change", this._onChange);
	    _read_only_store2.default.on("change:read_only_mode", this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _app_header_store2.default.off("change", this._onChange);
	    _read_only_store2.default.off("change:read_only_mode", this._onChange);
	  },
	
	  _onLogoClick: function _onLogoClick() {
	    _app_actions2.default.logoClicked();
	  },
	
	  _onNewChatClick: function _onNewChatClick(evt) {
	    _analytics_actions2.default.newChatButtonClicked();
	    _dialog_actions2.default.showQuickSwitcherDialog();
	    evt.preventDefault();
	  },
	
	  _getUserStatus: function _getUserStatus() {
	    if (this.state.ready) {
	      return React.createElement(_user_status2.default, { search_text: this.state.search_text,
	        focus_search: this.state.focus_search,
	        active_chat: this.state.active_chat,
	        multi_org_supported: this.state.feature_flags.web_client_subdomain_scoped_session,
	        search_enabled: this.state.feature_flags.web_client_embedded_search,
	        should_animate_avatar: this.state.should_animate_avatar,
	        read_only_mode: this.state.read_only_mode,
	        is_guest: this.props.is_guest });
	    }
	  },
	
	  _getNewChatButton: function _getNewChatButton() {
	    if (this.state.ready) {
	      var newChatClasses = (0, _classnames2.default)({
	        'aui-button': true,
	        'aui-button-primary': true,
	        'is-native': _utils2.default.clientSubType.isNative(this.state.client_subtype)
	      });
	
	      return React.createElement(
	        "ul",
	        { className: "aui-nav", "data-skate-ignore": true },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._onNewChatClick, id: "new_chat_btn", ref: "new_chat_btn", className: newChatClasses, "aria-label": _app_header_strings2.default.new_chat_btn_title, "data-tipsify-ignore": true },
	            _app_header_strings2.default.new_chat_btn_title
	          )
	        )
	      );
	    }
	  },
	
	  _getInviteUserButton: function _getInviteUserButton() {
	    if (!this.state.feature_flags.hide_invite_your_team_button) {
	      if (this.state.ready && (this.state.user_is_admin || this.state.invite_url)) {
	        return React.createElement(
	          "ul",
	          { className: "aui-nav", "data-skate-ignore": true },
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { onClick: this._onInviteUserClick,
	                className: "aui-button aui-button-link hc-invite-users aui-inline-dialog-trigger",
	                "aria-label": _app_header_strings2.default.invite_your_team_btn_title,
	                "data-tipsify-ignore": true },
	              _app_header_strings2.default.invite_your_team_btn_title
	            )
	          )
	        );
	      }
	    }
	  },
	
	  _getAppLogo: function _getAppLogo() {
	    return React.createElement(
	      "a",
	      { id: "app_logo", ref: "app_logo", href: "https://" + this.state.web_server + "/home", onClick: this._onLogoClick, target: "_blank" },
	      React.createElement(
	        "span",
	        { className: "aui-header-logo-device" },
	        _common_strings2.default.hipchat
	      )
	    );
	  },
	
	  _onInviteUserClick: function _onInviteUserClick() {
	    _dialog_actions2.default.showInviteTeammatesDialog({ type: _analytics_keys2.default.TOP });
	    _analytics_actions2.default.inviteTeamClickedEvent("top.navigation");
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  render: function render() {
	    var hipchatLogo = !_utils2.default.clientSubType.isNative(this.state.client_subtype) ? this._getAppLogo() : false;
	    var userStatus = this._getUserStatus();
	    var newChatButton = this.props.is_guest ? false : this._getNewChatButton();
	    var inviteUsersButton = this.props.is_guest ? false : this._getInviteUserButton();
	
	    var banner;
	    var show_banner = this.state.ready && this.state.notification_supported && !this.state.notification_dismissed_forever && !this.state.notification_permission;
	    if (show_banner) {
	      banner = React.createElement(_notification_banner2.default, this.state);
	    }
	
	    var classes = (0, _classnames2.default)({
	      'app-header': true,
	      'banner-dismissed': !this.state.banner_shown,
	      'banner-shown': this.state.banner_shown && show_banner
	    });
	
	    return React.createElement(
	      "header",
	      { id: "header", className: classes, role: "banner" },
	      banner,
	      React.createElement(
	        "nav",
	        { className: "aui-header aui-dropdown2-trigger-group", role: "navigation", "data-aui-responsive": "true" },
	        React.createElement(
	          "div",
	          { className: "aui-header-inner" },
	          React.createElement(
	            "div",
	            { className: "aui-header-primary" },
	            React.createElement(
	              "h1",
	              { id: "logo", className: "aui-header-logo aui-header-logo-hc" },
	              hipchatLogo
	            ),
	            newChatButton,
	            inviteUsersButton
	          ),
	          userStatus
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _user_status_menu = __webpack_require__(318);
	
	var _user_status_menu2 = _interopRequireDefault(_user_status_menu);
	
	var _connection_status = __webpack_require__(321);
	
	var _connection_status2 = _interopRequireDefault(_connection_status);
	
	var _help_menu_content = __webpack_require__(330);
	
	var _help_menu_content2 = _interopRequireDefault(_help_menu_content);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _app_header_actions = __webpack_require__(276);
	
	var _app_header_actions2 = _interopRequireDefault(_app_header_actions);
	
	var _search_input = __webpack_require__(331);
	
	var _search_input2 = _interopRequireDefault(_search_input);
	
	var _presenceIcon = __webpack_require__(311);
	
	var _presenceIcon2 = _interopRequireDefault(_presenceIcon);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _aui_dropdown2_trigger = __webpack_require__(332);
	
	var _aui_dropdown2_trigger2 = _interopRequireDefault(_aui_dropdown2_trigger);
	
	var _aui_dropdown = __webpack_require__(333);
	
	var _aui_dropdown2 = _interopRequireDefault(_aui_dropdown);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _connection_status_store = __webpack_require__(326);
	
	var _connection_status_store2 = _interopRequireDefault(_connection_status_store);
	
	var _connection = __webpack_require__(327);
	
	var _connection2 = _interopRequireDefault(_connection);
	
	var _network = __webpack_require__(328);
	
	var _network2 = _interopRequireDefault(_network);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "UserStatus",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  componentDidMount: function componentDidMount() {
	    _current_user_store2.default.on(['change'], this._onChange);
	    _configuration_store2.default.on('change:web_server', this._onChange);
	    _connection_status_store2.default.on('change', this._onChange);
	
	    this._debouncedResize = _.debounce(this._debouncedChange, 50, { leading: false, trailing: true });
	    $(window).on('resize', this._debouncedResize);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _current_user_store2.default.off(['change'], this._onChange);
	    _configuration_store2.default.off('change:web_server', this._onChange);
	    _connection_status_store2.default.off('change', this._onChange);
	
	    $(window).off('resize', this._debouncedResize);
	    this._debouncedResize.cancel();
	  },
	  _onHelpButtonClicked: function _onHelpButtonClicked() {
	    _app_header_actions2.default.helpButtonClicked();
	  },
	  _onUserProfileDropdownClick: function _onUserProfileDropdownClick() {
	    _app_header_actions2.default.userProfileDropdownClicked();
	  },
	  _getSearchInput: function _getSearchInput() {
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(_search_input2.default, { jid: this.props.active_chat,
	        text: this.props.search_text,
	        focus_search: this.props.focus_search,
	        search_enabled: this.props.search_enabled })
	    );
	  },
	  _getHelpMenu: function _getHelpMenu(is_guest) {
	    var help_menu;
	
	    if (!is_guest) {
	      help_menu = React.createElement(
	        "li",
	        null,
	        React.createElement(
	          _aui_dropdown2_trigger2.default,
	          { type: "link", id: "header-help-menu-link", dropdownID: "header-help-menu", className: "hc-header-help-menu", arrowless: true },
	          React.createElement("span", { className: "aui-icon aui-icon-small aui-iconfont-help" })
	        ),
	        React.createElement(
	          _aui_dropdown2.default,
	          { dropdownID: "header-help-menu", className: "aui-dropdown2-in-header" },
	          React.createElement(_help_menu_content2.default, { read_only_mode: this.props.read_only_mode })
	        )
	      );
	    }
	
	    return help_menu;
	  },
	  render: function render() {
	    var searchInput = this.props.is_guest || this._shouldHideSearchInput() ? false : this._getSearchInput(),
	        help_menu = this._getHelpMenu(this.props.is_guest);
	
	    return React.createElement(
	      "div",
	      { className: "aui-header-secondary" },
	      React.createElement(
	        "ul",
	        { className: "aui-nav", "data-skate-ignore": true },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(_connection_status2.default, null)
	        ),
	        searchInput,
	        help_menu,
	        React.createElement(
	          "li",
	          { id: "status_dropdown", ref: "status_dropdown", className: "status-dropdown", onClick: this._onUserProfileDropdownClick },
	          React.createElement(
	            _aui_dropdown2_trigger2.default,
	            { type: "link", dropdownID: "current-user-status", className: "hc-header-user-avatar" },
	            React.createElement(_person_avatar2.default, { avatar_url: this.state.photo_small,
	              size: "small",
	              shouldAnimate: this.props.should_animate_avatar,
	              show_presence: false }),
	            React.createElement(_presenceIcon2.default, { presence: this.state.show, active: true, uid: this.state.id })
	          ),
	          React.createElement(
	            _aui_dropdown2.default,
	            { dropdownID: "current-user-status", className: "aui-dropdown2-in-header" },
	            React.createElement(_user_status_menu2.default, {
	              web_server: this.state.web_server,
	              is_guest: this.props.is_guest,
	              multi_org_supported: this.props.multi_org_supported,
	              presence_show: this.state.show,
	              presence_status: this.state.status,
	              current_user_uid: this.state.id })
	          )
	        )
	      )
	    );
	  },
	  _shouldHideSearchInput: function _shouldHideSearchInput() {
	    var headerWidth = $('.aui-header').width();
	
	    return (this.state.connectionStatus !== _connection2.default.CONNECTED || this.state.networkStatus !== _network2.default.ONLINE) && headerWidth < 950;
	  },
	  _getState: function _getState() {
	    return _.extend({
	      web_server: _configuration_store2.default.get('web_server'),
	      presenceDialogVisible: false,
	      currentTime: _utils2.default.getMoment(),
	      connectionStatus: _connection_status_store2.default.get('connection_status'),
	      networkStatus: _connection_status_store2.default.get('network_status')
	    }, _current_user_store2.default.getAll());
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _debouncedChange: function _debouncedChange() {
	    _app_header_actions2.default.positionDialogs();
	    this._onChange();
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _presenceIcon = __webpack_require__(311);
	
	var _presenceIcon2 = _interopRequireDefault(_presenceIcon);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _avatar_helper = __webpack_require__(258);
	
	var _avatar_helper2 = _interopRequireDefault(_avatar_helper);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'PersonAvatar',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    active: React.PropTypes.bool,
	    show_presence: React.PropTypes.bool,
	    size: React.PropTypes.string,
	    avatar_url: React.PropTypes.string,
	    avatar_bg_color: React.PropTypes.string,
	    text: React.PropTypes.string,
	    name: React.PropTypes.string,
	    uid: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
	    shouldAnimate: React.PropTypes.bool
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      active: true,
	      show_presence: true,
	      size: 'xsmall',
	      avatar_url: '',
	      avatar_bg_color: _app_config2.default.default_group_avatar_bg,
	      text: '',
	      name: '',
	      uid: '',
	      shouldAnimate: true,
	      onClick: function onClick() {}
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      src: null,
	      asset_base_uri: _configuration_store2.default.get('asset_base_uri'),
	      force_default_avatar: false
	    };
	  },
	
	
	  /*
	   * NOTE: The _isMounted code here is an anti-pattern. Do not emulate this code.
	   *       The utils.image.load promise below can't be cancelled when it unmounts
	   *       so this is a workaround.
	   */
	  _isMounted: false,
	
	  componentDidMount: function componentDidMount() {
	    var _this = this;
	
	    this._isMounted = true;
	    if (this.props.avatar_url) {
	      _utils2.default.image.load(this.props.avatar_url, _app_config2.default.avatar_loading_timeout).then(function (image) {
	        if (_this._isMounted) {
	          if (_this.state.src !== image) {
	            _this.setState({
	              src: image
	            });
	          }
	          _this._drawCanvas();
	        }
	      }).catch(function () {
	        if (_this._isMounted) {
	          _this.setState({
	            force_default_avatar: true
	          });
	        }
	      });
	    }
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    this._drawCanvas();
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._isMounted = false;
	  },
	
	
	  _getAvatar: function _getAvatar() {
	    if (!this.props.shouldAnimate && _utils2.default.file.is_gif(this.props.avatar_url)) {
	      return React.createElement('canvas', { className: 'aui-avatar-img', ref: 'canvas' });
	    }
	
	    var style = {
	      backgroundImage: 'url(' + this.props.avatar_url + ')'
	    };
	
	    return React.createElement('span', { className: 'aui-avatar-img', style: style });
	  },
	
	  _drawCanvas: function _drawCanvas() {
	    var image = this.state.src;
	    var canvas = this.refs.canvas;
	
	    if (image && canvas) {
	      var w = image.width;
	      var h = image.height;
	      var min = w;
	      var x = 0;
	      var y = 0;
	
	      // maintaining aspect ratio and centering image in canvas
	      if (w < h) {
	        min = w;
	        y = (h - min) / 2;
	      } else if (h < w) {
	        min = h;
	        x = (w - min) / 2;
	      }
	
	      canvas.height = canvas.width = min;
	      canvas.getContext('2d').drawImage(image, x, y, min, min, 0, 0, min, min);
	    }
	  },
	
	  _getDefaultAvatar: function _getDefaultAvatar() {
	    var style = {
	      backgroundColor: this.props.avatar_bg_color
	    },
	        text = this.props.text.toUpperCase();
	
	    if (this.props.name && !text) {
	      text = _avatar_helper2.default.getAvatarInitialsFromName(this.props.name);
	    }
	
	    if (this.state.asset_base_uri && !text) {
	      style.backgroundImage = 'url(' + this.state.asset_base_uri + 'assets/img/user-avatar-blue-48' + (window.HC.resolution > 1 ? '@2x' : '') + '.png)';
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-default-avatar', style: style },
	      text
	    );
	  },
	
	  _getStatus: function _getStatus() {
	    if (!this.props.show_presence) {
	      return false;
	    }
	
	    return React.createElement(_presenceIcon2.default, { presence: this.props.presence,
	      mobile: this.props.mobile,
	      active: this.props.active,
	      uid: this.props.uid });
	  },
	
	  render: function render() {
	    var avatar = this.props.avatar_url && !this.state.force_default_avatar ? this._getAvatar() : this._getDefaultAvatar(),
	        status = this._getStatus(),
	        classes = 'aui-avatar aui-avatar-project aui-avatar-' + this.props.size;
	
	    return React.createElement(
	      'span',
	      { className: classes, onClick: this.props.onClick },
	      React.createElement(
	        'span',
	        { className: 'aui-avatar-inner' },
	        avatar
	      ),
	      status
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _icon = __webpack_require__(312);
	
	var _icon2 = _interopRequireDefault(_icon);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _presence_subscription_helper = __webpack_require__(290);
	
	var _presence_subscription_helper2 = _interopRequireDefault(_presence_subscription_helper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "PresenceIcon",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  componentWillMount: function componentWillMount() {
	    if (this.props.uid) {
	      _presence_subscription_helper2.default.subscribeToPresence(this.props.uid);
	    }
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    if (prevProps.uid !== this.props.uid) {
	      _presence_subscription_helper2.default.unsubscribeFromPresence(prevProps.uid);
	      _presence_subscription_helper2.default.subscribeToPresence(this.props.uid);
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this.props.uid) {
	      _presence_subscription_helper2.default.unsubscribeFromPresence(this.props.uid);
	    }
	  },
	
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      classNames: {
	        "hc-status-icon": true
	      },
	      presence: "chat",
	      mobile: false,
	      active: false,
	      uid: ''
	    };
	  },
	
	  _getPresenceIconName: function _getPresenceIconName(statusName) {
	    var iconName = statusName;
	
	    if (statusName === "chat") {
	      iconName = "available";
	    } else if (statusName === "unknown") {
	      iconName = "unavailable";
	    }
	
	    if (this.props.active) {
	      iconName += "-selected";
	    }
	
	    return iconName;
	  },
	
	  _getStatusName: function _getStatusName() {
	    var statusName = "unknown";
	
	    if (this.props.presence === "unknown" && this.props.mobile) {
	      statusName = "mobile";
	    } else if (this.props.presence) {
	      statusName = this.props.presence;
	    }
	
	    return statusName;
	  },
	
	  render: function render() {
	    var statusName = this._getStatusName();
	    var iconName = this._getPresenceIconName(statusName);
	    var className = "icon-" + statusName;
	    var c = {};
	    c[className] = true;
	    var classes = _.assign({}, this.props.classNames, c);
	
	    return React.createElement(_icon2.default, { classes: classes, iconName: iconName, uid: this.props.uid });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var cx = __webpack_require__(313);
	
	module.exports = React.createClass({
	
	  displayName: "Icon",
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      classes: {},
	      iconName: "chat",
	      active: false,
	      uid: ''
	    };
	  },
	
	  _getClassNames: function _getClassNames() {
	    return _.assign({}, {
	      "aui-icon": true,
	      "hipchat-icon-small": true
	    }, this.props.classes);
	  },
	
	  render: function render() {
	    var classNames = this._getClassNames();
	    var iconHtml = "<svg class='" + cx(classNames) + "' data-uid='" + this.props.uid + "'><use xlink:href='#icon-" + this.props.iconName + "'></use></svg>";
	
	    return React.createElement("span", { dangerouslySetInnerHTML: { __html: iconHtml } });
	  }
	});

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(315);

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentWithPureRenderMixin
	 */
	
	'use strict';
	
	var shallowCompare = __webpack_require__(316);
	
	/**
	 * If your React component's render function is "pure", e.g. it will render the
	 * same result given the same props and state, provide this Mixin for a
	 * considerable performance boost.
	 *
	 * Most React components have pure render functions.
	 *
	 * Example:
	 *
	 *   var ReactComponentWithPureRenderMixin =
	 *     require('ReactComponentWithPureRenderMixin');
	 *   React.createClass({
	 *     mixins: [ReactComponentWithPureRenderMixin],
	 *
	 *     render: function() {
	 *       return <div className={this.props.className}>foo</div>;
	 *     }
	 *   });
	 *
	 * Note: This only checks shallow equality for props and state. If these contain
	 * complex data structures this mixin may have false-negatives for deeper
	 * differences. Only mixin to components which have simple props and state, or
	 * use `forceUpdate()` when you know deep data structures have changed.
	 */
	var ReactComponentWithPureRenderMixin = {
	  shouldComponentUpdate: function (nextProps, nextState) {
	    return shallowCompare(this, nextProps, nextState);
	  }
	};
	
	module.exports = ReactComponentWithPureRenderMixin;

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule shallowCompare
	*/
	
	'use strict';
	
	var shallowEqual = __webpack_require__(317);
	
	/**
	 * Does a shallow comparison for props and state.
	 * See ReactComponentWithPureRenderMixin
	 */
	function shallowCompare(instance, nextProps, nextState) {
	  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
	}
	
	module.exports = shallowCompare;

/***/ },
/* 317 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _presenceIcon = __webpack_require__(311);
	
	var _presenceIcon2 = _interopRequireDefault(_presenceIcon);
	
	var _app_header_strings = __webpack_require__(319);
	
	var _app_header_strings2 = _interopRequireDefault(_app_header_strings);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _app_header_actions = __webpack_require__(276);
	
	var _app_header_actions2 = _interopRequireDefault(_app_header_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _aui_section = __webpack_require__(320);
	
	var _aui_section2 = _interopRequireDefault(_aui_section);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "UserStatusMenu",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    web_server: React.PropTypes.string,
	    is_guest: React.PropTypes.bool,
	    multi_org_supported: React.PropTypes.bool,
	    presence_show: React.PropTypes.string,
	    presence_status: React.PropTypes.string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      active: true
	    };
	  },
	
	  _onSignOut: function _onSignOut() {
	    _app_actions2.default.signout();
	  },
	  _onSettingsClick: function _onSettingsClick() {
	    _app_header_actions2.default.requestPreferencesDialog();
	  },
	  _onLogInToAnotherTeam: function _onLogInToAnotherTeam() {
	    _app_actions2.default.logInToAnotherTeam();
	  },
	  _onPresenceUpdate: function _onPresenceUpdate(e) {
	    var show = e.currentTarget.getAttribute('data-show');
	    _current_user_actions2.default.changeStatus({
	      status: this.props.presence_status,
	      show: show,
	      type: 'show'
	    });
	    _inline_dialog_actions2.default.showUserStatusMessage({
	      anchor: document.getElementById('status_dropdown'),
	      status: this.props.presence_status,
	      show: show
	    });
	  },
	
	
	  _shouldAllowLogIntoAnotherTeam: function _shouldAllowLogIntoAnotherTeam() {
	    return !this.props.is_guest && this.props.multi_org_supported;
	  },
	
	  _getSettings: function _getSettings() {
	    return React.createElement(
	      'li',
	      { className: 'settings', role: 'listitem' },
	      React.createElement(
	        'a',
	        { id: 'hc-settings', onClick: this._onSettingsClick },
	        React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-configure' }),
	        ' ',
	        _app_header_strings2.default.settings
	      )
	    );
	  },
	
	  _getLogIntoAnotherTeam: function _getLogIntoAnotherTeam() {
	    return React.createElement(
	      _aui_section2.default,
	      { className: 'hc-actions' },
	      React.createElement(
	        'ul',
	        { role: 'list' },
	        React.createElement(
	          'li',
	          { className: 'login-to-another-team', role: 'listitem' },
	          React.createElement(
	            'a',
	            { id: 'hc-login-team', onClick: this._onLogInToAnotherTeam },
	            React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-list-add' }),
	            ' ',
	            _app_header_strings2.default.log_in_to_another_team
	          )
	        )
	      )
	    );
	  },
	
	  _getProfileSection: function _getProfileSection() {
	    return React.createElement(
	      _aui_section2.default,
	      null,
	      React.createElement(
	        'ul',
	        { role: 'list' },
	        React.createElement(
	          'li',
	          { role: 'listitem' },
	          React.createElement(
	            'a',
	            { onClick: this._onUserProfileClick, className: 'hc-user-name', href: 'https://' + this.props.web_server + '/account', target: '_blank' },
	            _app_header_strings2.default.profile
	          )
	        )
	      )
	    );
	  },
	
	  _onUserProfileClick: function _onUserProfileClick() {
	    _analytics_actions2.default.editProfileClicked();
	  },
	
	
	  render: function render() {
	    var settings = this.props.is_guest ? false : this._getSettings();
	    var userProfileSection = this.props.is_guest ? null : this._getProfileSection();
	    var loginToAnotherTeam = this._shouldAllowLogIntoAnotherTeam() ? this._getLogIntoAnotherTeam() : false;
	
	    return React.createElement(
	      'div',
	      { role: 'application' },
	      userProfileSection,
	      React.createElement(
	        _aui_section2.default,
	        { className: 'hc-availability' },
	        React.createElement(
	          'ul',
	          { role: 'list' },
	          React.createElement(
	            'li',
	            { className: 'chat aui-inline-dialog-trigger', role: 'listitem' },
	            React.createElement(
	              'a',
	              { id: 'hc-avail', 'data-show': _presence2.default.AVAILABLE, onClick: this._onPresenceUpdate },
	              React.createElement(_presenceIcon2.default, {
	                presence: _presence2.default.AVAILABLE,
	                active: this.props.active }),
	              _app_header_strings2.default.available
	            )
	          ),
	          React.createElement(
	            'li',
	            { className: 'xa aui-inline-dialog-trigger', role: 'listitem' },
	            React.createElement(
	              'a',
	              { id: 'hc-xa', 'data-show': _presence2.default.AWAY, onClick: this._onPresenceUpdate },
	              React.createElement(_presenceIcon2.default, {
	                presence: _presence2.default.AWAY,
	                active: this.props.active }),
	              _app_header_strings2.default.away
	            )
	          ),
	          React.createElement(
	            'li',
	            { className: 'dnd aui-inline-dialog-trigger', role: 'listitem' },
	            React.createElement(
	              'a',
	              { id: 'hc-dnd', 'data-show': _presence2.default.DND, onClick: this._onPresenceUpdate },
	              React.createElement(_presenceIcon2.default, {
	                presence: _presence2.default.DND,
	                active: this.props.active }),
	              _app_header_strings2.default.dnd
	            )
	          )
	        )
	      ),
	      React.createElement(
	        _aui_section2.default,
	        { className: 'hc-actions' },
	        React.createElement(
	          'ul',
	          { role: 'list' },
	          settings,
	          React.createElement(
	            'li',
	            { className: 'signout', role: 'listitem' },
	            React.createElement(
	              'a',
	              { id: 'hc-signout', onClick: this._onSignOut },
	              React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-devtools-checkout' }),
	              ' ',
	              _app_header_strings2.default.log_out
	            )
	          )
	        )
	      ),
	      loginToAnotherTeam
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 319 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  provide_feedback: "Provide feedback",
	  profile: "Profile",
	  help: "Help & Support",
	  get_started: "Get started",
	  keyboard_shortcuts: "Keyboard shortcuts",
	  whats_new: "What's new",
	  emoticon_list: "Emoticon list",
	  status: "Status",
	  available: "Available",
	  away: "Away",
	  dnd: "Do not disturb",
	  settings: "Settings",
	  log_out: "Log out",
	  log_in_to_another_team: "Log in to another team",
	  new_chat_btn_title: "New chat",
	  invite_your_team_btn_title: "Invite your team"
	};
	module.exports = exports['default'];

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	  displayName: 'aui_section',
	
	
	  propTypes: {
	    heading: React.PropTypes.string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      heading: ''
	    };
	  },
	  _getHeading: function _getHeading() {
	    if (!this.props.heading) {
	      return undefined;
	    }
	    return React.createElement(
	      'strong',
	      { 'aria-role': 'presentation', 'class': 'aui-dropdown2-heading' },
	      this.props.heading
	    );
	  },
	  render: function render() {
	    var _cx;
	
	    var attrs = {
	      'role': 'presentation',
	      'className': (0, _classnames2.default)((_cx = {}, (0, _defineProperty3.default)(_cx, this.props.className, !!this.props.className), (0, _defineProperty3.default)(_cx, 'aui-dropdown2-section', true), _cx))
	    };
	
	    var heading = this._getHeading;
	
	    return React.createElement(
	      'div',
	      attrs,
	      heading,
	      React.createElement(
	        'div',
	        { role: 'group' },
	        this.props.children
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _connection_offline_status = __webpack_require__(322);
	
	var _connection_offline_status2 = _interopRequireDefault(_connection_offline_status);
	
	var _connection_cannot_connect_status = __webpack_require__(324);
	
	var _connection_cannot_connect_status2 = _interopRequireDefault(_connection_cannot_connect_status);
	
	var _connection_countdown_status = __webpack_require__(325);
	
	var _connection_countdown_status2 = _interopRequireDefault(_connection_countdown_status);
	
	var _connection_status_store = __webpack_require__(326);
	
	var _connection_status_store2 = _interopRequireDefault(_connection_status_store);
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _connection_notification_strings = __webpack_require__(323);
	
	var _connection_notification_strings2 = _interopRequireDefault(_connection_notification_strings);
	
	var _connection = __webpack_require__(327);
	
	var _connection2 = _interopRequireDefault(_connection);
	
	var _network = __webpack_require__(328);
	
	var _network2 = _interopRequireDefault(_network);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ConnectionStatus",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  componentDidMount: function componentDidMount() {
	    _connection_status_store2.default.on('change', this._onChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _connection_status_store2.default.off('change', this._onChange);
	  },
	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    /*
	     * Connection inline dialog should be hidden
	     * if the status changes.
	     */
	    if (this.state.status !== nextState.status || this.state.network_status !== nextState.network_status) {
	      _inline_dialog_actions2.default.hideInlineDialog();
	    }
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    /*
	     * Should only re-render if:
	     * - the status changes (ex: connected -> reconnecting)
	     * - the network status changes (ex: online -> offline)
	     * - the countdown banner is showing (allows time changes to render)
	     * - secondsToRetry is counting down from 1 to 0
	     *
	     * This logic prevents the connecting spinner from jumping due
	     * to re-renders.
	     */
	
	    return this.state.status !== nextState.status || this.state.network_status !== nextState.network_status || this.state.status === _connection2.default.RECONNECT_DELAY || this.state.secondsToRetry === 1 && nextState.secondsToRetry === 0;
	  },
	  render: function render() {
	    if (this.state.network_status === _network2.default.OFFLINE) {
	      _analytics_actions2.default.connectionUIStateOffline();
	      return React.createElement(_connection_offline_status2.default, { status: this.state.network_status });
	    }
	
	    switch (this.state.status) {
	      case _connection2.default.RECONNECTING:
	        _analytics_actions2.default.connectionUIStateConnecting();
	        return this._getReconnectingBanner();
	
	      case _connection2.default.RECONNECT_DELAY:
	        _analytics_actions2.default.connectionUIStateConnectDelay();
	        return this._getDelayBanner();
	
	      case _connection2.default.DISCONNECTED:
	        _analytics_actions2.default.connectionUIStateCannotConnect();
	        return React.createElement(_connection_cannot_connect_status2.default, { status: this.state.status });
	
	      default:
	        return React.createElement('span', null);
	    }
	  },
	  _getReconnectingBanner: function _getReconnectingBanner() {
	    var banner = React.createElement('span', null);
	    banner = React.createElement(
	      'div',
	      { className: 'hc-header-connection reconnecting' },
	      React.createElement(
	        'span',
	        { className: 'connection-status-icon' },
	        React.createElement(_spinner2.default, { spin: true, spinner_class: 'connection-spinner', size: 'small', color: 'white', left: '-16px', top: '-8px' })
	      ),
	      React.createElement(
	        'span',
	        { className: 'connection-status' },
	        _connection_notification_strings2.default.connecting
	      )
	    );
	    return banner;
	  },
	  _getDelayBanner: function _getDelayBanner() {
	    var banner = React.createElement('span', null);
	    banner = React.createElement(_connection_countdown_status2.default, { seconds: this.state.secondsToRetry, status: this.state.status });
	    return banner;
	  },
	  _getState: function _getState() {
	    var connectionState = _connection_status_store2.default.getAll(),
	        msToRetry = connectionState.reconnectingIn,
	        secondsToRetry = Math.round(msToRetry / 1000);
	
	    /*
	     * The page fires the unloading event, THEN strophe fires a disconnected event -- but we
	     * don't want the red "disconnected" banner to show after you hit the refresh button, so
	     * unsubscribe from the ConnectionStatusStore when we get the UNLOADING status
	     */
	    if (connectionState.connection_status === _connection2.default.UNLOADING) {
	      _connection_status_store2.default.off('change', this._onChange);
	    }
	
	    return {
	      status: connectionState.connection_status,
	      network_status: connectionState.network_status,
	      msToRetry: msToRetry,
	      secondsToRetry: secondsToRetry
	    };
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _connection_notification_strings = __webpack_require__(323);
	
	var _connection_notification_strings2 = _interopRequireDefault(_connection_notification_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ConnectionOfflineStatus",
	
	  _showInlineDialog: function _showInlineDialog() {
	    _inline_dialog_actions2.default.showConnectionStatusMessage({
	      anchor: this.refs.banner,
	      status: this.props.status
	    });
	  },
	  _hideInlineDialog: function _hideInlineDialog() {
	    _inline_dialog_actions2.default.hideInlineDialog();
	  },
	  render: function render() {
	    return React.createElement(
	      'div',
	      { ref: 'banner', className: 'hc-header-connection disconnected aui-inline-dialog-trigger', onMouseEnter: this._showInlineDialog, onClick: this._hideInlineDialog },
	      React.createElement(
	        'span',
	        { className: 'connection-status-icon' },
	        React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-warning' })
	      ),
	      React.createElement(
	        'span',
	        { className: 'connection-status' },
	        _connection_notification_strings2.default.offline
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 323 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  connecting: 'Connecting...',
	  connecting_seconds: function connecting_seconds(sec) {
	    return 'Connecting in ' + sec + ' second' + (sec !== 1 ? 's' : '');
	  },
	  check_network: 'We\'re having trouble connecting to HipChat. We\'ll try again in a few seconds.',
	  retry_cta: 'Retry now',
	  unable_to_connect_hipchat: function unable_to_connect_hipchat(status_url) {
	    return 'We couldn\'t connect to HipChat. Check your network connection or check our <a href="' + status_url + '" target="_blank">status</a>.';
	  },
	  cant_connect: 'Couldn\'t connect',
	  disconnecting: 'Disconnecting',
	  offline: 'Offline',
	  offline_status: 'It looks like youre not connected to the internet. Check your network connection.'
	};
	module.exports = exports['default'];

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _connection_notification_strings = __webpack_require__(323);
	
	var _connection_notification_strings2 = _interopRequireDefault(_connection_notification_strings);
	
	var _connection_actions = __webpack_require__(215);
	
	var _connection_actions2 = _interopRequireDefault(_connection_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ConnectionCannotConnectStatus",
	
	  _handleMouseEnter: function _handleMouseEnter() {
	    _inline_dialog_actions2.default.showConnectionStatusMessage({
	      anchor: this.refs.banner,
	      status: this.props.status
	    });
	  },
	  _handleCantConnectLinkClick: function _handleCantConnectLinkClick() {
	    _connection_actions2.default.reconnect();
	    _inline_dialog_actions2.default.hideInlineDialog();
	    _analytics_actions2.default.tryToReconnectFromHeader();
	  },
	  _hideInlineDialog: function _hideInlineDialog() {
	    _inline_dialog_actions2.default.hideInlineDialog();
	  },
	  render: function render() {
	    return React.createElement(
	      'div',
	      { ref: 'banner', className: 'hc-header-connection disconnected aui-inline-dialog-trigger', onMouseEnter: this._handleMouseEnter, onClick: this._hideInlineDialog },
	      React.createElement(
	        'span',
	        { className: 'connection-status-icon' },
	        React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-warning' })
	      ),
	      React.createElement(
	        'span',
	        { className: 'connection-status' },
	        _connection_notification_strings2.default.cant_connect
	      ),
	      React.createElement(
	        'a',
	        { className: 'reconnect-now', onClick: this._handleCantConnectLinkClick },
	        _connection_notification_strings2.default.retry_cta
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _connection_notification_strings = __webpack_require__(323);
	
	var _connection_notification_strings2 = _interopRequireDefault(_connection_notification_strings);
	
	var _connection_actions = __webpack_require__(215);
	
	var _connection_actions2 = _interopRequireDefault(_connection_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ConnectionCountdownStatus",
	
	  propTypes: {
	    seconds: React.PropTypes.number,
	    minutes: React.PropTypes.number
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      seconds: 0,
	      minutes: 0
	    };
	  },
	  _handleMouseEnter: function _handleMouseEnter() {
	    _inline_dialog_actions2.default.showConnectionStatusMessage({
	      anchor: this.refs.banner,
	      status: this.props.status
	    });
	  },
	  _handleReconnectClick: function _handleReconnectClick() {
	    _connection_actions2.default.handleReconnectLinkClick();
	    _inline_dialog_actions2.default.hideInlineDialog();
	    _analytics_actions2.default.tryToReconnectFromHeader();
	  },
	  _hideInlineDialog: function _hideInlineDialog() {
	    _inline_dialog_actions2.default.hideInlineDialog();
	  },
	
	
	  /* Get correct countdown message
	   * - seconds singular or plural
	   */
	  _getCountdownMessage: function _getCountdownMessage() {
	    return _connection_notification_strings2.default.connecting_seconds(this.props.seconds);
	  },
	  render: function render() {
	    var message = this._getCountdownMessage();
	    return React.createElement(
	      'div',
	      { ref: 'banner', className: 'hc-header-connection countdown aui-inline-dialog-trigger', onMouseEnter: this._handleMouseEnter, onClick: this._hideInlineDialog },
	      message,
	      React.createElement(
	        'a',
	        { className: 'reconnect-now', onClick: this._handleReconnectClick },
	        _connection_notification_strings2.default.retry_cta
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _timer = __webpack_require__(209);
	
	var _timer2 = _interopRequireDefault(_timer);
	
	var _connection = __webpack_require__(327);
	
	var _connection2 = _interopRequireDefault(_connection);
	
	var _network = __webpack_require__(328);
	
	var _network2 = _interopRequireDefault(_network);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ConnectionStatusStore = function (_Store) {
	  (0, _inherits3.default)(ConnectionStatusStore, _Store);
	
	  function ConnectionStatusStore() {
	    (0, _classCallCheck3.default)(this, ConnectionStatusStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ConnectionStatusStore).call(this));
	
	    _this._countdownTimer = new _timer2.default(function () {
	      return _this._countdownTimerFn();
	    }, 1000, 1000, true);
	    _this._offlineBannerTimer = new _timer2.default(function () {
	      return _this._offlineBannerTimerFn();
	    }, 5000);
	    return _this;
	  }
	
	  (0, _createClass3.default)(ConnectionStatusStore, [{
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'network-up': function networkUp() {
	          _this2._offlineBannerTimer.clear();
	          _this2.set({ 'network_status': _network2.default.ONLINE });
	        },
	        'network-down': function networkDown() {
	          _this2._offlineBannerTimer.start();
	        },
	        'strophe-connected': function stropheConnected() {
	          _this2._setConnectionState(_connection2.default.CONNECTED);
	        },
	        'strophe-reconnected': function stropheReconnected() {
	          _this2._setConnectionState(_connection2.default.CONNECTED);
	        },
	        'strophe-reconnecting': function stropheReconnecting(data) {
	          _this2._setConnectionState(_connection2.default.RECONNECTING, data);
	        },
	        'strophe-reconnect-delay': function stropheReconnectDelay(data) {
	          _this2._setConnectionState(_connection2.default.RECONNECT_DELAY, data);
	          _this2._countdownTimer.clear().start();
	        },
	        'strophe-connection-failed': function stropheConnectionFailed() {
	          _this2._setConnectionState(_connection2.default.DISCONNECTED);
	        },
	        'unload-app': function unloadApp() {
	          _this2._setConnectionState(_connection2.default.UNLOADING);
	        },
	        'exit-app': function exitApp() {
	          _this2._setConnectionState(_connection2.default.UNLOADING);
	        }
	      });
	    }
	  }, {
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        connection_status: _connection2.default.CONNECTED,
	        network_status: _network2.default.ONLINE,
	        reconnectingIn: 0,
	        reconnectionAttempts: 0
	      };
	    }
	  }, {
	    key: '_setConnectionState',
	    value: function _setConnectionState(status, data) {
	      this.set({
	        connection_status: status,
	        reconnectionAttempts: _.get(data, 'reconnectAttempts') || this.data.reconnectionAttempts,
	        reconnectingIn: _.get(data, 'reconnectDelay') || this.data.reconnectingIn
	      });
	    }
	  }, {
	    key: '_countdownTimerFn',
	    value: function _countdownTimerFn() {
	      var current = this.data.reconnectingIn,
	          next = current > 1000 ? current - 1000 : 0;
	      this.set('reconnectingIn', next);
	      if (next === 0) {
	        this._countdownTimer.clear();
	      }
	    }
	  }, {
	    key: '_offlineBannerTimerFn',
	    value: function _offlineBannerTimerFn() {
	      this.set({ 'network_status': _network2.default.OFFLINE });
	    }
	  }]);
	  return ConnectionStatusStore;
	}(_store2.default);
	
	exports.default = new ConnectionStatusStore();
	module.exports = exports['default'];

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _freeze2.default)({
	  CONNECTED: 'connected',
	  DISCONNECTED: 'disconnected',
	  RECONNECTING: 'reconnecting',
	  RECONNECT_DELAY: 'reconnect-delay',
	  UNLOADING: 'unloading'
	});
	module.exports = exports['default'];

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _freeze2.default)({
	  ONLINE: 'online',
	  OFFLINE: 'offline'
	});
	module.exports = exports['default'];

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'Spinner',
	
	  propTypes: {
	    size: React.PropTypes.oneOf(['small', 'medium', 'large']).isRequired,
	    delay: React.PropTypes.number
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    this._stopSpinner();
	  },
	  componentWillUpdate: function componentWillUpdate() {
	    this._stopSpinner();
	  },
	  getDefaultProps: function getDefaultProps() {
	    return {
	      size: 'medium',
	      zIndex: 100,
	      ref: 'spinner',
	      delay: 0
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    this._setSpinner();
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    this._setSpinner();
	  },
	  _getSpinner: function _getSpinner() {
	    return ReactDOM.findDOMNode(this);
	  },
	  _setSpinner: function _setSpinner() {
	    var options;
	
	    if (this.props.spin) {
	      options = this._getOptions();
	      this._startSpinner(this.props.size, options);
	    } else {
	      this._stopSpinner();
	    }
	  },
	  _getColor: function _getColor() {
	    var theme = _preferences_store2.default.getTheme();
	    return _app_config2.default.spinner_colors[theme];
	  },
	  _getOptions: function _getOptions() {
	    var options = _.clone(this.props);
	
	    if (!options.color) {
	      options.color = this._getColor();
	    }
	
	    return options;
	  },
	  _startSpinner: function _startSpinner(optsOrPreset, opts) {
	    var spinner = AJS.$(this._getSpinner());
	    if (this.props.delay > 0) {
	      this.timer = setTimeout(function () {
	        spinner.spin(optsOrPreset, opts);
	      }, this.props.delay);
	    } else {
	      spinner.spin(optsOrPreset, opts);
	    }
	  },
	  _stopSpinner: function _stopSpinner() {
	    if (this.timer) {
	      this.timer = clearTimeout(this.timer);
	    }
	    AJS.$(this._getSpinner()).spinStop();
	  },
	  render: function render() {
	    return React.createElement('div', { className: 'hc-spinner ' + (this.props.spinner_class ? this.props.spinner_class : ''), ref: this.props.ref });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_header_strings = __webpack_require__(319);
	
	var _app_header_strings2 = _interopRequireDefault(_app_header_strings);
	
	var _app_header_actions = __webpack_require__(276);
	
	var _app_header_actions2 = _interopRequireDefault(_app_header_actions);
	
	var _keyboard_shortcuts = __webpack_require__(279);
	
	var _keyboard_shortcuts2 = _interopRequireDefault(_keyboard_shortcuts);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "HelpMenuContent",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  componentDidMount: function componentDidMount() {
	    _configuration_store2.default.on(["change:web_server", "change:feature_flags"], this._onChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _configuration_store2.default.off(["change:web_server", "change:feature_flags"], this._onChange);
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _getState: function _getState() {
	    var client_subtype = _configuration_store2.default.get("client_subtype");
	    return {
	      web_server: _configuration_store2.default.get("web_server"),
	      isWindows: _utils2.default.clientSubType.isWindows(client_subtype),
	      isMac: _utils2.default.clientSubType.isMac(client_subtype),
	      isNative: _utils2.default.clientSubType.isNative(client_subtype),
	      isBTF: _.get(_configuration_store2.default.get('feature_flags'), 'btf', false)
	    };
	  },
	  _onKeyboardShortcutsClick: function _onKeyboardShortcutsClick() {
	    var commands = _keyboard_shortcuts2.default.getKeyCommands();
	    _dialog_actions2.default.showKeyboardShortcutsDialog(commands);
	  },
	  _onWhatsNewClick: function _onWhatsNewClick() {
	    _app_header_actions2.default.requestReleaseNotesDialog();
	  },
	  _getOnlineHelp: function _getOnlineHelp() {
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { className: "hc-online-help", href: _app_config2.default.help_link_url, target: "_blank" },
	        _app_header_strings2.default.help
	      )
	    );
	  },
	  _getGetStartedLink: function _getGetStartedLink() {
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { className: "hc-get-started", href: _app_config2.default.get_started_url, target: "_blank" },
	        _app_header_strings2.default.get_started
	      )
	    );
	  },
	  _getKeyboardShortcutsLink: function _getKeyboardShortcutsLink() {
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { className: "hc-keyboard-shortcuts", onClick: this._onKeyboardShortcutsClick },
	        _app_header_strings2.default.keyboard_shortcuts
	      )
	    );
	  },
	  _getEmoticonListLink: function _getEmoticonListLink() {
	    var link = "https://" + this.state.web_server + "/emoticons";
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { className: "hc-emoticon-list-link", href: link, target: "_blank" },
	        _app_header_strings2.default.emoticon_list
	      )
	    );
	  },
	  _getWhatsNewLink: function _getWhatsNewLink() {
	    if (this.state.isNative || this.state.isBTF) {
	      return null;
	    }
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { id: "whats-new", onClick: this._onWhatsNewClick },
	        _app_header_strings2.default.whats_new
	      )
	    );
	  },
	  _getStatusLink: function _getStatusLink() {
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { className: "hc-status-page-link", href: _app_config2.default.status_page_url, target: "_blank" },
	        _app_header_strings2.default.status
	      )
	    );
	  },
	  _getFeedbackLink: function _getFeedbackLink() {
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { id: "give-feedback", href: _app_config2.default.feedback_issue_url, target: "_blank" },
	        _app_header_strings2.default.provide_feedback
	      )
	    );
	  },
	  render: function render() {
	    var onlineHelpLink = this._getOnlineHelp(),
	        getStartedLink = this.props.read_only_mode ? false : this._getGetStartedLink(),
	        keyboardShortcutsLink = this._getKeyboardShortcutsLink(),
	        statusLink = this.state.isBTF ? false : this._getStatusLink(),
	        emoticonLink = this.props.read_only_mode ? false : this._getEmoticonListLink(),
	        showWhatsNewLink = !this.state.isBTF && !this.state.isNative && !this.props.read_only_mode,
	        whatsNewLink = showWhatsNewLink ? this._getWhatsNewLink() : false,
	        feedbackLink = this.props.read_only_mode ? false : this._getFeedbackLink();
	
	    return React.createElement(
	      "div",
	      { className: "aui-dropdown2-section" },
	      React.createElement(
	        "ul",
	        null,
	        onlineHelpLink,
	        getStartedLink,
	        keyboardShortcutsLink,
	        emoticonLink,
	        whatsNewLink,
	        statusLink,
	        feedbackLink
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_header_actions = __webpack_require__(276);
	
	var _app_header_actions2 = _interopRequireDefault(_app_header_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "SearchInput",
	
	  componentDidMount: function componentDidMount() {
	    this._shouldFocus();
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    this._shouldFocus();
	  },
	  _shouldFocus: function _shouldFocus() {
	    var input = ReactDOM.findDOMNode(this.refs.searchInput);
	    if (this.props.focus_search && input) {
	      this._focusAndSelect(input);
	    }
	  },
	  _focusAndSelect: function _focusAndSelect(input) {
	    if (input !== document.activeElement) {
	      input.focus();
	      input.select();
	    }
	  },
	  render: function render() {
	    var inputClasses = (0, _classnames2.default)({
	      'mousetrap': true
	    });
	
	    return React.createElement(
	      'div',
	      { className: 'aui-quicksearch' },
	      React.createElement('input', { id: 'search-query',
	        tabIndex: '-1',
	        type: 'text',
	        className: inputClasses,
	        placeholder: 'Search history',
	        name: 'name',
	        autoComplete: 'off',
	        'data-tipsify-ignore': true,
	        'aria-label': 'Search for something',
	        ref: 'searchInput',
	        onKeyDown: this._onKeyDown,
	        onChange: this._onChange,
	        onBlur: this._onBlur,
	        onFocus: this._onFocus,
	        value: this.props.text })
	    );
	  },
	  _onKeyDown: function _onKeyDown(evt) {
	    if (evt.keyCode === _utils2.default.keyCode.Enter) {
	      if (this.props.search_enabled) {
	        _app_header_actions2.default.searchHistory(this.props.jid, this.props.text);
	      } else {
	        _app_header_actions2.default.searchHistoryExternally(this.props.jid, this.props.text);
	      }
	      _analytics_actions2.default.searchInputSubmitted(this.props.jid);
	    } else if (evt.keyCode === _utils2.default.keyCode.Esc) {
	      _app_header_actions2.default.setSearchText({
	        text: ""
	      });
	      if (this.props.jid !== 'search') {
	        this._focusOnMessageInput();
	      }
	    }
	  },
	  _focusOnMessageInput: function _focusOnMessageInput() {
	    document.getElementById('' + _app_config2.default.chat_input_id).focus();
	  },
	  _onChange: function _onChange(evt) {
	    _app_header_actions2.default.setSearchText({
	      text: evt.target.value
	    });
	  },
	  _onBlur: function _onBlur() {
	    _app_header_actions2.default.searchBlurred();
	  },
	  _onFocus: function _onFocus() {
	    _analytics_actions2.default.searchInputClicked();
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Create an AUI Dropdown2 trigger. The standard use case as defined in the
	 * AUI docs (https://docs.atlassian.com/aui/latest/docs/dropdown2.html) is for
	 * the trigger to be a button. This component does not make that distinction,
	 * so if you want the trigger to be a button, you simply need to add the button
	 * css classes:
	 *
	 * <AUIDropdown2Trigger className="aui-button aui-button-primary" dropdownID="123">
	 *   Trigger text
	 * </AUIDropdownTrigger>
	 */
	exports.default = React.createClass({
	
	  displayName: 'AUIDropdown2Trigger',
	
	  propTypes: {
	    type: React.PropTypes.oneOf(['a', 'link', 'button']),
	    dropdownID: React.PropTypes.string.isRequired,
	    arrowless: React.PropTypes.bool,
	    disabled: React.PropTypes.bool,
	    alignmentContainer: React.PropTypes.string, // optional selector
	    hideLocation: React.PropTypes.string // optional selector
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      type: 'button',
	      arrowless: false,
	      disabled: false
	    };
	  },
	  render: function render() {
	    var _cx;
	
	    var attrs = {
	      'id': this.props.id || _.uniqueId(),
	      'href': '#' + this.props.dropdownID,
	      'aria-owns': this.props.dropdownID,
	      'title': this.props.title || '',
	      'aria-label': this.props['aria-label'] || this.props.title || '',
	      'aria-controls': this.props.dropdownID,
	      'aria-disabled': this.props.disabled,
	      'aria-haspopup': true,
	      'className': (0, _classnames2.default)((_cx = {}, (0, _defineProperty3.default)(_cx, this.props.className, !!this.props.className), (0, _defineProperty3.default)(_cx, 'aui-dropdown2-trigger', true), (0, _defineProperty3.default)(_cx, 'aui-dropdown2-trigger-arrowless', this.props.arrowless), _cx))
	    };
	
	    if (this.props.alignmentContainer) {
	      attrs['data-container'] = this.props.alignmentContainer; // AUI 5.7
	      attrs['data-aui-alignment-container'] = this.props.alignmentContainer; // AUI 5.8
	    }
	
	    if (this.props.hideLocation) {
	      attrs['data-dropdown2-hide-location'] = this.props.hideLocation;
	    }
	
	    switch (this.props.type) {
	      case 'a':
	      case 'link':
	        return React.createElement(
	          'a',
	          attrs,
	          this.props.children
	        );
	
	      case 'button':
	      default:
	        return React.createElement(
	          'button',
	          attrs,
	          this.props.children
	        );
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * https://docs.atlassian.com/aui/latest/docs/dropdown2.html
	 * Usage:
	 *
	 * <AUIDropdown2Trigger dropdownID="123">Trigger</AUIDropdown2Trigger>
	 *
	 * <AUIDropdown2 dropdownID="123">
	 *   // dropdown html contents or a react component that renders it
	 * <AUIDropdown2>
	 *
	 * Notes:
	 *  - dropdownID is required for both the dropdown and trigger elements and must match
	 */
	exports.default = React.createClass({
	
	  displayName: 'AUIDropdown2',
	
	  propTypes: {
	    dropdownID: React.PropTypes.string.isRequired,
	    onShow: React.PropTypes.func,
	    onHide: React.PropTypes.func
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onShow: _.noop,
	      onHide: _.noop
	    };
	  },
	
	
	  /*
	   * When the dropdown is shown, AUI will move the container element
	   * to the body and fire a "show" event. We'll wait for that event
	   * and then React.render this component's children to the container
	   *
	   * When the dropdown is closed, we'll unmount this component's
	   * children from the container element
	   */
	  componentDidMount: function componentDidMount() {
	    AJS.$(this._getDropdownElement()).on({
	      'aui-dropdown2-show': this.renderDropdownContents,
	      'aui-dropdown2-hide': this.removeDropdownContents
	    });
	  },
	
	
	  /*
	   * Remove AUI DOM event listeners
	   */
	  componentWillUnmount: function componentWillUnmount() {
	    this.removeDropdownContents();
	    AJS.$(this._getDropdownElement()).off();
	  },
	
	
	  /*
	   * AUI's gonna take over and move this element all around the DOM
	   * mutating it all the way so don't let React try to update it
	   */
	  shouldComponentUpdate: function shouldComponentUpdate() {
	    return false;
	  },
	
	
	  /*
	   * For our initial render, we want to take the dropdown html
	   * and render it statically within this component. We don't want
	   * React to try to manage the HTML at all, but we *DO* want to have
	   * it in there so AUI can properly measure the size of the contents
	   * and place it properly when the dropdown becomes visible
	   */
	  render: function render() {
	    var _cx;
	
	    var attrs = {
	      'id': this.props.dropdownID,
	      'aria-hidden': 'true',
	      'role': 'menu',
	      'className': (0, _classnames2.default)((_cx = {}, (0, _defineProperty3.default)(_cx, this.props.className, !!this.props.className), (0, _defineProperty3.default)(_cx, 'aui-dropdown2', true), (0, _defineProperty3.default)(_cx, 'aui-style-default', true), _cx)),
	      'dangerouslySetInnerHTML': {
	        __html: this._getStaticDropdownDOM()
	      }
	    };
	
	    return React.createElement('div', attrs);
	  },
	  invokeTrigger: function invokeTrigger() {
	    AJS.$('[aria-owns="' + this.props.dropdownID + '"]').trigger('aui-button-invoke');
	  },
	
	
	  /*
	   * When the dropdown is shown & once AUI has moved it across
	   * the DOM, we'll blow away the static contents, and overwrite
	   * it with a new React-managed component
	   */
	  renderDropdownContents: function renderDropdownContents() {
	    ReactDOM.render(this.props.children, this._getDropdownElement());
	    AJS.$(window).one('resize', this.invokeTrigger);
	    this.props.onShow();
	  },
	
	
	  /*
	   * When the dropdown is hidden & once AUI has moved it again,
	   * we'll unmount the React component, and replace the inner
	   * contents with the static DOM children we had originally.
	   * This way AUI has the contents again to measure with for
	   * the next time the dropdown opens
	   */
	  removeDropdownContents: function removeDropdownContents() {
	    AJS.$(window).off('resize', this.invokeTrigger);
	    ReactDOM.unmountComponentAtNode(this._getDropdownElement());
	    AJS.$(this._getDropdownElement()).empty().html(this._getStaticDropdownDOM());
	    this.props.onHide();
	  },
	
	
	  /*
	   * Find the element on the page. It can be anywhere in the DOM after AUI moves it
	   */
	  _getDropdownElement: function _getDropdownElement() {
	    return document.getElementById(this.props.dropdownID);
	  },
	
	
	  /*
	   * Render the child components in this dropdown as raw HTML
	   */
	  _getStaticDropdownDOM: function _getStaticDropdownDOM() {
	    return ReactDOMServer.renderToStaticMarkup(this.props.children);
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.STORAGE_KEY = undefined;
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _alert_flag_model = __webpack_require__(335);
	
	var _alert_flag_model2 = _interopRequireDefault(_alert_flag_model);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var STORAGE_KEY = exports.STORAGE_KEY = 'hc.read-only-dismissed';
	
	var ReadOnlyStore = function (_Store) {
	  (0, _inherits3.default)(ReadOnlyStore, _Store);
	
	  function ReadOnlyStore() {
	    (0, _classCallCheck3.default)(this, ReadOnlyStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ReadOnlyStore).call(this));
	
	    _this.local = {};
	    return _this;
	  }
	
	  (0, _createClass3.default)(ReadOnlyStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        read_only_mode: false,
	        read_only_input_markdown: '',
	        feature_flag_enabled: false,
	        alert_flag: {},
	        is_fetching: false,
	        is_fetched: false,
	        is_visible: false,
	        is_dismissed: this.getStorage(),
	        is_flag_pending: false,
	        title: '',
	        text: '',
	        icon_url: '',
	        button_text: '',
	        button_url: '',
	        continue_text: '',
	        continue_button: 'Continue',
	        questions_markdown: '',
	        contact_markdown: ''
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(config) {
	          _this2.handleConfig(config);
	        }
	      });
	
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(config) {
	          _this2.handleConfig(config);
	        },
	        'dismiss-alert-flag': function dismissAlertFlag() {
	          _this2.handleDismissAlertFlag();
	        },
	        'dismiss-read-only-modal': function dismissReadOnlyModal() {
	          _this2.handleDismissModal();
	        },
	        'API:fetch-read-only-content-success': function APIFetchReadOnlyContentSuccess(data) {
	          _this2.handleReadOnlyContentSuccess(data);
	        },
	        'API:fetch-read-only-content-failure': function APIFetchReadOnlyContentFailure(error) {
	          _this2.handleReadOnlyContentFailure(error);
	        },
	        'API:fetch-alert-flag-success': function APIFetchAlertFlagSuccess(data) {
	          _this2.handleAlertFlagSuccess(data);
	        },
	        'API:fetch-alert-flag-failed': function APIFetchAlertFlagFailed(error) {
	          _this2.handleAlertFlagFailure(error);
	        }
	      });
	    }
	  }, {
	    key: 'handleConfig',
	    value: function handleConfig() {
	      var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      this.set({
	        read_only_mode: _utils2.default.coerceBoolean(_.get(config, 'read_only_mode'), false),
	        read_only_input_markdown: _.get(config, 'read_only_input_markdown', ''),
	        feature_flag_enabled: _.get(config, 'feature_flags.web_client_migration_flags', false)
	      });
	
	      var _data = this.data;
	      var read_only_mode = _data.read_only_mode;
	      var is_fetching = _data.is_fetching;
	      var is_fetched = _data.is_fetched;
	      var is_dismissed = _data.is_dismissed;
	
	      var shouldFetch = !is_fetching && !is_fetched && !is_dismissed;
	
	      if (read_only_mode && shouldFetch) {
	        this.set({
	          is_fetching: true,
	          is_visible: true
	        });
	        setTimeout(function () {
	          _logger2.default.log('[ReadOnly] Fetching interstitial content');
	          _app_dispatcher2.default.dispatch('API:fetch-read-only-content');
	        }, 0);
	      }
	
	      this.checkForAlertFlag(1000);
	    }
	  }, {
	    key: 'checkForAlertFlag',
	    value: function checkForAlertFlag() {
	      var interval = arguments.length <= 0 || arguments[0] === undefined ? _app_config2.default.alert_flag_poll_interval : arguments[0];
	
	      var flagVisible = this.data.alert_flag && this.data.alert_flag.id !== undefined;
	
	      if (!this.data.feature_flag_enabled || this.data.is_flag_pending || flagVisible) {
	        return;
	      }
	
	      _logger2.default.log('[ReadOnly] Checking for Alert Flag in %sms', interval);
	      clearTimeout(this.local.timer);
	      this.set({
	        is_flag_pending: true
	      });
	      this.local.timer = setTimeout(function () {
	        _app_dispatcher2.default.dispatch('API:fetch-alert-flag');
	      }, interval);
	    }
	  }, {
	    key: 'handleAlertFlagSuccess',
	    value: function handleAlertFlagSuccess(data) {
	      _logger2.default.log('[ReadOnly] Alert Flag fetch success', data);
	
	      this.set({
	        is_flag_pending: false
	      });
	
	      if (!data || data.id === undefined) {
	        _logger2.default.log('[ReadOnly] Alert Flag response included no or malformed data; will retry...');
	        this.checkForAlertFlag();
	        return;
	      }
	
	      var flagId = this.data.alert_flag ? this.data.alert_flag.id : undefined;
	      var flagVisible = flagId !== undefined;
	      if (!this.data.feature_flag_enabled || flagVisible) {
	        _logger2.default.log('[ReadOnly] Alert Flag already displayed. id: %s', flagId);
	        return;
	      }
	
	      var alert_flag = new _alert_flag_model2.default(data);
	      this.set({
	        alert_flag: alert_flag
	      });
	      _app_dispatcher2.default.dispatch('show-flag', (0, _extends3.default)({}, alert_flag, {
	        close: 'manual',
	        onClose: function onClose() {
	          _flag_actions2.default.dismissAlertFlag();
	        }
	      }));
	    }
	  }, {
	    key: 'handleAlertFlagFailure',
	    value: function handleAlertFlagFailure(error) {
	      _logger2.default.log('[ReadOnly] Alert Flag fetch failure', error);
	      this.set({
	        is_flag_pending: false
	      });
	      this.checkForAlertFlag();
	    }
	  }, {
	    key: 'handleDismissAlertFlag',
	    value: function handleDismissAlertFlag() {
	      var id = this.data.alert_flag.id;
	
	      if (id === undefined) {
	        return;
	      }
	      _logger2.default.log('[ReadOnly] Dismissing Alert Flag', id);
	      _app_dispatcher2.default.dispatch('API:dismiss-alert-flag', { id: id });
	      this.set({
	        alert_flag: {}
	      });
	      this.checkForAlertFlag();
	    }
	  }, {
	    key: 'handleReadOnlyContentSuccess',
	    value: function handleReadOnlyContentSuccess(data) {
	      _logger2.default.log('[ReadOnly] Interstitial content fetch success', data);
	      this.set((0, _extends3.default)({
	        is_fetching: false,
	        is_fetched: true,
	        is_visible: this.data.is_dismissed ? false : true
	      }, data));
	    }
	  }, {
	    key: 'handleReadOnlyContentFailure',
	    value: function handleReadOnlyContentFailure(error) {
	      _logger2.default.log('[ReadOnly] Interstitial content fetch failure', error);
	      this.set({
	        is_fetching: false,
	        is_fetched: true,
	        is_visible: false
	      });
	    }
	  }, {
	    key: 'handleDismissModal',
	    value: function handleDismissModal() {
	      _logger2.default.log('[ReadOnly] Dismiss interstitial');
	      this.setStorage();
	      this.set({
	        is_visible: false,
	        is_dismissed: true
	      });
	    }
	  }, {
	    key: 'getStorage',
	    value: function getStorage(key) {
	      return window.localStorage.getItem(STORAGE_KEY) ? true : false;
	    }
	  }, {
	    key: 'setStorage',
	    value: function setStorage(key, val) {
	      return window.localStorage.setItem(STORAGE_KEY, 1);
	    }
	  }]);
	  return ReadOnlyStore;
	}(_store2.default);
	
	exports.default = new ReadOnlyStore();

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(148);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _create = __webpack_require__(52);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class AlertFlagModel
	 *
	 * @property {number} id
	 * @property {string} color
	 * @property {string} title
	 * @property {string} body
	 * @property {string} image_url (optional)
	 * @property {string} link_url
	 * @property {string} link_text
	 */
	
	/**
	 * Example:
	 * {
	 *     "id": 15,
	 *     "color": "[blue|green|yellow|red]"
	 *     "title": "Alert Flag Title",
	 *     "body": "This is super important and needs your urgent attention",
	 *     "image_url": "https://s3.amazonaws.com/some_image.png" (optional),
	 *     "link_url": "https://hipchat.com/alert",
	 *     "link_text": "Learn more"
	 * }
	 */
	
	function normalizeAlertFlag(input) {
	  var typesMap = {
	    'blue': 'info',
	    'green': 'success',
	    'yellow': 'warning',
	    'red': 'error'
	  };
	
	  return _.transform(input, function (result, val, key) {
	    switch (key) {
	      case 'id':
	        result.id = !_.isNaN(val) ? parseInt(val, 10) : null;
	        break;
	
	      case 'color':
	        result.type = typesMap[val] || 'info';
	        break;
	
	      case 'title':
	      case 'body':
	      case 'image_url':
	      case 'link_url':
	      case 'link_text':
	        result[key] = String(val);
	        break;
	    }
	  });
	}
	
	var AlertFlagModel = function AlertFlagModel() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? (0, _create2.default)(null) : arguments[0];
	  (0, _classCallCheck3.default)(this, AlertFlagModel);
	
	  (0, _assign2.default)(this, normalizeAlertFlag(input));
	};
	
	exports.default = AlertFlagModel;
	module.exports = exports['default'];

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_header_actions = __webpack_require__(276);
	
	var _app_header_actions2 = _interopRequireDefault(_app_header_actions);
	
	var _notification_banner_strings = __webpack_require__(337);
	
	var _notification_banner_strings2 = _interopRequireDefault(_notification_banner_strings);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "NotificationBanner",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    ready: React.PropTypes.bool.isRequired,
	    notification_permission: React.PropTypes.bool.isRequired,
	    notification_preference: React.PropTypes.bool.isRequired,
	    notification_dismissed: React.PropTypes.oneOfType([React.PropTypes.bool, React.PropTypes.number]).isRequired
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      dismissed: false
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    if (this.props.notification_preference && !this.props.notification_permission) {
	      this._updateBannerState(true);
	    }
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	
	    if (this.state.dismissed) {
	      return;
	    }
	
	    if (!this.props.notification_preference && nextProps.notification_preference) {
	      this._updateBannerState(true);
	    } else if (this.props.notification_preference && !nextProps.notification_preference) {
	      this._updateBannerState(false);
	    }
	  },
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'aui-banner hc-banner-warning', role: 'banner', 'aria-hidden': 'false' },
	      _notification_banner_strings2.default.banner_message,
	      '',
	      React.createElement(
	        'a',
	        { onClick: this._enableNotifications, ref: 'enable_btn', className: 'enable' },
	        _notification_banner_strings2.default.enable_link
	      ),
	      ' ',
	      this.props.notification_dismissed > 0 ? _notification_banner_strings2.default.seriously_recommended : _notification_banner_strings2.default.recommended,
	      React.createElement(
	        'strong',
	        null,
	        ''
	      ),
	      React.createElement(
	        'a',
	        { onClick: this._dismiss, ref: 'dismiss_btn' },
	        _notification_banner_strings2.default.dismiss_link
	      ),
	      this.props.notification_dismissed > 0 ? React.createElement(
	        'span',
	        null,
	        React.createElement(
	          'strong',
	          null,
	          ''
	        ),
	        React.createElement(
	          'a',
	          { onClick: this._dismissForever, ref: 'dismiss_forever_btn' },
	          _notification_banner_strings2.default.dismiss_forever_link
	        )
	      ) : React.createElement('span', null)
	    );
	  },
	  _updateBannerState: function _updateBannerState(shown) {
	    _.delay(function () {
	      _app_dispatcher2.default.dispatch('position-app-header-dialogs');
	      _app_dispatcher2.default.dispatch('notification-banner-status', { shown: shown });
	    }, _app_config2.default.notification_banner_slide);
	  },
	  _enableNotifications: function _enableNotifications() {
	    this._hideBanner();
	    _app_header_actions2.default.requestNotificationPermission();
	  },
	  _dismiss: function _dismiss() {
	    this._hideBanner();
	    _app_header_actions2.default.dismissNotificationBanner();
	  },
	  _dismissForever: function _dismissForever() {
	    this._hideBanner();
	    _app_header_actions2.default.dismissNotificationBannerForever();
	  },
	  _hideBanner: function _hideBanner() {
	    this.setState({
	      dismissed: true
	    });
	    _app_dispatcher2.default.dispatch('notification-banner-status', {
	      shown: false
	    });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 337 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  banner_message: "Don't miss out on all those important messages.",
	  enable_link: "Enable desktop notifications",
	  dismiss_link: "Not right now",
	  dismiss_forever_link: "Don't ask me again",
	  recommended: "(Recommended)",
	  seriously_recommended: "(We seriously recommend this)"
	};
	module.exports = exports['default'];

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var InlineDialogActions = __webpack_require__(277);
	
	function _hideLayerFromEscKeypress(e) {
	  var intKey = window.Event ? e.which : e.keyCode;
	  if (intKey === 27) {
	    InlineDialogActions.hideInlineDialog();
	  }
	}
	
	function _hideLayerFromClick(e) {
	  var $target = $(e.target);
	  if ($target.closest(".aui-inline-dialog-trigger").length === 0 && $target.parents(".aui-inline-dialog").length === 0) {
	    InlineDialogActions.hideInlineDialog();
	  }
	}
	
	module.exports = {
	  componentDidMount: function componentDidMount() {
	    window.addEventListener('keydown', _hideLayerFromEscKeypress);
	    window.addEventListener('click', _hideLayerFromClick);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    window.removeEventListener('keydown', _hideLayerFromEscKeypress);
	    window.removeEventListener('click', _hideLayerFromClick);
	  },
	
	  _onKeyDown: _hideLayerFromEscKeypress
	};

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _modal_dialog_store = __webpack_require__(284);
	
	var _modal_dialog_store2 = _interopRequireDefault(_modal_dialog_store);
	
	var _settings_dialog = __webpack_require__(340);
	
	var _settings_dialog2 = _interopRequireDefault(_settings_dialog);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _invite_user_dialog = __webpack_require__(359);
	
	var _invite_user_dialog2 = _interopRequireDefault(_invite_user_dialog);
	
	var _remove_user_dialog = __webpack_require__(370);
	
	var _remove_user_dialog2 = _interopRequireDefault(_remove_user_dialog);
	
	var _create_room_dialog = __webpack_require__(372);
	
	var _create_room_dialog2 = _interopRequireDefault(_create_room_dialog);
	
	var _room_privacy_dialog = __webpack_require__(375);
	
	var _room_privacy_dialog2 = _interopRequireDefault(_room_privacy_dialog);
	
	var _rename_room_dialog = __webpack_require__(377);
	
	var _rename_room_dialog2 = _interopRequireDefault(_rename_room_dialog);
	
	var _delete_room_dialog = __webpack_require__(379);
	
	var _delete_room_dialog2 = _interopRequireDefault(_delete_room_dialog);
	
	var _room_invite_dialog = __webpack_require__(380);
	
	var _room_invite_dialog2 = _interopRequireDefault(_room_invite_dialog);
	
	var _archive_room_dialog = __webpack_require__(381);
	
	var _archive_room_dialog2 = _interopRequireDefault(_archive_room_dialog);
	
	var _desktop_4_dialog = __webpack_require__(382);
	
	var _desktop_4_dialog2 = _interopRequireDefault(_desktop_4_dialog);
	
	var _addon_dialog = __webpack_require__(384);
	
	var _addon_dialog2 = _interopRequireDefault(_addon_dialog);
	
	var _quick_switcher_dialog = __webpack_require__(394);
	
	var _quick_switcher_dialog2 = _interopRequireDefault(_quick_switcher_dialog);
	
	var _invite_teammates_dialog = __webpack_require__(404);
	
	var _invite_teammates_dialog2 = _interopRequireDefault(_invite_teammates_dialog);
	
	var _guest_access_dialog = __webpack_require__(406);
	
	var _guest_access_dialog2 = _interopRequireDefault(_guest_access_dialog);
	
	var _room_notifications_dialog = __webpack_require__(407);
	
	var _room_notifications_dialog2 = _interopRequireDefault(_room_notifications_dialog);
	
	var _keyboard_shortcuts_dialog = __webpack_require__(409);
	
	var _keyboard_shortcuts_dialog2 = _interopRequireDefault(_keyboard_shortcuts_dialog);
	
	var _release_notes_dialog = __webpack_require__(410);
	
	var _release_notes_dialog2 = _interopRequireDefault(_release_notes_dialog);
	
	var _integration_dialog = __webpack_require__(412);
	
	var _integration_dialog2 = _interopRequireDefault(_integration_dialog);
	
	var _integrations_management_dialog = __webpack_require__(438);
	
	var _integrations_management_dialog2 = _interopRequireDefault(_integrations_management_dialog);
	
	var _edit_message_dialog = __webpack_require__(443);
	
	var _edit_message_dialog2 = _interopRequireDefault(_edit_message_dialog);
	
	var _delete_message_dialog = __webpack_require__(445);
	
	var _delete_message_dialog2 = _interopRequireDefault(_delete_message_dialog);
	
	var _not_editable_dialog = __webpack_require__(454);
	
	var _not_editable_dialog2 = _interopRequireDefault(_not_editable_dialog);
	
	var _welcome_dialog = __webpack_require__(455);
	
	var _welcome_dialog2 = _interopRequireDefault(_welcome_dialog);
	
	var _modal_backdrop = __webpack_require__(464);
	
	var _modal_backdrop2 = _interopRequireDefault(_modal_backdrop);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ModalDialogContainer",
	
	  componentDidMount: function componentDidMount() {
	    _modal_dialog_store2.default.on('change', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _modal_dialog_store2.default.off('change', this._onChange);
	  },
	
	  getInitialState: function getInitialState() {
	    return _modal_dialog_store2.default.getAll();
	  },
	
	  _onChange: function _onChange() {
	    this.setState(_modal_dialog_store2.default.getAll());
	  },
	
	  _getDialogBackdrop: function _getDialogBackdrop() {
	    var dialogData = this.state.dialogData || {},
	        bgDismiss = dialogData.bgDismiss === false ? dialogData.bgDismiss : _app_config2.default.default_backdrop_dismiss_on_click;
	
	    return React.createElement(_modal_backdrop2.default, { btnLoading: this.state.btnLoading,
	      bgDismiss: bgDismiss });
	  },
	
	  _getDialog: function _getDialog() {
	    var currentDialogId = _modal_dialog_store2.default.getCurrentModalDialog();
	    var currentDialog = false;
	
	    if (currentDialogId) {
	      switch (currentDialogId) {
	        case "room-notifications-dialog":
	          currentDialog = React.createElement(_room_notifications_dialog2.default, this.state.dialogData);
	          break;
	
	        case "settings-dialog":
	          currentDialog = React.createElement(_settings_dialog2.default, this.state.dialogData);
	          break;
	
	        case "invite-users-dialog":
	          currentDialog = React.createElement(_invite_user_dialog2.default, this.state.dialogData);
	          break;
	
	        case "remove-users-dialog":
	          currentDialog = React.createElement(_remove_user_dialog2.default, this.state.dialogData);
	          break;
	
	        case "create-room-dialog":
	          currentDialog = React.createElement(_create_room_dialog2.default, (0, _extends3.default)({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;
	
	        case "room-privacy-dialog":
	          currentDialog = React.createElement(_room_privacy_dialog2.default, (0, _extends3.default)({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;
	
	        case "rename-room-dialog":
	          currentDialog = React.createElement(_rename_room_dialog2.default, (0, _extends3.default)({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;
	
	        case "delete-room-dialog":
	          currentDialog = React.createElement(_delete_room_dialog2.default, (0, _extends3.default)({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;
	
	        case "room-invite-dialog":
	          currentDialog = React.createElement(_room_invite_dialog2.default, this.state.dialogData);
	          break;
	
	        case "archive-room-dialog":
	          currentDialog = React.createElement(_archive_room_dialog2.default, this.state.dialogData);
	          break;
	
	        case "disable-guest-dialog":
	          currentDialog = React.createElement(_guest_access_dialog2.default, this.state.dialogData);
	          break;
	
	        case "addon-dialog":
	          currentDialog = React.createElement(_addon_dialog2.default, this.state.dialogData);
	          break;
	
	        case "invite-teammates-dialog":
	          currentDialog = React.createElement(_invite_teammates_dialog2.default, (0, _extends3.default)({}, this.state.dialogData, { web_server: this.state.web_server }));
	          break;
	
	        case "keyboard-shortcuts-dialog":
	          currentDialog = React.createElement(_keyboard_shortcuts_dialog2.default, this.state.dialogData);
	          break;
	
	        case "release-notes-dialog":
	          currentDialog = React.createElement(_release_notes_dialog2.default, this.state.dialogData);
	          break;
	
	        case "quick-switcher-dialog":
	          currentDialog = React.createElement(_quick_switcher_dialog2.default, this.state.dialogData);
	          break;
	
	        case "integration-dialog":
	          currentDialog = React.createElement(_integration_dialog2.default, this.state.dialogData);
	          break;
	
	        case "desktop-4-dialog":
	          currentDialog = React.createElement(_desktop_4_dialog2.default, this.state.dialogData);
	          break;
	
	        case "integrations-management-dialog":
	          currentDialog = React.createElement(_integrations_management_dialog2.default, this.state.dialogData);
	          break;
	
	        case "edit-message-dialog":
	          currentDialog = React.createElement(_edit_message_dialog2.default, this.state.dialogData);
	          break;
	
	        case "delete-message-dialog":
	          currentDialog = React.createElement(_delete_message_dialog2.default, this.state.dialogData);
	          break;
	
	        case "not-editable-dialog":
	          currentDialog = React.createElement(_not_editable_dialog2.default, this.state.dialogData);
	          break;
	
	        case "welcome-dialog":
	          currentDialog = React.createElement(_welcome_dialog2.default, this.state.dialogData);
	          break;
	
	      }
	    }
	
	    return currentDialog;
	  },
	
	  render: function render() {
	    var dialog = this._getDialog(),
	        dialogBackdrop;
	
	    if (dialog) {
	      dialogBackdrop = this._getDialogBackdrop();
	    }
	
	    return(
	      // we use key here to draw new backdrop for each new dialog
	      React.createElement(
	        "div",
	        { key: this.state.activeDialog },
	        dialog,
	        dialogBackdrop
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _nav_panel = __webpack_require__(343);
	
	var _nav_panel2 = _interopRequireDefault(_nav_panel);
	
	var _nav_panel_content = __webpack_require__(344);
	
	var _nav_panel_content2 = _interopRequireDefault(_nav_panel_content);
	
	var _preference_checkbox_field = __webpack_require__(345);
	
	var _preference_checkbox_field2 = _interopRequireDefault(_preference_checkbox_field);
	
	var _preference_radio_field = __webpack_require__(348);
	
	var _preference_radio_field2 = _interopRequireDefault(_preference_radio_field);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _aui_form_inline_fieldgroup = __webpack_require__(351);
	
	var _aui_form_inline_fieldgroup2 = _interopRequireDefault(_aui_form_inline_fieldgroup);
	
	var _aui_input_fieldgroup = __webpack_require__(352);
	
	var _aui_input_fieldgroup2 = _interopRequireDefault(_aui_input_fieldgroup);
	
	var _mac_dock_bounce_field = __webpack_require__(354);
	
	var _mac_dock_bounce_field2 = _interopRequireDefault(_mac_dock_bounce_field);
	
	var _sounds_field = __webpack_require__(355);
	
	var _sounds_field2 = _interopRequireDefault(_sounds_field);
	
	var _global_room_notifications_form = __webpack_require__(356);
	
	var _global_room_notifications_form2 = _interopRequireDefault(_global_room_notifications_form);
	
	var _do_not_disturb_form = __webpack_require__(358);
	
	var _do_not_disturb_form2 = _interopRequireDefault(_do_not_disturb_form);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'SettingsDialog',
	
	  componentDidMount: function componentDidMount() {
	    _preferences_store2.default.on('change', this._onChange);
	    _configuration_store2.default.on('change', this._onChange);
	    document.querySelector('body').addEventListener('keydown', this._onKeyDown);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _preferences_store2.default.off('change', this._onChange);
	    _configuration_store2.default.off('change', this._onChange);
	    document.querySelector('body').removeEventListener('keydown', this._onKeyDown);
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	    this.setState({ dirty: true });
	  },
	  getInitialState: function getInitialState() {
	    var initState = this._getState(),
	        otherDefaults = {
	      errors: {},
	      dirty: false
	    };
	
	    return _.merge(initState, otherDefaults);
	  },
	  _getState: function _getState() {
	    var prefs = {},
	        preferences = _preferences_store2.default.getAll();
	
	    _.assign(prefs, preferences, {
	      feature_flags: _configuration_store2.default.get('feature_flags'),
	      client_subtype: _configuration_store2.default.get('client_subtype'),
	      display_name: _configuration_store2.default.get('display_name'),
	      group_name: _configuration_store2.default.get('group_name')
	    });
	
	    return prefs;
	  },
	
	
	  //TODO: Remove client subtype checks and let wrappers tell the web client what to display
	  /**
	   * Check for when items need to be Windows-specific
	   * @returns {boolean}
	   * @private
	   */
	  _isWindows: function _isWindows() {
	    return _utils2.default.clientSubType.isWindows(this.state.client_subtype);
	  },
	
	
	  /**
	   * Check for when items need to be Linux-specific
	   * @returns {boolean}
	   * @private
	   */
	  _isLinux: function _isLinux() {
	    return _utils2.default.clientSubType.isLinux(this.state.client_subtype);
	  },
	
	
	  /**
	   * Check for when items need to be Mac-specific
	   * @returns {boolean}
	   * @private
	   */
	  _isMac: function _isMac() {
	    return _utils2.default.clientSubType.isMac(this.state.client_subtype);
	  },
	
	
	  /**
	   * Check for when items belong any native flavor
	   * @returns {boolean}
	   * @private
	   */
	  _isNative: function _isNative() {
	    return _utils2.default.clientSubType.isNative(this.state.client_subtype);
	  },
	  _getGeneralPanel: function _getGeneralPanel() {
	    var generalPanelNativeOptions = this._getGeneralPanelNativeOptions();
	    var attachedCardsOption = this._getAttachedCardsOption();
	
	    return React.createElement(
	      _nav_panel_content2.default,
	      { name: _dialog_strings2.default.general, key: 'general-settings-panel' },
	      React.createElement(
	        'form',
	        { className: 'aui', onSubmit: this._onSubmit },
	        React.createElement(_preference_checkbox_field2.default, { id: _preferences_keys2.default.HIDE_PRESENCE_MESSAGES,
	          label: _dialog_strings2.default.hide_presence_messages,
	          value: 'false',
	          isReverse: true }),
	        React.createElement(_preference_checkbox_field2.default, { id: _preferences_keys2.default.USE_24_HR_FORMAT,
	          label: _dialog_strings2.default.use_24_hour_format }),
	        attachedCardsOption,
	        React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.HIDE_GIFS_BY_DEFAULT,
	          label: _dialog_strings2.default.hide_gifs_by_default }),
	        React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.REPLACE_TEXT_EMOTICONS,
	          label: _dialog_strings2.default.replace_text_emoticons }),
	        React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.SHOW_UNREAD_DIVIDER,
	          label: _dialog_strings2.default.show_unread_divider }),
	        generalPanelNativeOptions
	      )
	    );
	  },
	  _getGeneralPanelNativeOptions: function _getGeneralPanelNativeOptions() {
	    var nativeOptions = [];
	
	    if (this._isWindows()) {
	      nativeOptions.push(this._getWindowsGeneralOptions());
	    }
	    if (this._isNative()) {
	      nativeOptions.push(this._getNativeGeneralOptions());
	    }
	    if (this._isMac()) {
	      nativeOptions.push(this._getMacGeneralOptions());
	    }
	    return nativeOptions;
	  },
	  _getAttachedCardsOption: function _getAttachedCardsOption() {
	    if (_.get(this.state.feature_flags, 'web_client_attach_to_collapsable_enabled')) {
	      return React.createElement(_preference_checkbox_field2.default, {
	        id: _client_preferences_keys2.default.HIDE_ATTACHED_CARDS_BY_DEFAULT,
	        label: _dialog_strings2.default.hide_attached_cards_by_default });
	    }
	    return undefined;
	  },
	  _getWindowsGeneralOptions: function _getWindowsGeneralOptions() {
	    return [React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.LAUNCH_WITH_OS_STARTUP, label: _dialog_strings2.default.start_up_with_windows })];
	  },
	  _getMacGeneralOptions: function _getMacGeneralOptions() {
	    return [React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.ENABLE_AUTOCORRECT, label: _dialog_strings2.default.enable_autocorrect })];
	  },
	  _getNativeGeneralOptions: function _getNativeGeneralOptions() {
	    return [React.createElement(
	      _aui_form_inline_fieldgroup2.default,
	      null,
	      React.createElement(_preference_checkbox_field2.default, {
	        id: _preferences_keys2.default.ENABLE_IDLE,
	        label: _dialog_strings2.default.idle }),
	      React.createElement(_aui_input_fieldgroup2.default, {
	        id: _preferences_keys2.default.IDLE_MINUTES,
	        key: _preferences_keys2.default.IDLE_MINUTES,
	        label: _dialog_strings2.default.minutes,
	        labelPosition: 'right',
	        size: 'short-field',
	        defaultValue: this.state[_preferences_keys2.default.IDLE_MINUTES],
	        error: this.state.errors[_preferences_keys2.default.IDLE_MINUTES],
	        type: 'text',
	        onChange: this._trackUnsavedChanges,
	        onBlur: this._onPreferenceChanged })
	    ), React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.ENABLE_LOGGING, label: _dialog_strings2.default.enable_logging }), React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.ENABLE_SPELL_CHECK, label: _dialog_strings2.default.enable_spell_check })];
	  },
	  _getAppearancePanel: function _getAppearancePanel() {
	    var panel = React.createElement('span', { name: _dialog_strings2.default.appearance });
	    var animated_avatars = null;
	
	    if (_configuration_store2.default.get('feature_flags').web_client_freeze_gifs) {
	      animated_avatars = React.createElement(_preference_radio_field2.default, { id: _client_preferences_keys2.default.ANIMATED_AVATARS,
	        label: _dialog_strings2.default.animated_avatars,
	        options: _preferences_store2.default.getAnimatedAvatarsOptions() });
	    }
	
	    if (this.state.feature_flags && this.state.feature_flags.web_client_appearance_settings || HC.ENV !== 'production' || this._isNative()) {
	      panel = React.createElement(
	        _nav_panel_content2.default,
	        { name: _dialog_strings2.default.appearance, key: 'appearance-settings-panel' },
	        React.createElement(
	          'form',
	          { className: 'aui' },
	          React.createElement(_preference_radio_field2.default, { id: _preferences_keys2.default.THEME,
	            label: _dialog_strings2.default.theme,
	            options: _preferences_store2.default.getThemeOptions() }),
	          React.createElement(_preference_radio_field2.default, { id: _preferences_keys2.default.DENSITY,
	            label: _dialog_strings2.default.density,
	            options: _preferences_store2.default.getDensityOptions() }),
	          React.createElement(_preference_radio_field2.default, { id: _preferences_keys2.default.CHAT_VIEW,
	            label: _dialog_strings2.default.chat_view,
	            options: _preferences_store2.default.getChatViewOptions() }),
	          React.createElement(_preference_radio_field2.default, { id: _preferences_keys2.default.NAME_DISPLAY,
	            label: _dialog_strings2.default.name_display,
	            options: _preferences_store2.default.getNameDisplayOptions() }),
	          animated_avatars
	        )
	      );
	    }
	
	    return panel;
	  },
	  _getNotificationsPanel: function _getNotificationsPanel() {
	    var video_enabled = _.get(this.state, 'feature_flags.web_client_video_chat', false),
	        room_notifications_enabled = _.get(this.state, 'feature_flags.web_client_per_room_notifications', false),
	        room_notification_settings = this._getRoomNotificationSettings(room_notifications_enabled),
	        native_notification_settings = this._getNativeNotificationSettings(),
	        sounds_field = this._getSoundsField(video_enabled),
	        dnd_with_video,
	        notify_when_dnd,
	        notify_for_oto;
	
	    if (room_notifications_enabled) {
	      notify_for_oto = React.createElement(_preference_checkbox_field2.default, {
	        id: _preferences_keys2.default.NOTIFY_FOR_PRIVATE,
	        label: _dialog_strings2.default.notify_for_oto_per_room_enabled });
	    }
	
	    if (video_enabled) {
	      dnd_with_video = React.createElement(_do_not_disturb_form2.default, {
	        notifyForVideo: this.state[_preferences_keys2.default.NOTIFY_FOR_VIDEO_WHEN_DND],
	        notifyAlways: this.state[_preferences_keys2.default.NOTIFY_WHEN_DND] });
	    } else {
	      notify_when_dnd = React.createElement(_preference_checkbox_field2.default, {
	        id: _preferences_keys2.default.NOTIFY_WHEN_DND,
	        label: _dialog_strings2.default.do_not_notify_when_dnd_basic });
	    }
	
	    return React.createElement(
	      _nav_panel_content2.default,
	      { name: _dialog_strings2.default.notifications, key: 'notifications-settings-panel' },
	      React.createElement(
	        'form',
	        { className: 'aui' },
	        sounds_field,
	        notify_for_oto,
	        native_notification_settings,
	        React.createElement(_preference_checkbox_field2.default, {
	          id: _preferences_keys2.default.SHOW_TOASTERS,
	          label: _dialog_strings2.default.show_toasters }),
	        notify_when_dnd
	      ),
	      room_notification_settings,
	      dnd_with_video
	    );
	  },
	  _getSoundsField: function _getSoundsField(video_enabled) {
	    var sounds_field;
	    if (video_enabled) {
	      sounds_field = React.createElement(_sounds_field2.default, {
	        soundsEnabled: this.state[_preferences_keys2.default.SOUNDS_ENABLED],
	        messageSounds: this.state[_preferences_keys2.default.MESSAGE_SOUNDS],
	        videoSounds: this.state[_preferences_keys2.default.VIDEO_SOUNDS] });
	    } else {
	      sounds_field = React.createElement(_preference_checkbox_field2.default, {
	        id: _preferences_keys2.default.SOUNDS_ENABLED,
	        label: _dialog_strings2.default.basic_play_sound });
	    }
	    return sounds_field;
	  },
	  _getRoomNotificationSettings: function _getRoomNotificationSettings(room_notifications_enabled) {
	    if (room_notifications_enabled) {
	      return React.createElement(_global_room_notifications_form2.default, null);
	    }
	
	    return React.createElement(
	      'form',
	      { className: 'aui' },
	      React.createElement(
	        'h3',
	        null,
	        _dialog_strings2.default.notify_when_header
	      ),
	      React.createElement(_preference_checkbox_field2.default, { id: _preferences_keys2.default.NOTIFY_FOR_ROOM,
	        label: _dialog_strings2.default.notify_for_room }),
	      React.createElement(_preference_checkbox_field2.default, { id: _preferences_keys2.default.NOTIFY_FOR_PRIVATE_ROOM,
	        label: _dialog_strings2.default.notify_for_private_room }),
	      React.createElement(_preference_checkbox_field2.default, { id: _preferences_keys2.default.NOTIFY_FOR_TAG,
	        label: _dialog_strings2.default.notify_for_tag }),
	      React.createElement(_preference_checkbox_field2.default, { id: _preferences_keys2.default.NOTIFY_FOR_PRIVATE,
	        label: _dialog_strings2.default.notify_for_oto })
	    );
	  },
	  _getNativeNotificationSettings: function _getNativeNotificationSettings() {
	    if (this._isWindows()) {
	      return [React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.KEEP_POPUPS_VISIBLE,
	        label: _dialog_strings2.default.keep_popups_visible }), React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.BLINK_TASKBAR,
	        label: _dialog_strings2.default.blink_taskbar })];
	    } else if (this._isLinux()) {
	      return [React.createElement(_preference_checkbox_field2.default, { id: _client_preferences_keys2.default.KEEP_POPUPS_VISIBLE,
	        label: _dialog_strings2.default.keep_popups_visible })];
	    } else if (this._isMac()) {
	      return [React.createElement(_mac_dock_bounce_field2.default, {
	        bounceIcon: this.state.bounceIcon,
	        bounceOnce: this.state.bounceOnce })];
	    }
	  },
	  _getConnectionPanel: function _getConnectionPanel() {
	    return React.createElement(
	      _nav_panel_content2.default,
	      { name: _dialog_strings2.default.connection, key: 'connection-settings-panel' },
	      React.createElement(
	        'p',
	        null,
	        _dialog_strings2.default.proxy_settings_description(this.state.display_name)
	      ),
	      React.createElement('br', null),
	      React.createElement(
	        'button',
	        {
	          className: 'aui-button aui-button-primary',
	          'aria-disabled': this.props.btnLoading,
	          onClick: this._onClickProxySettings },
	        _dialog_strings2.default.proxy_settings(this.state.display_name)
	      )
	    );
	  },
	  _dialogBody: function _dialogBody() {
	    var generalPanel = this._getGeneralPanel(),
	        appearancePanel = this._getAppearancePanel(),
	        notificationsPanel = this._getNotificationsPanel(),
	        connectionPanel = this._getConnectionPanel(),
	        navPanelContent = [generalPanel, appearancePanel, notificationsPanel];
	
	    if (this._isWindows()) {
	      navPanelContent.push(connectionPanel);
	    }
	
	    return React.createElement(
	      _nav_panel2.default,
	      {
	        onChange: this._onPreferenceChanged,
	        defaultTab: this.props.activeTab },
	      navPanelContent
	    );
	  },
	
	
	  trackedPreferences: {},
	
	  _trackUnsavedChanges: function _trackUnsavedChanges(e) {
	    e.stopPropagation();
	    this.trackedPreferences[e.target.id] = e.target.value;
	  },
	  _onKeyDown: function _onKeyDown(e) {
	    var _this = this;
	
	    var key = window.Event ? e.which : e.keyCode;
	
	    if (key === _utils2.default.keyCode.Esc) {
	      _.forEach(this.trackedPreferences, function (value, id) {
	        var target = {
	          id: id,
	          value: value,
	          type: 'text'
	        };
	        _this._onPreferenceChanged({ target: target });
	      });
	    }
	  },
	  _getPreference: function _getPreference(target) {
	    var pref = {};
	
	    switch (target.type) {
	      case 'radio':
	        var checked = document.querySelector('input[name=\'' + target.name + '\']:checked');
	        pref[target.name] = checked.id;
	        break;
	      case 'checkbox':
	        var value = target.value === 'true';
	        pref[target.id] = target.checked ? value : !value;
	        break;
	      case 'text':
	        pref[target.id] = target.value;
	        break;
	    }
	
	    return pref;
	  },
	  _onPreferenceChanged: function _onPreferenceChanged(e) {
	    var target = e.target,
	        preference = this._getPreference(target),
	        formValidated = this._validate(target);
	
	    if (formValidated) {
	      _preferences_actions2.default.savePreferences(preference);
	      _spi2.default.onPreferencesUpdated(preference);
	    }
	  },
	  _validate: function _validate(target) {
	    var value = target.value;
	
	    if ((0, _keys2.default)(this.state.errors).length) {
	      this._clearErrors();
	    }
	
	    if (target.id === _preferences_keys2.default.IDLE_MINUTES) {
	      if (! +value) {
	        this.setState({
	          errors: (0, _defineProperty3.default)({}, _preferences_keys2.default.IDLE_MINUTES, _dialog_strings2.default.minimum_idle_minutes)
	        });
	        return false;
	      } else if (+value < 0) {
	        this.setState({
	          errors: (0, _defineProperty3.default)({}, _preferences_keys2.default.IDLE_MINUTES, _dialog_strings2.default.minimum_idle_minutes)
	        });
	        return false;
	      } else if (+value > 99) {
	        this.setState({
	          errors: (0, _defineProperty3.default)({}, _preferences_keys2.default.IDLE_MINUTES, _dialog_strings2.default.maximum_idle_minutes)
	        });
	        return false;
	      }
	    }
	
	    return true;
	  },
	  _clearErrors: function _clearErrors() {
	    this.setState({
	      errors: {}
	    });
	  },
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	  },
	  _onClickProxySettings: function _onClickProxySettings() {
	    if (_spi2.default.buttonClickedProxySettings) {
	      _spi2.default.buttonClickedProxySettings();
	    }
	  },
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, {
	      dialogId: 'settings-dialog',
	      title: _dialog_strings2.default.title_settings(this.state.group_name),
	      dialogBody: this._dialogBody,
	      noCloseLink: true });
	  }
	}); /*global HC*/
	
	module.exports = exports['default'];

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ModalDialog",
	
	  propTypes: {
	    size: React.PropTypes.oneOf(['small', 'medium', 'large', 'xlarge'])
	  },
	
	  mixins: [_modal_dialog_visibility_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    document.querySelector("body").addEventListener('keydown', this._onKeyDown);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    document.querySelector("body").removeEventListener('keydown', this._onKeyDown);
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      closeLinkText: _dialog_strings2.default.close,
	      dialogId: "dialog",
	      dialogBody: _.noop,
	      dialogFooterButton: _.noop,
	      dialogFooterLinks: _.noop,
	      dialogFilter: false,
	      dialogFilterPlaceholder: "",
	      dialogFilterCallback: _.noop,
	      btnLoading: false,
	      size: "medium",
	      hint: "",
	      isWarning: false,
	      showFooter: true
	    };
	  },
	
	  _getTitle: function _getTitle() {
	    var title;
	    if (this.props.lozenge_text) {
	      title = React.createElement(
	        "h2",
	        { className: "aui-dialog2-header-main" },
	        this.props.title,
	        React.createElement(
	          "span",
	          { className: "aui-lozenge aui-lozenge-current" },
	          this.props.lozenge_text
	        )
	      );
	    } else {
	      title = React.createElement(
	        "h2",
	        { className: "aui-dialog2-header-main" },
	        this.props.title
	      );
	    }
	    return title;
	  },
	
	  _getSecondaryHeader: function _getSecondaryHeader() {
	    var secondaryHeader = false;
	    if (this.props.dialogFilter) {
	      secondaryHeader = React.createElement(
	        "div",
	        { className: "aui-dialog2-header-secondary" },
	        React.createElement(
	          "form",
	          { className: "aui", action: "#" },
	          React.createElement("input", { className: "text", type: "search", name: "search",
	            placeholder: this.props.dialogFilterPlaceholder, onChange: this.props.dialogFilterCallback })
	        )
	      );
	    }
	    return secondaryHeader;
	  },
	
	  _getHint: function _getHint() {
	    var hint;
	    if (this.props.noHint) {
	      hint = false;
	    } else {
	      hint = React.createElement(
	        "div",
	        { className: "aui-dialog2-footer-hint" },
	        this.props.hint
	      );
	    }
	    return hint;
	  },
	
	  _getCloseBtn: function _getCloseBtn() {
	    var btn;
	    if (this.props.btnLoading) {
	      btn = false;
	    } else {
	      btn = React.createElement(
	        "a",
	        { className: "aui-dialog2-header-close", onClick: this._onClickClose },
	        React.createElement(
	          "span",
	          { className: "aui-icon aui-icon-small aui-iconfont-close-dialog" },
	          _dialog_strings2.default.close
	        )
	      );
	    }
	    return btn;
	  },
	
	  _getCloseLink: function _getCloseLink() {
	    var link;
	    if (this.props.noCloseLink) {
	      link = false;
	    } else {
	      link = React.createElement(
	        "button",
	        { className: "aui-button aui-button-link", "aria-disabled": this.props.btnLoading, onClick: this._onClickClose },
	        this.props.closeLinkText
	      );
	    }
	    return link;
	  },
	
	  _getSectionStyle: function _getSectionStyle() {
	    var style = {};
	    if (this.props.customWidth) {
	      style = {
	        width: this.props.customWidth
	      };
	    }
	    return style;
	  },
	  _getDialogContentStyle: function _getDialogContentStyle() {
	    var style = {};
	    if (this.props.customHeight) {
	      style = {
	        height: this.props.customHeight
	      };
	    }
	    return style;
	  },
	
	
	  close: function close() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  _onKeyDown: function _onKeyDown(e) {
	    var key = window.Event ? e.which : e.keyCode;
	    if (key === _utils2.default.keyCode.Esc && !this.props.btnLoading) {
	      this.close();
	    }
	  },
	
	  _onClickClose: function _onClickClose() {
	    if (!this.props.btnLoading) {
	      this.close();
	    }
	  },
	
	  _getFooter: function _getFooter() {
	    var closeLink = this._getCloseLink(),
	        hint = this._getHint();
	
	    return React.createElement(
	      "footer",
	      { className: "aui-dialog2-footer" },
	      React.createElement(
	        "div",
	        { className: "aui-dialog2-footer-actions" },
	        React.createElement(
	          "div",
	          { className: "hc-dialog-btn-spinner" },
	          React.createElement(_spinner2.default, { spin: this.props.btnLoading, size: "small", color: _app_config2.default.spinner_colors["light"] })
	        ),
	        this.props.dialogFooterButton(),
	        this.props.dialogFooterLinks(),
	        closeLink
	      ),
	      hint
	    );
	  },
	
	  render: function render() {
	    var closeBtn = this._getCloseBtn(),
	        footer = this.props.showFooter ? this._getFooter() : null,
	        title = this._getTitle(),
	        secondaryHeader = this._getSecondaryHeader();
	
	    var classes = (0, _classnames2.default)({
	      'aui-layer': true,
	      'aui-dialog2': true,
	      'aui-dialog2-warning': this.props.isWarning
	    }, "aui-dialog2-" + this.props.size);
	
	    return React.createElement(
	      "section",
	      { role: "dialog", id: this.props.dialogId, className: classes, style: this._getSectionStyle(),
	        "aria-hidden": !this.state.dialogVisible },
	      React.createElement(
	        "header",
	        { className: "aui-dialog2-header" },
	        title,
	        secondaryHeader,
	        closeBtn
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dialog2-content hc-dialog-content", style: this._getDialogContentStyle() },
	        this.props.dialogBody()
	      ),
	      footer
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog_store = __webpack_require__(284);
	
	var _modal_dialog_store2 = _interopRequireDefault(_modal_dialog_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  getInitialState: function getInitialState() {
	    return _modal_dialog_store2.default.getAll();
	  },
	
	  _onChange: function _onChange() {
	    if (this.isMounted()) {
	      this.setState(_modal_dialog_store2.default.getAll());
	    }
	  },
	
	  componentWillMount: function componentWillMount() {
	    _modal_dialog_store2.default.on('change', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _modal_dialog_store2.default.off('change', this._onChange);
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _nav_panel_content = __webpack_require__(344);
	
	var _nav_panel_content2 = _interopRequireDefault(_nav_panel_content);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'NavPanel',
	
	  propTypes: {
	    children: function children(props, propName) {
	      if (props[propName].length < 2) {
	        return new Error('NavPanel component requires more than one tab (child components)');
	      }
	      if (!_.every(props[propName], function (child) {
	        return child.props.name;
	      })) {
	        return new Error('All NavPanel child components *must* have a name attribute');
	      }
	    }
	  },
	
	  _onClick: function _onClick(e) {
	    var name = e.target.getAttribute('name');
	    if (this.state.activeTab !== name) {
	      // Only send analytics event if the activeTab has changed
	      this._handleNavPanelAnalytics(name);
	    }
	    this.setState({
	      activeTab: name
	    });
	  },
	  getInitialState: function getInitialState() {
	    var activeTab = { activeTab: this.props.children[0].props.name };
	
	    if (this.props.defaultTab && _.find(this.props.children, { props: { name: this.props.defaultTab } })) {
	      activeTab = { activeTab: this.props.defaultTab };
	    }
	
	    return activeTab;
	  },
	  _handleNavPanelAnalytics: function _handleNavPanelAnalytics(name) {
	    switch (name) {
	      case _dialog_strings2.default.general:
	        _analytics_actions2.default.generalSettingsPanelSelected();
	        break;
	      case _dialog_strings2.default.notifications:
	        _analytics_actions2.default.notificationsSettingsPanelSelected();
	        break;
	      case _dialog_strings2.default.appearance:
	        _analytics_actions2.default.appearanceSettingsPanelSelected();
	        break;
	    }
	  },
	  render: function render() {
	    var _this = this;
	
	    var menuItems = React.Children.map(this.props.children, function (child) {
	      if (child.type.displayName === 'NavPanelContent') {
	
	        var classes = (0, _classnames2.default)({
	          'aui-nav-selected': _this.state.activeTab === child.props.name
	        });
	
	        return React.createElement(
	          'li',
	          { role: 'tab', className: classes, selected: _this.state.activeTab === child.props.name, key: _.uniqueId() },
	          React.createElement(
	            'a',
	            { onClick: _this._onClick,
	              name: child.props.name },
	            child.props.name
	          )
	        );
	      }
	    });
	    var tabPanels = React.Children.map(this.props.children, function (child) {
	      if (child.type.displayName === 'NavPanelContent') {
	        return React.createElement(
	          _nav_panel_content2.default,
	          { name: child.props.name, selected: _this.state.activeTab === child.props.name,
	            key: _.uniqueId(), lozenge_text: child.props.lozenge_text },
	          child.props.children
	        );
	      }
	    });
	
	    return React.createElement(
	      'div',
	      (0, _extends3.default)({}, this.props, { className: 'hc-nav-panel aui-group' }),
	      React.createElement(
	        'div',
	        { className: 'aui-item aui-navgroup aui-navgroup-vertical' },
	        React.createElement(
	          'ul',
	          { className: 'aui-nav', 'data-skate-ignore': true },
	          menuItems
	        )
	      ),
	      React.createElement(
	        'div',
	        { className: 'aui-item' },
	        tabPanels
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 344 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = React.createClass({
	
	  displayName: "NavPanelContent",
	
	  _getTitle: function _getTitle() {
	    var title;
	    if (this.props.lozenge_text) {
	      title = React.createElement(
	        "h2",
	        null,
	        this.props.name,
	        React.createElement(
	          "span",
	          { className: "aui-lozenge aui-lozenge-current" },
	          this.props.lozenge_text
	        )
	      );
	    } else {
	      title = React.createElement(
	        "h2",
	        null,
	        this.props.name
	      );
	    }
	    return title;
	  },
	
	  render: function render() {
	    var title = this._getTitle();
	
	    return React.createElement(
	      "div",
	      { className: "nav-panel-content", "aria-hidden": !this.props.selected, "aria-labeledby": this.props.tabId },
	      title,
	      this.props.children
	    );
	  }
	});

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AuiCheckboxField = __webpack_require__(346);
	var PreferencesStore = __webpack_require__(161);
	var PreferencesKeys = __webpack_require__(164);
	var ClientPreferencesKeys = __webpack_require__(166);
	var AnalyticsActions = __webpack_require__(196);
	
	module.exports = React.createClass({
	
	  displayName: "PreferenceCheckboxField",
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      isReverse: false
	    };
	  },
	
	  _isDefaultChecked: function _isDefaultChecked() {
	    var isChecked = PreferencesStore.get(this.props.id);
	
	    if (this.props.isReverse) {
	      isChecked = !isChecked;
	    }
	
	    return isChecked;
	  },
	
	  _handleAnalytics: function _handleAnalytics() {
	    switch (this.props.id) {
	      case ClientPreferencesKeys.HIDE_GIFS_BY_DEFAULT:
	        this._handleGifsClicked();
	        break;
	      case PreferencesKeys.NOTIFY_FOR_PRIVATE_ROOM:
	        this._handlePrivateRoomNotificationClicked();
	        break;
	      case PreferencesKeys.NOTIFY_FOR_ROOM:
	        this._handleOpenRoomNotificationClicked();
	        break;
	    }
	  },
	
	  _handleGifsClicked: function _handleGifsClicked() {
	    var old_val = PreferencesStore.get(this.props.id),
	        new_val = !old_val;
	    AnalyticsActions.hideGifsClicked(old_val, new_val);
	  },
	
	  _handlePrivateRoomNotificationClicked: function _handlePrivateRoomNotificationClicked() {
	    var old_val = PreferencesStore.get(this.props.id),
	        new_val = !old_val;
	    AnalyticsActions.privateRoomNotificationClicked(old_val, new_val);
	  },
	
	  _handleOpenRoomNotificationClicked: function _handleOpenRoomNotificationClicked() {
	    var old_val = PreferencesStore.get(this.props.id),
	        new_val = !old_val;
	    AnalyticsActions.openRoomNotificationClicked(old_val, new_val);
	  },
	
	  render: function render() {
	    return React.createElement(AuiCheckboxField, (0, _extends3.default)({}, this.props, { onChange: this._handleAnalytics, defaultChecked: this._isDefaultChecked() }));
	  }
	});

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AuiCheckbox = __webpack_require__(347);
	
	module.exports = React.createClass({
	
	  displayName: "AuiCheckBoxField",
	
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "checkbox" },
	      React.createElement(AuiCheckbox, (0, _extends3.default)({ key: _.uniqueId() }, this.props)),
	      React.createElement(
	        "label",
	        { htmlFor: this.props.id, key: _.uniqueId() },
	        this.props.label
	      )
	    );
	  }
	});

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "AuiCheckbox",
	
	  propTypes: {
	    defaultChecked: React.PropTypes.bool,
	    onChange: React.PropTypes.func
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      value: true,
	      defaultChecked: false,
	      onChange: function onChange() {}
	    };
	  },
	
	  render: function render() {
	    var props = _.clone(this.props);
	    props.name = this.props.name || this.props.id;
	    return React.createElement("input", (0, _extends3.default)({ type: "checkbox", className: "checkbox" }, props));
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _aui_radio = __webpack_require__(349);
	
	var _aui_radio2 = _interopRequireDefault(_aui_radio);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "PreferenceRadioField",
	
	  propTypes: {
	    options: React.PropTypes.array,
	    label: React.PropTypes.string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      options: []
	    };
	  },
	
	  _isDefaultChecked: function _isDefaultChecked(val) {
	    return val === _preferences_store2.default.get(this.props.id);
	  },
	
	  _handleAnalytics: function _handleAnalytics(option) {
	    switch (this.props.id) {
	      case _preferences_keys2.default.THEME:
	        this._handleThemeClicked(option);
	        break;
	      case _preferences_keys2.default.DENSITY:
	        this._handleDensityClicked(option);
	        break;
	      case _preferences_keys2.default.CHAT_VIEW:
	        this._handleChatViewClicked(option);
	        break;
	      case _preferences_keys2.default.NAME_DISPLAY:
	        this._handleNameDisplayClicked(option);
	        break;
	      case _client_preferences_keys2.default.ANIMATED_AVATARS:
	        this._handleAnimatedAvatarsClicked(option);
	        break;
	    }
	  },
	
	  _getCurrentPref: function _getCurrentPref() {
	    return _preferences_store2.default.get(this.props.id);
	  },
	
	  _handleThemeClicked: function _handleThemeClicked(option) {
	    var currentSelection = this._getCurrentPref();
	    if (option === "light" && option !== currentSelection) {
	      _analytics_actions2.default.lightThemeSelected();
	    } else if (option === "dark" && option !== currentSelection) {
	      _analytics_actions2.default.darkThemeSelected();
	    }
	  },
	
	  _handleDensityClicked: function _handleDensityClicked(option) {
	    var currentSelection = this._getCurrentPref();
	    if (option === "normal" && option !== currentSelection) {
	      _analytics_actions2.default.normalTextDensitySelected();
	    } else if (option === "tighter" && option !== currentSelection) {
	      _analytics_actions2.default.tighterTextDensitySelected();
	    }
	  },
	
	  _handleChatViewClicked: function _handleChatViewClicked(option) {
	    var currentSelection = this._getCurrentPref();
	    if (option === "classic" && option !== currentSelection) {
	      _analytics_actions2.default.classicChatViewSelected();
	    } else if (option === "classic_neue" && option !== currentSelection) {
	      _analytics_actions2.default.classicNeueChatViewSelected();
	    }
	  },
	
	  _handleNameDisplayClicked: function _handleNameDisplayClicked(option) {
	    var currentSelection = this._getCurrentPref();
	    if (option === "names" && option !== currentSelection) {
	      _analytics_actions2.default.fullNamesNameDisplaySelected();
	    } else if (option === "mentions" && option !== currentSelection) {
	      _analytics_actions2.default.mentionNamesNameDisplaySelected();
	    }
	  },
	
	  _handleAnimatedAvatarsClicked: function _handleAnimatedAvatarsClicked(option) {
	    var currentSelection = this._getCurrentPref();
	    if (option === "animated" && option !== currentSelection) {
	      _analytics_actions2.default.animatedAvatarsSelected();
	    } else if (option === "static" && option !== currentSelection) {
	      _analytics_actions2.default.staticAvatarsSelected();
	    }
	  },
	
	  render: function render() {
	    var _this = this;
	
	    return React.createElement(
	      'fieldset',
	      { className: 'group' },
	      React.createElement(
	        'legend',
	        null,
	        React.createElement(
	          'span',
	          null,
	          this.props.label
	        )
	      ),
	      this.props.options.map(function (option) {
	        var key = 'radio-' + _this.props.id + '-' + option;
	        return React.createElement(_aui_radio2.default, {
	          val: option,
	          id: option,
	          key: key,
	          label: _dialog_strings2.default[option],
	          name: _this.props.id,
	          defaultChecked: _this._isDefaultChecked(option),
	          onChange: _this._handleAnalytics.bind(_this, option) });
	      })
	    );
	  }
	});

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var AuiInput = __webpack_require__(350);
	
	module.exports = React.createClass({
	
	  displayName: "AuiRadio",
	
	  _getDescription: function _getDescription() {
	    var desc = false;
	    if (this.props.description) {
	      if (this.props.description_is_link && this.props.description_link_action) {
	        desc = React.createElement(
	          "div",
	          { className: "description" },
	          React.createElement(
	            "a",
	            { onClick: this.props.description_link_action.bind(this) },
	            this.props.description
	          )
	        );
	      } else {
	        desc = React.createElement(
	          "div",
	          { className: "description" },
	          this.props.description
	        );
	      }
	    }
	    return desc;
	  },
	
	  _getIcon: function _getIcon() {
	    if (this.props.icon) {
	      var iconClass = "aui-icon hipchat-icon-small icon-" + this.props.icon;
	      return React.createElement(
	        "span",
	        { className: iconClass },
	        this.props.icon
	      );
	    }
	  },
	
	  render: function render() {
	    var name = this.props.name || this.props.id;
	    var description = this._getDescription();
	    var classNames = this.props.className || "";
	    var icon = this._getIcon();
	
	    return React.createElement(
	      "div",
	      { className: "radio " + classNames },
	      React.createElement(AuiInput, { type: "radio",
	        ref: "radio",
	        id: this.props.id,
	        name: name,
	        value: this.props.value,
	        checked: this.props.checked,
	        defaultChecked: this.props.defaultChecked,
	        onChange: this.props.onChange }),
	      React.createElement(
	        "label",
	        { htmlFor: this.props.id },
	        icon,
	        this.props.label
	      ),
	      description
	    );
	  }
	});

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "AuiInput",
	
	  propTypes: {
	    onChange: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onBlur: React.PropTypes.func
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      type: "text",
	      onChange: function onChange() {},
	      onFocus: function onFocus() {},
	      onBlur: function onBlur() {}
	    };
	  },
	
	  focus: function focus() {
	    ReactDOM.findDOMNode(this.refs.input).focus();
	  },
	
	  render: function render() {
	
	    var name = this.props.name || this.props.id;
	    var classes = this.props.size ? this.props.type + " " + this.props.size : this.props.type;
	
	    return React.createElement("input", (0, _extends3.default)({}, this.props, { ref: "input", className: classes, name: name }));
	  }
	
	});

/***/ },
/* 351 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = React.createClass({
	
	  displayName: "AuiFormInlineFieldGroup",
	
	  getDefaults: function getDefaults() {
	    return {
	      className: ''
	    };
	  },
	
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "inline-field-group " + this.props.className },
	      this.props.children
	    );
	  }
	
	});

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AuiFormFieldGroup = __webpack_require__(353),
	    AuiInput = __webpack_require__(350);
	
	module.exports = React.createClass({
	
	  displayName: "AuiInputFieldGroup",
	
	  focus: function focus() {
	    this.refs.input.focus();
	  },
	
	  render: function render() {
	    return React.createElement(
	      AuiFormFieldGroup,
	      this.props,
	      React.createElement(AuiInput, (0, _extends3.default)({ ref: "input" }, this.props))
	    );
	  }
	
	});

/***/ },
/* 353 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = React.createClass({
	
	  displayName: "AuiFormFieldGroup",
	
	  _getDescription: function _getDescription() {
	    if (this.props.description) {
	      return React.createElement(
	        "div",
	        { className: "description" },
	        this.props.description
	      );
	    }
	  },
	
	  _getRequiredIcon: function _getRequiredIcon() {
	    if (this.props.required) {
	      return React.createElement(
	        "span",
	        { className: "aui-icon icon-required" },
	        " required"
	      );
	    }
	  },
	
	  getError: function getError() {
	    if (this.props.error) {
	      return React.createElement(
	        "div",
	        { className: "error" },
	        this.props.error
	      );
	    }
	  },
	
	  render: function render() {
	    var name = this.props.name || this.props.id;
	    var description = this._getDescription();
	    var requiredIcon = this._getRequiredIcon();
	    var error = this.getError();
	    var classes = "field-group";
	
	    if (this.props.labelPosition) {
	      classes += " label-position-" + this.props.labelPosition;
	    }
	
	    return React.createElement(
	      "div",
	      { className: classes },
	      React.createElement(
	        "label",
	        { htmlFor: name },
	        this.props.label,
	        requiredIcon
	      ),
	      this.props.children,
	      description,
	      error
	    );
	  }
	
	});

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _aui_form_inline_fieldgroup = __webpack_require__(351);
	
	var _aui_form_inline_fieldgroup2 = _interopRequireDefault(_aui_form_inline_fieldgroup);
	
	var _aui_checkbox = __webpack_require__(347);
	
	var _aui_checkbox2 = _interopRequireDefault(_aui_checkbox);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	  displayName: 'MacDockBounceFieldType',
	
	  mixins: [React.addons.PureRenderMixin],
	
	  propTypes: {
	    bounceIcon: React.PropTypes.bool.isRequired,
	    bounceOnce: React.PropTypes.bool.isRequired
	  },
	
	  componentDidMount: function componentDidMount() {
	    AJS.$(this.refs.dropdown).auiSelect2({
	      minimumResultsForSearch: Infinity
	    }).on('change.mac-dock-bounce', this._onBounceOnceChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    AJS.$(this.refs.dropdown).off('.mac-dock-bounce').auiSelect2('destroy');
	    AJS.$('#select2-drop-mask').remove();
	    AJS.$('.select2-sizer').remove();
	  },
	  _onBounceIconChange: function _onBounceIconChange(e) {
	    var data = {
	      bounceIcon: e.target.checked
	    };
	
	    // If we're unsetting the 'bounceIcon' preference, also set 'bounceOnce'
	    // back to the default.
	    if (!data.bounceIcon) {
	      data.bounceOnce = true;
	    }
	
	    e.stopPropagation();
	
	    _preferences_actions2.default.savePreferences(data);
	  },
	  _onBounceOnceChange: function _onBounceOnceChange(e) {
	    var data = {
	      bounceOnce: e.target.value === 'once'
	    };
	
	    e.stopPropagation();
	
	    _preferences_actions2.default.savePreferences(data);
	  },
	  render: function render() {
	    var _props = this.props;
	    var bounceIcon = _props.bounceIcon;
	    var bounceOnce = _props.bounceOnce;
	    var values = {
	      once: 'once',
	      forever: 'forever'
	    };
	    var defaultDropDownValue = bounceOnce ? values.once : values.forever;
	    var dropDownDisabled = !bounceIcon;
	    var classes = (0, _classnames2.default)({
	      'mac-dock-bounce-preference': true,
	      'checkbox-select2-field': true,
	      'disabled': dropDownDisabled
	    });
	
	    return React.createElement(
	      _aui_form_inline_fieldgroup2.default,
	      { className: classes, key: _client_preferences_keys2.default.BOUNCE_ICON },
	      React.createElement(
	        'div',
	        { className: 'checkbox' },
	        React.createElement(_aui_checkbox2.default, { id: _client_preferences_keys2.default.BOUNCE_ICON,
	          defaultChecked: bounceIcon,
	          onClick: this._onBounceIconChange }),
	        React.createElement(
	          'label',
	          { htmlFor: _client_preferences_keys2.default.BOUNCE_ICON },
	          _dialog_strings2.default.bounce_icon
	        ),
	        React.createElement(
	          'select',
	          { defaultValue: defaultDropDownValue,
	            ref: 'dropdown',
	            disabled: dropDownDisabled,
	            'aria-disabled': dropDownDisabled },
	          React.createElement(
	            'option',
	            { value: values.once },
	            _dialog_strings2.default.bounce_icon_once
	          ),
	          React.createElement(
	            'option',
	            { value: values.forever },
	            _dialog_strings2.default.bounce_icon_forever
	          )
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _aui_form_inline_fieldgroup = __webpack_require__(351);
	
	var _aui_form_inline_fieldgroup2 = _interopRequireDefault(_aui_form_inline_fieldgroup);
	
	var _aui_checkbox = __webpack_require__(347);
	
	var _aui_checkbox2 = _interopRequireDefault(_aui_checkbox);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MESSAGE_SOUNDS = '1';
	var VIDEO_SOUNDS = '2';
	var ALL_SOUNDS = '3';
	
	exports.default = React.createClass({
	
	  displayName: 'SoundsField',
	
	  mixins: [React.addons.PureRenderMixin],
	
	  propTypes: {
	    soundsEnabled: React.PropTypes.bool.isRequired,
	    messageSounds: React.PropTypes.bool.isRequired,
	    videoSounds: React.PropTypes.bool.isRequired
	  },
	
	  componentDidMount: function componentDidMount() {
	    AJS.$(this.refs.dropdown).auiSelect2({
	      minimumResultsForSearch: Infinity
	    }).on('change', this._onSoundPrefChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    AJS.$(this.refs.dropdown).off('change').auiSelect2('destroy');
	    AJS.$('#select2-drop-mask').remove();
	    AJS.$('.select2-sizer').remove();
	  },
	  _onSoundsEnabledChange: function _onSoundsEnabledChange(e) {
	    e.stopPropagation();
	    _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _preferences_keys2.default.SOUNDS_ENABLED, !this.props.soundsEnabled));
	  },
	  _onSoundPrefChange: function _onSoundPrefChange(e) {
	    var _PreferencesActions$s2;
	
	    var selected = e.target.value;
	    e.stopPropagation();
	
	    _preferences_actions2.default.savePreferences((_PreferencesActions$s2 = {}, (0, _defineProperty3.default)(_PreferencesActions$s2, _preferences_keys2.default.MESSAGE_SOUNDS, selected === ALL_SOUNDS || selected === MESSAGE_SOUNDS), (0, _defineProperty3.default)(_PreferencesActions$s2, _preferences_keys2.default.VIDEO_SOUNDS, selected === ALL_SOUNDS || selected === VIDEO_SOUNDS), _PreferencesActions$s2));
	  },
	  render: function render() {
	    var _props = this.props;
	    var soundsEnabled = _props.soundsEnabled;
	    var messageSounds = _props.messageSounds;
	    var videoSounds = _props.videoSounds;
	    var message_sounds_selected = messageSounds && !videoSounds ? MESSAGE_SOUNDS : false;
	    var video_sounds_selected = !messageSounds && videoSounds ? VIDEO_SOUNDS : false;
	    var all_sounds_selected = messageSounds && videoSounds ? ALL_SOUNDS : false;
	    var defaultDropDownValue = all_sounds_selected || video_sounds_selected || message_sounds_selected;
	    var dropDownDisabled = !soundsEnabled;
	    var classes = (0, _classnames2.default)({
	      'sounds-preference': true,
	      'checkbox-select2-field': true,
	      'disabled': dropDownDisabled
	    });
	
	    return React.createElement(
	      _aui_form_inline_fieldgroup2.default,
	      { className: classes, key: _preferences_keys2.default.SOUNDS_ENABLED },
	      React.createElement(
	        'div',
	        { className: 'checkbox' },
	        React.createElement(_aui_checkbox2.default, {
	          id: _preferences_keys2.default.SOUNDS_ENABLED,
	          defaultChecked: soundsEnabled,
	          onClick: this._onSoundsEnabledChange }),
	        React.createElement(
	          'label',
	          { className: 'select-title', htmlFor: _preferences_keys2.default.SOUNDS_ENABLED },
	          _dialog_strings2.default.play_sound_part_1
	        ),
	        React.createElement(
	          'select',
	          {
	            defaultValue: defaultDropDownValue,
	            ref: 'dropdown',
	            disabled: dropDownDisabled,
	            'aria-disabled': dropDownDisabled },
	          React.createElement(
	            'option',
	            { value: MESSAGE_SOUNDS },
	            _dialog_strings2.default.message_notifications
	          ),
	          React.createElement(
	            'option',
	            { value: VIDEO_SOUNDS },
	            _dialog_strings2.default.video_notifications
	          ),
	          React.createElement(
	            'option',
	            { value: ALL_SOUNDS },
	            _dialog_strings2.default.message_and_video_notifications
	          )
	        ),
	        React.createElement(
	          'label',
	          { className: 'select-title', htmlFor: _preferences_keys2.default.SOUNDS_ENABLED },
	          _dialog_strings2.default.play_sound_part_2
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _aui_form_fieldset = __webpack_require__(357);
	
	var _aui_form_fieldset2 = _interopRequireDefault(_aui_form_fieldset);
	
	var _aui_radio = __webpack_require__(349);
	
	var _aui_radio2 = _interopRequireDefault(_aui_radio);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "RoomNotificationsForm",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  _getNotificationSettings: function _getNotificationSettings() {
	    return {
	      level: _preferences_store2.default.getGlobalNotificationSetting()
	    };
	  },
	
	  _saveNotificationSettings: function _saveNotificationSettings(newSettings) {
	    _preferences_store2.default.setGlobalNotificationSetting(newSettings.level);
	  },
	
	  _onChange: function _onChange(event) {
	    var newValue = event.target.value.trim();
	
	    // if they've actually changed the value, fire an analytics event
	    if (this.state.level !== newValue) {
	      _analytics_actions2.default.globalNotificationLevelChanged(this.state.level, newValue);
	    }
	    this.setState({ level: newValue });
	    this._saveNotificationSettings({ level: newValue });
	  },
	
	  _getState: function _getState() {
	    var settings = this._getNotificationSettings(),
	        notification_level = _.get(settings, "level", "global");
	    return {
	      mention: _current_user_store2.default.get('mention') || '',
	      level: notification_level
	    };
	  },
	
	  _showSettingsDialog: function _showSettingsDialog() {
	    _dialog_actions2.default.showSettingDialog();
	  },
	
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  render: function render() {
	    return React.createElement(
	      "form",
	      { id: "room-notifications-form", ref: "form", className: "aui per-room-notifs", onChange: this._onChange },
	      React.createElement(
	        "h3",
	        null,
	        _dialog_strings2.default.notify_rooms_header
	      ),
	      React.createElement(
	        _aui_form_fieldset2.default,
	        { ref: "override-opts" },
	        React.createElement(_aui_radio2.default, { id: "notif-loud",
	          name: "notification",
	          defaultChecked: this.state.level === "loud",
	          value: "loud",
	          icon: "volume-loud",
	          label: _forms_strings2.default.label.loud,
	          description: _forms_strings2.default.description.notif_loud }),
	        React.createElement(_aui_radio2.default, { id: "notif-normal",
	          name: "notification",
	          defaultChecked: this.state.level === "normal",
	          value: "normal",
	          icon: "volume-normal",
	          label: _forms_strings2.default.label.normal,
	          description: _forms_strings2.default.description.notif_normal(this.state.mention) }),
	        React.createElement(_aui_radio2.default, { id: "notif-quiet",
	          name: "notification",
	          defaultChecked: this.state.level === "quiet",
	          value: "quiet",
	          icon: "volume-quiet",
	          label: _forms_strings2.default.label.quiet,
	          description: _forms_strings2.default.description.notif_quiet(this.state.mention) })
	      )
	    );
	  }
	});

/***/ },
/* 357 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = React.createClass({
	
	  displayName: "AuiFormFieldSet",
	
	  render: function render() {
	    var classNames = this.props.className || "";
	    return React.createElement(
	      "fieldset",
	      { className: "group " + classNames },
	      React.createElement(
	        "legend",
	        null,
	        React.createElement(
	          "label",
	          { htmlFor: this.props.id },
	          this.props.label
	        )
	      ),
	      this.props.children
	    );
	  }
	
	});

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _aui_radio = __webpack_require__(349);
	
	var _aui_radio2 = _interopRequireDefault(_aui_radio);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'DoNotDisturbForm',
	
	  mixins: [React.addons.PureRenderMixin],
	
	  propTypes: {
	    notifyForVideo: React.PropTypes.bool.isRequired,
	    notifyAlways: React.PropTypes.bool.isRequired
	  },
	
	  _onChange: function _onChange(e) {
	    var _PreferencesActions$s;
	
	    var notify_always = e.target.id === _preferences_keys2.default.NOTIFY_WHEN_DND,
	        notify_for_video = e.target.id === _preferences_keys2.default.NOTIFY_FOR_VIDEO_WHEN_DND;
	
	    e.stopPropagation();
	    _preferences_actions2.default.savePreferences((_PreferencesActions$s = {}, (0, _defineProperty3.default)(_PreferencesActions$s, _preferences_keys2.default.NOTIFY_FOR_VIDEO_WHEN_DND, notify_for_video), (0, _defineProperty3.default)(_PreferencesActions$s, _preferences_keys2.default.NOTIFY_WHEN_DND, notify_always), _PreferencesActions$s));
	  },
	  render: function render() {
	    var true_dnd = !this.props.notifyForMessages && !this.props.notifyForMessages;
	
	    return React.createElement(
	      'form',
	      { className: 'aui', onChange: this._onChange },
	      React.createElement(
	        'h3',
	        null,
	        _dialog_strings2.default.dnd_header
	      ),
	      React.createElement(
	        'fieldset',
	        null,
	        React.createElement(_aui_radio2.default, {
	          id: 'trueDND',
	          name: 'dnd_setting',
	          defaultChecked: true_dnd,
	          label: _dialog_strings2.default.do_not_notify_when_dnd }),
	        React.createElement(_aui_radio2.default, {
	          id: _preferences_keys2.default.NOTIFY_FOR_VIDEO_WHEN_DND,
	          name: 'dnd_setting',
	          defaultChecked: this.props.notifyForVideo,
	          label: _dialog_strings2.default.notify_for_video_when_dnd }),
	        React.createElement(_aui_radio2.default, {
	          id: _preferences_keys2.default.NOTIFY_WHEN_DND,
	          name: 'dnd_setting',
	          defaultChecked: this.props.notifyAlways,
	          label: _dialog_strings2.default.notify_when_dnd })
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ModalDialog = __webpack_require__(341),
	    InviteUsersForm = __webpack_require__(360),
	    strings = __webpack_require__(203),
	    RoomsNavStore = __webpack_require__(368),
	    utils = __webpack_require__(99),
	    ieSubmitMixin = __webpack_require__(369),
	    DialogVisibilityMixin = __webpack_require__(342);
	
	module.exports = React.createClass({
	
	  displayName: "InviteUserDialog",
	
	  mixins: [ieSubmitMixin, DialogVisibilityMixin],
	
	  componentDidMount: function componentDidMount() {
	    RoomsNavStore.on(['change'], this._onStoreChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    RoomsNavStore.off(['change'], this._onStoreChange);
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getActiveChatState();
	  },
	
	  _getActiveChatState: function _getActiveChatState() {
	    return {
	      active_chat: RoomsNavStore.get("active_chat"),
	      rooms: RoomsNavStore.get("rooms")
	    };
	  },
	
	  _onStoreChange: function _onStoreChange() {
	    this.setState(this._getActiveChatState());
	  },
	
	  _dialogTitle: function _dialogTitle() {
	    return strings.invite_users(utils.room.get_room_name(_.keyBy(this.state.rooms.rooms, 'jid'), this.state.active_chat));
	  },
	
	  _dialogBody: function _dialogBody() {
	    if (utils.jid.is_room(this.state.active_chat)) {
	      var type = this.state.dialogData ? this.state.dialogData.type : false;
	      return React.createElement(InviteUsersForm, { type: type, dialogVisible: this.state.dialogVisible, room_jid: this.state.active_chat, invite_user_jids: this.props.invite_users });
	    }
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { form: "invite-users-form", className: "aui-button aui-button-primary", type: "submit", onClick: this.ieSubmit },
	      "Invite people"
	    );
	  },
	
	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "invite-users-dialog",
	      title: this._dialogTitle(),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel" });
	  }
	});

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _aui_select2_fieldgroup = __webpack_require__(361);
	
	var _aui_select2_fieldgroup2 = _interopRequireDefault(_aui_select2_fieldgroup);
	
	var _aui_textarea_fieldgroup = __webpack_require__(363);
	
	var _aui_textarea_fieldgroup2 = _interopRequireDefault(_aui_textarea_fieldgroup);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _forms_store = __webpack_require__(365);
	
	var _forms_store2 = _interopRequireDefault(_forms_store);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	var _form_error_strings = __webpack_require__(366);
	
	var _form_error_strings2 = _interopRequireDefault(_form_error_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _analytics_keys = __webpack_require__(197);
	
	var _analytics_keys2 = _interopRequireDefault(_analytics_keys);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _user_utils = __webpack_require__(126);
	
	var _user_utils2 = _interopRequireDefault(_user_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NO_MATCHES_FOUND_LINK_ID = 'invite-users-select-no-matches-found';
	
	exports.default = React.createClass({
	
	  displayName: "InviteUsersForm",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    _forms_store2.default.on(['change:activeChatParticipants', 'change:users', 'change:web_server'], this._onChange);
	    this.shouldAutoFocus = true;
	    document.addEventListener('click', this._onDocumentClick, true);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.dialogVisible && this.shouldAutoFocus) {
	      this._focusInput();
	      this.shouldAutoFocus = false;
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _forms_store2.default.off(['change:activeChatParticipants', 'change:users', 'change:web_server'], this._onChange);
	    document.removeEventListener('click', this._onDocumentClick, true);
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _getState: function _getState() {
	    return {
	      user_is_admin: _forms_store2.default.get("user_is_admin"),
	      invite_url: _forms_store2.default.get("invite_url"),
	      web_server: _forms_store2.default.get("web_server"),
	      users: _forms_store2.default.get("users"),
	      jid: _current_user_store2.default.get('jid'),
	      activeChatParticipants: _forms_store2.default.get("activeChatParticipants"),
	      errors: _.get(this, 'state.errors', {})
	    };
	  },
	
	  _onDocumentClick: function _onDocumentClick(evt) {
	    if (evt.target.id === NO_MATCHES_FOUND_LINK_ID) {
	      if (evt.target.getAttribute('target') === '_blank') {
	        evt.stopPropagation();
	        return;
	      }
	      evt.preventDefault();
	      _dialog_actions2.default.showInviteTeammatesDialog({ type: _analytics_keys2.default.INVITE_USERS_DIALOG, default_text: evt.target.getAttribute('data-term') });
	      _analytics_actions2.default.inviteTeamClickedEvent(_analytics_keys2.default.INVITE_USERS_DIALOG);
	    }
	  },
	
	
	  _rosterForSelect: function _rosterForSelect() {
	    var nonGuestUsers = _utils2.default.roster.get_non_guest_users(this.state.users);
	
	    return _utils2.default.roster.format_for_select2(_.union(this.state.jid, this.state.activeChatParticipants), nonGuestUsers);
	  },
	
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(ReactDOM.findDOMNode(this.refs.form)).serializeArray(),
	        users = form_inputs[0].value,
	        msg = _utils2.default.strings.stripHiddenCharacters(form_inputs[1].value.trim()).slice(0, 250),
	        promises = [],
	        errors;
	
	    errors = this._validate(users, msg);
	    if (errors) {
	      this.setState({
	        errors: errors
	      });
	    } else {
	      promises.push(this._inviteUsers(users.split(','), msg));
	      this._handlePromises(promises);
	      this._closeDialog();
	    }
	  },
	
	  _validate: function _validate(users, msg) {
	    if (!users) {
	      return {
	        user: _form_error_strings2.default.invite_users_form.no_users
	      };
	    }
	  },
	
	  _inviteUsers: function _inviteUsers(user_jids, msg) {
	    var _this = this;
	
	    return new _promise2.default(function (resolve) {
	      _form_actions2.default.inviteUsers({
	        room_jid: _this.props.room_jid,
	        user_jids: user_jids,
	        reason: msg
	      });
	      resolve(user_jids);
	    });
	  },
	
	  _handlePromises: function _handlePromises(promises) {
	    _promise2.default.all(promises).then(function (data) {
	      this._throwFlagSuccess();
	      if (this.props.type) {
	        _analytics_actions2.default.inviteUsersToRoomSent(this.props.type, data[0].length);
	      }
	    }.bind(this), function () {
	      this._throwFlagError();
	    }.bind(this));
	  },
	
	  _throwFlagSuccess: function _throwFlagSuccess() {
	    _flag_actions2.default.showFlag({
	      type: "success",
	      body: _forms_strings2.default.success.users_invited,
	      close: "auto"
	    });
	  },
	
	  _throwFlagError: function _throwFlagError() {
	    _flag_actions2.default.showFlag({
	      type: "error",
	      body: this._flagErrorActions(_forms_strings2.default.fail.invite_fail),
	      close: "manual"
	    });
	  },
	
	  _flagErrorActions: function _flagErrorActions(error_msg) {
	    var _this2 = this;
	
	    return function () {
	      return React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "p",
	          { className: "hc-message-body" },
	          error_msg
	        ),
	        React.createElement(
	          "ul",
	          { className: "aui-nav-actions-list" },
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { onClick: _this2._flagActionClick, href: "#" },
	              "strings.button.try_again"
	            )
	          )
	        )
	      );
	    };
	  },
	
	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".hc-flag").data('flag-index');
	    _flag_actions2.default.removeFlag(flag_index);
	    this._showDialog();
	  },
	
	  _showDialog: function _showDialog() {
	    _dialog_actions2.default.showInviteUsersDialog();
	  },
	
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  _focusInput: function _focusInput() {
	    // Can't use the ref here, because the Select2 plugin has it's own abstraction.
	    ReactDOM.findDOMNode(this).querySelector('input[type=text]:first-of-type').focus();
	  },
	
	  _selectFormatNoMatches: function _selectFormatNoMatches(term) {
	
	    var link = '';
	
	    if (this.state.user_is_admin || this.state.invite_url) {
	
	      link = "<a href=\"#\" data-term=\"" + term + "\" id=\"" + NO_MATCHES_FOUND_LINK_ID + "\" className=\"aui-inline-dialog-trigger\">" + _common_strings2.default.buttons.invite_team_in_invite_users_dialog + "</a>";
	
	      if (!this.state.invite_url) {
	        link = "<a href=\"https://" + this.state.web_server + "/admin\" target=\"_blank\" id=\"" + NO_MATCHES_FOUND_LINK_ID + "\" className=\"aui-inline-dialog-trigger\">" + _common_strings2.default.buttons.invite_team_in_invite_users_dialog + "</a>";
	      }
	    }
	
	    return _common_strings2.default.no_one_found + ". " + link;
	  },
	
	  render: function render() {
	    var errors = this.state.errors;
	    return React.createElement(
	      "form",
	      { id: "invite-users-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(_aui_select2_fieldgroup2.default, {
	        id: "invite-users-people",
	        label: _forms_strings2.default.label.these_people,
	        multiple: true,
	        data: this._rosterForSelect(),
	        selected: this.props.invite_user_jids,
	        sortResults: function sortResults(results, ctx, search) {
	          return _user_utils2.default.sort_users(results, search.term, 'text');
	        },
	        error: errors.user,
	        ref: "user_select",
	        formatNoMatches: this._selectFormatNoMatches
	      }),
	      React.createElement(_aui_textarea_fieldgroup2.default, {
	        id: "invite-users-message",
	        label: _forms_strings2.default.label.message,
	        rows: "5",
	        maxLength: "250",
	        ref: "invite_message" })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var AuiFormFieldGroup = __webpack_require__(353),
	    AuiSelect2Input = __webpack_require__(362);
	
	module.exports = React.createClass({
	
	  displayName: "AuiSelect2FieldGroup",
	
	  render: function render() {
	    var _props = this.props;
	    var id = _props.id;
	    var size = _props.size;
	    var name = _props.name;
	    var placeholder = _props.placeholder;
	    var multiple = _props.multiple;
	    var selected = _props.selected;
	    var maxDisplayedItems = _props.maxDisplayedItems;
	    var data = _props.data;
	    var formatNoMatches = _props.formatNoMatches;
	    var sortResults = _props.sortResults;
	
	
	    var select2Options = {
	      id: id, size: size, name: name,
	      placeholder: placeholder, multiple: multiple, selected: selected,
	      maxDisplayedItems: maxDisplayedItems, data: data, formatNoMatches: formatNoMatches
	    };
	
	    if (sortResults) {
	      select2Options.sortResults = sortResults;
	    }
	
	    return React.createElement(
	      AuiFormFieldGroup,
	      this.props,
	      React.createElement(AuiSelect2Input, select2Options)
	    );
	  }
	
	});

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "AuiSelect2Input",
	
	  propTypes: {
	    multiple: React.PropTypes.bool,
	    placeholder: React.PropTypes.string,
	    data: React.PropTypes.array,
	    sortResults: React.PropTypes.func,
	    maxDisplayedItems: React.PropTypes.number,
	    selected: React.PropTypes.array
	  },
	
	  componentDidMount: function componentDidMount() {
	    this._setupSelect();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    AJS.$(ReactDOM.findDOMNode(this)).auiSelect2("destroy");
	    AJS.$("#select2-drop-mask").remove();
	    AJS.$(".select2-sizer").remove();
	  },
	
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return !_.isEqual(nextProps, this.props);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._setupSelect();
	  },
	
	
	  getDefaultProps: function getDefaultProps() {
	    var _this = this;
	
	    return {
	      multiple: false,
	      placeholder: "",
	      data: [],
	      sortResults: function sortResults(results) {
	        return results.slice(0, _this.maxDisplayedItems);
	      },
	      maxDisplayedItems: _app_config2.default.select2_max_displayed_items,
	      selected: [],
	      formatNoMatches: function formatNoMatches() {
	        return 'No matches found.';
	      }
	    };
	  },
	
	  _setupSelect: function _setupSelect() {
	    var options = this._getSelectOptions();
	    AJS.$(ReactDOM.findDOMNode(this)).auiSelect2(options);
	    if (options.selected && options.selected.length > 0) {
	      AJS.$(ReactDOM.findDOMNode(this)).val(options.selected).trigger("change");
	    }
	  },
	
	  _getSelectOptions: function _getSelectOptions() {
	    var _this2 = this;
	
	    return {
	      multiple: this.props.multiple,
	      placeholder: this.props.placeholder,
	      data: this.props.data,
	      selected: this.props.selected,
	      sortResults: function sortResults() {
	        var _props;
	
	        return (_props = _this2.props).sortResults.apply(_props, arguments).slice(0, _this2.props.maxDisplayedItems);
	      },
	      formatNoMatches: this.props.formatNoMatches
	    };
	  },
	
	  render: function render() {
	    var name = this.props.name || this.props.id,
	        classes = this.props.size ? "aui-select2 " + this.props.size : "aui-select2";
	
	    return React.createElement("input", { type: "hidden", id: this.props.id, className: classes, name: name });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var AuiFormFieldGroup = __webpack_require__(353),
	    AuiTextArea = __webpack_require__(364);
	
	module.exports = React.createClass({
	
	  displayName: "AuiTextAreaFieldGroup",
	
	  render: function render() {
	    return React.createElement(
	      AuiFormFieldGroup,
	      this.props,
	      React.createElement(AuiTextArea, this.props)
	    );
	  }
	});

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "AuiTextarea",
	
	  propTypes: {
	    onChange: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onBlur: React.PropTypes.func
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onChange: function onChange() {},
	      onFocus: function onFocus() {},
	      onBlur: function onBlur() {}
	    };
	  },
	
	  render: function render() {
	
	    var name = this.props.name || this.props.id;
	    var classes = this.props.size ? "textarea " + this.props.size : "textarea";
	
	    return React.createElement("textarea", (0, _extends3.default)({}, this.props, { className: classes, name: name }));
	  }
	
	});

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FormsStore = function (_Store) {
	  (0, _inherits3.default)(FormsStore, _Store);
	
	  function FormsStore() {
	    (0, _classCallCheck3.default)(this, FormsStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(FormsStore).call(this));
	  }
	
	  (0, _createClass3.default)(FormsStore, [{
	    key: "getDefaults",
	    value: function getDefaults() {
	      return {
	        activeChat: null,
	        activeChatParticipants: [],
	        roomNames: [],
	        users: {},
	        user_is_admin: false,
	        web_server: _app_config2.default.default_web_server,
	        invite_url: false
	      };
	    }
	  }, {
	    key: "registerListeners",
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(data) {
	          _this2.set({
	            user_is_admin: data.is_admin,
	            invite_url: data.invite_url
	          });
	        }
	      });
	
	      _app_dispatcher2.default.register({
	        'updated:activeRooms': function updatedActiveRooms() {
	          if (_this2.data.activeChat) {
	            _this2.handleActiveChatUpdate(_this2.data.activeChat.jid);
	          }
	        },
	        'updated:allRooms': function updatedAllRooms(rooms) {
	          _this2.handleAllRoomsUpdate(rooms);
	        },
	        'updated:roster': function updatedRoster(roster) {
	          _this2.handleRosterUpdate(roster);
	        },
	        'updated:active_chat': function updatedActive_chat(active_chat_jid) {
	          _this2.handleActiveChatUpdate(active_chat_jid);
	        },
	        'updated:web_server': function updatedWeb_server(web_server) {
	          _this2.set("web_server", web_server);
	        }
	      });
	    }
	  }, {
	    key: "handleAllRoomsUpdate",
	    value: function handleAllRoomsUpdate(rooms) {
	      var roomNames = _.map(rooms, 'name');
	      this.set("roomNames", roomNames);
	    }
	  }, {
	    key: "handleRosterUpdate",
	    value: function handleRosterUpdate(roster) {
	      var users = _.keyBy(_.map(roster, function (user) {
	        var is_guest = !!user.is_guest;
	
	        return {
	          name: user.name,
	          jid: user.jid,
	          id: Number(user.id),
	          is_guest: is_guest
	        };
	      }), "jid");
	
	      this.set("users", users);
	    }
	  }, {
	    key: "handleActiveChatUpdate",
	    value: function handleActiveChatUpdate(active_chat_jid) {
	      var active_chat,
	          active_chat_participants = [],
	          active_rooms = _application_store2.default.get("activeRooms");
	
	      if (active_rooms) {
	        active_chat = active_rooms[active_chat_jid];
	        if (active_chat) {
	          this.set({
	            activeChat: active_chat
	          });
	          _.each(active_chat.participants, function (group) {
	            _.each(group, function (jid) {
	              active_chat_participants.push(jid);
	            });
	          });
	        }
	        if (active_chat_participants.length) {
	          this.set({
	            activeChatParticipants: active_chat_participants
	          });
	        }
	      }
	    }
	  }]);
	  return FormsStore;
	}(_store2.default);
	
	module.exports = new FormsStore();

/***/ },
/* 366 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  create_room_form: {
	    no_permisions: "Your administrator has restricted creating rooms.",
	    no_room_name: "Every room needs a name.",
	    room_already_exists: "That room name is already taken",
	    name_too_long: "That name is too long. You'll have to shorten it."
	  },
	  rename_room_form: {
	    no_room_name: "Every room needs a name.",
	    same_name: "That's the same name.",
	    name_too_long: "That name is too long. You'll have to shorten it.",
	    room_already_exists: "The room name is already taken"
	  },
	  invite_users_form: {
	    no_users: "Who do you want to invite?"
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 367 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps) || !_.isEqual(this.state, nextState);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _network_status_helper = __webpack_require__(218);
	
	var _network_status_helper2 = _interopRequireDefault(_network_status_helper);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _avatar_helper = __webpack_require__(258);
	
	var _avatar_helper2 = _interopRequireDefault(_avatar_helper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RoomsNavStore = function (_Store) {
	  (0, _inherits3.default)(RoomsNavStore, _Store);
	
	  function RoomsNavStore() {
	    (0, _classCallCheck3.default)(this, RoomsNavStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RoomsNavStore).call(this));
	
	    _this.local = {
	      auto_join: [],
	      closedChatsIndex: {}
	    };
	
	    _this.savePrefsDebounced = _.debounce(_this.savePrefs, 2000, { leading: false, trailing: true });
	    return _this;
	  }
	
	  (0, _createClass3.default)(RoomsNavStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        current_user: {},
	        active_chat: _preferences_store2.default.getChatToFocus(),
	        active_chat_type: '',
	        rooms: {
	          people: [],
	          rooms: []
	        },
	        room_order: [],
	        search_nav_item_visible: false,
	        group_name: "",
	        group_avatar_url: "",
	        group_avatar_bg: "",
	        feature_flags: {},
	        drag_target: false,
	        drag_over_target: false,
	        drag_over_clientY: false,
	        dragging: false,
	        ui_available: false
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'app-state-ready': function appStateReady() {
	          _this2.hc_init_complete = true;
	        },
	        'updated:ui_available': function updatedUi_available(val) {
	          // This is the point where the preloader has been hidden
	          _this2.set("ui_available", val);
	        }
	      });
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(config) {
	          _this2.handleConfig(config);
	        },
	        'updated:current_user': function updatedCurrent_user(user) {
	          _this2.set('current_user', user);
	        },
	        'updated:roster': function updatedRoster(roster) {
	          _this2.handleRosterUpdate(roster);
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          _this2.handleRoomsUpdate(rooms);
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.handleSelectRoom(jid);
	        },
	        'updated:profiles': function updatedProfiles(profiles) {
	          _this2.handleProfiles(profiles);
	        },
	        'room-closed': function roomClosed(_ref) {
	          var jid = _ref.jid;
	
	          _this2.handleRoomClosed(jid);
	        },
	        'search-history': function searchHistory() {
	          _this2.set('search_nav_item_visible', true);
	        },
	        'remove-search-nav-item': function removeSearchNavItem() {
	          _this2.set('search_nav_item_visible', false);
	        },
	        'update-room-order': function updateRoomOrder(room_jids) {
	          _this2.set({
	            drag_target: false
	          });
	          _this2.updateRoomOrder(room_jids);
	        },
	        "restore-room-order": function restoreRoomOrder(_ref2) {
	          var jid = _ref2.jid;
	
	          var oldIndex = _this2.local.closedChatsIndex[jid];
	          if (oldIndex !== undefined) {
	            var roomOrder = _.cloneDeep(_this2.data.room_order);
	            var newIndex = _this2.data.room_order.indexOf(jid);
	            if (oldIndex !== newIndex && oldIndex < _this2.data.room_order.length) {
	              roomOrder.splice(newIndex, 1);
	              roomOrder.splice(oldIndex, 0, jid);
	              _this2.updateRoomOrder(roomOrder);
	            }
	            if (_network_status_helper2.default.isOnline()) {
	              delete _this2.local.closedChatsIndex[jid];
	            }
	          }
	        },
	        'navigate-rooms': function navigateRooms(data) {
	          _this2.navigateRooms(data);
	        },
	        'rooms-nav-drag-start': function roomsNavDragStart(data) {
	          _this2.handleDragStart(data.target);
	        },
	        'rooms-nav-drag-over': function roomsNavDragOver(data) {
	          _this2.handleDragOver(data.event);
	        },
	        'rooms-nav-drag-end': function roomsNavDragEnd() {
	          _this2.handleDragEnd();
	        }
	      });
	    }
	
	    /**
	     * Helper method for grouping tabs (rooms first then people)
	     * @param {object} tabs
	     */
	
	  }, {
	    key: 'groupRooms',
	    value: function groupRooms(tabs) {
	      tabs = _.groupBy(_.reject(tabs, function (item) {
	        return !item || item.name === '';
	      }), function (chat) {
	        return chat.type === 'groupchat' ? 'rooms' : 'people';
	      });
	      return tabs;
	    }
	
	    /**
	     * Helper method for ordering rooms
	     * @param {array} rooms
	     */
	
	  }, {
	    key: 'orderRooms',
	    value: function orderRooms(rooms) {
	      if (this.data.room_order.length) {
	        var results = _.compact(_.map(this.data.room_order, function (jid) {
	          if (rooms[jid]) {
	            return rooms[jid];
	          }
	        }));
	        var newRooms = _.map(rooms, function (room) {
	          var newRoom = _.find(results, function (item) {
	            return room.jid === item.jid;
	          });
	          if (!newRoom) {
	            return room;
	          }
	        });
	        return _.compact(results.concat(newRooms));
	      }
	      return rooms;
	    }
	
	    /**
	     * Helper method for setting room_order array based on autoJoin or RoomsNavStore rooms
	     * @param {array} autoJoin
	     */
	
	  }, {
	    key: 'setRoomOrder',
	    value: function setRoomOrder(autoJoin) {
	      var _this3 = this;
	
	      var jids;
	      if (autoJoin) {
	        jids = _.map(autoJoin, function (room) {
	          return room.jid;
	        });
	      } else {
	        jids = _.flatten(_.map(['rooms', 'people'], function (groupName) {
	          return _.map(_this3.data.rooms[groupName], function (room) {
	            return room.jid;
	          });
	        }));
	      }
	      this.set({
	        room_order: jids
	      });
	    }
	  }, {
	    key: 'handleConfig',
	    value: function handleConfig(config) {
	      var group_avatar_url = _avatar_helper2.default.cleanAvatarURL(_.get(config, "group_avatar_url"));
	      this.set({
	        group_avatar_bg: _.get(config, "group_avatar_bg"),
	        group_avatar_url: group_avatar_url,
	        group_name: _.get(config, "group_name"),
	        feature_flags: _.get(config, "feature_flags")
	      });
	    }
	  }, {
	    key: 'handleRosterUpdate',
	    value: function handleRosterUpdate(roster) {
	      var _this4 = this;
	
	      _.map(roster, function (user, jid) {
	        var room = _.find(_this4.data.rooms['people'], function (chat) {
	          return chat.jid === jid;
	        });
	        if (room) {
	          _.assign(room.presence, roster[jid].presence);
	          if (_.get(user, "name")) {
	            room.name = user.name;
	          }
	        }
	      });
	
	      this.set({
	        rooms: this.data.rooms
	      });
	      this.setRoomOrder();
	    }
	
	    /**
	     * Handle rooms update - accepts activeRooms obj with jids as keys
	     * @param {object} activeRooms
	     */
	
	  }, {
	    key: 'handleRoomsUpdate',
	    value: function handleRoomsUpdate(activeRooms) {
	      var rooms = void 0;
	      var orderedRooms = void 0;
	
	      _.reject(activeRooms, function (room) {
	        return !room;
	      });
	      orderedRooms = this.orderRooms(activeRooms);
	      rooms = this.groupRooms(orderedRooms);
	      _.assign(this.data, {
	        rooms: _.defaults(rooms, { rooms: [], people: [] }),
	        active_chat: this.data.active_chat
	      });
	      if (this.hc_init_complete && !activeRooms[this.data.active_chat] && !_utils2.default.jid.is_search(this.data.active_chat)) {
	        this.data.active_chat = 'lobby';
	      }
	      this.saveRooms(orderedRooms, this.data.active_chat, this.data.rooms);
	    }
	  }, {
	    key: 'handleProfiles',
	    value: function handleProfiles(profiles) {
	      _.forOwn(this.data.rooms.people, function (chat) {
	        var name = _.get(profiles, '["' + chat.jid + '"].name');
	        if (name) {
	          chat.name = name;
	        }
	      });
	      this.set({
	        rooms: this.data.rooms
	      });
	    }
	  }, {
	    key: 'getRoomIndex',
	    value: function getRoomIndex(jid) {
	      return this.data.room_order.indexOf(jid);
	    }
	  }, {
	    key: 'getNextRoom',
	    value: function getNextRoom(jid) {
	      var nextRoom, idx;
	      if (this.data.room_order.length) {
	        idx = this.getRoomIndex(jid);
	        if (idx >= 0) {
	          if (idx === this.data.room_order.length - 1) {
	            idx--;
	          } else {
	            idx++;
	          }
	          if (idx > -1) {
	            nextRoom = this.data.room_order[idx];
	          }
	        }
	      }
	      return nextRoom || "lobby";
	    }
	  }, {
	    key: 'handleRoomClosed',
	    value: function handleRoomClosed(jid) {
	      var index = this.getRoomIndex(jid);
	      if (index !== -1) {
	        this.local.closedChatsIndex[jid] = index;
	      }
	      if (jid === this.data.active_chat) {
	        var data = {
	          jid: this.getNextRoom(jid),
	          isClosed: true
	        };
	        _app_dispatcher2.default.dispatch('set-route', data);
	        _analytics_dispatcher2.default.dispatch('analytics-select-room', data);
	      }
	      _app_dispatcher2.default.dispatch('close-file-viewer');
	    }
	  }, {
	    key: 'handleSelectRoom',
	    value: function handleSelectRoom(jid) {
	      var inRoster = _.find(this.data.rooms.rooms, { jid: jid }) || _.find(this.data.rooms.people, { jid: jid });
	      var selectedJid = inRoster || _utils2.default.jid.is_search(jid) ? jid : 'lobby';
	      _.map(this.data.rooms, function (group) {
	        _.assign(_.find(group, function (room) {
	          return room.jid === jid;
	        }));
	      });
	      this.set({
	        rooms: this.data.rooms,
	        active_chat: selectedJid
	      });
	      this.setRoomOrder();
	      if (this.hc_init_complete) {
	        this.savePrefsDebounced();
	      }
	    }
	  }, {
	    key: 'navigateRooms',
	    value: function navigateRooms(instructions) {
	      var _this5 = this;
	
	      var roomIndex = _.findIndex(this.data.room_order, function (jid) {
	        return jid === _this5.data.active_chat;
	      });
	
	      if (instructions.direction === "up") {
	        this.navigateRoomsUp(roomIndex);
	      } else if (instructions.direction === "down") {
	        this.navigateRoomsDown(roomIndex);
	      } else if (instructions.direction === "top") {
	        this.navigateToTopChat();
	      } else if (instructions.direction === "bottom") {
	        this.navigateToBottomChat();
	      } else if (instructions.direction === "index") {
	        this.navigateToChatAtIndex(instructions.index);
	      }
	
	      _app_dispatcher2.default.dispatch('close-file-viewer');
	    }
	  }, {
	    key: 'navigateToTopChat',
	    value: function navigateToTopChat() {
	      var newJid = _.head(this.data.room_order);
	      if (newJid && newJid !== this.data.active_chat) {
	        _app_dispatcher2.default.dispatch('set-route', {
	          jid: newJid
	        });
	      }
	    }
	  }, {
	    key: 'navigateToBottomChat',
	    value: function navigateToBottomChat() {
	      var newJid = _.last(this.data.room_order);
	      if (newJid && newJid !== this.data.active_chat) {
	        _app_dispatcher2.default.dispatch('set-route', {
	          jid: newJid
	        });
	      }
	    }
	  }, {
	    key: 'navigateToChatAtIndex',
	    value: function navigateToChatAtIndex(index) {
	      var newJid = this.data.room_order[index];
	      if (newJid && newJid !== this.data.active_chat) {
	        _app_dispatcher2.default.dispatch('set-route', {
	          jid: newJid
	        });
	      }
	    }
	  }, {
	    key: 'navigateRoomsUp',
	    value: function navigateRoomsUp(roomIndex) {
	      var newJid;
	      if (roomIndex === -1 && _utils2.default.jid.is_lobby(this.data.active_chat)) {
	        newJid = this.data.room_order[this.data.room_order.length - 1];
	      } else if (roomIndex === 0) {
	        newJid = "lobby";
	      } else {
	        newJid = this.data.room_order[roomIndex - 1];
	      }
	
	      if (newJid) {
	        _app_dispatcher2.default.dispatch('set-route', {
	          jid: newJid
	        });
	      }
	    }
	  }, {
	    key: 'navigateRoomsDown',
	    value: function navigateRoomsDown(roomIndex) {
	      var newJid;
	      if (roomIndex === -1 && _utils2.default.jid.is_lobby(this.data.active_chat)) {
	        newJid = this.data.room_order[0];
	      } else if (roomIndex === this.data.room_order.length - 1) {
	        newJid = "lobby";
	      } else {
	        newJid = this.data.room_order[roomIndex + 1];
	      }
	
	      if (newJid) {
	        _app_dispatcher2.default.dispatch('set-route', {
	          jid: newJid
	        });
	      }
	    }
	
	    /* Takes array of room jids */
	
	  }, {
	    key: 'updateRoomOrder',
	    value: function updateRoomOrder(jids) {
	      var currentRoomData = [];
	      var fullRoomData = void 0;
	      var rooms = void 0;
	
	      currentRoomData = currentRoomData.concat(this.data.rooms["rooms"], this.data.rooms["people"]);
	      fullRoomData = _.map(jids, function (jid) {
	        return _.find(currentRoomData, function (item) {
	          return item.jid === jid;
	        });
	      });
	      rooms = _.groupBy(fullRoomData, function (chat) {
	        return chat.type === 'groupchat' ? 'rooms' : 'people';
	      });
	      this.saveRooms(fullRoomData, this.data.active_chat, rooms);
	    }
	  }, {
	    key: 'saveRooms',
	    value: function saveRooms(roomData, activeChat, roomObj) {
	      var autoJoin = _.map(roomData, function (room) {
	        return {
	          jid: room.jid,
	          name: room.name
	        };
	      });
	
	      this.set({
	        rooms: roomObj,
	        active_chat: activeChat
	      });
	      this.local.auto_join = autoJoin.length ? autoJoin : false;
	      if (this.hc_init_complete) {
	        this.savePrefsDebounced();
	        this.setRoomOrder();
	      }
	    }
	  }, {
	    key: 'savePrefs',
	    value: function savePrefs() {
	      var prefs = {};
	
	      prefs["autoJoin"] = this.local.auto_join;
	      if (this.data.active_chat !== 'search') {
	        prefs["chatToFocus"] = this.data.active_chat;
	      }
	
	      _preferences_actions2.default.savePreferences(prefs);
	    }
	  }, {
	    key: 'handleDragStart',
	    value: function handleDragStart(target) {
	      if (target) {
	        this.set({
	          drag_target: target,
	          dragging: true
	        });
	      }
	    }
	  }, {
	    key: 'handleDragOver',
	    value: function handleDragOver(event) {
	      if (event && event.target && event.clientY) {
	        this.set({
	          drag_over_target: event.target,
	          drag_over_clientY: event.clientY,
	          dragging: true
	        });
	      }
	    }
	  }, {
	    key: 'handleDragEnd',
	    value: function handleDragEnd() {
	      this.set({
	        drag_over_target: false,
	        drag_over_clientY: false,
	        dragging: false
	      });
	    }
	  }]);
	  return RoomsNavStore;
	}(_store2.default);
	
	module.exports = new RoomsNavStore();

/***/ },
/* 369 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*global Modernizr*/
	exports.default = {
	
	  ieSubmit: function ieSubmit(e) {
	
	    if (!Modernizr.formattribute) {
	
	      e.preventDefault();
	
	      var form = document.getElementById(e.target.getAttribute('form'));
	
	      if (form) {
	        var button = form.ownerDocument.createElement('input');
	        button.style.display = 'none';
	        button.type = 'submit';
	        form.appendChild(button).click();
	        form.removeChild(button);
	      }
	    }
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ModalDialog = __webpack_require__(341),
	    strings = __webpack_require__(203),
	    RemoveUsersForm = __webpack_require__(371),
	    ieSubmitMixin = __webpack_require__(369);
	
	module.exports = React.createClass({
	
	  displayName: "RemoveUserDialog",
	
	  mixins: [ieSubmitMixin],
	
	  _dialogTitle: function _dialogTitle() {
	    return strings.choose_removed_members;
	  },
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(RemoveUsersForm, null);
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { form: "remove-users-form", className: "aui-button aui-button-primary", type: "submit", onClick: this.ieSubmit },
	      strings.ok
	    );
	  },
	
	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "remove-users-dialog",
	      title: this._dialogTitle(),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel",
	      size: "small" });
	  }
	});

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _aui_checkbox_field = __webpack_require__(346);
	
	var _aui_checkbox_field2 = _interopRequireDefault(_aui_checkbox_field);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _forms_store = __webpack_require__(365);
	
	var _forms_store2 = _interopRequireDefault(_forms_store);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'RemoveUsersForm',
	
	  shouldComponentUpdate: function shouldComponentUpdate() {
	    return !ReactDOM.findDOMNode(this.refs['form']).querySelectorAll(':checked').length;
	  },
	  componentDidMount: function componentDidMount() {
	    _forms_store2.default.on(['change:users', 'change:activeChat', 'change:activeChatParticipants'], this._onChange);
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    ReactDOM.findDOMNode(this.refs.form).reset();
	    if ($(ReactDOM.findDOMNode(this.refs.form)).find('.aui-select2')) {
	      AJS.$(ReactDOM.findDOMNode(this.refs.form)).find('.aui-select2').auiSelect2('data', null);
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _forms_store2.default.off(['change:users', 'change:activeChat', 'change:activeChatParticipants'], this._onChange);
	  },
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _getState: function _getState() {
	    return {
	      activeChatParticipants: _forms_store2.default.get('activeChatParticipants'),
	      users: _forms_store2.default.get('users'),
	      activeChat: _forms_store2.default.get('activeChat')
	    };
	  },
	  _getName: function _getName(jid) {
	    return this.state.users[jid].name;
	  },
	  _getUID: function _getUID(jid) {
	    return Number(this.state.users[jid].id);
	  },
	  _isAdmin: function _isAdmin(jid) {
	    return _.includes(this.state.activeChat.admins, this._getUID(jid));
	  },
	  _sortParticipants: function _sortParticipants() {
	    var _this = this;
	
	    var participants = _.map(this.state.activeChatParticipants, function (jid) {
	      return {
	        jid: jid,
	        name: _this._getName(jid),
	        isAdmin: _this._isAdmin(jid)
	      };
	    });
	    return _.sortBy(participants, ['isAdmin', 'name']);
	  },
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(ReactDOM.findDOMNode(this.refs.form)).serializeArray(),
	        submit_data = {
	      room_jid: this.state.activeChat.jid,
	      user_jids: _.map(form_inputs, 'value')
	    };
	
	    if (submit_data.user_jids.length) {
	      _form_actions2.default.removeUsers(submit_data, this._handleResponse);
	    } else {
	      this._throwFlagError(_forms_strings2.default.fail.no_users_flag);
	    }
	    this._closeDialog();
	  },
	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = _.get(data, 'error.text.__text') ? data.error.text.__text : _forms_strings2.default.fail.remove_users;
	      this._throwFlagError(error_msg);
	    } else {
	      this._throwFlagSuccess(_forms_strings2.default.success.users_removed);
	    }
	  },
	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    _flag_actions2.default.showFlag({
	      type: 'success',
	      body: msg,
	      close: 'auto'
	    });
	  },
	  _throwFlagError: function _throwFlagError(error) {
	    _flag_actions2.default.showFlag({
	      type: 'error',
	      body: this._flagBody(error),
	      close: 'manual'
	    });
	  },
	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest('.hc-flag').data('flag-index');
	    _flag_actions2.default.removeFlag(flag_index);
	    this._showDialog();
	  },
	  _flagBody: function _flagBody(error_msg) {
	    var _this2 = this;
	
	    return function () {
	      return React.createElement(
	        'div',
	        null,
	        React.createElement(
	          'p',
	          { className: 'hc-message-body' },
	          error_msg
	        ),
	        React.createElement(
	          'ul',
	          { className: 'aui-nav-actions-list' },
	          React.createElement(
	            'li',
	            null,
	            React.createElement(
	              'a',
	              { onClick: _this2._flagActionClick, href: '#' },
	              _forms_strings2.default.button.try_again
	            )
	          )
	        )
	      );
	    };
	  },
	  _showDialog: function _showDialog() {
	    _dialog_actions2.default.showRemoveUsersDialog();
	  },
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	  render: function render() {
	    var sortedParticipants = this._sortParticipants();
	    return React.createElement(
	      'form',
	      { id: 'remove-users-form', ref: 'form', className: 'aui', onSubmit: this._onSubmit },
	      React.createElement(
	        'div',
	        null,
	        _forms_strings2.default.description.choose_people_to_remove
	      ),
	      _.map(sortedParticipants, function (user, index) {
	        return React.createElement(_aui_checkbox_field2.default, { id: user.jid, value: user.jid, label: user.name, disabled: user.isAdmin, key: index });
	      })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ModalDialog = __webpack_require__(341),
	    strings = __webpack_require__(203),
	    CreateRoomForm = __webpack_require__(373),
	    ieSubmitMixin = __webpack_require__(369),
	    DialogVisibilityMixin = __webpack_require__(342),
	    cx = __webpack_require__(313);
	
	module.exports = React.createClass({
	
	  displayName: "CreateRoomDialog",
	
	  mixins: [ieSubmitMixin, DialogVisibilityMixin],
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(CreateRoomForm, { dialogVisible: this.state.dialogVisible,
	      loading: this.props.btnLoading,
	      room_name: this.props.room_name,
	      room_topic: this.props.room_topic,
	      privacy: this.props.privacy });
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    var btnClasses = cx({
	      'aui-button': true,
	      'aui-button-primary': true
	    });
	
	    return React.createElement(
	      "button",
	      { form: "create-room-form", className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading, type: "submit", onClick: this.ieSubmit },
	      strings.create_room
	    );
	  },
	
	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "create-room-dialog",
	      title: strings.create_a_new_room,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      btnLoading: this.props.btnLoading,
	      closeLinkText: "Cancel" });
	  }
	});

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _aui_input_fieldgroup = __webpack_require__(352);
	
	var _aui_input_fieldgroup2 = _interopRequireDefault(_aui_input_fieldgroup);
	
	var _room_privacy_radios = __webpack_require__(374);
	
	var _room_privacy_radios2 = _interopRequireDefault(_room_privacy_radios);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _room_nav_actions = __webpack_require__(288);
	
	var _room_nav_actions2 = _interopRequireDefault(_room_nav_actions);
	
	var _forms_store = __webpack_require__(365);
	
	var _forms_store2 = _interopRequireDefault(_forms_store);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	var _form_error_strings = __webpack_require__(366);
	
	var _form_error_strings2 = _interopRequireDefault(_form_error_strings);
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "CreateRoomForm",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    _forms_store2.default.on('change:roomNames', this._onChange);
	    this.shouldAutoFocus = true;
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _forms_store2.default.off('change:roomNames', this._onChange);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.errors.name || this.props.dialogVisible && this.shouldAutoFocus) {
	      this._focusInput();
	      this.shouldAutoFocus = false;
	    }
	  },
	
	  getInitialState: function getInitialState() {
	    var initialState = _.extend({
	      room_name: this.props.room_name || null,
	      room_topic: this.props.room_topic || null,
	      privacy: this.props.privacy || "public"
	    }, this._getState());
	    return initialState;
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _getState: function _getState() {
	    return {
	      roomNames: _forms_store2.default.get("roomNames"),
	      errors: {}
	    };
	  },
	
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(this.refs.form).serializeArray(),
	        privacy = form_inputs[2] ? form_inputs[2].value : "public",
	        submit_data = {
	      name: form_inputs[0].value.trim(),
	      topic: form_inputs[1] ? form_inputs[1].value.trim() : "",
	      privacy: privacy
	    };
	
	    var errors = this._validateFormData(submit_data);
	    if (errors) {
	      this.setState({ errors: errors, privacy: privacy });
	    } else {
	      this.setState({ errors: {}, privacy: privacy });
	      _dialog_actions2.default.startBtnLoading();
	      _form_actions2.default.createRoom(submit_data, this._handleResponse);
	    }
	  },
	
	  _validateFormData: function _validateFormData(formData) {
	    var errors = {};
	
	    // validate room name
	    if (!formData.name) {
	      errors.name = _form_error_strings2.default.create_room_form.no_room_name;
	    } else if (formData.name.length > 50) {
	      errors.name = _form_error_strings2.default.create_room_form.name_too_long;
	    } else if (_.find(this.state.roomNames, function (roomName) {
	      return _.isString(roomName) && roomName.toLowerCase() === formData.name.toLowerCase();
	    })) {
	      errors.name = _form_error_strings2.default.create_room_form.room_already_exists;
	    }
	
	    // validate room topic
	    if (formData.topic.length > _app_config2.default.max_topic_text_length) {
	      errors.topic = _chat_header_strings2.default.topic_length_error(_app_config2.default.max_topic_text_length);
	    }
	
	    return !_.isEmpty(errors) ? errors : null;
	  },
	
	  _handleResponse: function _handleResponse(error, room) {
	    if (error) {
	      this.setState({
	        errors: {
	          name: error.status === 403 ? _form_error_strings2.default.create_room_form.no_permisions : error.message || _forms_strings2.default.fail.create_room
	        }
	      });
	      _dialog_actions2.default.stopBtnLoading();
	    } else {
	      var name = room.name || "Room",
	          success_msg = _forms_strings2.default.success.room_created(name);
	      this._throwFlagSuccess(success_msg);
	      _room_nav_actions2.default.select(room.jid, 'groupchat');
	    }
	  },
	
	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    _flag_actions2.default.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },
	
	  _showDialog: function _showDialog() {
	    _dialog_actions2.default.showCreateRoomDialog();
	  },
	
	  _focusInput: function _focusInput() {
	    document.getElementById('create-room-name').focus();
	  },
	
	  render: function render() {
	    var errors = this.state.errors;
	    var room_name = this.state.room_name;
	    var room_topic = this.state.room_topic;
	    var privacy = this.state.privacy;
	    return React.createElement(
	      "form",
	      { id: "create-room-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(_aui_input_fieldgroup2.default, { value: room_name,
	        disabled: this.props.loading,
	        ref: "nameField",
	        id: "create-room-name",
	        label: _forms_strings2.default.label.room_name,
	        maxLength: "50",
	        description: _forms_strings2.default.description.create_room_description,
	        error: errors.name }),
	      React.createElement(_aui_input_fieldgroup2.default, { value: room_topic,
	        disabled: this.props.loading,
	        ref: "topicField",
	        id: "create-room-topic",
	        label: _forms_strings2.default.label.room_topic,
	        maxLength: _app_config2.default.max_topic_text_length,
	        description: _forms_strings2.default.description.create_room_topic,
	        error: errors.topic }),
	      React.createElement(_room_privacy_radios2.default, { disabled: this.props.loading,
	        defaultChecked: privacy })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var AuiFieldSet = __webpack_require__(357),
	    strings = __webpack_require__(262),
	    AuiRadio = __webpack_require__(349);
	
	module.exports = React.createClass({
	
	  displayName: "RoomPrivacyRadios",
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      public_desc: strings.description.public_room,
	      private_desc: strings.description.private_room
	    };
	  },
	
	  render: function render() {
	    return React.createElement(
	      AuiFieldSet,
	      { label: "Access:" },
	      React.createElement(AuiRadio, { id: "public-room", key: _.uniqueId(), name: "privacy", defaultChecked: this.props.defaultChecked === "public", value: "public", label: strings.label.public_room, description: this.props.public_desc }),
	      React.createElement(AuiRadio, { id: "private-room", key: _.uniqueId(), name: "privacy", defaultChecked: this.props.defaultChecked === "private", value: "private", label: strings.label.private_room, description: this.props.private_desc })
	    );
	  }
	
	});

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ModalDialog = __webpack_require__(341),
	    strings = __webpack_require__(203),
	    RoomPrivacyForm = __webpack_require__(376),
	    ieSubmitMixin = __webpack_require__(369),
	    cx = __webpack_require__(313);
	
	module.exports = React.createClass({
	
	  displayName: "RoomPrivacyDialog",
	
	  mixins: [ieSubmitMixin],
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(RoomPrivacyForm, { jid: this.props.jid, name: this.props.name, privacy: this.props.privacy, loading: this.props.btnLoading });
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    var btnClasses = cx({
	      'aui-button': true,
	      'aui-button-primary': true
	    });
	
	    return React.createElement(
	      "button",
	      { form: "room-privacy-form", className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading, type: "submit", onClick: this.ieSubmit },
	      strings.set_privacy
	    );
	  },
	
	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "room-privacy-dialog",
	      title: strings.change_privacy,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      btnLoading: this.props.btnLoading,
	      closeLinkText: strings.cancel });
	  }
	});

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _room_privacy_radios = __webpack_require__(374);
	
	var _room_privacy_radios2 = _interopRequireDefault(_room_privacy_radios);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RoomPrivacyForm",
	
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    var val;
	    if (!nextProps.loading) {
	      val = true;
	    } else {
	      val = false;
	    }
	    return val;
	  },
	
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(ReactDOM.findDOMNode(this.refs.form)).serializeArray(),
	        submit_data = {
	      jid: this.props.jid,
	      privacy: form_inputs[0].value
	    };
	
	    if (submit_data.privacy !== this.props.privacy) {
	      _dialog_actions2.default.startBtnLoading();
	      _form_actions2.default.changeRoomPrivacy(submit_data, this._handleResponse);
	    }
	  },
	
	  _handleResponse: function _handleResponse(error) {
	    if (error) {
	      this._throwFlagError(error.message || _forms_strings2.default.fail.change_privacy_flag);
	    } else {
	      var privacy = this.props.privacy === "public" ? "private" : "public";
	      var success_msg = _forms_strings2.default.success.privacy_changed(this.props.name, privacy);
	      this._throwFlagSuccess(success_msg);
	    }
	    this._closeDialog();
	  },
	
	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    _flag_actions2.default.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },
	
	  _throwFlagError: function _throwFlagError(error) {
	    _flag_actions2.default.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },
	
	  _onFlagActionClick: function _onFlagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".hc-flag").data('flag-index');
	    _flag_actions2.default.removeFlag(flag_index);
	    this._showDialog();
	  },
	
	  _flagBody: function _flagBody(error_msg) {
	    var _this = this;
	
	    return function () {
	      return React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "p",
	          { className: "hc-message-body" },
	          error_msg
	        ),
	        React.createElement(
	          "ul",
	          { className: "aui-nav-actions-list" },
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { onClick: _this._onFlagActionClick, href: "#" },
	              _forms_strings2.default.button.try_again
	            )
	          )
	        )
	      );
	    };
	  },
	
	  _showDialog: function _showDialog() {
	    _dialog_actions2.default.showRoomPrivacyDialog({
	      jid: this.props.jid,
	      name: this.props.name,
	      privacy: this.props.privacy
	    });
	  },
	
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  render: function render() {
	    return React.createElement(
	      "form",
	      { id: "room-privacy-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(_room_privacy_radios2.default, { defaultChecked: this.props.privacy, private_desc: _forms_strings2.default.description.privacy })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ModalDialog = __webpack_require__(341),
	    RenameRoomForm = __webpack_require__(378),
	    strings = __webpack_require__(203),
	    ieSubmitMixin = __webpack_require__(369),
	    DialogVisibilityMixin = __webpack_require__(342),
	    cx = __webpack_require__(313);
	
	module.exports = React.createClass({
	
	  displayName: "RenameRoomDialog",
	
	  mixins: [ieSubmitMixin, DialogVisibilityMixin],
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(RenameRoomForm, { dialogVisible: this.state.dialogVisible,
	      jid: this.props.jid,
	      name: this.props.name,
	      loading: this.props.btnLoading });
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    var btnClasses = cx({
	      'aui-button': true,
	      'aui-button-primary': true
	    });
	
	    return React.createElement(
	      "button",
	      { form: "rename-room-form", className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading, type: "submit", onClick: this.ieSubmit },
	      strings.rename
	    );
	  },
	
	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "rename-room-dialog",
	      title: strings.rename_room(this.props.name),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      btnLoading: this.props.btnLoading,
	      closeLinkText: strings.cancel });
	  }
	});

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _aui_input_fieldgroup = __webpack_require__(352);
	
	var _aui_input_fieldgroup2 = _interopRequireDefault(_aui_input_fieldgroup);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _form_error_strings = __webpack_require__(366);
	
	var _form_error_strings2 = _interopRequireDefault(_form_error_strings);
	
	var _forms_store = __webpack_require__(365);
	
	var _forms_store2 = _interopRequireDefault(_forms_store);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "RenameRoomForm",
	
	  componentDidMount: function componentDidMount() {
	    _forms_store2.default.on('change:roomNames', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _forms_store2.default.off('change:roomNames', this._onChange);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.errors.name || this.props.dialogVisible) {
	      this._focusInput();
	    }
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _getState: function _getState() {
	    return {
	      roomNames: _forms_store2.default.get("roomNames"),
	      errors: {}
	    };
	  },
	
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(ReactDOM.findDOMNode(this.refs.form)).serializeArray(),
	        name = form_inputs[0].value.trim();
	
	    var errors = this._validate(name);
	    if (errors) {
	      this.setState({
	        errors: errors
	      });
	    } else {
	      this._clearErrors();
	      _dialog_actions2.default.startBtnLoading();
	      _form_actions2.default.changeRoomName({
	        jid: this.props.jid,
	        name: name
	      }, this._handleResponse);
	    }
	  },
	
	  _validate: function _validate(name) {
	    if (!name) {
	      return {
	        name: _form_error_strings2.default.rename_room_form.no_room_name
	      };
	    } else if (name.length > 50) {
	      return {
	        name: _form_error_strings2.default.rename_room_form.name_too_long
	      };
	    } else if (name === this.props.name) {
	      return {
	        name: _form_error_strings2.default.rename_room_form.same_name
	      };
	    } else if (_.find(this.state.roomNames, function (roomName) {
	      return _.isString(roomName) && roomName.toLowerCase() === name.toLowerCase();
	    })) {
	      return {
	        name: _form_error_strings2.default.rename_room_form.room_already_exists
	      };
	    }
	  },
	
	  _clearErrors: function _clearErrors() {
	    this.setState({
	      errors: {}
	    });
	  },
	
	  _handleResponse: function _handleResponse(error) {
	    if (error) {
	      this.setState({
	        errors: {
	          name: error.message || _forms_strings2.default.fail.rename_flag
	        }
	      });
	      _dialog_actions2.default.stopBtnLoading();
	    } else {
	      this._throwFlagSuccess(_forms_strings2.default.success.rename_flag);
	      this._closeDialog();
	    }
	  },
	
	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    _flag_actions2.default.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },
	
	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".hc-flag").data('flag-index');
	    _flag_actions2.default.removeFlag(flag_index);
	    this._showDialog();
	  },
	
	  _flagBody: function _flagBody() {
	    var _this = this;
	
	    return function () {
	      return React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "ul",
	          { className: "aui-nav-actions-list" },
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { onClick: _this._flagActionClick, href: "#" },
	              _forms_strings2.default.button.try_again
	            )
	          )
	        )
	      );
	    };
	  },
	
	  _showDialog: function _showDialog() {
	    _dialog_actions2.default.showRenameRoomDialog({
	      jid: this.props.jid,
	      name: this.props.name
	    });
	  },
	
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  _focusInput: function _focusInput() {
	    document.getElementById('room-name').focus();
	  },
	
	  render: function render() {
	    var errors = this.state.errors;
	
	    return React.createElement(
	      "form",
	      { id: "rename-room-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(_aui_input_fieldgroup2.default, { id: "room-name", ref: "nameField", disabled: this.props.loading, maxLength: "50", label: _forms_strings2.default.label.new_room_name, error: errors.name })
	    );
	  }
	});

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _room_dropdown_actions = __webpack_require__(287);
	
	var _room_dropdown_actions2 = _interopRequireDefault(_room_dropdown_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "DeleteRoomDialog",
	
	  propTypes: {
	    jid: React.PropTypes.string.isRequired
	  },
	
	  componentDidMount: function componentDidMount() {
	    this._focusButton();
	  },
	
	  _dialogBody: function _dialogBody() {
	    return _dialog_strings2.default.confirm_delete(this.props.name);
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    var btnClasses = (0, _classnames2.default)({
	      'aui-button': true,
	      'aui-button-primary': true
	    });
	
	    return React.createElement(
	      "button",
	      { onClick: this._deleteRoom, className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading },
	      _dialog_strings2.default.delete_room
	    );
	  },
	
	  _deleteRoom: function _deleteRoom(e) {
	    e.preventDefault();
	    _dialog_actions2.default.startBtnLoading();
	    _room_dropdown_actions2.default.deleteRoom({
	      jid: this.props.jid,
	      id: this.props.room_id
	    }, this._handleResponse);
	  },
	
	  _handleResponse: function _handleResponse(error) {
	    if (error) {
	      this._throwFlagError(error.message || _dialog_strings2.default.delete_room_fail);
	    } else {
	      var success_msg = _dialog_strings2.default.room_deleted(this.props.name);
	      this._throwFlagSuccess(success_msg);
	      _room_dropdown_actions2.default.closeRoom(this.props.jid);
	    }
	    this._closeDialog();
	  },
	
	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    _flag_actions2.default.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },
	
	  _throwFlagError: function _throwFlagError(error) {
	    _flag_actions2.default.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },
	
	  _flagBody: function _flagBody(error_msg) {
	    var _this = this;
	
	    return function () {
	      return React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "p",
	          { className: "hc-message-body" },
	          error_msg
	        ),
	        React.createElement(
	          "ul",
	          { className: "aui-nav-actions-list" },
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { onClick: _this._flagActionClick, href: "#" },
	              _dialog_strings2.default.try_again
	            )
	          )
	        )
	      );
	    };
	  },
	
	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data('flag-index');
	    _flag_actions2.default.removeFlag(flag_index);
	    this._showDialog();
	  },
	
	  _showDialog: function _showDialog() {
	    _dialog_actions2.default.showDeleteRoomDialog({
	      jid: this.props.jid,
	      name: this.props.name
	    });
	  },
	
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  _focusButton: function _focusButton() {
	    ReactDOM.findDOMNode(this).querySelector(".aui-button-primary").focus();
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: "delete-room-dialog",
	      title: _dialog_strings2.default.delete_room,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: _dialog_strings2.default.cancel,
	      btnLoading: this.props.btnLoading,
	      size: "small" });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _linkify = __webpack_require__(105);
	
	var _linkify2 = _interopRequireDefault(_linkify);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ModalDialog = __webpack_require__(341),
	    AppDispatcher = __webpack_require__(9),
	    strings = __webpack_require__(203),
	    DialogActions = __webpack_require__(95);
	
	module.exports = React.createClass({
	
	  displayName: "RoomInviteDialog",
	
	  _dialogBody: function _dialogBody() {
	    var invitePrompt = strings.invited_to_join(this.props.from_user, this.props.room_name);
	    return React.createElement(
	      "div",
	      null,
	      invitePrompt,
	      React.createElement("br", null),
	      React.createElement("br", null),
	      React.createElement("span", { dangerouslySetInnerHTML: this._getReasonHTML() })
	    );
	  },
	
	  _getReasonHTML: function _getReasonHTML() {
	    var linkifyConfig = {
	      truncate_length: 50
	    };
	
	    if (this.props.reason) {
	      var reason = _linkify2.default.linkify(_utils2.default.escape(this.props.reason), undefined, linkifyConfig);
	
	      return {
	        __html: "\"" + reason + "\""
	      };
	    }
	
	    return {
	      __html: ''
	    };
	  },
	
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { onClick: this._acceptInvite, className: "aui-button aui-button-primary" },
	      strings.join
	    );
	  },
	
	  _acceptInvite: function _acceptInvite(e) {
	    e.preventDefault();
	    AppDispatcher.dispatch('groupchat-invite-accepted', {
	      jid: this.props.room_jid
	    });
	    DialogActions.closeDialog();
	  },
	
	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "room-invite-dialog",
	      title: strings.join_room(this.props.room_name),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Ignore",
	      size: "small" });
	  }
	});

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _rooms_nav_store = __webpack_require__(368);
	
	var _rooms_nav_store2 = _interopRequireDefault(_rooms_nav_store);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _room_dropdown_actions = __webpack_require__(287);
	
	var _room_dropdown_actions2 = _interopRequireDefault(_room_dropdown_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ArchiveRoomDialog",
	
	  componentDidMount: function componentDidMount() {
	    _rooms_nav_store2.default.on(['change'], this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _rooms_nav_store2.default.off(['change'], this._onChange);
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getActiveChatState();
	  },
	
	  _getActiveChatState: function _getActiveChatState() {
	    return {
	      active_chat: _rooms_nav_store2.default.get("active_chat"),
	      rooms: _rooms_nav_store2.default.get("rooms")
	    };
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getActiveChatState());
	  },
	
	  _dialogBody: function _dialogBody() {
	    return this.props.archive ? React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        null,
	        React.createElement(
	          "strong",
	          null,
	          _dialog_strings2.default.really_archive(this._getRoomName())
	        )
	      ),
	      React.createElement(
	        "p",
	        null,
	        _dialog_strings2.default.confirm_archive
	      )
	    ) : React.createElement(
	      "p",
	      null,
	      _dialog_strings2.default.really_unarchive(this._getRoomName())
	    );
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { onClick: this.onAction(this.props.archive), className: "aui-button aui-button-primary" },
	      this.props.archive ? _dialog_strings2.default.archive : _dialog_strings2.default.unarchive
	    );
	  },
	
	  _getRoomName: function _getRoomName() {
	    return _utils2.default.room.get_room_name(_.keyBy(this.state.rooms.rooms, "jid"), this.state.active_chat);
	  },
	
	  _getRoomId: function _getRoomId() {
	    return _utils2.default.room.get_room_id(_.keyBy(this.state.rooms.rooms, "jid"), this.state.active_chat);
	  },
	
	  onAction: function onAction(archive) {
	
	    var data = {
	      jid: this.state.active_chat,
	      id: this._getRoomId()
	    };
	
	    var cb = this._buildResponseHandler(archive);
	
	    return function (evt) {
	      if (evt) {
	        evt.preventDefault();
	      }
	      if (archive) {
	        _room_dropdown_actions2.default.archiveRoom(data, cb);
	      } else {
	        _room_dropdown_actions2.default.unarchiveRoom(data, cb);
	      }
	      _dialog_actions2.default.closeDialog();
	    };
	  },
	  _buildResponseHandler: function _buildResponseHandler(archive) {
	    var _this = this;
	
	    return function (data) {
	      if (data.error) {
	        var error_msg = archive ? _dialog_strings2.default.archive_fail : _dialog_strings2.default.unarchive_fail;
	        _this._throwFlagError(error_msg);
	      } else {
	        var success_msg = archive ? _dialog_strings2.default.room_archived : _dialog_strings2.default.room_unarchived;
	        _this._throwFlagSuccess(success_msg);
	      }
	    };
	  },
	
	
	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    _flag_actions2.default.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },
	
	  _throwFlagError: function _throwFlagError(error) {
	    _flag_actions2.default.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },
	
	  _flagBody: function _flagBody(error_msg) {
	    var _this2 = this;
	
	    return function () {
	      return React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "p",
	          { className: "hc-message-body" },
	          error_msg
	        ),
	        React.createElement(
	          "ul",
	          { className: "aui-nav-actions-list" },
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { onClick: _this2.onFlagClickAction(_this2.props.archive) },
	              _dialog_strings2.default.try_again
	            )
	          )
	        )
	      );
	    };
	  },
	
	  onFlagClickAction: function onFlagClickAction(archive) {
	
	    var action = this.onAction(archive);
	
	    return function (e) {
	      var flag_index = $(e.target).closest(".flag").data('flag-index');
	      _flag_actions2.default.removeFlag(flag_index);
	      action(e);
	    };
	  },
	
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: "archive-room-dialog",
	      title: this.props.archive ? _dialog_strings2.default.archive_room_name(this._getRoomName()) : _dialog_strings2.default.unarchive_room_name(this._getRoomName()),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel" });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog_alternate = __webpack_require__(383);
	
	var _modal_dialog_alternate2 = _interopRequireDefault(_modal_dialog_alternate);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "Desktop4Dialog",
	
	  componentDidMount: function componentDidMount() {
	    _spi2.default.onDesktop4DialogShown();
	  },
	  getDefaultProps: function getDefaultProps() {
	    return {
	      content: {}
	    };
	  },
	  _onClick: function _onClick() {
	    _dialog_actions2.default.closeDialog();
	  },
	  _getTitle: function _getTitle() {
	    var title = _.get(this.props.content, "title");
	
	    if (_.isString(title)) {
	      return React.createElement(
	        "h2",
	        null,
	        title
	      );
	    }
	  },
	  _getIntro: function _getIntro() {
	    var intro = _.get(this.props.content, "intro");
	
	    if (_.isString(intro)) {
	      return React.createElement(
	        "p",
	        null,
	        intro
	      );
	    }
	  },
	  _getBullets: function _getBullets() {
	    var bullets = _.get(this.props.content, "bullets");
	
	    if (_.isArray(bullets) && bullets.length) {
	      return React.createElement(
	        "ul",
	        null,
	        bullets.map(function (bullet) {
	          return React.createElement(
	            "li",
	            null,
	            bullet
	          );
	        })
	      );
	    }
	  },
	  _getOutro: function _getOutro() {
	    var outro = _.get(this.props.content, "outro");
	
	    if (_.isString(outro)) {
	      return React.createElement(
	        "p",
	        null,
	        outro
	      );
	    }
	  },
	  _getCTA: function _getCTA() {
	    var cta = _.get(this.props.content, "cta", _dialog_strings2.default.close);
	
	    if (_.isString(cta)) {
	      return React.createElement(
	        "button",
	        { className: "aui-button aui-button-primary", onClick: this._onClick },
	        cta
	      );
	    }
	  },
	  _dialogBody: function _dialogBody() {
	    var title = this._getTitle(),
	        intro = this._getIntro(),
	        bullets = this._getBullets(),
	        outro = this._getOutro(),
	        cta = this._getCTA();
	
	    return React.createElement(
	      "div",
	      null,
	      React.createElement("div", { className: "img" }),
	      title,
	      React.createElement(
	        "div",
	        { className: "inner-content" },
	        intro,
	        bullets,
	        outro
	      ),
	      cta
	    );
	  },
	  render: function render() {
	    return React.createElement(_modal_dialog_alternate2.default, { dialogId: "desktop-4-dialog",
	      dialogBody: this._dialogBody,
	      size: "small" });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ModalDialogAlternate",
	
	  propTypes: {
	    size: React.PropTypes.oneOf(['small', 'medium', 'large', 'xlarge'])
	  },
	
	  mixins: [_modal_dialog_visibility_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    document.querySelector("body").addEventListener('keydown', this._onKeyDown);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    document.querySelector("body").removeEventListener('keydown', this._onKeyDown);
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      dialogId: "dialog",
	      size: "medium",
	      dialogBody: _.noop
	    };
	  },
	
	  close: function close() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  _onKeyDown: function _onKeyDown(e) {
	    var key = window.Event ? e.which : e.keyCode;
	    if (key === _utils2.default.keyCode.Esc) {
	      this.close();
	    }
	  },
	
	  _onClick: function _onClick() {
	    this.close();
	  },
	
	  render: function render() {
	    var sizeClass = "aui-dialog2-" + this.props.size,
	        classes = (0, _classnames2.default)({
	      "aui-layer": true,
	      "aui-dialog2": true,
	      "modal-dialog-alt": true
	    }, sizeClass);
	
	    return React.createElement(
	      "section",
	      { role: "dialog", id: this.props.dialogId, className: classes, "aria-hidden": !this.state.dialogVisible },
	      React.createElement(
	        "div",
	        { className: "aui-dialog2-content" },
	        this.props.dialogBody()
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _connect_addon = __webpack_require__(385);
	
	var _connect_addon2 = _interopRequireDefault(_connect_addon);
	
	var _rooms_nav_store = __webpack_require__(368);
	
	var _rooms_nav_store2 = _interopRequireDefault(_rooms_nav_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _host = __webpack_require__(386);
	
	var _host2 = _interopRequireDefault(_host);
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var REACT_CONTAINER_ID = "connect-dialog-container";
	module.exports = React.createClass({
	
	  displayName: "AddonDialog",
	
	  _getAddonOptions: function _getAddonOptions() {
	    var addonOptions = $.extend({}, this.props.addon_options);
	    if (addonOptions.chrome === undefined) {
	      addonOptions.chrome = true;
	    }
	
	    if (addonOptions.resize === undefined && (this.props.addon_options.width || this.props.addon_options.height)) {
	      addonOptions.resize = false;
	    }
	
	    addonOptions.width = this._getWidth(addonOptions.width || _app_config2.default.default_connect_dialog_width);
	    addonOptions.height = this._getHeight(addonOptions.height || _app_config2.default.default_connect_dialog_height, addonOptions.chrome);
	    return addonOptions;
	  },
	
	  _getDimension: function _getDimension(dimension, value) {
	    this.max_width = _connect_addon2.default.dialog.getMaxWidth();
	    this.max_height = _connect_addon2.default.dialog.getMaxHeight();
	
	    if (!value || parseInt(value, 10) > this['max_' + dimension]) {
	      return this['max_' + dimension];
	    } else if (value) {
	      return parseInt(value, 10);
	    }
	
	    return _app_config2.default['default_connect_dialog_' + dimension];
	  },
	  _getWidth: function _getWidth(width) {
	    if (width === undefined) {
	      width = parseInt(this.props.addon_options.width, 10) || _app_config2.default.default_connect_dialog_width;
	    }
	    return this._getDimension('width', width);
	  },
	  _getHeight: function _getHeight(height, chrome) {
	    if (height === undefined) {
	      height = parseInt(this.props.addon_options.height, 10) || _app_config2.default.default_connect_dialog_height;
	    }
	    height = this._getDimension('height', height);
	    var chromeMaxHeight = _connect_addon2.default.dialog.getMaxHeight() - _app_config2.default.connect_aui_dialog_chrome_height;
	
	    if (chrome && height > chromeMaxHeight) {
	      return chromeMaxHeight;
	    }
	
	    return height;
	  },
	  _getOptions: function _getOptions() {
	    return $.extend(true, this._getAddonOptions(), {
	      capabilities: _connect_addon2.default.dialog.capabilities
	    });
	  },
	  _createDialog: function _createDialog() {
	    var options = this._getOptions(),
	        containerDiv = AJS.$(ReactDOM.findDOMNode(this.refs.connectDialog));
	
	    containerDiv.css({
	      width: this._getWidth(),
	      height: this._getHeight(undefined, options.chrome)
	    });
	    this.resize(this._getWidth(), this._getHeight(undefined, options.chrome));
	
	    containerDiv.find('.ap-dialog-submit').hide();
	    containerDiv.on("ra.iframe.destroy", function () {
	      _dialog_actions2.default.closeDialog();
	    });
	  },
	  componentDidMount: function componentDidMount() {
	    _connect_addon2.default.bindAnalyticsIntercept();
	    _rooms_nav_store2.default.on(['change'], this._onChange);
	    this._createDialog();
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _connect_addon2.default.unbindAnalyticsIntercept();
	    _rooms_nav_store2.default.off(['change'], this._onChange);
	    var addon_key = this.props.addon_key;
	    _analytics_actions2.default.connectDialogClosedEvent(addon_key);
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getActiveChatState();
	  },
	
	  _getActiveChatState: function _getActiveChatState() {
	    return {
	      active_chat: _rooms_nav_store2.default.get("active_chat"),
	      rooms: _rooms_nav_store2.default.get("rooms")
	    };
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getActiveChatState());
	  },
	
	  _resized: function _resized(width, height) {
	    this.resize(width, height);
	  },
	  _dimensions: function _dimensions(width, height) {
	    var max_height = _connect_addon2.default.dialog.getMaxHeight(),
	        max_width = _connect_addon2.default.dialog.getMaxWidth();
	
	    return {
	      height: Math.min(parseInt(height, 10), max_height),
	      width: Math.min(parseInt(width, 10), max_width)
	    };
	  },
	  resize: function resize(width, height) {
	    var top,
	        dimensions = this._dimensions(width, height);
	    top = ($(document).height() - dimensions.height) / 2;
	    var $el = $('#' + REACT_CONTAINER_ID).css('top', top);
	    AJS.layer($el).changeSize(dimensions.width, dimensions.height);
	  },
	  dialogBody: function dialogBody() {
	    var xdm = _host2.default.create({
	      addon_key: this.props.addon_key,
	      key: this.props.module_key
	    });
	    var ns = _connect_addon2.default.getNamespace(this.props.addon_key, this.props.module_key),
	        options = this._getOptions(),
	        src = _connect_addon2.default.getIframeUrl(this.props.addon_url, ns, options);
	
	    return React.createElement('iframe', { className: 'hc-addon-iframe', id: xdm.id, name: xdm.name, src: src,
	      onLoad: this._onLoad });
	  },
	
	  render: function render() {
	    var options = this._getOptions(),
	        dimensions = this._dimensions(this._getWidth(), this._getHeight(undefined, options.chrome));
	    return React.createElement(_modal_dialog2.default, { ref: 'connectDialog', dialogId: REACT_CONTAINER_ID,
	      title: this.props.addon_options.header,
	      dialogBody: this.dialogBody,
	      closeLinkText: _dialog_strings2.default.close,
	      customWidth: dimensions.width,
	      customHeight: dimensions.height });
	  }
	});

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _uri = __webpack_require__(142);
	
	var _uri2 = _interopRequireDefault(_uri);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function objectToQueryParams(params) {
	  var url = '';
	
	  (0, _keys2.default)(params).forEach(function (key) {
	    url += key + '=' + encodeURIComponent(params[key]) + '&';
	  });
	
	  return url.substring(0, url.length - 1);
	}
	
	//TODO: this probably should be an action
	function callAnalytics(event, params) {
	  if (typeof params !== 'undefined') {
	    _analytics_dispatcher2.default.dispatch("analytics-connect-event", params);
	  }
	}
	
	module.exports = {
	  bindAnalyticsIntercept: function bindAnalyticsIntercept() {
	    if (AJS && typeof AJS.bind === 'function') {
	      AJS.bind('analyticsEvent', callAnalytics);
	    }
	  },
	  unbindAnalyticsIntercept: function unbindAnalyticsIntercept() {
	    if (AJS && typeof AJS.unbind === 'function') {
	      AJS.unbind('analyticsEvent', callAnalytics);
	    }
	  },
	  getCapabilities: function getCapabilities() {
	    return {
	      hostlib: 'https://' + _application_store2.default.get('web_server') + '/min/?b=js&f=connect/all-debug.js,connect/plugin-init.js'
	    };
	  },
	  getIframeUrl: function getIframeUrl(src, namespace, additionalCapabilties) {
	
	    var uri = _uri2.default.parse(window.location.href);
	    var params = {
	      'xdm_e': uri.getBase(),
	      'xdm_c': 'channel-' + namespace,
	      'cp': '',
	      'lic': 'none',
	      'embedded': true
	    },
	        capabilities = $.extend({}, this.getCapabilities(), additionalCapabilties),
	        iframeUrl = '' + src + (_.includes(src, '?') ? '&' : '?') + objectToQueryParams(params) + '#' + (0, _stringify2.default)(capabilities);
	
	    return iframeUrl;
	  },
	  getNamespace: function getNamespace(addon_key, module_key) {
	    return addon_key + '__' + module_key;
	  },
	  getDocumentHeight: function getDocumentHeight() {
	    return $(document).height();
	  },
	
	  dialog: {
	    getMaxWidth: function getMaxWidth() {
	      var documentWidth = $(document).width();
	      return documentWidth - Math.min(120, documentWidth / 100 * 10);
	    },
	    getMaxHeight: function getMaxHeight(chrome) {
	      var maxHeight = module.exports.getDocumentHeight();
	      if (chrome) {
	        maxHeight -= _app_config2.default.connect_aui_dialog_chrome_height;
	      }
	      return maxHeight - Math.min(60, maxHeight / 100 * 10);
	    },
	    capabilities: {
	      resize: {},
	      close: {}
	    }
	  }
	};

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _index = __webpack_require__(387);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = _index2.default;

/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _xdmrpc = __webpack_require__(388);
	
	var _xdmrpc2 = _interopRequireDefault(_xdmrpc);
	
	var _util = __webpack_require__(392);
	
	var _util2 = _interopRequireDefault(_util);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Connect = function () {
	  function Connect() {
	    (0, _classCallCheck3.default)(this, Connect);
	
	    this._xdm = new _xdmrpc2.default();
	  }
	
	  /**
	   * Send a message to iframes matching the targetSpec. This message is added to
	   *  a message queue for delivery to ensure the message is received if an iframe 
	   *  has not yet loaded
	   * 
	   * @param type The name of the event type
	   * @param targetSpec The spec to match against extensions when sending this event
	   * @param event The event payload
	   * @param callback A callback to be executed when the remote iframe calls its callback
	   */
	
	
	  (0, _createClass3.default)(Connect, [{
	    key: 'dispatch',
	    value: function dispatch(type, targetSpec, event, callback) {
	      this._xdm.queueEvent(type, targetSpec, event, callback);
	      return this.getExtensions(targetSpec);
	    }
	
	    /**
	     * Send a message to iframes matching the targetSpec immediately. This message will 
	     *  only be sent to iframes that are already open, and will not be delivered if none
	     *  are currently open.
	     * 
	     * @param type The name of the event type
	     * @param targetSpec The spec to match against extensions when sending this event
	     * @param event The event payload
	     */
	
	  }, {
	    key: 'broadcast',
	    value: function broadcast(type, targetSpec, event) {
	      this._xdm.dispatch(type, targetSpec, event, null, null);
	      return this.getExtensions(targetSpec);
	    }
	  }, {
	    key: '_createId',
	    value: function _createId(extension) {
	      if (!extension.addon_key || !extension.key) {
	        throw Error('Extensions require addon_key and key');
	      }
	      return extension.addon_key + '__' + extension.key + '__' + _util2.default.randomString();
	    }
	    /**
	    * Creates a new iframed module, without actually creating the DOM element.
	    * The iframe attributes are passed to the 'setupCallback', which is responsible for creating
	    * the DOM element and returning the window reference.
	    *
	    * @param extension The extension definition. Example:
	    *   {
	    *     addon_key: 'my-addon',
	    *     key: 'my-module',
	    *     url: 'https://example.com/my-module',
	    *     options: { autoresize: false }
	    *   }
	    *
	    * @param initCallback The optional initCallback is called when the bridge between host and iframe is established.
	    **/
	
	  }, {
	    key: 'create',
	    value: function create(extension, initCallback) {
	      var extension_id = this.registerExtension(extension, initCallback);
	
	      var data = {
	        extension_id: extension_id,
	        api: this._xdm.getApiSpec(),
	        origin: _util2.default.locationOrigin(),
	        options: extension.options || {}
	      };
	
	      return {
	        id: extension_id,
	        name: (0, _stringify2.default)(data),
	        src: extension.url
	      };
	    }
	  }, {
	    key: 'registerRequestNotifier',
	    value: function registerRequestNotifier(callback) {
	      this._xdm.registerRequestNotifier(callback);
	    }
	  }, {
	    key: 'registerExtension',
	    value: function registerExtension(extension, initCallback) {
	      var extension_id = this._createId(extension);
	      this._xdm.registerExtension(extension_id, {
	        extension: extension,
	        initCallback: initCallback
	      });
	      return extension_id;
	    }
	  }, {
	    key: 'registerKeyListener',
	    value: function registerKeyListener(extension_id, key, modifiers, callback) {
	      this._xdm.registerKeyListener(extension_id, key, modifiers, callback);
	    }
	  }, {
	    key: 'unregisterKeyListener',
	    value: function unregisterKeyListener(extension_id, key, modifiers, callback) {
	      this._xdm.unregisterKeyListener(extension_id, key, modifiers, callback);
	    }
	  }, {
	    key: 'defineModule',
	    value: function defineModule(moduleName, module) {
	      this._xdm.defineAPIModule(module, moduleName);
	    }
	  }, {
	    key: 'defineGlobals',
	    value: function defineGlobals(module) {
	      this._xdm.defineAPIModule(module);
	    }
	  }, {
	    key: 'getExtensions',
	    value: function getExtensions(filter) {
	      return this._xdm.getRegisteredExtensions(filter);
	    }
	  }, {
	    key: 'unregisterExtension',
	    value: function unregisterExtension(filter) {
	      return this._xdm.unregisterExtension(filter);
	    }
	  }]);
	  return Connect;
	}();
	
	module.exports = new Connect();

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof2 = __webpack_require__(23);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _getOwnPropertyNames = __webpack_require__(389);
	
	var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _util = __webpack_require__(392);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _postmessage = __webpack_require__(393);
	
	var _postmessage2 = _interopRequireDefault(_postmessage);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	* Postmessage format:
	*
	* Initialization
	* --------------
	* {
	*   type: 'init',
	*   eid: 'my-addon__my-module-xyz'  // the extension identifier, unique across iframes
	* }
	*
	* Request
	* -------
	* {
	*   type: 'req',
	*   eid: 'my-addon__my-module-xyz',  // the extension identifier, unique for iframe
	*   mid: 'xyz',  // a unique message identifier, required for callbacks
	*   mod: 'cookie',  // the module name
	*   fn: 'read',  // the method name
	*   args: [arguments]  // the method arguments
	* }
	*
	* Response
	* --------
	* {
	*   type: 'resp'
	*   eid: 'my-addon__my-module-xyz',  // the extension identifier, unique for iframe
	*   mid: 'xyz',  // a unique message identifier, obtained from the request
	*   args: [arguments]  // the callback arguments
	* }
	*
	* Event
	* -----
	* {
	*   type: 'evt',
	*   etyp: 'some-event',
	*   evnt: { ... }  // the event data
	*   mid: 'xyz', // a unique message identifier for the event
	* }
	**/
	
	var VALID_EVENT_TIME_MS = 30000; //30 seconds
	
	var XDMRPC = function (_PostMessage) {
	  (0, _inherits3.default)(XDMRPC, _PostMessage);
	
	  function XDMRPC(config) {
	    (0, _classCallCheck3.default)(this, XDMRPC);
	
	    config = config || {};
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(XDMRPC).call(this, config));
	
	    _this._registeredExtensions = config.extensions || {};
	    _this._registeredAPIModules = {};
	    _this._pendingCallbacks = {};
	    _this._keycodeCallbacks = {};
	    _this._pendingEvents = {};
	    _this._messageHandlers = {
	      init: _this._handleInit,
	      req: _this._handleRequest,
	      resp: _this._handleResponse,
	      event_query: _this._handleEventQuery,
	      broadcast: _this._handleBroadcast,
	      key_listen: _this._handleKeyListen
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(XDMRPC, [{
	    key: '_handleInit',
	    value: function _handleInit(event, reg) {
	      this._registeredExtensions[reg.extension_id].source = event.source;
	      if (reg.initCallback) {
	        reg.initCallback(event.data.eid);
	        delete reg.initCallback;
	      }
	    }
	  }, {
	    key: '_handleResponse',
	    value: function _handleResponse(event) {
	      var data = event.data;
	      var pendingCallback = this._pendingCallbacks[data.mid];
	      if (pendingCallback) {
	        delete this._pendingCallbacks[data.mid];
	        pendingCallback.apply(window, data.args);
	      }
	    }
	  }, {
	    key: 'registerRequestNotifier',
	    value: function registerRequestNotifier(cb) {
	      this._registeredRequestNotifier = cb;
	    }
	  }, {
	    key: '_handleRequest',
	    value: function _handleRequest(event, reg) {
	      function sendResponse() {
	        var args = _util2.default.argumentsToArray(arguments);
	        event.source.postMessage({
	          mid: event.data.mid,
	          type: 'resp',
	          args: args
	        }, reg.extension.url);
	      }
	
	      var data = event.data;
	      var module = this._registeredAPIModules[data.mod];
	      var extension = this.getRegisteredExtensions(reg.extension)[0];
	      if (module) {
	        var fnName = data.fn;
	        if (data._cls) {
	          (function () {
	            var Cls = module[data._cls];
	            var ns = data.mod + '-' + data._cls + '-';
	            sendResponse._id = data._id;
	            if (fnName === 'constructor') {
	              if (!Cls._construct) {
	                Cls.constructor.prototype._destroy = function () {
	                  delete this._context._proxies[ns + this._id];
	                };
	                Cls._construct = function () {
	                  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                    args[_key] = arguments[_key];
	                  }
	
	                  var inst = new (Function.prototype.bind.apply(Cls.constructor, [null].concat(args)))();
	                  var callback = args[args.length - 1];
	                  inst._id = callback._id;
	                  inst._context = callback._context;
	                  inst._context._proxies[ns + inst._id] = inst;
	                  return inst;
	                };
	              }
	              module = Cls;
	              fnName = '_construct';
	            } else {
	              module = extension._proxies[ns + data._id];
	            }
	          })();
	        }
	        var method = module[fnName];
	        if (method) {
	          var methodArgs = data.args;
	          sendResponse._context = extension;
	          methodArgs.push(sendResponse);
	          method.apply(module, methodArgs);
	          if (this._registeredRequestNotifier) {
	            this._registeredRequestNotifier.call(null, {
	              module: data.mod,
	              fn: data.fn,
	              type: data.type,
	              addon_key: reg.extension.addon_key,
	              key: reg.extension.key,
	              extension_id: reg.extension_id
	            });
	          }
	        }
	      }
	    }
	  }, {
	    key: '_handleBroadcast',
	    value: function _handleBroadcast(event, reg) {
	      var event_data = event.data;
	      var targetSpec = function targetSpec(r) {
	        return r.extension.addon_key === reg.extension.addon_key && r.extension_id !== reg.extension_id;
	      };
	      this.dispatch(event_data.etyp, targetSpec, event_data.evnt, null, null);
	    }
	  }, {
	    key: '_handleKeyListen',
	    value: function _handleKeyListen(event, reg) {
	      var eventData = event.data;
	      var keycodeEntry = this._keycodeKey(eventData.keycode, eventData.modifiers, reg.extension_id);
	      var listeners = this._keycodeCallbacks[keycodeEntry];
	      if (listeners) {
	        listeners.forEach(function (listener) {
	          listener.call(null, {
	            addon_key: reg.extension.addon_key,
	            key: reg.extension.key,
	            extension_id: reg.extension_id,
	            keycode: eventData.keycode,
	            modifiers: eventData.modifiers
	          });
	        }, this);
	      }
	    }
	  }, {
	    key: 'defineAPIModule',
	    value: function defineAPIModule(module, moduleName) {
	      if (moduleName) {
	        this._registeredAPIModules[moduleName] = module;
	      } else {
	        this._registeredAPIModules._globals = _util2.default.extend({}, this._registeredAPIModules._globals, module);
	      }
	      return this._registeredAPIModules;
	    }
	  }, {
	    key: '_fullKey',
	    value: function _fullKey(targetSpec) {
	      var key = targetSpec.addon_key || 'global';
	      if (targetSpec.key) {
	        key = key + '@@' + targetSpec.key;
	      }
	
	      return key;
	    }
	  }, {
	    key: 'queueEvent',
	    value: function queueEvent(type, targetSpec, event, callback) {
	      var loaded_frame,
	          targets = this._findRegistrations(targetSpec);
	
	      loaded_frame = targets.some(function (target) {
	        return target.registered_events !== undefined;
	      }, this);
	
	      if (loaded_frame) {
	        this.dispatch(type, targetSpec, event, callback);
	      } else {
	        this._pendingEvents[this._fullKey(targetSpec)] = {
	          type: type,
	          targetSpec: targetSpec,
	          event: event,
	          callback: callback,
	          time: new Date().getTime(),
	          uid: _util2.default.randomString()
	        };
	      }
	    }
	  }, {
	    key: '_handleEventQuery',
	    value: function _handleEventQuery(message, extension) {
	      var _this2 = this;
	
	      var executed = {};
	      var now = new Date().getTime();
	      var keys = (0, _keys2.default)(this._pendingEvents);
	      keys.forEach(function (index) {
	        var element = _this2._pendingEvents[index];
	        var eventIsValid = now - element.time <= VALID_EVENT_TIME_MS;
	        var isSameTarget = !element.targetSpec || _this2._findRegistrations(element.targetSpec).length !== 0;
	
	        if (eventIsValid && isSameTarget) {
	          executed[index] = element;
	          element.targetSpec = element.targetSpec || {};
	          element.targetSpec.addon_key = extension.extension.addon_key;
	          element.targetSpec.key = extension.extension.key;
	          _this2.dispatch(element.type, element.targetSpec, element.event, element.callback, message.source);
	        } else if (!eventIsValid) {
	          delete _this2._pendingEvents[index];
	        }
	      });
	
	      this._registeredExtensions[extension.extension_id].registered_events = message.data.args;
	
	      return executed;
	    }
	  }, {
	    key: 'dispatch',
	    value: function dispatch(type, targetSpec, event, callback, source) {
	      function sendEvent(reg, evnt) {
	        if (reg.source) {
	          var mid;
	          if (callback) {
	            mid = _util2.default.randomString();
	            this._pendingCallbacks[mid] = callback;
	          }
	
	          reg.source.postMessage({
	            type: 'evt',
	            mid: mid,
	            etyp: type,
	            evnt: evnt
	          }, reg.extension.url);
	        }
	      }
	
	      var registrations = this._findRegistrations(targetSpec || {});
	      registrations.forEach(function (reg) {
	        if (source) {
	          reg.source = source;
	        }
	
	        if (reg.source) {
	          _util2.default._bind(this, sendEvent)(reg, event);
	        }
	      }, this);
	    }
	  }, {
	    key: '_findRegistrations',
	    value: function _findRegistrations(targetSpec) {
	      var _this3 = this;
	
	      if (this._registeredExtensions.length === 0) {
	        _util2.default.error('no registered extensions', this._registeredExtensions);
	        return [];
	      }
	      var keys = (0, _getOwnPropertyNames2.default)(targetSpec);
	      var registrations = (0, _getOwnPropertyNames2.default)(this._registeredExtensions).map(function (key) {
	        return _this3._registeredExtensions[key];
	      });
	
	      if (targetSpec instanceof Function) {
	        return registrations.filter(targetSpec);
	      } else {
	        return registrations.filter(function (reg) {
	          return keys.every(function (key) {
	            return reg.extension[key] === targetSpec[key];
	          });
	        });
	      }
	    }
	  }, {
	    key: 'registerExtension',
	    value: function registerExtension(extension_id, data) {
	      // delete duplicate registrations
	      if (data.extension.addon_key && data.extension.key) {
	        var existingView = this._findRegistrations({
	          addon_key: data.extension.addon_key,
	          key: data.extension.key
	        });
	        if (existingView.length !== 0) {
	          delete this._registeredExtensions[existingView[0].extension_id];
	        }
	      }
	      data._proxies = {};
	      data.extension_id = extension_id;
	      this._registeredExtensions[extension_id] = data;
	    }
	  }, {
	    key: '_keycodeKey',
	    value: function _keycodeKey(key, modifiers, extension_id) {
	      var code = key;
	
	      if (modifiers) {
	        if (typeof modifiers === "string") {
	          modifiers = [modifiers];
	        }
	        modifiers.sort();
	        modifiers.forEach(function (modifier) {
	          code += '$$' + modifier;
	        }, this);
	      }
	
	      return code + '__' + extension_id;
	    }
	  }, {
	    key: 'registerKeyListener',
	    value: function registerKeyListener(extension_id, key, modifiers, callback) {
	      if (typeof modifiers === "string") {
	        modifiers = [modifiers];
	      }
	      var extension = this._registeredExtensions[extension_id];
	      var keycodeEntry = this._keycodeKey(key, modifiers, extension_id);
	      if (!this._keycodeCallbacks[keycodeEntry]) {
	        this._keycodeCallbacks[keycodeEntry] = [];
	        extension.source.postMessage({
	          type: 'key_listen',
	          keycode: key,
	          modifiers: modifiers,
	          action: 'add'
	        }, extension.source.location.href);
	      }
	      this._keycodeCallbacks[keycodeEntry].push(callback);
	    }
	  }, {
	    key: 'unregisterKeyListener',
	    value: function unregisterKeyListener(extension_id, key, modifiers, callback) {
	      var keycodeEntry = this._keycodeKey(key, modifiers, extension_id);
	      var potentialCallbacks = this._keycodeCallbacks[keycodeEntry];
	      var extension = this._registeredExtensions[extension_id];
	
	      if (potentialCallbacks) {
	        if (callback) {
	          var index = potentialCallbacks.indexOf(callback);
	          this._keycodeCallbacks[keycodeEntry].splice(index, 1);
	        } else {
	          delete this._keycodeCallbacks[keycodeEntry];
	        }
	
	        extension.source.postMessage({
	          type: 'key_listen',
	          keycode: key,
	          modifiers: modifiers,
	          action: 'remove'
	        }, extension.source.location.href);
	      }
	    }
	  }, {
	    key: 'getApiSpec',
	    value: function getApiSpec() {
	      var that = this;
	      function createModule(moduleName) {
	        var module = that._registeredAPIModules[moduleName];
	        if (!module) {
	          throw new Error("unregistered API module: " + moduleName);
	        }
	        function getModuleDefinition(mod) {
	          return (0, _getOwnPropertyNames2.default)(mod).reduce(function (accumulator, memberName) {
	            var member = mod[memberName];
	            switch (typeof member === 'undefined' ? 'undefined' : (0, _typeof3.default)(member)) {
	              case 'function':
	                accumulator[memberName] = {
	                  args: _util2.default.argumentNames(member)
	                };
	                break;
	              case 'object':
	                if (member.hasOwnProperty('constructor')) {
	                  accumulator[memberName] = getModuleDefinition(member);
	                }
	                break;
	            }
	            return accumulator;
	          }, {});
	        }
	        return getModuleDefinition(module);
	      }
	      return (0, _getOwnPropertyNames2.default)(this._registeredAPIModules).reduce(function (accumulator, moduleName) {
	        accumulator[moduleName] = createModule(moduleName);
	        return accumulator;
	      }, {});
	    }
	
	    // validate origin of postMessage
	
	  }, {
	    key: '_checkOrigin',
	    value: function _checkOrigin(event, reg) {
	      var no_source_types = ['init', 'event_query'];
	      var isNoSourceType = reg && !reg.source && no_source_types.indexOf(event.data.type) > -1;
	      var sourceTypeMatches = reg && event.source === reg.source;
	      var hasExtensionUrl = reg && reg.extension.url.indexOf(event.origin) === 0;
	      var isValidOrigin = hasExtensionUrl && (isNoSourceType || sourceTypeMatches);
	      if (!isValidOrigin) {
	        _util2.default.warn("Failed to validate origin: " + event.origin);
	      }
	      return isValidOrigin;
	    }
	  }, {
	    key: 'getRegisteredExtensions',
	    value: function getRegisteredExtensions(filter) {
	      if (filter) {
	        return this._findRegistrations(filter);
	      }
	      return this._registeredExtensions;
	    }
	  }, {
	    key: 'unregisterExtension',
	    value: function unregisterExtension(filter) {
	      var registrations = this._findRegistrations(filter);
	      if (registrations.length !== 0) {
	        registrations.forEach(function (registration) {
	          var _this4 = this;
	
	          var keys = (0, _keys2.default)(this._pendingEvents);
	          keys.forEach(function (index) {
	            var element = _this4._pendingEvents[index];
	            var targetSpec = element.targetSpec || {};
	
	            if (targetSpec.addon_key === registration.extension.addon_key) {
	              delete _this4._pendingEvents[index];
	            }
	          });
	
	          delete this._registeredExtensions[registration.extension_id];
	        }, this);
	      }
	    }
	  }]);
	  return XDMRPC;
	}(_postmessage2.default);
	
	module.exports = XDMRPC;

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(390), __esModule: true };

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(8);
	__webpack_require__(391);
	module.exports = function getOwnPropertyNames(it){
	  return $.getNames(it);
	};

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(15)('getOwnPropertyNames', function(){
	  return __webpack_require__(40).get;
	});

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _getOwnPropertyNames = __webpack_require__(389);
	
	var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);
	
	var _typeof2 = __webpack_require__(23);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LOG_PREFIX = "[Simple-XDM] ";
	
	var Util = function () {
	  function Util() {
	    (0, _classCallCheck3.default)(this, Util);
	  }
	
	  (0, _createClass3.default)(Util, [{
	    key: "locationOrigin",
	    value: function locationOrigin() {
	      if (!window.location.origin) {
	        return window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
	      } else {
	        return window.location.origin;
	      }
	    }
	  }, {
	    key: "randomString",
	    value: function randomString() {
	      return Math.floor(Math.random() * 1000000000).toString(16);
	    }
	  }, {
	    key: "isString",
	    value: function isString(str) {
	      return typeof str === "string" || str instanceof String;
	    }
	  }, {
	    key: "argumentsToArray",
	    value: function argumentsToArray(arrayLike) {
	      return Array.prototype.slice.call(arrayLike);
	    }
	  }, {
	    key: "argumentNames",
	    value: function argumentNames(fn) {
	      return fn.toString().replace(/((\/\/.*$)|(\/\*[^]*?\*\/))/mg, '') // strip comments
	      .replace(/[^(]+\(([^)]*)[^]+/, '$1') // get signature
	      .match(/([^\s,]+)/g) || [];
	    }
	  }, {
	    key: "hasCallback",
	    value: function hasCallback(args) {
	      var length = args.length;
	      return length > 0 && typeof args[length - 1] === 'function';
	    }
	  }, {
	    key: "error",
	    value: function error(msg) {
	      if (window.console) {
	        console.error(LOG_PREFIX + msg);
	      }
	    }
	  }, {
	    key: "warn",
	    value: function warn(msg) {
	      if (window.console) {
	        console.warn(LOG_PREFIX + msg);
	      }
	    }
	  }, {
	    key: "_bind",
	    value: function _bind(thisp, fn) {
	      if (Function.prototype.bind) {
	        return fn.bind(thisp);
	      }
	      return function () {
	        return fn.apply(thisp, arguments);
	      };
	    }
	  }, {
	    key: "each",
	    value: function each(o, it) {
	      var l;
	      var k;
	      if (o) {
	        l = o.length;
	        if (l != null && typeof o !== 'function') {
	          k = 0;
	          while (k < l) {
	            if (it.call(o[k], k, o[k]) === false) {
	              break;
	            }
	            k += 1;
	          }
	        } else {
	          for (k in o) {
	            if (o.hasOwnProperty(k)) {
	              if (it.call(o[k], k, o[k]) === false) {
	                break;
	              }
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: "extend",
	    value: function extend(dest) {
	      var args = arguments;
	      var srcs = [].slice.call(args, 1, args.length);
	      srcs.forEach(function (source) {
	        if ((typeof source === "undefined" ? "undefined" : (0, _typeof3.default)(source)) === "object") {
	          (0, _getOwnPropertyNames2.default)(source).forEach(function (name) {
	            dest[name] = source[name];
	          });
	        }
	      });
	      return dest;
	    }
	  }]);
	  return Util;
	}();
	
	module.exports = new Util();

/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _util = __webpack_require__(392);
	
	var _util2 = _interopRequireDefault(_util);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PostMessage = function () {
	  function PostMessage(data) {
	    (0, _classCallCheck3.default)(this, PostMessage);
	
	    var d = data || {};
	    this._registerListener(d.listenOn);
	  }
	
	  // listen for postMessage events (defaults to window).
	
	
	  (0, _createClass3.default)(PostMessage, [{
	    key: "_registerListener",
	    value: function _registerListener(listenOn) {
	      if (!listenOn || !listenOn.addEventListener) {
	        listenOn = window;
	      }
	      listenOn.addEventListener("message", _util2.default._bind(this, this._receiveMessage), false);
	    }
	  }, {
	    key: "_receiveMessage",
	    value: function _receiveMessage(event) {
	      var extensionId = event.data.eid,
	          reg = void 0;
	
	      if (extensionId && this._registeredExtensions) {
	        reg = this._registeredExtensions[extensionId];
	      }
	
	      if (!this._checkOrigin(event, reg)) {
	        return false;
	      }
	
	      var handler = this._messageHandlers[event.data.type];
	      if (handler) {
	        handler.call(this, event, reg);
	      }
	    }
	  }]);
	  return PostMessage;
	}();
	
	module.exports = PostMessage;

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _quick_switcher_content = __webpack_require__(395);
	
	var _quick_switcher_content2 = _interopRequireDefault(_quick_switcher_content);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "QuickSwitcherDialog",
	
	  mixins: [_modal_dialog_visibility_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    _analytics_actions2.default.quickSwitcherViewed();
	    document.querySelector("body").addEventListener('keydown', this._onKeyDown, true);
	    this._focusInput();
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    clearTimeout(this.timeout);
	    document.querySelector("body").removeEventListener('keydown', this._onKeyDown, true);
	  },
	  close: function close() {
	    if (!this.timeout) {
	      this.timeout = setTimeout(function () {
	        _dialog_actions2.default.closeDialog();
	      }, 300);
	    }
	  },
	  _onKeyDown: function _onKeyDown(e) {
	    var key = window.Event ? e.which : e.keyCode;
	    if (key === _utils2.default.keyCode.Esc) {
	      e.stopPropagation();
	      e.preventDefault();
	      this.close();
	    }
	  },
	  _focusInput: function _focusInput() {
	    var $input = $(ReactDOM.findDOMNode(this.refs.qs_content)).find("input");
	    if ($input.length) {
	      $input.focus();
	    }
	  },
	  render: function render() {
	    return React.createElement(
	      'section',
	      { role: 'dialog', id: 'quick-switcher-dialog', className: 'hc-qs', 'aria-hidden': !this.state.dialogVisible },
	      React.createElement(_quick_switcher_content2.default, { ref: 'qs_content', hideHint: this.props.hideHint })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _quick_switcher_input = __webpack_require__(396);
	
	var _quick_switcher_input2 = _interopRequireDefault(_quick_switcher_input);
	
	var _quick_switcher_empty_state = __webpack_require__(399);
	
	var _quick_switcher_empty_state2 = _interopRequireDefault(_quick_switcher_empty_state);
	
	var _quick_switcher_hint = __webpack_require__(400);
	
	var _quick_switcher_hint2 = _interopRequireDefault(_quick_switcher_hint);
	
	var _quick_switcher_store = __webpack_require__(401);
	
	var _quick_switcher_store2 = _interopRequireDefault(_quick_switcher_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _quick_switcher_actions = __webpack_require__(397);
	
	var _quick_switcher_actions2 = _interopRequireDefault(_quick_switcher_actions);
	
	var _quick_switcher_person = __webpack_require__(402);
	
	var _quick_switcher_person2 = _interopRequireDefault(_quick_switcher_person);
	
	var _quick_switcher_room = __webpack_require__(403);
	
	var _quick_switcher_room2 = _interopRequireDefault(_quick_switcher_room);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'QuickSwitcherContent',
	
	  componentDidMount: function componentDidMount() {
	    _quick_switcher_store2.default.on(['change'], this._onChange);
	    _preferences_store2.default.on(['change:' + _client_preferences_keys2.default.SHOW_QUICK_SWITCHER_HINT], this._onChange);
	    this._throttledScrollToSelected = _.throttle(this._scrollToSelected, 100, { leading: false, trailing: true });
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _quick_switcher_store2.default.off(['change'], this._onChange);
	    _preferences_store2.default.off(['change:' + _client_preferences_keys2.default.SHOW_QUICK_SWITCHER_HINT], this._onChange);
	    _quick_switcher_actions2.default.reset();
	    this._throttledScrollToSelected.cancel();
	  },
	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    // only fire the event if we are going from some results to no results.
	    if (nextState.total === 0 && this.state.total > 0) {
	      _analytics_actions2.default.quickSwitcherNoResults(nextState.text);
	    }
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    ReactDOM.findDOMNode(this.refs.input.refs.input_field).focus();
	  },
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  _getState: function _getState() {
	    var qsData = _quick_switcher_store2.default.getAll();
	
	    return {
	      text: qsData.text,
	      filtered: qsData.filtered,
	      filtered_time: qsData.filtered_time,
	      selected_item: qsData.selected_item,
	      rows: qsData.list,
	      total: qsData.list.length,
	      show_hint: _preferences_store2.default.getShowQuickSwitcherHint(),
	      should_animate_avatar: _preferences_store2.default.shouldAnimateAvatars()
	    };
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _getEmptyState: function _getEmptyState() {
	    var empty_state = null;
	
	    if (this.state.text && !this.state.total && this.state.filtered) {
	      empty_state = React.createElement(_quick_switcher_empty_state2.default, { ref: 'empty_state' });
	    }
	
	    return empty_state;
	  },
	  _getHint: function _getHint() {
	    var hint = null;
	
	    if (this.state.show_hint && !this.props.hideHint) {
	      hint = React.createElement(_quick_switcher_hint2.default, { ref: 'qs_hint', with_results: this.state.total > 0 });
	    }
	
	    return hint;
	  },
	  _scrollTop: function _scrollTop() {
	    if (this.refs.scrollable) {
	      this.refs.scrollable.scrollTo(0);
	    }
	  },
	  _scrollToSelected: function _scrollToSelected() {
	
	    if (!this.refs.scrollable || !this.state.rows.length) {
	      return;
	    }
	
	    var container = ReactDOM.findDOMNode(this.refs.scrollable_wrap),
	        rowHeight = document.getElementsByClassName('hc-qs-item')[0].clientHeight,
	        start = Math.ceil(container.scrollTop / rowHeight),
	        end = Math.floor((container.clientHeight + container.scrollTop) / rowHeight);
	
	    if (this.state.selected_item < start || this.state.selected_item > end - 1) {
	      var selected_item = container.querySelector('.hc-qs-item.selected');
	      if (!selected_item) {
	        selected_item = container.querySelector('.hc-qs-item-container:last-child .hc-qs-item');
	      }
	      _utils2.default.scrollIntoViewIfNeeded(selected_item, container, false);
	    }
	  },
	  renderItem: function renderItem(index, key) {
	
	    var item = this.state.rows[index],
	        rendered_item;
	
	    if (item.item_type === 'user') {
	      var mention_markup = '@' + item.mention_match_markup;
	      rendered_item = React.createElement(_quick_switcher_person2.default, { key: 'qs-item-' + item.jid,
	        name: item.name,
	        id: item.id,
	        name_markup: item.name_match_markup,
	        mention_name: item.mention_name,
	        mention_markup: mention_markup,
	        jid: item.jid,
	        photo_url: item.photo_url,
	        show: item.presence_show,
	        mobile: item.presence_mobile,
	        idx: index,
	        should_animate_avatar: this.state.should_animate_avatar,
	        selected: this.state.selected_item === index });
	    } else {
	      rendered_item = React.createElement(_quick_switcher_room2.default, { key: 'qs-item-' + item.jid,
	        name: item.name,
	        name_markup: item.name_match_markup,
	        jid: item.jid,
	        privacy: item.privacy,
	        idx: index,
	        selected: this.state.selected_item === index });
	    }
	
	    return React.createElement(
	      'div',
	      { key: key, className: 'hc-qs-item-container' },
	      rendered_item
	    );
	  },
	  render: function render() {
	
	    var scrollableWrapClasses = (0, _classnames2.default)({
	      'hc-qs-list-wrap': true,
	      'with-hint': this.state.show_hint
	    }),
	        empty_state = this._getEmptyState(),
	        hint = this._getHint();
	
	    return React.createElement(
	      'div',
	      { className: 'hc-qs-content' },
	      React.createElement(_quick_switcher_input2.default, {
	        text: this.state.text,
	        scrollTop: this._scrollTop,
	        canNavigate: this.state.rows.length > 0,
	        scrollToSelected: this._throttledScrollToSelected,
	        ref: 'input' }),
	      React.createElement(
	        'div',
	        { ref: 'scrollable_wrap', className: scrollableWrapClasses },
	        empty_state,
	        React.createElement(ReactList, {
	          ref: 'scrollable',
	          itemRenderer: this.renderItem,
	          length: this.state.rows.length,
	          selected: this.state.selected_item,
	          filtered_time: this.state.filtered_time,
	          threshold: 10,
	          type: 'simple' })
	      ),
	      hint
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _quick_switcher_actions = __webpack_require__(397);
	
	var _quick_switcher_actions2 = _interopRequireDefault(_quick_switcher_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _quick_switcher_strings = __webpack_require__(398);
	
	var _quick_switcher_strings2 = _interopRequireDefault(_quick_switcher_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'QuickSwitcherInput',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    scrollTop: React.PropTypes.func,
	    scrollToSelected: React.PropTypes.func,
	    text: React.PropTypes.string,
	    canNavigate: React.PropTypes.bool
	  },
	
	  componentDidMount: function componentDidMount() {
	    this.debouncedFilter = _.debounce(this._filter, 150);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this.debouncedFilter.cancel();
	  },
	  _onInputChange: function _onInputChange(e) {
	    _quick_switcher_actions2.default.setInputText({
	      text: e.target.value
	    });
	    this.debouncedFilter();
	  },
	  _filter: function _filter() {
	    _quick_switcher_actions2.default.filter();
	    this.props.scrollTop();
	  },
	  _onKeyDown: function _onKeyDown(e) {
	
	    if (e.keyCode === _utils2.default.keyCode.UpArrow || e.keyCode === _utils2.default.keyCode.DownArrow) {
	      e.preventDefault();
	      _mouse_position2.default.useLatest();
	
	      if (!this.props.canNavigate) {
	        return;
	      }
	
	      if (e.keyCode === _utils2.default.keyCode.UpArrow) {
	        _quick_switcher_actions2.default.selectPrev();
	        this.props.scrollToSelected();
	      }
	
	      if (e.keyCode === _utils2.default.keyCode.DownArrow) {
	        _quick_switcher_actions2.default.selectNext();
	        this.props.scrollToSelected();
	      }
	    } else if (e.keyCode === _utils2.default.keyCode.Tab) {
	      e.preventDefault();
	    } else if (e.keyCode === _utils2.default.keyCode.Enter) {
	      e.preventDefault();
	      _dialog_actions2.default.closeDialog();
	      _quick_switcher_actions2.default.selectItem();
	    }
	  },
	  render: function render() {
	
	    /*
	     * HC-19280 Using an absolutely positioned label instead of an input placeholder here b/c IE10 & 11
	     * hide placeholders when the input is focused. Since the quick-switcher opens up focused,
	     * there's no visible instructions as to what this dialog is for
	     */
	    var labelClass = this.props.text.length ? 'hidden' : '';
	
	    return React.createElement(
	      'div',
	      { className: 'hc-qs-input-wrap' },
	      React.createElement(
	        'form',
	        { className: 'aui', autoComplete: 'off' },
	        React.createElement(
	          'label',
	          { ref: 'input_label', htmlFor: 'quickSwitcher', className: labelClass },
	          _quick_switcher_strings2.default.input_placeholder
	        ),
	        React.createElement('input', { name: 'quickSwitcher',
	          id: 'quickSwitcher',
	          className: 'text long-field hc-qs-input',
	          type: 'text',
	          ref: 'input_field',
	          onChange: this._onInputChange,
	          onKeyDown: this._onKeyDown,
	          value: this.props.text })
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  setInputText: function setInputText(data) {
	    _app_dispatcher2.default.dispatch('qs-input-value', data);
	  },
	  selectPrev: function selectPrev() {
	    _app_dispatcher2.default.dispatch('qs-select-prev');
	  },
	  selectNext: function selectNext() {
	    _app_dispatcher2.default.dispatch('qs-select-next');
	  },
	  selectItem: function selectItem() {
	    _app_dispatcher2.default.dispatch('qs-select-item');
	  },
	  itemHovered: function itemHovered(data) {
	    _app_dispatcher2.default.dispatch('qs-item-hover', {
	      index: data.index
	    });
	  },
	  reset: function reset() {
	    _app_dispatcher2.default.dispatch('qs-reset');
	  },
	  filter: function filter() {
	    _app_dispatcher2.default.dispatch('qs-filter');
	  },
	  hideHint: function hideHint() {
	    _app_dispatcher2.default.dispatch('qs-hide-hint');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 398 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  input_placeholder: "Find rooms and people",
	  empty_state: "Nothing matches your search",
	  hint_text: "Quickly open this dialog with"
	};
	module.exports = exports['default'];

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _quick_switcher_strings = __webpack_require__(398);
	
	var _quick_switcher_strings2 = _interopRequireDefault(_quick_switcher_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "QuickSwitcherEmptyState",
	
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-qs-list" },
	      React.createElement(
	        "div",
	        { className: "hc-qs-item hc-qs-empty-state", ref: "text" },
	        _quick_switcher_strings2.default.empty_state
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _quick_switcher_actions = __webpack_require__(397);
	
	var _quick_switcher_actions2 = _interopRequireDefault(_quick_switcher_actions);
	
	var _keyboard_shortcut_strings = __webpack_require__(282);
	
	var _keyboard_shortcut_strings2 = _interopRequireDefault(_keyboard_shortcut_strings);
	
	var _keyboard_shortcuts = __webpack_require__(279);
	
	var _keyboard_shortcuts2 = _interopRequireDefault(_keyboard_shortcuts);
	
	var _quick_switcher_strings = __webpack_require__(398);
	
	var _quick_switcher_strings2 = _interopRequireDefault(_quick_switcher_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'QuickSwitcherHint',
	
	  componentWillMount: function componentWillMount() {
	    var keyCommand = _keyboard_shortcuts2.default.getCommandByTitle(_keyboard_shortcut_strings2.default.new_chat);
	    if (keyCommand) {
	      this._keyCommand = keyCommand.join('+').toUpperCase();
	    }
	  },
	  getIcon: function getIcon() {
	    var icon = void 0;
	
	    if (_utils2.default.platform.isMac()) {
	      icon = React.createElement(
	        'span',
	        { className: 'hc-qs-hint-key mac-hint-key' },
	        _keyboard_shortcut_strings2.default.command
	      );
	    } else {
	      icon = React.createElement(
	        'span',
	        { className: 'hc-qs-hint-key' },
	        React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-info' })
	      );
	    }
	    return icon;
	  },
	  _onClick: function _onClick() {
	    _quick_switcher_actions2.default.hideHint();
	  },
	  render: function render() {
	
	    var classes = (0, _classnames2.default)({
	      'hc-qs-hint': true,
	      'hidden': !this._keyCommand,
	      'with-results': this.props.with_results
	    }),
	        hint_icon = this.getIcon();
	
	    return React.createElement(
	      'div',
	      { className: classes, ref: 'hint' },
	      hint_icon,
	      React.createElement(
	        'span',
	        { className: 'hc-qs-hint-text' },
	        _quick_switcher_strings2.default.hint_text + ' ' + this._keyCommand
	      ),
	      React.createElement('span', {
	        onClick: this._onClick,
	        ref: 'close_hint',
	        className: 'aui-icon aui-icon-small aui-iconfont-remove-label hc-qs-hint-close' })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _chat_search = __webpack_require__(273);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var QuickSwitcherStore = function (_Store) {
	  (0, _inherits3.default)(QuickSwitcherStore, _Store);
	
	  function QuickSwitcherStore() {
	    (0, _classCallCheck3.default)(this, QuickSwitcherStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(QuickSwitcherStore).call(this));
	
	    _this.local = _this.getLocalDefaults();
	    return _this;
	  }
	
	  (0, _createClass3.default)(QuickSwitcherStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        text: '',
	        list: [],
	        filtered: false,
	        filtered_time: null,
	        selected_item: 0
	      };
	    }
	  }, {
	    key: 'getLocalDefaults',
	    value: function getLocalDefaults() {
	      return {
	        enabled: false,
	        all: [],
	        active: {},
	        rooms: [],
	        roster: []
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'qs-input-value': function qsInputValue(data) {
	          _this2.handleInputValueChange(data.text);
	        },
	        'qs-item-hover': function qsItemHover(data) {
	          _this2.set({
	            selected_item: data.index
	          });
	        },
	        'qs-select-item': function qsSelectItem() {
	          _this2.selectItem();
	        },
	        'qs-select-prev': function qsSelectPrev() {
	          _this2.selectPrev();
	        },
	        'qs-select-next': function qsSelectNext() {
	          _this2.selectNext();
	        },
	        'qs-filter': function qsFilter() {
	          _this2.filterList(true);
	        },
	        'qs-reset': function qsReset() {
	          _this2.resetQuickSwitcher();
	        },
	        'qs-hide-hint': function qsHideHint() {
	          _this2.hideHint();
	        },
	        'before:show-modal-dialog': function beforeShowModalDialog(data) {
	          _this2.enableQuickSwitcher(data);
	        },
	        'before:hide-modal-dialog': function beforeHideModalDialog() {
	          _this2.disableQuickSwitcher();
	        },
	        'updated:roster': function updatedRoster() {
	          if (_this2.local.enabled) {
	            _this2.setupLocalData();
	            _this2.filterList();
	          }
	        }
	      });
	    }
	  }, {
	    key: 'enableQuickSwitcher',
	    value: function enableQuickSwitcher(data) {
	      if (!this.local.enabled && _.get(data, "dialog_type") === "quick-switcher-dialog") {
	        this.local.enabled = true;
	        this.setupLocalData();
	      }
	    }
	  }, {
	    key: 'disableQuickSwitcher',
	    value: function disableQuickSwitcher() {
	      if (this.local.enabled) {
	        this.clearLocalData();
	      }
	    }
	  }, {
	    key: 'setupLocalData',
	    value: function setupLocalData() {
	      this.updateRooms(_application_store2.default.get("allRooms"));
	      this.updateActive(_application_store2.default.get("activeRooms"));
	      this.updateRoster(_application_store2.default.get("roster"));
	    }
	  }, {
	    key: 'clearLocalData',
	    value: function clearLocalData() {
	      this.local = this.getLocalDefaults();
	    }
	  }, {
	    key: 'filterList',
	    value: function filterList() {
	      var forceUpdate = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      var query = this.data.text;
	
	      if (query) {
	        var priorities = _.keysIn(this.local.active),
	            sorted_list = (0, _chat_search.chatSearch)(this.local.all, query, priorities);
	
	        if (forceUpdate || this.data.selected_item > sorted_list.length - 1) {
	          this.data.selected_item = 0;
	        }
	
	        this.set({
	          list: sorted_list,
	          filtered_time: new Date().getTime(),
	          selected_item: this.data.selected_item,
	          filtered: true
	        });
	      } else {
	        this.set({
	          list: [],
	          selected_item: 0,
	          filtered_time: null,
	          filtered: false
	        });
	      }
	    }
	  }, {
	    key: 'handleInputValueChange',
	    value: function handleInputValueChange(text) {
	      this.set({
	        text: text,
	        filtered: false
	      });
	    }
	  }, {
	    key: 'updateAll',
	    value: function updateAll() {
	      var _this3 = this;
	
	      this.local.all = _.map(this.local.all, function (chat) {
	        if (_this3.local.active[chat.jid]) {
	          _.assign(chat, _this3.local.active[chat.jid]);
	        } else {
	          // for not active rooms
	          _.assign(chat, {
	            unreadCount: 0,
	            unreadMentionCount: 0,
	            hasMention: false
	          });
	        }
	        return chat;
	      });
	    }
	  }, {
	    key: 'updateActive',
	    value: function updateActive(updated_rooms) {
	      this.local.active = _.mapValues(updated_rooms, function (room) {
	        return _.pick(room, 'unreadCount', 'unreadMentionCount', 'hasMention');
	      });
	      this.updateAll();
	    }
	  }, {
	    key: 'updateRooms',
	    value: function updateRooms(updated_rooms) {
	      var rooms = [];
	      _.forOwn(updated_rooms, function (room) {
	        rooms.push({
	          item_type: 'room',
	          name: room.name,
	          jid: room.jid,
	          privacy: room.privacy
	        });
	      });
	      this.local.rooms = rooms;
	      this.updateAndConcatAll();
	    }
	  }, {
	    key: 'removeGuests',
	    value: function removeGuests(roster) {
	      return _.reject(roster, _utils2.default.user.is_guest);
	    }
	  }, {
	    key: 'mapUserData',
	    value: function mapUserData(user) {
	      return {
	        item_type: 'user',
	        id: user.id,
	        name: user.display_name || user.name,
	        mention_name: user.mention_name,
	        jid: user.jid,
	        photo_url: user.photo_url,
	        presence_show: user.presence.show,
	        presence_mobile: user.presence.mobile
	      };
	    }
	  }, {
	    key: 'updateRoster',
	    value: function updateRoster(updated_roster) {
	      // The roster comes in as an object. Mapping the values of it to an array.
	      var roster = _.values(updated_roster);
	
	      this.local.roster = this.removeGuests(roster).map(this.mapUserData);
	      this.updateAndConcatAll();
	    }
	  }, {
	    key: 'updateAndConcatAll',
	    value: function updateAndConcatAll() {
	      this.local.all = [].concat(this.local.roster, this.local.rooms);
	      this.updateAll();
	    }
	  }, {
	    key: 'selectItem',
	    value: function selectItem() {
	      var item = this.data.list[this.data.selected_item];
	
	      if (!item) {
	        return;
	      }
	
	      _app_dispatcher2.default.dispatch('set-route', {
	        jid: item.jid
	      });
	      _analytics_dispatcher2.default.dispatch('analytics-open-room', {
	        jid: item.jid,
	        source: 'switcher'
	      });
	    }
	  }, {
	    key: 'selectNext',
	    value: function selectNext() {
	      var selected_item;
	      if (this.data.selected_item !== this.data.list.length - 1) {
	        selected_item = this.data.selected_item + 1;
	      }
	      this.set('selected_item', selected_item);
	    }
	  }, {
	    key: 'selectPrev',
	    value: function selectPrev() {
	      var selected_item;
	      if (this.data.selected_item !== 0) {
	        selected_item = this.data.selected_item - 1;
	      }
	      this.set('selected_item', selected_item);
	    }
	  }, {
	    key: 'resetQuickSwitcher',
	    value: function resetQuickSwitcher() {
	      this.set({
	        text: '',
	        list: [],
	        selected_item: 0,
	        filtered: false
	      });
	    }
	  }, {
	    key: 'hideHint',
	    value: function hideHint() {
	      _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _client_preferences_keys2.default.SHOW_QUICK_SWITCHER_HINT, false));
	    }
	  }]);
	  return QuickSwitcherStore;
	}(_store2.default);
	
	exports.default = new QuickSwitcherStore();
	module.exports = exports['default'];

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _quick_switcher_actions = __webpack_require__(397);
	
	var _quick_switcher_actions2 = _interopRequireDefault(_quick_switcher_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'QuickSwitcherPerson',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    'selected': React.PropTypes.bool,
	    'photo_url': React.PropTypes.string,
	    'name': React.PropTypes.string,
	    'name_markup': React.PropTypes.string,
	    'mention_name': React.PropTypes.string,
	    'mention_markup': React.PropTypes.string,
	    'show': React.PropTypes.string,
	    'mobile': React.PropTypes.string,
	    'idx': React.PropTypes.number,
	    'id': React.PropTypes.oneOfType([React.PropTypes.number, React.PropTypes.string]),
	    'should_animate_avatar': React.PropTypes.bool
	  },
	
	  _onEnter: function _onEnter(evt) {
	    if (_mouse_position2.default.hasChanged(evt)) {
	      _quick_switcher_actions2.default.itemHovered({
	        index: this.props.idx
	      });
	    }
	  },
	  _onClick: function _onClick(e) {
	    e.preventDefault();
	    _dialog_actions2.default.closeDialog();
	    _quick_switcher_actions2.default.selectItem();
	  },
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      'hc-qs-item': true,
	      'selected': this.props.selected
	    });
	
	    return React.createElement(
	      'div',
	      { className: classes, onClick: this._onClick, onMouseEnter: this._onEnter },
	      React.createElement(
	        'span',
	        { className: 'hc-qs-aui-avatar' },
	        React.createElement(_person_avatar2.default, {
	          avatar_url: this.props.photo_url,
	          size: 'medium',
	          uid: this.props.id,
	          presence: this.props.show,
	          mobile: this.props.mobile,
	          shouldAnimate: this.props.should_animate_avatar,
	          active: 'false' })
	      ),
	      React.createElement('span', { className: 'hc-qs-name', dangerouslySetInnerHTML: { __html: this.props.name_markup || this.props.name } }),
	      React.createElement('span', { className: 'hc-qs-mention-name', dangerouslySetInnerHTML: { __html: this.props.mention_markup || this.props.mention_name } })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _quick_switcher_actions = __webpack_require__(397);
	
	var _quick_switcher_actions2 = _interopRequireDefault(_quick_switcher_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "QuickSwitcherRoom",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    "selected": React.PropTypes.bool,
	    "name": React.PropTypes.string,
	    "name_markup": React.PropTypes.string,
	    "privacy": React.PropTypes.string,
	    "idx": React.PropTypes.number
	  },
	
	  _onEnter: function _onEnter(evt) {
	    if (_mouse_position2.default.hasChanged(evt)) {
	      _quick_switcher_actions2.default.itemHovered({
	        index: this.props.idx
	      });
	    }
	  },
	  _onClick: function _onClick(e) {
	    e.preventDefault();
	    _dialog_actions2.default.closeDialog();
	    _quick_switcher_actions2.default.selectItem();
	  },
	  render: function render() {
	
	    var classes = (0, _classnames2.default)({
	      "hc-qs-item": true,
	      "selected": this.props.selected
	    });
	
	    return React.createElement(
	      "div",
	      { className: classes, onClick: this._onClick, onMouseEnter: this._onEnter },
	      React.createElement("span", { className: "hc-qs-room-icon aui-icon hipchat-icon-medium icon-" + (this.props.privacy || 'dot') }),
	      React.createElement("span", { className: "hc-qs-name", dangerouslySetInnerHTML: { __html: this.props.name_markup || this.props.name } })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _cookies = __webpack_require__(405);
	
	var _cookies2 = _interopRequireDefault(_cookies);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "InviteTeammatesDialog",
	
	  mixins: [_modal_dialog_visibility_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    var _this = this;
	
	    this._setClientCookie();
	    this._getIframe().on("load", this._onIframeLoad);
	    this.spinTimer = _.delay(function () {
	      if (!_this._getIframe().hasClass('loaded')) {
	        AJS.$("#invite-teammates-dialog >.aui-dialog2-content").spin('large');
	      }
	    }, _app_config2.default.modal_transition_allowance);
	    $(window).on('beforeunload', this._removeClientCookie);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._removeClientCookie();
	    clearTimeout(this.spinTimer);
	    this._getIframe().off("load", this._onIframeLoad);
	    $(window).off('beforeunload', this._removeClientCookie);
	  },
	
	
	  _setClientCookie: function _setClientCookie() {
	    _cookies2.default.setItem("client", "web");
	  },
	
	  _removeClientCookie: function _removeClientCookie() {
	    _cookies2.default.removeItem("client", "web");
	  },
	
	  _onIframeLoad: function _onIframeLoad() {
	    var _this2 = this;
	
	    AJS.$("#invite-teammates-dialog >.aui-dialog2-content").spinStop();
	    this._getIframe().addClass("loaded");
	    var $body = $(this._getIframeBody());
	    $body.find("#btn_copy_invite_link").remove();
	    $body.find(".external-link").click(function (e) {
	      var $target = $(e.target);
	      $target.attr("target", "_blank");
	      $target.attr("href", _this2._getExternalUrl($target.attr("href")));
	    });
	    $body.find("a[href='#hcnative:close']").click(this._close);
	    $body.on('keydown', this._onKeyDown);
	    $body.find("#btn_send_invites").click(function (e) {
	      if ($(e.target).attr('aria-disabled') !== 'true') {
	        var number = $(e.target).text().replace(/\D/g, '');
	        if (_this2.state.dialogData && _this2.state.dialogData.type) {
	          _analytics_actions2.default.inviteTeamSent(_this2.state.dialogData.type, number);
	        }
	      }
	    });
	  },
	
	
	  _getExternalUrl: function _getExternalUrl(href) {
	    var url;
	
	    var key = "#hcnative:externalLinkClicked:";
	
	    var keyIndex = href.indexOf(key);
	    if (keyIndex > -1) {
	      var uri = decodeURIComponent(href.substr(keyIndex + key.length));
	      try {
	        var data = JSON.parse(uri);
	        url = data.url;
	      } catch (e) {
	        url = null;
	      }
	    }
	
	    return url;
	  },
	
	  _getIframe: function _getIframe() {
	    return $(ReactDOM.findDOMNode(this.refs.inviteUsersIframe));
	  },
	  _getIframeBody: function _getIframeBody() {
	    return _.get(this._getIframe().get(0), 'contentWindow.document.body');
	  },
	  _close: function _close() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	
	  _onKeyDown: function _onKeyDown(e) {
	    var key = window.Event ? e.which : e.keyCode;
	    if (key === _utils2.default.keyCode.Esc) {
	      this._close();
	    }
	  },
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement('iframe', { ref: 'inviteUsersIframe', id: 'invite-users-frame', src: 'https://' + this.props.web_server + '/native/invite?default_text=' + (this.props.default_text || '') });
	  },
	
	  render: function render() {
	    return React.createElement(
	      'section',
	      { role: 'dialog', id: 'invite-teammates-dialog', className: 'aui-layer aui-dialog2 aui-dialog2-medium',
	        'aria-hidden': !this.state.dialogVisible },
	      React.createElement(
	        'div',
	        { className: 'aui-dialog2-content' },
	        this._dialogBody()
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 405 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	  getItem: function getItem(sKey) {
	    if (!sKey) {
	      return null;
	    }
	    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	  },
	  setItem: function setItem(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	      return false;
	    }
	    var sExpires = "";
	    if (vEnd) {
	      switch (vEnd.constructor) {
	        case Number:
	          sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	          break;
	        case String:
	          sExpires = "; expires=" + vEnd;
	          break;
	        case Date:
	          sExpires = "; expires=" + vEnd.toUTCString();
	          break;
	      }
	    }
	    document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	    return true;
	  },
	  removeItem: function removeItem(sKey, sPath, sDomain) {
	    if (!this.hasItem(sKey)) {
	      return false;
	    }
	    document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	    return true;
	  },
	  hasItem: function hasItem(sKey) {
	    if (!sKey) {
	      return false;
	    }
	    return new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(document.cookie);
	  },
	  keys: function keys() {
	    var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	    for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	      aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	    }
	    return aKeys;
	  }
	};

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _rooms_nav_store = __webpack_require__(368);
	
	var _rooms_nav_store2 = _interopRequireDefault(_rooms_nav_store);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _room_dropdown_actions = __webpack_require__(287);
	
	var _room_dropdown_actions2 = _interopRequireDefault(_room_dropdown_actions);
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "GuestAccessDialog",
	
	  mixins: [_modal_dialog_visibility_mixin2.default],
	
	  getInitialState: function getInitialState() {
	    return this._getActiveChatState();
	  },
	
	  _getActiveChatState: function _getActiveChatState() {
	    return {
	      active_chat: _rooms_nav_store2.default.get("active_chat"),
	      rooms: _rooms_nav_store2.default.get("rooms")
	    };
	  },
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        null,
	        React.createElement(
	          "strong",
	          null,
	          _dialog_strings2.default.really_disable_guest
	        )
	      ),
	      React.createElement(
	        "p",
	        null,
	        _dialog_strings2.default.confirm_disable_guest
	      )
	    );
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { onClick: this._onFooterButtonClicked, className: "aui-button aui-button-primary", "aria-disabled": this.state.btnLoading, disabled: this.state.btnLoading },
	      _dialog_strings2.default.ok
	    );
	  },
	
	  _onFooterButtonClicked: function _onFooterButtonClicked(e) {
	    e.preventDefault();
	    this._disableGuestAccess();
	  },
	
	  _disableGuestAccess: function _disableGuestAccess() {
	    _dialog_actions2.default.startBtnLoading();
	
	    _room_dropdown_actions2.default.disableGuestAccess({
	      jid: this.state.active_chat
	    }, this._disableGuestCallback);
	  },
	
	  _disableGuestCallback: function _disableGuestCallback(error) {
	    if (error) {
	      this._throwFlagError(error.message || _dialog_strings2.default.disable_guest_fail);
	    }
	    _dialog_actions2.default.closeDialog();
	  },
	
	  _throwFlagError: function _throwFlagError(errorMessage) {
	    _flag_actions2.default.showFlag({
	      type: "error",
	      body: this._flagBody(errorMessage),
	      close: "manual"
	    });
	  },
	
	  _flagBody: function _flagBody(errorMessage) {
	    var _this = this;
	
	    return function () {
	      return React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "p",
	          { className: "hc-message-body" },
	          errorMessage
	        ),
	        React.createElement(
	          "ul",
	          { className: "aui-nav-actions-list" },
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { onClick: _this._flagActionClick, href: "#" },
	              _dialog_strings2.default.try_again
	            )
	          )
	        )
	      );
	    };
	  },
	
	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data('flag-index');
	    _flag_actions2.default.removeFlag(flag_index);
	    this._showDialog();
	  },
	
	  _showDialog: function _showDialog() {
	    _dialog_actions2.default.showDisableGuestAccessDialog();
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: "disable-guest-dialog",
	      title: _dialog_strings2.default.disable_guest,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      btnLoading: this.state.btnLoading,
	      closeLinkText: _dialog_strings2.default.cancel });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _room_notifications_form = __webpack_require__(408);
	
	var _room_notifications_form2 = _interopRequireDefault(_room_notifications_form);
	
	var _ie_submit_mixin = __webpack_require__(369);
	
	var _ie_submit_mixin2 = _interopRequireDefault(_ie_submit_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "RoomNotificationsDialog",
	
	  mixins: [_ie_submit_mixin2.default],
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(_room_notifications_form2.default, { jid: this.props.jid, room_name: this.props.room_name });
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: 'room-notifications-dialog',
	      title: _dialog_strings2.default.room_notifications,
	      size: 'small',
	      dialogBody: this._dialogBody,
	      noCloseLink: true });
	  }
	});

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _aui_form_fieldset = __webpack_require__(357);
	
	var _aui_form_fieldset2 = _interopRequireDefault(_aui_form_fieldset);
	
	var _aui_radio = __webpack_require__(349);
	
	var _aui_radio2 = _interopRequireDefault(_aui_radio);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "RoomNotificationsForm",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  _getNotificationSettings: function _getNotificationSettings() {
	    return _.get(_preferences_store2.default.getRoomNotificationOverrides(), this.props.jid, {});
	  },
	  _saveNotificationSettings: function _saveNotificationSettings(newSettings) {
	    // if they set it back to the global settings, let's remove the override
	    // otherwise let's save their overriden settings
	    if (newSettings.level === "global") {
	      _preferences_store2.default.removeRoomNotificationOverride(this.props.jid);
	    } else {
	      // save it to the server
	      _preferences_store2.default.overrideNotificationForRoom(this.props.jid, newSettings);
	    }
	  },
	
	
	  /**
	   * This function exists to help us understand how to properly keep the two sets of radios
	   * properly sync'd up.
	   */
	  _getSelection: function _getSelection(event) {
	    var targetId = _.get(event, "target.id", "notif-global"),
	        retVal = {
	      is_overridden: true
	    };
	
	    switch (targetId) {
	      case "notif-loud":
	        retVal.level = "loud";
	        break;
	      case "notif-normal":
	        retVal.level = "normal";
	        break;
	      case "notif-quiet":
	        retVal.level = "quiet";
	        break;
	      case "notif-custom":
	        retVal.level = this.state.global_setting;
	        break;
	      case "notif-global":
	        retVal.level = "global";
	        retVal.is_overridden = false;
	        break;
	    }
	
	    return retVal;
	  },
	  _onChange: function _onChange(event) {
	    var inputInfo = this._getSelection(event);
	
	    // if they've actually changed the value, or if they've changed between global and custom, fire an analytics event
	    if (this.state.level !== inputInfo.level || this.state.is_overridden !== inputInfo.is_overridden) {
	      _analytics_actions2.default.roomNotificationLevelChanged(this.state.level, inputInfo.level);
	    }
	    var newVal = _.merge({}, this._getState(), { level: inputInfo.level, is_overridden: inputInfo.is_overridden });
	    this.setState(newVal);
	    this._saveNotificationSettings({ level: inputInfo.level });
	  },
	  _getState: function _getState() {
	    var global_setting = _preferences_store2.default.getGlobalNotificationSetting();
	    var settings = this._getNotificationSettings(),
	        notification_level = _.get(settings, "level", "global"),
	        is_overridden = notification_level !== "global";
	
	    return {
	      mention: _current_user_store2.default.get('mention') || '',
	      global_setting: global_setting,
	      level: notification_level,
	      is_overridden: is_overridden
	    };
	  },
	  _showSettingsDialog: function _showSettingsDialog() {
	    _dialog_actions2.default.showSettingDialog({ activeTab: _dialog_strings2.default.notifications });
	  },
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	  _getDefaultLabelDecoration: function _getDefaultLabelDecoration() {
	    var levelIcon = 'icon-volume-' + this.state.global_setting;
	    var levelLabel = _forms_strings2.default.label[this.state.global_setting];
	    var classNames = 'aui-icon hipchat-icon-small global ' + levelIcon;
	
	    return React.createElement(
	      'span',
	      null,
	      React.createElement(
	        'span',
	        { className: classNames },
	        levelLabel
	      ),
	      React.createElement(
	        'span',
	        { className: 'global-level-label' },
	        levelLabel
	      )
	    );
	  },
	  render: function render() {
	    var defaultLabelDecoration = this._getDefaultLabelDecoration();
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'div',
	        { className: 'heading' },
	        React.createElement(
	          'span',
	          { className: 'prefix' },
	          _forms_strings2.default.description.notif_header_prefix
	        ),
	        React.createElement(
	          'span',
	          { className: 'room-name', title: this.props.room_name },
	          this.props.room_name
	        ),
	        React.createElement(
	          'div',
	          { className: 'settings-info' },
	          _forms_strings2.default.description.notif_settings_info_prefix,
	          React.createElement(
	            'a',
	            { onClick: this._showSettingsDialog },
	            _forms_strings2.default.description.notif_settings_link
	          ),
	          _forms_strings2.default.description.notif_settings_info_suffix
	        )
	      ),
	      React.createElement(
	        'form',
	        { id: 'room-notifications-form', ref: 'form', className: 'aui', onChange: this._onChange },
	        React.createElement(
	          _aui_form_fieldset2.default,
	          { ref: 'global' },
	          defaultLabelDecoration,
	          React.createElement(_aui_radio2.default, { id: 'notif-global',
	            name: 'override',
	            className: 'notif-global-radio',
	            defaultChecked: this.state.level === "global",
	            checked: !this.state.is_overridden,
	            value: 'global',
	            label: _forms_strings2.default.label.default_text }),
	          React.createElement(_aui_radio2.default, { id: 'notif-custom',
	            name: 'override',
	            defaultChecked: this.state.is_overridden,
	            checked: this.state.is_overridden,
	            value: 'custom',
	            label: _forms_strings2.default.label.custom })
	        ),
	        React.createElement(
	          _aui_form_fieldset2.default,
	          { ref: 'override-opts', className: 'override-opts' },
	          React.createElement(_aui_radio2.default, { id: 'notif-loud',
	            name: 'notification',
	            defaultChecked: this.state.level === "loud",
	            checked: this.state.is_overridden && this.state.level === "loud",
	            value: 'loud', label: _forms_strings2.default.label.loud,
	            icon: 'volume-loud',
	            description: _forms_strings2.default.description.notif_loud }),
	          React.createElement(_aui_radio2.default, { id: 'notif-normal',
	            name: 'notification',
	            defaultChecked: this.state.level === "normal",
	            checked: this.state.is_overridden && this.state.level === "normal",
	            value: 'normal', label: _forms_strings2.default.label.normal,
	            icon: 'volume-normal',
	            description: _forms_strings2.default.description.notif_normal(this.state.mention) }),
	          React.createElement(_aui_radio2.default, { id: 'notif-quiet',
	            name: 'notification',
	            defaultChecked: this.state.level === "quiet",
	            checked: this.state.is_overridden && this.state.level === "quiet",
	            value: 'quiet', label: _forms_strings2.default.label.quiet,
	            icon: 'volume-quiet',
	            description: _forms_strings2.default.description.notif_quiet(this.state.mention) })
	        )
	      )
	    );
	  }
	});

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ModalDialog = __webpack_require__(341);
	var KeyboardShortcutStrings = __webpack_require__(282);
	
	module.exports = React.createClass({
	
	  displayName: "KeyboardShortcutsDialog",
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      shortcuts: {}
	    };
	  },
	
	  _getKeyItem: function _getKeyItem(command, index) {
	    var keys = this._getKeyLayout(command.keys);
	    return React.createElement(
	      "li",
	      { className: "hc-list-item", key: index },
	      React.createElement(
	        "span",
	        { className: "hc-list-item-desc" },
	        command.title
	      ),
	      keys
	    );
	  },
	
	  _getKeyLayout: function _getKeyLayout(keys) {
	    var _this = this;
	
	    return React.createElement(
	      "span",
	      { className: "hc-list-item-action" },
	      _.map(keys, function (item, index) {
	        return _this._getKey(item, index);
	      })
	    );
	  },
	
	  _getKey: function _getKey(key, index) {
	    var keyClass = "hc-key-" + key.type,
	        name = key.name,
	        keyLayout;
	    if (index !== 0) {
	      keyLayout = React.createElement(
	        "span",
	        { key: index },
	        React.createElement(
	          "span",
	          { className: "hc-key-separator" },
	          KeyboardShortcutStrings.separator
	        ),
	        React.createElement(
	          "kbd",
	          { className: keyClass },
	          name
	        )
	      );
	    } else {
	      keyLayout = React.createElement(
	        "kbd",
	        { className: keyClass, key: index },
	        name
	      );
	    }
	    return keyLayout;
	  },
	
	  _dialogBody: function _dialogBody() {
	    var _this2 = this;
	
	    return React.createElement(
	      "ul",
	      { className: "hc-list" },
	      _.map(this.props.shortcuts, function (command, index) {
	        return _this2._getKeyItem(command, index);
	      })
	    );
	  },
	
	  render: function render() {
	    var attrs = {
	      'dialogId': 'keyboard-shortcuts-dialog',
	      'title': 'Keyboard Shortcuts',
	      'dialogBody': this._dialogBody,
	      'size': 'medium'
	    };
	
	    return React.createElement(ModalDialog, attrs);
	  }
	});

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog_alternate = __webpack_require__(383);
	
	var _modal_dialog_alternate2 = _interopRequireDefault(_modal_dialog_alternate);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _release_notes_strings = __webpack_require__(411);
	
	var _release_notes_strings2 = _interopRequireDefault(_release_notes_strings);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function matchEndpoint(type, subtype) {
	  switch (type) {
	    case 'qt':
	      return matchEndpoint(subtype);
	
	    case 'windows':
	      return 'qtwindows';
	
	    case 'linux':
	      return 'qtlinux';
	
	    default:
	      return type;
	  }
	}
	
	exports.default = React.createClass({
	
	  displayName: "ReleaseNotesDialog",
	
	  getInitialState: function getInitialState() {
	    return {
	      asset_base_uri: _application_store2.default.get('asset_base_uri'),
	      client_version_id: _application_store2.default.get('client_version_id'),
	      endpoint: matchEndpoint(_application_store2.default.get('client_type'), _application_store2.default.get('client_subtype'))
	    };
	  },
	
	  _onClick: function _onClick() {
	    _dialog_actions2.default.closeDialog();
	  },
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(
	      "div",
	      { className: "release-notes" },
	      React.createElement("img", { src: this.state.asset_base_uri + _app_config2.default.new_hotness_image_asset }),
	      React.createElement(
	        "h2",
	        { className: "release-notes-header" },
	        _release_notes_strings2.default.header
	      ),
	      React.createElement(
	        "div",
	        { className: "inner-content" },
	        React.createElement("iframe", { ref: "iframe", src: "https://www.hipchat.com/release_notes/client_embed/" + this.state.endpoint + "?version_str=" + this.state.client_version_id })
	      ),
	      React.createElement(
	        "button",
	        { className: "aui-button aui-button-primary", onClick: this._onClick },
	        _release_notes_strings2.default.close
	      )
	    );
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog_alternate2.default, { dialogId: "release-notes-dialog",
	      dialogBody: this._dialogBody,
	      size: "small" });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 411 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  header: "Release Notes",
	  close: "Close"
	};
	module.exports = exports['default'];

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _integration_frame = __webpack_require__(413);
	
	var _integration_frame2 = _interopRequireDefault(_integration_frame);
	
	var _integrations_view_store = __webpack_require__(436);
	
	var _integrations_view_store2 = _interopRequireDefault(_integrations_view_store);
	
	var _integration_dialog_store = __webpack_require__(428);
	
	var _integration_dialog_store2 = _interopRequireDefault(_integration_dialog_store);
	
	var _integration_dialog_actions = __webpack_require__(427);
	
	var _integration_dialog_actions2 = _interopRequireDefault(_integration_dialog_actions);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _integrations_view_actions = __webpack_require__(425);
	
	var _integrations_view_actions2 = _interopRequireDefault(_integrations_view_actions);
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "IntegrationDialog",
	
	  propTypes: {
	    integration: React.PropTypes.shape({
	      full_key: React.PropTypes.string.isRequired
	    }).isRequired,
	    room_id: React.PropTypes.string.isRequired,
	    init_event: React.PropTypes.object
	  },
	
	  componentWillMount: function componentWillMount() {
	    this.filterChange = _.debounce(_integration_dialog_actions2.default.filterChange, _app_config2.default.dialog.filter_debounce_wait);
	  },
	
	  componentDidMount: function componentDidMount() {
	    _integration_dialog_store2.default.on('change', this._onChange);
	    _integrations_view_store2.default.onIntegrationViewStatusChange(this.props.room_id, this.props.integration.full_key, this._onChange);
	    _preferences_store2.default.on('change:theme', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _integration_dialog_store2.default.off('change', this._onChange);
	    _integrations_view_store2.default.offIntegrationViewStatusChange(this.props.room_id, this.props.integration.full_key, this._onChange);
	    _preferences_store2.default.off('change:theme', this._onChange);
	  },
	
	  getInitialState: function getInitialState() {
	    return _.merge({
	      view: {
	        signed_url_loading: true
	      }
	    }, this._getState());
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _getState: function _getState() {
	    return {
	      dialog: _integration_dialog_store2.default.getAll(),
	      view: _integrations_view_store2.default.getIntegrationViewStatus(this.props.room_id, this.props.integration.full_key) || {},
	      theme: _preferences_store2.default.get('theme')
	    };
	  },
	
	  _renderErrorFrame: function _renderErrorFrame() {
	    if (!this.state.view.error) {
	      return null;
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-integrations-error' },
	      React.createElement('div', { className: 'hc-integrations-error-image' }),
	      React.createElement(
	        'p',
	        null,
	        _integrations_strings2.default.integration_failed_to_load
	      ),
	      React.createElement(
	        'button',
	        { onClick: this._retryLoadingPanel, className: 'aui-button aui-button-primary' },
	        _integrations_strings2.default.retry
	      )
	    );
	  },
	
	  _renderIntegrationFrame: function _renderIntegrationFrame() {
	    if (!this._canRender()) {
	      return null;
	    }
	
	    var signed_url = _utils2.default.appendQueryParameter(this.state.view.signed_url, "theme", this.state.theme);
	
	    return React.createElement(_integration_frame2.default, { integration: this.state.dialog,
	      signed_url: signed_url,
	      room_id: this.props.room_id,
	      init_event: this.props.init_event });
	  },
	
	  _dialogBody: function _dialogBody() {
	    var loading = false;
	    var containerStyle = "hc-integration-view-dialog";
	    if (!this.props.integration.internal) {
	      loading = this.state.view.signed_url_loading || this.state.view.signed_url && this.state.view.frame_loading !== false;
	      containerStyle += " hc-integration-view-dialog-loading";
	    }
	
	    return React.createElement(
	      'div',
	      { className: containerStyle },
	      React.createElement(_spinner2.default, { spin: loading }),
	      this._renderIntegrationFrame(),
	      this._renderErrorFrame()
	    );
	  },
	
	  _dialogFilterPlaceholder: function _dialogFilterPlaceholder() {
	    var filter = this.state.dialog.options.filter;
	    return filter ? filter.placeholder : "";
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    var primaryAction = this.state.dialog.options.primaryAction;
	    if (primaryAction) {
	      return this._renderButton(primaryAction, "aui-button-primary");
	    }
	  },
	
	  _dialogFooterLinks: function _dialogFooterLinks() {
	    var _this = this;
	
	    var secondaryActions = this.state.dialog.options.secondaryActions;
	    if (secondaryActions) {
	      return _.map(secondaryActions, function (action, index) {
	        var key = _this.props.integration.full_key + ':' + index;
	        return _this._renderButton(action, "aui-button-link", key);
	      });
	    }
	    return this._renderButton({ enabled: true, name: _dialog_strings2.default.close }, "aui-button-link");
	  },
	
	  _renderButton: function _renderButton(action, style, key) {
	    var disabled = !_.get(action, "enabled", true);
	    return React.createElement(
	      'button',
	      { 'aria-disabled': disabled, disabled: disabled, className: "aui-button " + style, key: key,
	        onClick: this._onButtonClick, 'data-action-key': action.key },
	      action.name
	    );
	  },
	
	  _isWarning: function _isWarning() {
	    return this.state.dialog.options.style === "warning";
	  },
	
	  _auiDialogSize: function _auiDialogSize() {
	    var size = this.state.dialog.options.size;
	    if (_.isString(size)) {
	      return size;
	    }
	    return "medium";
	  },
	
	  _customDialogWidth: function _customDialogWidth() {
	    return this._customDialogDimension('width', $(window).width());
	  },
	
	  _customDialogHeight: function _customDialogHeight() {
	    return this._customDialogDimension('height', $(window).height() - _app_config2.default.dialog.max_size_margin);
	  },
	
	  _customDialogDimension: function _customDialogDimension(dim, maxAllowed) {
	    var rawValue = _.get(this.state.dialog.options, ['size', dim]);
	    if (rawValue) {
	      var value = _utils2.default.strings.splitUnit(rawValue);
	      if (value) {
	        switch (value.unit) {
	          case '%':
	            return Math.min(100, value.num) + '%';
	          case 'px':
	            return Math.min(maxAllowed, value.num) + 'px';
	          default:
	            _logger2.default.error('[HC-Integrations]', 'Unsupported unit: ' + value.unit);
	        }
	      } else {
	        _logger2.default.error('[HC-Integrations]', 'Unsupported  format: ' + rawValue);
	      }
	    }
	  },
	
	  _onButtonClick: function _onButtonClick(e) {
	    var actionKey = e.target.getAttribute("data-action-key");
	    _integration_dialog_actions2.default.buttonClick(this.state.dialog, actionKey);
	  },
	
	  _onFilterChange: function _onFilterChange(e) {
	    this.filterChange(this.state.dialog, e.target.value);
	  },
	
	  _canRender: function _canRender() {
	    return _.isString(this.state.view.signed_url) && _.isString(this.state.dialog.addon_key) && _.isString(this.state.dialog.key);
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: 'integration-dialog',
	      size: this._auiDialogSize(),
	      customWidth: this._customDialogWidth(),
	      customHeight: this._customDialogHeight(),
	      title: this.state.dialog.title,
	      dialogBody: this._dialogBody,
	      dialogFilter: !!this.state.dialog.options.filter,
	      dialogFilterPlaceholder: this._dialogFilterPlaceholder(),
	      dialogFilterCallback: this._onFilterChange,
	      dialogFooterButton: this._dialogFooterButton,
	      dialogFooterLinks: this._dialogFooterLinks,
	      hint: this.state.dialog.options.hint,
	      isWarning: this._isWarning(),
	      noCloseLink: true });
	  },
	
	  _retryLoadingPanel: function _retryLoadingPanel() {
	    if (this.state.view.error) {
	      _integrations_view_actions2.default.fetchSignedUrl(this.state.dialog, this.props.room_id, this.state.view.url_template_values);
	    }
	  }
	});

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _host = __webpack_require__(386);
	
	var _host2 = _interopRequireDefault(_host);
	
	var _api_integration = __webpack_require__(414);
	
	var _api_integration2 = _interopRequireDefault(_api_integration);
	
	var _integrations_view_actions = __webpack_require__(425);
	
	var _integrations_view_actions2 = _interopRequireDefault(_integrations_view_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "IntegrationFrameView",
	
	  propTypes: {
	    integration: React.PropTypes.shape({
	      addon_key: React.PropTypes.string.isRequired,
	      key: React.PropTypes.string.isRequired
	    }).isRequired,
	    signed_url: React.PropTypes.string.isRequired,
	    room_id: React.PropTypes.string.isRequired,
	    init_event: React.PropTypes.object
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	  getInitialState: function getInitialState() {
	    _api_integration2.default.registerModules();
	    var xdm = _host2.default.create(this.props.integration);
	    return { xdm: xdm };
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _host2.default.unregisterExtension({
	      addon_key: this.props.integration.addon_key,
	      key: this.props.integration.key
	    });
	  },
	
	  componentDidMount: function componentDidMount() {
	    this._dispatchInitEvent();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._dispatchInitEvent();
	  },
	
	  _dispatchInitEvent: function _dispatchInitEvent() {
	    if (this.props.init_event) {
	      _logger2.default.debug('[HC-Integrations]', 'Dispatching event ' + this.props.init_event.event + ' to ' + this.props.integration.full_key, this.props.init_event.parameters);
	      _host2.default.dispatch(this.props.init_event.event, this.props.integration, this.props.init_event.parameters);
	    }
	  },
	
	  _onLoad: function _onLoad() {
	    _integrations_view_actions2.default.iframeLoaded({
	      integration: this.props.integration,
	      room_id: this.props.room_id,
	      duration: Math.floor(_utils2.default.timings.now() - this.startTimestamp)
	    });
	  },
	
	  render: function render() {
	    this.startTimestamp = _utils2.default.timings.now();
	    var xdm = this.state.xdm;
	    return React.createElement('iframe', { className: 'hc-addon-iframe', id: xdm.id, name: xdm.name, src: this.props.signed_url,
	      onLoad: this._onLoad });
	  }
	
	});

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.modules = undefined;
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _host = __webpack_require__(386);
	
	var _host2 = _interopRequireDefault(_host);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _auth_module = __webpack_require__(415);
	
	var AuthModule = _interopRequireWildcard(_auth_module);
	
	var _chat_module = __webpack_require__(419);
	
	var ChatModule = _interopRequireWildcard(_chat_module);
	
	var _dialog_module = __webpack_require__(426);
	
	var DialogModule = _interopRequireWildcard(_dialog_module);
	
	var _room_module = __webpack_require__(429);
	
	var RoomModule = _interopRequireWildcard(_room_module);
	
	var _sidebar_module = __webpack_require__(432);
	
	var SidebarModule = _interopRequireWildcard(_sidebar_module);
	
	var _user_module = __webpack_require__(433);
	
	var UserModule = _interopRequireWildcard(_user_module);
	
	var _file_module = __webpack_require__(434);
	
	var FileModule = _interopRequireWildcard(_file_module);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_app_dispatcher2.default.register("integration-iframe-event", function (event, target, data) {
	  _host2.default.broadcast(event, target, data);
	});
	
	var modules = exports.modules = {
	  dialog: DialogModule,
	  sidebar: SidebarModule,
	  room: RoomModule,
	  chat: ChatModule,
	  auth: AuthModule,
	  user: UserModule,
	  file: FileModule
	};
	
	var APIIntegration = function () {
	  function APIIntegration() {
	    (0, _classCallCheck3.default)(this, APIIntegration);
	  }
	
	  (0, _createClass3.default)(APIIntegration, [{
	    key: 'registerModules',
	    value: function registerModules() {
	      _.each(modules, function (module, key) {
	        _host2.default.defineModule(key, module);
	      });
	    }
	  }]);
	  return APIIntegration;
	}();
	
	exports.default = new APIIntegration();

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.withToken = withToken;
	
	var _integrations_token_cache = __webpack_require__(416);
	
	var _integrations_token_cache2 = _interopRequireDefault(_integrations_token_cache);
	
	var _api = __webpack_require__(264);
	
	var _api2 = _interopRequireDefault(_api);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function withToken(callback) {
	  var extension = callback._context.extension;
	  var roomId = _api2.default.getActiveChat().id;
	  _integrations_token_cache2.default.getToken(extension, roomId).then(function (jwt) {
	    callback(null, jwt.getToken());
	  }).catch(function (err) {
	    _logger2.default.error('[HC-Integrations]', 'Unable to create token for \'' + extension.full_key + '\' in room ' + roomId, err);
	    callback({ message: 'Unable to create token' });
	  });
	}

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray2 = __webpack_require__(127);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _jwt = __webpack_require__(417);
	
	var _jwt2 = _interopRequireDefault(_jwt);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _integrations_keys = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MIN_CLEANUP_INTERVAL = 60000; // 1 minute
	
	var TokenCache = function () {
	  function TokenCache() {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, TokenCache);
	
	    this.cache = {};
	    this._pruneCacheThrottled = _.throttle(this._pruneCache, MIN_CLEANUP_INTERVAL);
	    _app_dispatcher2.default.register(_integrations_keys.event_names.ON_INTEGRATIONS_UPDATE_SUMMARY, function (updateSummary) {
	      return _this._clear(updateSummary);
	    });
	  }
	
	  (0, _createClass3.default)(TokenCache, [{
	    key: 'getToken',
	    value: function getToken(extension, roomId) {
	      var _this2 = this;
	
	      this._pruneCacheThrottled();
	      return new _promise2.default(function (resolve, reject) {
	        var jwt = _this2._get(extension, roomId);
	        if (jwt && !jwt.expiresSoon()) {
	          resolve(jwt);
	        } else {
	          _dal2.default.getSignedUrl({ extension: extension, room_id: roomId }, {}, function (responseData, response) {
	            if (responseData && !responseData.error && response.status < 400) {
	              try {
	                jwt = _this2._set(extension, roomId, responseData.jwt);
	                resolve(jwt);
	              } catch (e) {
	                _logger2.default.error('[HC-Integrations]', 'Invalid token (' + responseData.jwt + '): ' + e.message);
	                reject();
	              }
	            } else {
	              var message = 'Error while fetching token (' + response.status + ')';
	              _logger2.default.error('[HC-Integrations]', message, responseData);
	              reject();
	            }
	          });
	        }
	      });
	    }
	  }, {
	    key: '_get',
	    value: function _get(extension, roomId) {
	      return _.get(this.cache, [roomId, extension.addon_key, extension.key]);
	    }
	  }, {
	    key: '_set',
	    value: function _set(extension, roomId, rawToken) {
	      var jwt = _jwt2.default.parse(rawToken);
	      _.set(this.cache, [roomId, extension.addon_key, extension.key], jwt);
	      return jwt;
	    }
	  }, {
	    key: '_pruneCache',
	    value: function _pruneCache() {
	      this.cache = _.mapValues(this.cache, function (addons) {
	        return _.mapValues(addons, function (extensions) {
	          return _.omitBy(extensions, function (jwt) {
	            return jwt.isExpired();
	          });
	        });
	      });
	      this.cache = _.omitBy(this.cache, function (addons) {
	        return _.isEmpty(addons);
	      });
	      _logger2.default.debug('[HC-Integrations]', 'Token cache pruned', this.cache);
	    }
	  }, {
	    key: '_clear',
	    value: function _clear(updateSummary) {
	      var _this3 = this;
	
	      _.forOwn(updateSummary, function (_ref, roomId) {
	        var _ref2 = (0, _slicedToArray3.default)(_ref, 2);
	
	        var removed = _ref2[0];
	        var updated = _ref2[1];
	
	        var addonsCollection = _.flatten([removed, updated]);
	        var changedAddonKeys = _.map(addonsCollection, function (addon) {
	          return addon.addon_key;
	        });
	        var roomIds = 'global' === roomId ? _.keys(_this3.cache) : [roomId];
	        _.each(roomIds, function (id) {
	          var addons = _.get(_this3.cache, [id], {});
	          _.set(_this3.cache, [id], _.omit(addons, changedAddonKeys));
	        });
	        _logger2.default.debug('[HC-Integrations]', 'Token invalidated for ' + changedAddonKeys, _this3.cache);
	      });
	    }
	  }]);
	  return TokenCache;
	}();
	
	exports.default = new TokenCache();
	module.exports = exports['default'];

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LEEWAY = 2 * 60; // 2 minutes
	
	function now() {
	  return Math.floor(Date.now() / 1000);
	}
	
	var JWT = function () {
	  (0, _createClass3.default)(JWT, null, [{
	    key: 'parse',
	    value: function parse(token) {
	      var parts = token.split('.');
	      if (parts.length !== 3) {
	        throw new Error('Invalid JWT format: ' + token);
	      }
	      var jwt = JSON.parse(atob(parts[1]));
	      return new JWT(jwt, token);
	    }
	  }]);
	
	  function JWT(jwt, token) {
	    (0, _classCallCheck3.default)(this, JWT);
	
	    this.jwt = jwt;
	    this.token = token;
	  }
	
	  (0, _createClass3.default)(JWT, [{
	    key: 'isExpired',
	    value: function isExpired() {
	      return now() > this.jwt.exp;
	    }
	  }, {
	    key: 'expiresSoon',
	    value: function expiresSoon() {
	      return now() + LEEWAY > this.jwt.exp;
	    }
	  }, {
	    key: 'getToken',
	    value: function getToken() {
	      return this.token;
	    }
	  }]);
	  return JWT;
	}();
	
	exports.default = JWT;
	module.exports = exports['default'];

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.extension_types = exports.glance_room_states = exports.states = exports.event_names = undefined;
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var event_names = exports.event_names = (0, _freeze2.default)({
	  REMOVE_DATA_FOR_ROOMS: 'integrations-remove-data-for-rooms',
	  ON_INTEGRATIONS_REMOVED: 'integrations-removed',
	  ON_INTEGRATIONS_UPDATED: 'integration-update',
	  ON_INTEGRATIONS_UPDATE_SUMMARY: 'integrations-update-summary'
	});
	
	var states = exports.states = (0, _freeze2.default)({
	  INIT: 'init',
	  STARTING: 'starting',
	  STARTED: 'started',
	  STOPPED: 'stopped',
	  DISABLED: 'disabled',
	  ERROR: 'error'
	});
	
	var glance_room_states = exports.glance_room_states = (0, _freeze2.default)({
	  WAITING: 'waiting',
	  INIT: 'init',
	  LOADING: 'loading',
	  LOADED: 'loaded',
	  DIRTY: 'dirty'
	});
	
	var extension_types = exports.extension_types = (0, _freeze2.default)({
	  GLANCE: 'glance',
	  DIALOG: 'dialog',
	  ACTION: 'action',
	  EXTERNAL_PAGE: 'externalPage',
	  WEB_PANEL: 'webPanel'
	});

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.focus = focus;
	exports.appendMessage = appendMessage;
	exports.addFileForUploadWithBase64 = addFileForUploadWithBase64;
	
	var _integrations_actions = __webpack_require__(420);
	
	var _integrations_actions2 = _interopRequireDefault(_integrations_actions);
	
	var _api = __webpack_require__(264);
	
	var _api2 = _interopRequireDefault(_api);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function focus() {
	  _integrations_actions2.default.focusChatText();
	}
	
	function appendMessage(text_value) {
	  var text = typeof text_value === 'string' ? text_value : '';
	
	  _api2.default.appendMessage({
	    text: text
	  });
	}
	
	function addFileForUploadWithBase64(url, name) {
	  _api2.default.addFileForUploadWithBase64(url, name, 'paste');
	}

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _integrations_view_actions = __webpack_require__(425);
	
	var _integrations_view_actions2 = _interopRequireDefault(_integrations_view_actions);
	
	var _api_integration_events = __webpack_require__(198);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = {
	  invokeAction: function invokeAction(action) {
	    var _this = this;
	
	    var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: "hipchat.client.integrations.action.invoke",
	      properties: {
	        addon_key: action.addon_key,
	        action_key: action.full_key,
	        target_key: action.target.key
	      }
	    });
	
	    if (data.msg && data.msg.file_data && data.msg.file_data.is_authenticated && !data.msg.file_data.fetched_url) {
	      _app_dispatcher2.default.dispatch('API:fetch-signed-file', data.msg.file_data, function (response) {
	        data.msg.file_data.fetched_url = response.temp_url;
	        return _this._initOpen(action, data);
	      });
	    } else {
	      return this._initOpen(action, data);
	    }
	  },
	  _initOpen: function _initOpen(action, data) {
	    var msg = _.cloneDeep(data.msg);
	
	    if (msg && msg.file_data && msg.file_data.fetched_url) {
	      msg.file_data.url = msg.file_data.fetched_url;
	    }
	
	    var parameters = _integration_helper2.default.extractIntegrationParametersFromMessage(msg);
	
	    return this.open(action.addon_key, action.target.key, {
	      event: action.key,
	      parameters: parameters,
	      urlTemplateValues: {
	        message: parameters
	      }
	    });
	  },
	  openDialog: function openDialog(addonKey, moduleKey) {
	    var data = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	    var source = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];
	
	    return this.open(addonKey, moduleKey, data, ['dialog'], source);
	  },
	  openSidebarView: function openSidebarView(addonKey, moduleKey) {
	    var data = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	    var source = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];
	
	    return this.open(addonKey, moduleKey, data, ['webPanel', 'glance'], source);
	  },
	  openExternalPage: function openExternalPage(addonKey, moduleKey) {
	    var data = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	    var source = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];
	
	    return this.open(addonKey, moduleKey, data, ['externalPage'], source);
	  },
	  closeSidebarView: function closeSidebarView() {
	    var source = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
	
	    _app_dispatcher2.default.dispatch('show-sidebar-integration', {
	      activeIntegration: null
	    });
	
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: "hipchat.client.integrations.action.close.view",
	      properties: {
	        source: source
	      }
	    });
	  },
	
	
	  /**
	   * @param {string} addonKey The add-on key
	   * @param {string} moduleKey The module  key
	   * @param {Object} data An object with three optional properties:
	   *     {
	   *       "options": { <dialog options to customize a dialog target> },
	   *       "urlTemplateValues": { <key/value pairs for url template substitution> },
	   *       "parameters": { <arbitrary data to be passed to the add-on through an event> }
	   *     }
	   * @param {Array.<string>} expectedTypes null for any type, or an array of the allowed module types
	   * @param {string} source The 'source' property in the analytics events
	   * @returns {boolean} True if successful, false otherwise
	   */
	  open: function open(addonKey, moduleKey) {
	    var data = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	    var expectedTypes = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	    var source = arguments.length <= 4 || arguments[4] === undefined ? "" : arguments[4];
	
	
	    var targetKey = _integration_helper2.default.to_full_key(addonKey, moduleKey);
	    var target = _integrations_store2.default.getExtensionByKey(targetKey);
	
	    if (!target) {
	      target = _integrations_store2.default.getInternalExtensionByKey(targetKey);
	    }
	
	    if (!target) {
	      _logger2.default.error('[HC-Integrations]', 'Unknown action target: ' + targetKey);
	      return false;
	    }
	
	    if (expectedTypes && !_.includes(expectedTypes, target.type)) {
	      _logger2.default.error('[HC-Integrations]', 'The target ' + targetKey + ' is not in allowed types. Expected: ' + expectedTypes);
	      return false;
	    }
	
	    var activeChat = _integrations_store2.default.get('active_chat');
	
	    switch (target.type) {
	      case 'webPanel':
	        this._dispatchAnalyticEvent("hipchat.client.integrations.action.open.view", target, source);
	        return this._openSidebarView(target, data, activeChat.id);
	      case 'glance':
	        if (_.isString(target.target)) {
	          this._dispatchAnalyticEvent("hipchat.client.integrations.action.open.glance", target, source);
	          return this._openGlance(target, data, activeChat.id);
	        }
	        _logger2.default.error('[HC-Integrations]', 'Cannot open a glance that does not have a target attribute', target.full_key);
	        this._dispatchAnalyticEvent("hipchat.client.integrations.action.open.unsupported.type", target, source);
	        return false;
	      case 'dialog':
	        this._dispatchAnalyticEvent("hipchat.client.integrations.action.open.dialog", target, source);
	        return this._openDialog(target, data, activeChat.id);
	      case 'externalPage':
	        this._dispatchAnalyticEvent("hipchat.client.integrations.action.open.external.page", target, source);
	        return this._openExternalPage(target, data, activeChat.id);
	      default:
	        _logger2.default.error('[HC-Integrations]', 'Unsupported target type', target.type);
	        this._dispatchAnalyticEvent("hipchat.client.integrations.action.open.unsupported.type", target, source);
	        return false;
	    }
	  },
	  focusChatText: function focusChatText() {
	    _app_dispatcher2.default.dispatch('application-focused');
	  },
	  _dispatchAnalyticEvent: function _dispatchAnalyticEvent(name, target, source) {
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: name,
	      properties: {
	        addon_key: target.addon_key,
	        full_key: target.full_key,
	        source: source
	      }
	    });
	  },
	  _openSidebarView: function _openSidebarView(webPanel, data, room_id) {
	    _integrations_view_actions2.default.fetchSignedUrlConditionally(webPanel, room_id, data.urlTemplateValues);
	    this._showIntegrationView(webPanel.full_key, data.glance_key, data);
	    return true;
	  },
	  _openGlance: function _openGlance(glance, data) {
	    var targetKey = _.isString(glance.target) ? glance.target : glance.target.key;
	
	    // Special treatment for internal Files and Links glances
	    var fullTargetKey = _integration_helper2.default.to_full_key(glance.addon_key, targetKey);
	    if (_integrations_store2.default.getInternalExtensionByKey(fullTargetKey)) {
	      return this._showIntegrationView(fullTargetKey, glance.full_key, data);
	    }
	
	    var targetData = _.extend({ glance_key: glance.full_key }, data);
	    return this.open(glance.addon_key, targetKey, targetData, ['webPanel', 'dialog', 'externalPage']);
	  },
	  _openDialog: function _openDialog(dialog, data, room_id) {
	    var customizedDialog = dialog;
	    if (data.options) {
	      customizedDialog = _.merge({}, dialog, {
	        title: data.options.title,
	        options: data.options.options
	      });
	    }
	
	    _logger2.default.info('[HC-Integrations]', 'Rendering dialog', customizedDialog);
	
	    var url_template_values = this._getUrlTemplateValues(data);
	    var init_event = this._createInitEvent(data);
	
	    _integrations_view_actions2.default.fetchSignedUrlConditionally(dialog, room_id, url_template_values);
	
	    _dialog_actions2.default.showIntegrationDialog({
	      room_id: room_id,
	      integration: customizedDialog,
	      init_event: init_event
	    });
	
	    _analytics_dispatcher2.default.dispatch('analytics-show-dialog', {
	      key: dialog.full_key
	    });
	    return true;
	  },
	  _openExternalPage: function _openExternalPage(externalPage, data, room_id) {
	    var promise = new _promise2.default(function (resolve, reject) {
	      _integrations_view_actions2.default.fetchSignedUrlWithResult(externalPage, room_id, data.urlTemplateValues, function (response_data, headers) {
	        if (response_data && !response_data.error && headers.status < 400) {
	          resolve(response_data.location);
	        } else {
	          _logger2.default.error('[HC-Integrations]', 'Error while fetching signed url (' + headers.status + ')', response_data);
	          reject();
	        }
	      });
	    });
	
	    _spi2.default.openExternalWindowWithPromise(promise);
	
	    _analytics_dispatcher2.default.dispatch('analytics-show-external-page', {
	      key: externalPage.full_key
	    });
	    return true;
	  },
	  _showIntegrationView: function _showIntegrationView(key, glance_key, data) {
	    var url_template_values = this._getUrlTemplateValues(data);
	    var init_event = this._createInitEvent(data);
	
	    _app_dispatcher2.default.dispatch('show-sidebar-integration', {
	      activeIntegration: { key: key, glance_key: glance_key, url_template_values: url_template_values, init_event: init_event }
	    });
	
	    var addon_key = _integration_helper2.default.split_full_key(key)[0];
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: "hipchat.client.integrations.sidebar.show.view",
	      properties: {
	        addon_key: addon_key,
	        full_key: key,
	        glance_key: glance_key
	      }
	    });
	    return true;
	  },
	  _createInitEvent: function _createInitEvent(data) {
	    var initEvent = null;
	    if (_.has(data, 'parameters')) {
	      initEvent = {
	        event: data.event || _api_integration_events.RECEIVE_PARAMETERS,
	        parameters: data.parameters
	      };
	    }
	    return initEvent;
	  },
	  _getUrlTemplateValues: function _getUrlTemplateValues(data) {
	    var urlTemplateValues = null;
	    if (_.has(data, 'urlTemplateValues')) {
	      urlTemplateValues = data.urlTemplateValues;
	    }
	    return urlTemplateValues;
	  }
	};

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	var _slicedToArray2 = __webpack_require__(127);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(47);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _integrations_storage = __webpack_require__(422);
	
	var _integrations_storage2 = _interopRequireDefault(_integrations_storage);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _conditions = __webpack_require__(423);
	
	var _conditions2 = _interopRequireDefault(_conditions);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _permissions_store = __webpack_require__(269);
	
	var _permissions_store2 = _interopRequireDefault(_permissions_store);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _integrations_view_actions = __webpack_require__(425);
	
	var _integrations_view_actions2 = _interopRequireDefault(_integrations_view_actions);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _integrations_keys = __webpack_require__(418);
	
	var _versionInfo = __webpack_require__(141);
	
	var _versionInfo2 = _interopRequireDefault(_versionInfo);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var default_weight = 100;
	var default_api_version = 1;
	var current_api_version = _versionInfo2.default.connect_api_version;
	var minimum_api_version = _versionInfo2.default.minimum_connect_api_version;
	
	function is_supported_version() {
	  var version = arguments.length <= 0 || arguments[0] === undefined ? default_api_version : arguments[0];
	
	  return version >= minimum_api_version && version <= current_api_version;
	}
	
	var IntegrationsStore = function (_Store) {
	  (0, _inherits3.default)(IntegrationsStore, _Store);
	
	  /*
	   * this.data.integrations has the following format:
	   * {
	   *   global: {
	   *     "<sha-1>": {
	   *       addon_key: "addon-key-1",
	   *       name: "Add-on 1",
	   *       ui_extensions: [
	   *         {
	   *           key: "xyz",
	   *           location: "hipchat.message.action",
	   *           name: "XYZ",
	   *           url: "...",
	   *           weight: 100
	   *         },
	   *         ...
	   *       ]
	   *     },
	   *     "<sha-1>": {
	   *       addon_key: "addon-key-2",
	   *       ...
	   *     }
	   *   },
	   *   '<room-id>': {
	   *     "<sha-1>": {
	   *       ...
	   *     }
	   *     ...
	   *   },
	   *   ...
	   * }
	   */
	
	  function IntegrationsStore() {
	    (0, _classCallCheck3.default)(this, IntegrationsStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(IntegrationsStore).call(this));
	
	    _this.storage = new _integrations_storage2.default();
	    _this.states = _integrations_keys.states;
	    return _this;
	  }
	
	  (0, _createClass3.default)(IntegrationsStore, [{
	    key: 'reset',
	    value: function reset() {
	      (0, _get3.default)((0, _getPrototypeOf2.default)(IntegrationsStore.prototype), 'reset', this).call(this);
	      this.storage.reset();
	    }
	  }, {
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        integrations: {},
	        active_rooms: {},
	        active_chat: null,
	        loading: true,
	        enabled: false,
	        error: null,
	        integration_timestamps: {},
	        addon_avatars: {},
	        pending_updates: {},
	        state: IntegrationsStore.states.INIT,
	        unsupported_integrations: [],
	        should_show_warning_icon: false
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(data) {
	          var newEnabled = _integration_helper2.default.isFeatureEnabled(data);
	
	          if (_this2.data.state !== IntegrationsStore.states.INIT) {
	            if (newEnabled === true && _this2.data.state === IntegrationsStore.states.DISABLED) {
	              _this2._setState(IntegrationsStore.states.STARTING);
	            } else if (newEnabled === false) {
	              _this2._setState(IntegrationsStore.states.DISABLED);
	            }
	          }
	
	          _this2.set("enabled", newEnabled);
	        },
	        // turns an XMPP push into a REST request.
	        'integration-update': function integrationUpdate(data) {
	          if (!_this2.data.enabled) {
	            return;
	          }
	          _this2._writeIntegrations(_this2._processIntegrationChanges(data, true));
	        },
	        'open-room': function openRoom(room) {
	          if (!_this2.data.enabled) {
	            return;
	          }
	          var activeChat = _this2.get('active_chat');
	          if (activeChat && activeChat.jid === room.jid) {
	            _this2._updateIntegrations([activeChat.id]);
	          }
	        },
	        'room-deleted': function roomDeleted(room) {
	          var updatedIntegrations = _this2.get('integrations');
	          var updatedTimeStamps = _this2.get('integration_timestamps');
	          var updatedPendingUpdates = _this2.get('pending_updates');
	          delete updatedIntegrations[room.id];
	          delete updatedTimeStamps[room.id];
	          delete updatedPendingUpdates[room.id];
	          _this2._writeIntegrations({
	            integrations: updatedIntegrations,
	            timestamps: updatedTimeStamps,
	            pending_updates: updatedPendingUpdates
	          });
	        },
	        'groupchat-invite-accepted': function groupchatInviteAccepted(room) {
	          // open-room is called when the user is invited into a room but
	          // the active_chat variable is not set because dontSelectRoom is set to true
	          if (!_this2.data.enabled) {
	            return;
	          }
	
	          var newRoom = _this2.data.active_rooms[room.jid];
	          if (!_.isUndefined(newRoom)) {
	            _this2._updateIntegrations([newRoom.id]);
	          }
	        },
	        'app-state-ready': function appStateReady() {
	          if (_this2.data.enabled) {
	            _this2._setState(IntegrationsStore.states.STARTING);
	          } else {
	            _this2._setState(IntegrationsStore.states.DISABLED);
	          }
	        },
	        'strophe-disconnected': function stropheDisconnected() {
	          if (_this2.data.enabled) {
	            _this2._setState(IntegrationsStore.states.STOPPED);
	          }
	        },
	        'strophe-connection-failed': function stropheConnectionFailed() {
	          if (_this2.data.enabled) {
	            _this2._setState(IntegrationsStore.states.STOPPED);
	          }
	        },
	        'strophe-disconnecting': function stropheDisconnecting() {
	          if (_this2.data.enabled) {
	            _this2._setState(IntegrationsStore.states.STOPPED);
	          }
	        },
	        'DAL:cache-configured': function DALCacheConfigured() {
	          if (_this2.data.enabled) {
	            _this2.storage.ready = true;
	            _this2.storage.getIntegrations().then(function (integrations) {
	              _this2.data.integrations = integrations;
	            });
	          }
	        },
	        'strophe-reconnected': function stropheReconnected() {
	          if (_this2.data.enabled) {
	            _this2._setState(IntegrationsStore.states.STARTING);
	          }
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          _this2._handleActiveRoomsUpdate(rooms);
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2._handleSelectRoom(jid);
	
	          var activeChat = _this2.get('active_chat');
	
	          if (!activeChat) {
	            return;
	          }
	
	          var activeIntegration = _this2.getActiveIntegration(activeChat.type),
	              activeIntegrationKey = _.get(activeIntegration, "key", null),
	              isGroupchat = _this2._isGroupchat(activeChat.type),
	              internalExtensions = isGroupchat ? _this2.getInternalExtensions() : _this2.getInternalExtensionsOTO();
	
	          if (activeIntegrationKey) {
	            var isInternal = !_.isUndefined(_.find(internalExtensions, function (integration) {
	              return integration.full_key === activeIntegrationKey;
	            }));
	            var extension = _this2.getExtensionByKey(activeIntegrationKey);
	
	            if (!isInternal && !extension) {
	              if (isGroupchat) {
	                _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _client_preferences_keys2.default.ACTIVE_GROUPCHAT_INTEGRATION, null));
	              } else {
	                _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _client_preferences_keys2.default.ACTIVE_CHAT_INTEGRATION, null));
	              }
	            } else if (!isInternal && activeChat.id) {
	              _integrations_view_actions2.default.fetchSignedUrlConditionally(extension, activeChat.id, {});
	            }
	          }
	
	          _this2._fetchPanelContentForInternalGlances(activeIntegration);
	        },
	        'refresh-integrations': function refreshIntegrations() {
	          _this2._updateIntegrations(['global', _.get(_this2.data, 'active_chat.id')]);
	        },
	        'show-sidebar-integration': function showSidebarIntegration(data) {
	          var activeChat = _this2.get('active_chat');
	
	          if (_this2._isGroupchat(activeChat.type)) {
	            _this2._setActiveGroupchatIntegration(data);
	          } else {
	            _this2._setActiveChatIntegration(data);
	          }
	
	          if (data.activeIntegration) {
	            _this2._fetchPanelContentForInternalGlances(data.activeIntegration);
	          }
	        }
	      });
	    }
	  }, {
	    key: '_syncIntegrations',
	    value: function _syncIntegrations() {
	      var _this3 = this;
	
	      var roomsToUpdate = _.values(this.data.active_rooms).filter(function (r) {
	        return r.type === "groupchat";
	      }).map(function (r) {
	        return r.id;
	      });
	
	      this._updateIntegrations(['global'].concat(roomsToUpdate), function (err) {
	        if (_this3.data.state !== IntegrationsStore.states.DISABLED) {
	          if (err) {
	            _this3._setState(IntegrationsStore.states.ERROR);
	          } else {
	            _this3._setState(IntegrationsStore.states.STARTED);
	          }
	        }
	      });
	    }
	  }, {
	    key: '_setActiveChatIntegration',
	    value: function _setActiveChatIntegration(data) {
	      if (data.activeIntegration) {
	        var _PreferencesActions$s3;
	
	        _preferences_actions2.default.savePreferences((_PreferencesActions$s3 = {}, (0, _defineProperty3.default)(_PreferencesActions$s3, _client_preferences_keys2.default.SHOW_CHAT_SIDEBAR, true), (0, _defineProperty3.default)(_PreferencesActions$s3, _client_preferences_keys2.default.CHAT_ACTIVE_PANEL, 'integrations'), (0, _defineProperty3.default)(_PreferencesActions$s3, _client_preferences_keys2.default.ACTIVE_CHAT_INTEGRATION, data.activeIntegration), _PreferencesActions$s3));
	      } else {
	        _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _client_preferences_keys2.default.ACTIVE_CHAT_INTEGRATION, null));
	      }
	    }
	  }, {
	    key: '_setActiveGroupchatIntegration',
	    value: function _setActiveGroupchatIntegration(data) {
	      if (data.activeIntegration) {
	        var _PreferencesActions$s5;
	
	        _preferences_actions2.default.savePreferences((_PreferencesActions$s5 = {}, (0, _defineProperty3.default)(_PreferencesActions$s5, _client_preferences_keys2.default.SHOW_GROUPCHAT_SIDEBAR, true), (0, _defineProperty3.default)(_PreferencesActions$s5, _client_preferences_keys2.default.GROUPCHAT_ACTIVE_PANEL, 'integrations'), (0, _defineProperty3.default)(_PreferencesActions$s5, _client_preferences_keys2.default.ACTIVE_GROUPCHAT_INTEGRATION, data.activeIntegration), _PreferencesActions$s5));
	      } else {
	        _preferences_actions2.default.savePreferences((0, _defineProperty3.default)({}, _client_preferences_keys2.default.ACTIVE_GROUPCHAT_INTEGRATION, null));
	      }
	    }
	  }, {
	    key: '_fetchPanelContentForInternalGlances',
	    value: function _fetchPanelContentForInternalGlances(activeIntegration) {
	      // TODO: At the moment the RosterStore handles all the events for fetching files and links. When we remove the 'dark feature'-flag for the
	      // integration panel we should also refactor the RosterStore so that we end up with an IntegrationStore, PeopleStore, FilesStore and
	      // LinksStore. But for now we'll need to dispatch this event from here.
	      _app_dispatcher2.default.dispatch('fetch-panel-content-for-internal-glances', { activeIntegration: activeIntegration });
	    }
	  }, {
	    key: '_fetchIntegrations',
	    value: function _fetchIntegrations(integrations, room_ids, cb) {
	      var _this4 = this;
	
	      var startTimestamp = _utils2.default.timings.now();
	      _app_dispatcher2.default.dispatch('API:sync-integrations', {
	        integrations: integrations,
	        room_ids: room_ids
	      }, function (resp, xhr) {
	        var duration = Math.floor(_utils2.default.timings.now() - startTimestamp);
	        if (!resp || resp.error) {
	          clearTimeout(_this4.loadingTimerId);
	          _this4.set({
	            error: resp.error,
	            loading: false
	          });
	          var errorMessage = _.get(resp, 'error.message', xhr.statusText);
	          _analytics_dispatcher2.default.dispatch('analytics-event', {
	            name: 'hipchat.client.integrations.sync.error',
	            properties: {
	              error: errorMessage,
	              duration: duration,
	              status: xhr.status
	            }
	          });
	
	          cb.call(_this4, _.get(resp, 'error', 'Unknown error when synchronising with client'), null);
	          return false;
	        }
	
	        cb.call(_this4, null, resp);
	
	        _analytics_dispatcher2.default.dispatch('analytics-event', {
	          name: 'hipchat.client.integrations.sync.success',
	          properties: {
	            duration: duration
	          }
	        });
	      });
	    }
	
	    // removes extensions from a room, given a list of delete nodes
	
	  }, {
	    key: '_removeIntegrations',
	    value: function _removeIntegrations(integrationsInRoom, addon_keys) {
	      return _.filter(integrationsInRoom, function (integration) {
	        return !_.includes(addon_keys, integration.addon_key);
	      });
	    }
	
	    // merge the integrations in a particular context (room or global)
	
	  }, {
	    key: '_mergeIntegrations',
	    value: function _mergeIntegrations(integrationsInRoom, addons) {
	      return _.merge({}, _.keyBy(integrationsInRoom, 'version'), _.keyBy(addons, 'version'));
	    }
	  }, {
	    key: '_processIntegrationChanges',
	    value: function _processIntegrationChanges(data) {
	      var _this5 = this;
	
	      var push_update = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      var integrations = this.get('integrations');
	      var integration_timestamps = this.get('integration_timestamps');
	      var current_pending_updates = _.clone(this.get('pending_updates'));
	      var new_pending_updates = _.get(data, 'pendingUpdates', {});
	
	      var new_timestamp = Date.now();
	
	      // for each room or global, find add-ons to remove and update
	
	      var updateSummary = {};
	
	      _.each(data.changedIntegrations, function (addons, roomId) {
	        if (push_update) {
	          (function () {
	            var keys = _.map(addons, function (addon) {
	              return addon.addon_key;
	            });
	            _.remove(current_pending_updates[roomId], function (key) {
	              return _.includes(keys, key);
	            });
	          })();
	        } else {
	          current_pending_updates[roomId] = _.get(new_pending_updates, roomId, []);
	        }
	
	        var _$partition = _.partition(addons, function (addon) {
	          return addon.is_deleted;
	        });
	
	        var _$partition2 = (0, _slicedToArray3.default)(_$partition, 2);
	
	        var to_remove = _$partition2[0];
	        var to_update = _$partition2[1];
	
	        if (!_.isEmpty(to_remove) || !_.isEmpty(to_update)) {
	          updateSummary[roomId] = [to_remove, to_update];
	        }
	
	        _.each(to_update, function (plugin) {
	          return _.set(integration_timestamps, [roomId, plugin.addon_key], new_timestamp);
	        });
	
	        // remove all the updated add-ons by addon_key
	        integrations[roomId] = _this5._removeIntegrations(integrations[roomId], _.map(addons, 'addon_key'));
	        // merge the two together.
	        integrations[roomId] = _this5._mergeIntegrations(integrations[roomId], to_update);
	
	        if (!_.isEmpty(to_remove)) {
	          var rooms = void 0;
	          if (roomId === "global") {
	            rooms = _.reduce(_this5.data.active_rooms, function (acc, room) {
	              if (_this5._isGroupchat(room.type)) {
	                acc.push({ id: room.id });
	              }
	
	              return acc;
	            }, []);
	          } else {
	            rooms = [{ id: roomId }];
	          }
	
	          _this5._removeIntegrationIfActive(to_remove, rooms);
	          _app_dispatcher2.default.dispatch(_integrations_keys.event_names.ON_INTEGRATIONS_REMOVED, { integrations: to_remove, rooms: rooms });
	        }
	      });
	
	      _app_dispatcher2.default.dispatch(_integrations_keys.event_names.ON_INTEGRATIONS_UPDATE_SUMMARY, updateSummary);
	      return { integrations: integrations, timestamps: integration_timestamps, pending_updates: current_pending_updates };
	    }
	
	    // go get the integrations from the REST API and run the update functions
	
	  }, {
	    key: '_updateIntegrations',
	    value: function _updateIntegrations(room_ids) {
	      var _this6 = this;
	
	      var cb = arguments.length <= 1 || arguments[1] === undefined ? _.noop : arguments[1];
	
	      this.data.error = null;
	      clearTimeout(this.loadingTimerId);
	      this.loadingTimerId = _.delay(function () {
	        _this6.set('loading', true);
	      }, _app_config2.default.integrations.loading_indicator_delay_ms);
	      var integrations = this.get('integrations');
	      this._fetchIntegrations(integrations, room_ids, function (error, data) {
	        if (!error) {
	          _this6._writeIntegrations(_this6._processIntegrationChanges(data));
	        }
	        cb(error, data);
	      });
	    }
	
	    // write integrations to storage.
	
	  }, {
	    key: '_writeIntegrations',
	    value: function _writeIntegrations(_ref) {
	      var integrations = _ref.integrations;
	      var timestamps = _ref.timestamps;
	      var pending_updates = _ref.pending_updates;
	
	      clearTimeout(this.loadingTimerId);
	
	      this.set({
	        integrations: integrations,
	        pending_updates: pending_updates,
	        unsupported_integrations: this._getUnsupportedIntegrationsPerRoom(integrations),
	        loading: false,
	        integration_timestamps: timestamps,
	        addon_avatars: this._getAddonAvatars(integrations, this.data.active_chat)
	      });
	
	      this.setShouldShowIntegrationsWarningIcon();
	      this.storage.save(integrations);
	      _app_dispatcher2.default.dispatch('integrations-updated', integrations);
	    }
	
	    /**
	     * Get the names of unsupported integrations grouped by room
	     *
	     * @param integrations
	     * @returns {*}
	     * @private
	     */
	
	  }, {
	    key: '_getUnsupportedIntegrationsPerRoom',
	    value: function _getUnsupportedIntegrationsPerRoom(integrations) {
	      var unsupported_integrations = {};
	      _.forEach(integrations, function (room_integrations, room_name) {
	        var disabledIntegrationKeys = _.reduce(room_integrations, function (addon_keys, integration) {
	          if (!is_supported_version(integration.client_api_version)) {
	            addon_keys.push(integration.addon_key);
	          }
	          return addon_keys;
	        }, []);
	
	        if (disabledIntegrationKeys.length) {
	          unsupported_integrations[room_name] = disabledIntegrationKeys;
	        }
	      });
	
	      return unsupported_integrations;
	    }
	
	    /**
	     * Get integrations for the current context (global + groupchat)
	     *
	     * @returns {Object.<string, object>} integrations
	     */
	
	  }, {
	    key: '_getIntegrationsForRooms',
	    value: function _getIntegrationsForRooms(room_ids) {
	      var include_global = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      var integrations = this.get('integrations');
	
	      if (include_global) {
	        room_ids = room_ids.concat('global');
	      }
	
	      return _.pick(integrations, room_ids);
	    }
	
	    /**
	     * Get integrations for the current context (global + room)
	     *
	     * @returns {Object.<string, object>} integrations
	     */
	
	  }, {
	    key: '_getIntegrationsForContext',
	    value: function _getIntegrationsForContext() {
	      var activeChat = this.get('active_chat');
	      if (activeChat && activeChat.type === "groupchat") {
	        return this._getIntegrationsForRooms([activeChat.id], true);
	      }
	      return this._getIntegrationsForRooms([]);
	    }
	
	    /**
	     * Get extensions in a given location
	     *
	     * @param location
	     * @returns {Object[]} list of extensions
	     */
	
	  }, {
	    key: 'getExtensionsByLocation',
	    value: function getExtensionsByLocation(location) {
	      return this.getExtensionsByLocationAndContext(location, {});
	    }
	
	    /**
	     * Get extensions in a given location with a given context. The custom context is typically a message
	     * or glance metadata. Example context:
	     *
	     * {
	     *   "message": {
	     *     "body": "some message",
	     *     ...
	     *   }
	     * }
	     *
	     * @param location {string} the location, e.g. "hipchat.sidebar.right"
	     * @param conditionContext {Object} can contain a 'message' context for conditions.
	     * @returns {Object[]} list of extensions
	     */
	
	  }, {
	    key: 'getExtensionsByLocationAndContext',
	    value: function getExtensionsByLocationAndContext(location, conditionContext) {
	      var conditions = this._createConditionContext(conditionContext.message);
	      var by_rooms = this._getIntegrationsForContext();
	      return this._getExtensions(by_rooms, {}, { location: location }, conditions);
	    }
	
	    /**
	     * Get extensions of a given type
	     *
	     * @param type
	     * @returns {Object[]} list of extensions
	     */
	
	  }, {
	    key: 'getExtensionsByType',
	    value: function getExtensionsByType(type) {
	      var by_rooms = this._getIntegrationsForContext();
	      return this._getExtensions(by_rooms, {}, { type: type });
	    }
	  }, {
	    key: 'getExtensionsByTypeAndRoom',
	    value: function getExtensionsByTypeAndRoom(type, room_id) {
	      var by_rooms = this._getIntegrationsForRooms([room_id], true);
	      return this._getExtensions(by_rooms, {}, { type: type });
	    }
	  }, {
	    key: 'getUnsupportedIntegrationsForRoom',
	    value: function getUnsupportedIntegrationsForRoom() {
	      var active_chat = this.get('active_chat');
	      if (!active_chat || !this._isGroupchat(active_chat.type)) {
	        return [];
	      }
	
	      var integrations = this.get('unsupported_integrations'),
	          room_ids = ['global', active_chat.id];
	
	      var integrationRooms = _.pick(integrations, room_ids);
	      var integrationValues = _.values(integrationRooms);
	      return _.flatten(integrationValues);
	    }
	  }, {
	    key: 'setShouldShowIntegrationsWarningIcon',
	    value: function setShouldShowIntegrationsWarningIcon() {
	      var should_show_warning_icon = false;
	
	      if (this.getUnsupportedIntegrationsForRoom().length > 0) {
	        should_show_warning_icon = true;
	      }
	
	      if (_.get(this.get('pending_updates'), 'global', []).length > 0 && _current_user_store2.default.get('is_admin')) {
	        should_show_warning_icon = true;
	      }
	
	      var active_chat_id = _.get(this.get('active_chat'), 'id');
	      if (_.get(this.get('pending_updates'), active_chat_id, []).length > 0 && _permissions_store2.default.canUpdateRoomIntegrations()) {
	        should_show_warning_icon = true;
	      }
	
	      this.set({
	        'should_show_warning_icon': should_show_warning_icon
	      });
	    }
	
	    /**
	     * Get the extension from the rooms matching the given key
	     *
	     * @param full_extension_key format => "${addon_key}:${module_key}"
	     * @returns {Object|null} extension
	     */
	
	  }, {
	    key: 'getExtensionByKey',
	    value: function getExtensionByKey(full_extension_key) {
	      if (_.isEmpty(full_extension_key)) {
	        return null;
	      }
	
	      var by_rooms = this._getIntegrationsForContext();
	
	      var _IntegrationHelper$sp = _integration_helper2.default.split_full_key(full_extension_key);
	
	      var _IntegrationHelper$sp2 = (0, _slicedToArray3.default)(_IntegrationHelper$sp, 2);
	
	      var addon_key = _IntegrationHelper$sp2[0];
	      var key = _IntegrationHelper$sp2[1];
	
	      var extensions = this._getExtensions(by_rooms, { addon_key: addon_key }, { key: key });
	      return extensions.length > 0 ? extensions[0] : null;
	    }
	
	    /**
	     * Get the list of built-in extensions
	     *
	     * @returns {Object[]} list of extension
	     */
	
	  }, {
	    key: 'getInternalExtensions',
	    value: function getInternalExtensions() {
	      return [_app_config2.default.people_glance, _app_config2.default.files_glance, _app_config2.default.links_glance];
	    }
	
	    /**
	     * Get the list of built-in extensions for OTO
	     *
	     * @returns {Object[]} list of extension
	     */
	
	  }, {
	    key: 'getInternalExtensionsOTO',
	    value: function getInternalExtensionsOTO() {
	      return [_app_config2.default.files_glance, _app_config2.default.links_glance];
	    }
	
	    /**
	     * Get a built-in extension matching the given key
	     *
	     * @param full_extension_key format => "${addon_key}:${module_key}"
	     * @returns {Object|null} extension
	     */
	
	  }, {
	    key: 'getInternalExtensionByKey',
	    value: function getInternalExtensionByKey(full_extension_key) {
	      return _.find(this.getInternalExtensions(), function (ext) {
	        return ext.full_key === full_extension_key;
	      });
	    }
	  }, {
	    key: 'getScopesForAddon',
	    value: function getScopesForAddon(addon_key) {
	      var integrationValues = _.mapValues(this._getIntegrationsForContext(), _.toArray);
	      var normalizedValues = _.flatten(_.toArray(integrationValues));
	      return _.get(_.find(normalizedValues, function (i) {
	        return i.addon_key === addon_key;
	      }), 'scopes', []);
	    }
	
	    /**
	     * Extract extensions from the provided integrations
	     *
	     * @param {Object} addon_filter property values to match for addon
	     * @param {Object} extension_filter property values to match for extension
	     * @param {Object} integrations_by_room
	     * @param {Object} conditions optional conditions to evaluate against each extension
	     * @returns {Object[]}
	     * @private
	     */
	
	  }, {
	    key: '_getExtensions',
	    value: function _getExtensions(integrations_by_room, addon_filter, extension_filter) {
	      var _this7 = this;
	
	      var conditions = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	      var extension_list = [];
	
	      var addon_matches = _.matches(addon_filter);
	      var extension_matches = _.matches(extension_filter);
	
	      _.each(integrations_by_room, function (addons, roomId) {
	        _.each(addons, function (addon) {
	
	          if (!addon_matches(addon) || !is_supported_version(addon.client_api_version)) {
	            return;
	          }
	          _.each(addon.ui_extensions, function (ui_extension) {
	            if (extension_matches(ui_extension) && (!conditions || conditions.evaluate(ui_extension.conditions))) {
	              extension_list.push(_.extend({
	                addon_key: addon.addon_key,
	                full_key: _integration_helper2.default.to_full_key(addon.addon_key, ui_extension.key),
	                addon_version: addon.version,
	                addon_timestamp: _this7._getTimestamp(roomId, addon.addon_key)
	              }, ui_extension));
	            }
	          });
	        });
	      });
	
	      return this._sort_extensions(extension_list);
	    }
	  }, {
	    key: '_sort_extensions',
	    value: function _sort_extensions(extension_list) {
	      var paired_extension_list = _.toPairs(_.groupBy(extension_list, function (extension) {
	        return extension.addon_key;
	      })),
	          sorted_extension_list = _.sortBy(paired_extension_list, function (_ref2) {
	        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2);
	
	        var key = _ref3[0];
	        var extension = _ref3[1];
	        return key;
	      });
	      return _.flatten(_.map(sorted_extension_list, function (_ref4) {
	        var _ref5 = (0, _slicedToArray3.default)(_ref4, 2);
	
	        var key = _ref5[0];
	        var extensions = _ref5[1];
	        return _.sortBy(extensions, function (extension) {
	          return extension.weight ? -extension.weight : -default_weight;
	        });
	      }));
	    }
	  }, {
	    key: '_createConditionContext',
	    value: function _createConditionContext(message) {
	      return new _conditions2.default().withRoom(this.get('active_chat')).withUser(_current_user_store2.default.getAll()).withMessage(message);
	    }
	  }, {
	    key: '_handleSelectRoom',
	    value: function _handleSelectRoom(jid) {
	      if (!jid) {
	        return;
	      }
	
	      var active_chat = this.data.active_rooms[jid];
	      if (_.isObject(active_chat)) {
	        this.set({
	          'active_chat': active_chat,
	          'addon_avatars': this._getAddonAvatars(this.data.integrations, active_chat)
	        });
	        this.setShouldShowIntegrationsWarningIcon();
	      }
	    }
	  }, {
	    key: '_handleActiveRoomsUpdate',
	    value: function _handleActiveRoomsUpdate(rooms) {
	      var deleted = _.difference(_.keys(this.data.active_rooms), _.keys(rooms));
	      if (deleted.length) {
	        var removedRooms = [];
	        for (var item in deleted) {
	          var jid = deleted[item],
	              deletedRoom = this.data.active_rooms[jid];
	          if (deletedRoom.type === "groupchat" && deletedRoom.id) {
	            removedRooms.push({ id: deletedRoom.id });
	          }
	        }
	
	        if (removedRooms.length) {
	          _app_dispatcher2.default.dispatch(_integrations_keys.event_names.REMOVE_DATA_FOR_ROOMS, { rooms: removedRooms });
	        }
	
	        this.data.active_rooms = _.omit(this.data.active_rooms, deleted);
	      } else {
	        this.data.active_rooms = _.merge(this.data.active_rooms, rooms);
	      }
	    }
	  }, {
	    key: '_getTimestamp',
	    value: function _getTimestamp(roomId, addonKey) {
	      // If we don't have a timestamp, then add one
	      var timestamp = _.get(this.data.integration_timestamps, [roomId, addonKey], null);
	
	      if (timestamp === null) {
	        timestamp = Date.now();
	        _.set(this.data.integration_timestamps, [roomId, addonKey], timestamp);
	      }
	
	      return timestamp;
	    }
	  }, {
	    key: '_getAddonAvatars',
	    value: function _getAddonAvatars(integrations, active_chat) {
	      var globalIntegrations = _.get(integrations, "global", []);
	      var roomIntegrations = _.get(integrations, _.get(active_chat, "id", ""), []);
	      var globalIntegrationValues = _.values(globalIntegrations);
	      var roomIntegrationValues = _.values(roomIntegrations);
	
	      var integrationWithAvatars = _.filter([].concat(globalIntegrationValues, roomIntegrationValues), function (i) {
	        return i.avatar;
	      });
	      var addonPairs = _.map(integrationWithAvatars, function (i) {
	        return [i.addon_key, i.avatar];
	      });
	      return _.fromPairs(addonPairs);
	    }
	  }, {
	    key: '_isGroupchat',
	    value: function _isGroupchat(chatType) {
	      return chatType === 'groupchat';
	    }
	  }, {
	    key: 'getActiveIntegration',
	    value: function getActiveIntegration(chatType) {
	      if (this._isGroupchat(chatType)) {
	        return _preferences_store2.default.getActiveGroupchatIntegration();
	      }
	
	      return _preferences_store2.default.getActiveChatIntegration();
	    }
	  }, {
	    key: '_removeIntegrationIfActive',
	    value: function _removeIntegrationIfActive(integrations, rooms) {
	      var activeChat = this.get('active_chat');
	      if (activeChat && _.find(rooms, { 'id': activeChat.id })) {
	        var activeGroupChatIntegration = _preferences_store2.default.getActiveGroupchatIntegration();
	        if (activeGroupChatIntegration) {
	          var _IntegrationHelper$sp3 = _integration_helper2.default.split_full_key(activeGroupChatIntegration.key);
	
	          var _IntegrationHelper$sp4 = (0, _slicedToArray3.default)(_IntegrationHelper$sp3, 1);
	
	          var addon_key = _IntegrationHelper$sp4[0];
	
	          if (_.find(integrations, { addon_key: addon_key })) {
	            this._setActiveGroupchatIntegration({});
	          }
	        }
	      }
	    }
	  }, {
	    key: '_setState',
	    value: function _setState(newState) {
	      if (this.data.state === newState) {
	        return;
	      }
	
	      _logger2.default.debug('[HC-Integrations]', 'State transition from ' + this.data.state + ' -> ' + newState);
	      this.set('state', newState);
	
	      if (newState === IntegrationsStore.states.STARTING) {
	        this._syncIntegrations();
	      }
	    }
	  }, {
	    key: 'getUniqueIntegrationsForContext',
	    value: function getUniqueIntegrationsForContext() {
	      var integrations = this._getIntegrationsForContext();
	
	      var all_integrations = _.map(integrations, function (context_integrations, context) {
	        return _.map(context_integrations, function (integration) {
	          return {
	            context: context,
	            addon_key: integration.addon_key,
	            name: integration.name,
	            icon: _.get(integration, 'icon.url')
	          };
	        });
	      });
	
	      var flattened_integrations = _.flatten(_.map(all_integrations, _.values));
	      return _.uniqBy(flattened_integrations, function (i) {
	        return i.addon_key;
	      });
	    }
	  }, {
	    key: 'getIntegrationStatusesForContext',
	    value: function getIntegrationStatusesForContext() {
	      var _this8 = this;
	
	      var integrations = this.getUniqueIntegrationsForContext();
	      var unsupported_integrations = this.getUnsupportedIntegrationsForRoom();
	
	      var pending_updates = _.filter(integrations, function (i) {
	        var pending_update_keys = _.get(_this8.get('pending_updates'), i.context, []);
	        return _.includes(pending_update_keys, i.addon_key);
	      });
	
	      var _$partition3 = _.partition(pending_updates, function (i) {
	        return i.context === "global";
	      });
	
	      var _$partition4 = (0, _slicedToArray3.default)(_$partition3, 2);
	
	      var pending_global_updates = _$partition4[0];
	      var pending_room_updates = _$partition4[1];
	
	      var _$partition5 = _.partition(integrations, function (i) {
	        return _.includes(unsupported_integrations, i.addon_key);
	      });
	
	      var _$partition6 = (0, _slicedToArray3.default)(_$partition5, 2);
	
	      var disabled = _$partition6[0];
	      var installed = _$partition6[1];
	
	
	      return {
	        pending_global: pending_global_updates,
	        pending_room: pending_room_updates,
	        disabled: disabled,
	        installed: installed
	      };
	    }
	  }]);
	  return IntegrationsStore;
	}(_store2.default);
	
	IntegrationsStore.states = (0, _freeze2.default)({
	  INIT: 'init',
	  STARTING: 'starting',
	  STARTED: 'started',
	  STOPPED: 'stopped',
	
	  DISABLED: 'disabled',
	  ERROR: 'error'
	});
	
	exports.default = new IntegrationsStore();
	module.exports = exports['default'];

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var IntegrationsStorage = function () {
	  function IntegrationsStorage() {
	    (0, _classCallCheck3.default)(this, IntegrationsStorage);
	
	    this.ready = false;
	  }
	
	  (0, _createClass3.default)(IntegrationsStorage, [{
	    key: '_getDefaults',
	    value: function _getDefaults() {
	      return {
	        "versions": {}
	      };
	    }
	
	    /**
	     * Write integrations to storage
	     * @param integrations
	     * @returns compressed integrations
	     */
	
	  }, {
	    key: 'save',
	    value: function save(integrations) {
	      integrations = this._deflate(integrations);
	      integrations = this._bisect(integrations, 0, _.keys(integrations.versions).length, _app_config2.default.integrations.persistent_store_max_size_bytes);
	
	      this.integrations = integrations;
	      if (this.ready) {
	        _dal2.default.Cache.set(_dal2.default.Cache.Keys.INTEGRATIONS, this.integrations);
	      }
	      return integrations;
	    }
	
	    /**
	     * Get uncompressed integrations from storage
	     * @returns {Promise} uncompressed integrations
	     */
	
	  }, {
	    key: 'getIntegrations',
	    value: function getIntegrations() {
	      var _this = this;
	
	      if (this.ready) {
	        return _dal2.default.Cache.get(_dal2.default.Cache.Keys.INTEGRATIONS).then(function (integrations) {
	          var data = integrations || _this._getDefaults();
	          return _this._inflateIntegrations(data);
	        });
	      }
	      return _promise2.default.resolve(this._getDefaults());
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      if (this.ready) {
	        _dal2.default.Cache.unset(_dal2.default.Cache.Keys.INTEGRATIONS);
	      }
	    }
	
	    /**
	     * remove integrations from rooms that are not in versions
	     */
	
	  }, {
	    key: '_cleanRooms',
	    value: function _cleanRooms(integrations) {
	      var room_integrations = _.clone(integrations);
	      delete room_integrations.versions;
	
	      var versions = _.keys(integrations.versions);
	      _.each(room_integrations, function (integrations_in_room, room) {
	        room_integrations[room] = _.intersection(versions, integrations_in_room);
	      });
	      room_integrations.versions = integrations.versions;
	      return room_integrations;
	    }
	
	    /**
	     * give a length of an object once it has been stored
	     */
	
	  }, {
	    key: '_objectLength',
	    value: function _objectLength(obj) {
	      var str = (0, _stringify2.default)(obj);
	      // UTF-16 means x2.
	      return str.length * 2;
	    }
	
	    /**
	     * modify the integrations if there is insufficient space
	     *
	     * @param integrations
	     * @param min
	     * @param max
	     * @returns {Object} modifiedIntegrations
	     * @private
	     */
	
	  }, {
	    key: '_bisect',
	    value: function _bisect(integrations, min, max, max_bytes) {
	      var sliced_integrations = integrations;
	      var max_integrations = void 0;
	
	      var get_sliced_integrations = function get_sliced_integrations(room_integrations, end) {
	        var versions = room_integrations.versions;
	
	        var keys_arr = _.keys(versions);
	        var version_keys = keys_arr.slice(0, end);
	        var new_integrations = _.clone(room_integrations, true);
	
	        //pick off unused keys
	        new_integrations.versions = _.pick(versions, version_keys);
	
	        // remove unused keys from rooms
	        return this._cleanRooms(new_integrations);
	      };
	
	      while (max > min + 1) {
	        var index = min + Math.floor((max - min) / 2);
	
	        sliced_integrations = get_sliced_integrations.call(this, integrations, index);
	        if (this._objectLength(sliced_integrations) > max_bytes) {
	          max = index;
	        } else {
	          min = index;
	        }
	      }
	      max_integrations = get_sliced_integrations.call(this, integrations, max);
	
	      return this._objectLength(max_integrations) <= max_bytes ? max_integrations : sliced_integrations;
	    }
	  }, {
	    key: '_inflateIntegrations',
	    value: function _inflateIntegrations(integrations) {
	      var integrations_data = {},
	          versions = integrations.versions || {};
	
	      integrations = integrations || {};
	
	      _.each(integrations, function (addons, room) {
	        if (room === "versions") {
	          return;
	        }
	
	        integrations_data[room] = {};
	        _.each(addons, function (addon) {
	          var addon_version = versions[addon];
	          if (!_.isUndefined(addon_version)) {
	            integrations_data[room][addon_version.addon_key] = addon_version;
	          }
	        });
	      });
	
	      return integrations_data;
	    }
	
	    /**
	     * prepares integrations object
	     *
	     * @param {Object} integrations
	     * @returns {Object} storedIntegrations
	     * @private
	     */
	
	  }, {
	    key: '_deflate',
	    value: function _deflate(integrations) {
	      var storedIntegrations = {
	        versions: {}
	      };
	      _.each(integrations, function (addons, room) {
	        storedIntegrations[room] = [];
	        _.each(addons, function (addon) {
	          storedIntegrations[room].push(addon.version);
	          storedIntegrations.versions[addon.version] = addon;
	        });
	      });
	      return storedIntegrations;
	    }
	  }]);
	  return IntegrationsStorage;
	}();
	
	module.exports = IntegrationsStorage;

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _link_utils = __webpack_require__(108);
	
	var _link_utils2 = _interopRequireDefault(_link_utils);
	
	var _traverse = __webpack_require__(424);
	
	var _traverse2 = _interopRequireDefault(_traverse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*global no_match*/
	
	
	var Context = {
	
	  check: function check(context, ctx) {
	    var subContext = context[ctx];
	    if (!subContext) {
	      _logger2.default.error('Context {ctx} is not set');
	      subContext = {};
	    }
	    return subContext;
	  },
	
	  ROOM: 'room',
	  USER: 'user',
	  MESSAGE: 'message',
	  GLANCE_DATA: 'glanceData'
	};
	
	var MetaDataMatcher = function () {
	  function MetaDataMatcher(metadata) {
	    (0, _classCallCheck3.default)(this, MetaDataMatcher);
	
	    this.metadata = metadata;
	  }
	
	  /**
	   * Matches metadata of cards and glances
	   * @param metadataConditions the conditions declared on the ui extension. Example:
	   *  [
	   *    { 'attr': 'domain', 'eq': 'jira.atlassian.com'},
	   *    { 'attr': 'nested.something', 'gt': 2}
	   *  ]
	   * @returns {boolean} true if matched, false otherwise
	   */
	
	
	  (0, _createClass3.default)(MetaDataMatcher, [{
	    key: 'match',
	    value: function match(metadataConditions) {
	      var _this = this;
	
	      return _.every(metadataConditions, function (cond) {
	        if (!cond.attr) {
	          _logger2.default.error('Metadata conditions must specify an "attr" attribute');
	          return false;
	        }
	
	        var value = _.get(_this.metadata, cond.attr);
	        if (typeof cond.eq !== 'undefined') {
	          return value === cond.eq;
	        } else if (typeof cond.lt !== 'undefined') {
	          return _.lt(value, cond.lt);
	        } else if (typeof cond.gt !== 'undefined') {
	          return _.gt(value, cond.gt);
	        }
	
	        _logger2.default.error('Unknown metadata operator in condition: ' + cond);
	        return false;
	      });
	    }
	  }]);
	  return MetaDataMatcher;
	}();
	
	var Evaluators = {
	
	  /**
	   * Check if the room in the context is a public room
	   * @param context the condition context, containing 'room'
	   * @returns {boolean}
	   */
	  'room_is_public': function room_is_public(context) {
	    var privacy = Context.check(context, Context.ROOM).privacy;
	    return _utils2.default.jid.is_public_room(privacy);
	  },
	
	  /**
	   * Check if the user in the context is an administrator
	   * @param context the condition context, containing 'user'
	   * @returns {boolean}
	   */
	  'user_is_admin': function user_is_admin(context) {
	    return Context.check(context, Context.USER).is_admin;
	  },
	
	  /**
	   * Check if the user in the context is a guest user
	   * @param context the condition context, containing 'user'
	   * @returns {boolean}
	   */
	  'user_is_guest': function user_is_guest(context) {
	    return Context.check(context, Context.USER).is_guest;
	  },
	
	  /**
	   * Check if the user in the context is the owner of the the room in the context
	   * @param context the condition context, containing 'user' and 'room'
	   * @returns {boolean}
	   */
	  'user_is_room_owner': function user_is_room_owner(context) {
	    var room = Context.check(context, Context.ROOM);
	    var user = Context.check(context, Context.USER);
	
	    return room.owner === user.id;
	  },
	
	  /**
	   * Check if the message in the context matches a certain sub-condition.
	   * @param context the condition context, containing 'message'
	   * @param params: Currently supported params:
	   *
	   * Matches the message type:
	   * params: {
	   *   "type": "notification"
	   * }
	   *
	   * Matches the message body (regular expression):
	   * params: {
	   *   "regex": {
	   *     "pattern": "<pattern>",
	   *     "flags": "i"
	   *   }
	   * }
	   *
	   * Matches the message sender:
	   * params: {
	   *   "sender": "Giphy"
	   * }
	   *
	   * @returns {boolean}
	   */
	  'message_matches': function message_matches(context, params) {
	
	    var message = Context.check(context, Context.MESSAGE);
	
	    function matchType() {
	      var type = _.get(params, 'type');
	      if (type) {
	        return message.type === type;
	      }
	      return true;
	    }
	
	    function matchFileType() {
	      var type = _.get(params, 'file_type');
	      if (type) {
	        return _.get(message, 'file_data.file_type') === type.replace('image', 'img');
	      }
	      return true;
	    }
	
	    function matchRegExp() {
	      var regex = _.get(params, 'regex');
	      if (regex) {
	        if (regex.pattern) {
	          try {
	            var regularExpression = new RegExp(regex.pattern, regex.flags);
	            return regularExpression.test(message.body);
	          } catch (e) {
	            _logger2.default.error(e);
	            return false;
	          }
	        } else {
	          _logger2.default.error('Regular Expression condition must specify a "pattern" attribute');
	          return false;
	        }
	      }
	      return true;
	    }
	
	    function matchSender() {
	      var sender = _.get(params, 'sender');
	      if (sender) {
	        return message.sender === sender;
	      }
	      return true;
	    }
	
	    return matchType() && matchFileType() && matchRegExp() && matchSender();
	  },
	
	  /**
	   * Check if the message in the context contains a link
	   * @param context the condition context, containing 'message'
	   * @returns {boolean}
	   */
	  'message_contains_link': function message_contains_link(context) {
	    var message = Context.check(context, Context.MESSAGE);
	    return _link_utils2.default.contains_url(message.body);
	  },
	
	  /**
	   * Check if the message in the context was sent by the user in the context
	   * @param context the condition context, containing 'message' and 'user'
	   * @returns {boolean}
	   */
	  'message_sent_by_current_user': function message_sent_by_current_user(context) {
	    var message = Context.check(context, Context.MESSAGE);
	    var user = Context.check(context, Context.USER);
	    return message.sender_id === user.id;
	  },
	
	  /**
	   * Check if the message in the context is a card and matches certain sub-conditions.
	   * @param context the condition context, containing 'message'
	   * @param params: Currently supported params:
	   *
	   * Matches the card style:
	   * params: {
	   *   "style": "application"
	   * }
	   *
	   * Matches metadata (see MetaDataMatcher above)
	   * params: {
	   *   "metadata": [
	   *     { 'attr': 'canBeClosed', 'eq': true}
	   *   ]
	   * }
	   *
	   * @returns {boolean}
	   */
	  'card_matches': function card_matches(context, params) {
	
	    var message = Context.check(context, Context.MESSAGE);
	
	    function matchStyle() {
	      var style = _.get(params, 'style');
	      if (style) {
	        return message.card && message.card.style === style;
	      }
	      return true;
	    }
	
	    function matchMetadata() {
	      var metadataConditions = _.get(params, 'metadata');
	      if (_.isArray(metadataConditions)) {
	        if (message.metadata) {
	          var matcher = new MetaDataMatcher(message.metadata);
	          return matcher.match(metadataConditions);
	        }
	        return false;
	      }
	      return true;
	    }
	
	    return matchStyle() && matchMetadata();
	  },
	
	  /**
	   * Check if the glance data in the context matches sub-conditions
	   * @param context the condition context, containing 'glanceData'
	   * @param params: Currently supported params:
	   *
	   * Matches metadata (see MetaDataMatcher above)
	   * params: {
	   *   "metadata": [
	   *     { 'attr': 'isConfigured', 'eq': true}
	   *   ]
	   * }
	   *
	   * @returns {boolean}
	   */
	  'glance_matches': function glance_matches(context, params) {
	
	    var glanceData = Context.check(context, Context.GLANCE_DATA);
	
	    function matchMetadata() {
	      var metadataConditions = _.get(params, 'metadata');
	      if (_.isArray(metadataConditions)) {
	        if (glanceData.metadata) {
	          var matcher = new MetaDataMatcher(glanceData.metadata);
	          return matcher.match(metadataConditions);
	        }
	        return false;
	      }
	      return true;
	    }
	
	    return matchMetadata();
	  }
	};
	
	var ConditionContext = function () {
	  (0, _createClass3.default)(ConditionContext, null, [{
	    key: 'no_match',
	    value: function no_match() {
	      return false;
	    }
	  }, {
	    key: 'getEvaluator',
	    value: function getEvaluator(condition) {
	      var evaluator = Evaluators[condition];
	      if (!evaluator) {
	        _logger2.default.warn('Unknown condition type: ' + condition);
	        evaluator = ConditionContext.no_match;
	      }
	      return evaluator;
	    }
	  }]);
	
	  function ConditionContext() {
	    (0, _classCallCheck3.default)(this, ConditionContext);
	
	    this.context = {};
	  }
	
	  (0, _createClass3.default)(ConditionContext, [{
	    key: 'withRoom',
	    value: function withRoom(room) {
	      this.context[Context.ROOM] = room;
	      return this;
	    }
	  }, {
	    key: 'withUser',
	    value: function withUser(user) {
	      this.context[Context.USER] = user;
	      return this;
	    }
	  }, {
	    key: 'withMessage',
	    value: function withMessage(message) {
	      this.context[Context.MESSAGE] = message;
	      return this;
	    }
	  }, {
	    key: 'withGlanceData',
	    value: function withGlanceData(glanceData) {
	      this.context[Context.GLANCE_DATA] = glanceData;
	      return this;
	    }
	
	    /**
	     * Evaluates conditions based on the context passed in on construction.
	     *
	     * @param conditions
	     *
	     * "conditions": [
	     *   {
	     *     "condition": "user_is_guest"
	     *   },
	     *   {
	     *     "condition": "feature_is_enabled",
	     *     "params": {
	     *       "feature": "web_client_video_chat"
	     *     }
	     *   }
	     * ]
	     *
	     * See also: https://extranet.atlassian.com/display/HC/Spec%3A+Capabilities+document+changes+for+pluggable+clients
	     */
	
	  }, {
	    key: 'evaluate',
	    value: function evaluate(conditions) {
	      try {
	        return _.isEmpty(conditions) || this._and(conditions);
	      } catch (e) {
	        _logger2.default.error(e);
	        return false;
	      }
	    }
	  }, {
	    key: 'canEvaluate',
	    value: function canEvaluate(condition) {
	      var hasDynamicConditions = (0, _traverse2.default)(condition).reduce(function (acc, obj) {
	        var result = void 0;
	        if (obj['condition'] === 'glance_matches') {
	          result = true;
	        } else {
	          result = acc;
	        }
	        return result;
	      }, false);
	
	      return !hasDynamicConditions || !_.isEmpty(this.context[Context.GLANCE_DATA]);
	    }
	  }, {
	    key: '_evaluateCondition',
	    value: function _evaluateCondition(condition) {
	      var conditionType = condition['condition'];
	
	      if (!conditionType) {
	        var compositeConditions = condition['conditions'] || [];
	        var compositeType = (condition['type'] || 'and').toLowerCase();
	        switch (compositeType) {
	          case 'and':
	            return this._and(compositeConditions);
	          case 'or':
	            return this._or(compositeConditions);
	          default:
	            _logger2.default.error('Illegal operator: ' + compositeType);
	            return no_match();
	        }
	      }
	
	      var evaluator = ConditionContext.getEvaluator(conditionType);
	      var result = evaluator(this.context, condition['params'] || {});
	      return condition.invert === true ? !result : result;
	    }
	  }, {
	    key: '_and',
	    value: function _and(conditions) {
	      var _this2 = this;
	
	      return _.every(conditions, function (condition) {
	        return _this2._evaluateCondition(condition);
	      });
	    }
	  }, {
	    key: '_or',
	    value: function _or(conditions) {
	      var _this3 = this;
	
	      return _.some(conditions, function (condition) {
	        return _this3._evaluateCondition(condition);
	      });
	    }
	  }]);
	  return ConditionContext;
	}();
	
	module.exports = ConditionContext;

/***/ },
/* 424 */
/***/ function(module, exports) {

	var traverse = module.exports = function (obj) {
	    return new Traverse(obj);
	};
	
	function Traverse (obj) {
	    this.value = obj;
	}
	
	Traverse.prototype.get = function (ps) {
	    var node = this.value;
	    for (var i = 0; i < ps.length; i ++) {
	        var key = ps[i];
	        if (!node || !hasOwnProperty.call(node, key)) {
	            node = undefined;
	            break;
	        }
	        node = node[key];
	    }
	    return node;
	};
	
	Traverse.prototype.has = function (ps) {
	    var node = this.value;
	    for (var i = 0; i < ps.length; i ++) {
	        var key = ps[i];
	        if (!node || !hasOwnProperty.call(node, key)) {
	            return false;
	        }
	        node = node[key];
	    }
	    return true;
	};
	
	Traverse.prototype.set = function (ps, value) {
	    var node = this.value;
	    for (var i = 0; i < ps.length - 1; i ++) {
	        var key = ps[i];
	        if (!hasOwnProperty.call(node, key)) node[key] = {};
	        node = node[key];
	    }
	    node[ps[i]] = value;
	    return value;
	};
	
	Traverse.prototype.map = function (cb) {
	    return walk(this.value, cb, true);
	};
	
	Traverse.prototype.forEach = function (cb) {
	    this.value = walk(this.value, cb, false);
	    return this.value;
	};
	
	Traverse.prototype.reduce = function (cb, init) {
	    var skip = arguments.length === 1;
	    var acc = skip ? this.value : init;
	    this.forEach(function (x) {
	        if (!this.isRoot || !skip) {
	            acc = cb.call(this, acc, x);
	        }
	    });
	    return acc;
	};
	
	Traverse.prototype.paths = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.path); 
	    });
	    return acc;
	};
	
	Traverse.prototype.nodes = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.node);
	    });
	    return acc;
	};
	
	Traverse.prototype.clone = function () {
	    var parents = [], nodes = [];
	    
	    return (function clone (src) {
	        for (var i = 0; i < parents.length; i++) {
	            if (parents[i] === src) {
	                return nodes[i];
	            }
	        }
	        
	        if (typeof src === 'object' && src !== null) {
	            var dst = copy(src);
	            
	            parents.push(src);
	            nodes.push(dst);
	            
	            forEach(objectKeys(src), function (key) {
	                dst[key] = clone(src[key]);
	            });
	            
	            parents.pop();
	            nodes.pop();
	            return dst;
	        }
	        else {
	            return src;
	        }
	    })(this.value);
	};
	
	function walk (root, cb, immutable) {
	    var path = [];
	    var parents = [];
	    var alive = true;
	    
	    return (function walker (node_) {
	        var node = immutable ? copy(node_) : node_;
	        var modifiers = {};
	        
	        var keepGoing = true;
	        
	        var state = {
	            node : node,
	            node_ : node_,
	            path : [].concat(path),
	            parent : parents[parents.length - 1],
	            parents : parents,
	            key : path.slice(-1)[0],
	            isRoot : path.length === 0,
	            level : path.length,
	            circular : null,
	            update : function (x, stopHere) {
	                if (!state.isRoot) {
	                    state.parent.node[state.key] = x;
	                }
	                state.node = x;
	                if (stopHere) keepGoing = false;
	            },
	            'delete' : function (stopHere) {
	                delete state.parent.node[state.key];
	                if (stopHere) keepGoing = false;
	            },
	            remove : function (stopHere) {
	                if (isArray(state.parent.node)) {
	                    state.parent.node.splice(state.key, 1);
	                }
	                else {
	                    delete state.parent.node[state.key];
	                }
	                if (stopHere) keepGoing = false;
	            },
	            keys : null,
	            before : function (f) { modifiers.before = f },
	            after : function (f) { modifiers.after = f },
	            pre : function (f) { modifiers.pre = f },
	            post : function (f) { modifiers.post = f },
	            stop : function () { alive = false },
	            block : function () { keepGoing = false }
	        };
	        
	        if (!alive) return state;
	        
	        function updateState() {
	            if (typeof state.node === 'object' && state.node !== null) {
	                if (!state.keys || state.node_ !== state.node) {
	                    state.keys = objectKeys(state.node)
	                }
	                
	                state.isLeaf = state.keys.length == 0;
	                
	                for (var i = 0; i < parents.length; i++) {
	                    if (parents[i].node_ === node_) {
	                        state.circular = parents[i];
	                        break;
	                    }
	                }
	            }
	            else {
	                state.isLeaf = true;
	                state.keys = null;
	            }
	            
	            state.notLeaf = !state.isLeaf;
	            state.notRoot = !state.isRoot;
	        }
	        
	        updateState();
	        
	        // use return values to update if defined
	        var ret = cb.call(state, state.node);
	        if (ret !== undefined && state.update) state.update(ret);
	        
	        if (modifiers.before) modifiers.before.call(state, state.node);
	        
	        if (!keepGoing) return state;
	        
	        if (typeof state.node == 'object'
	        && state.node !== null && !state.circular) {
	            parents.push(state);
	            
	            updateState();
	            
	            forEach(state.keys, function (key, i) {
	                path.push(key);
	                
	                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
	                
	                var child = walker(state.node[key]);
	                if (immutable && hasOwnProperty.call(state.node, key)) {
	                    state.node[key] = child.node;
	                }
	                
	                child.isLast = i == state.keys.length - 1;
	                child.isFirst = i == 0;
	                
	                if (modifiers.post) modifiers.post.call(state, child);
	                
	                path.pop();
	            });
	            parents.pop();
	        }
	        
	        if (modifiers.after) modifiers.after.call(state, state.node);
	        
	        return state;
	    })(root).node;
	}
	
	function copy (src) {
	    if (typeof src === 'object' && src !== null) {
	        var dst;
	        
	        if (isArray(src)) {
	            dst = [];
	        }
	        else if (isDate(src)) {
	            dst = new Date(src.getTime ? src.getTime() : src);
	        }
	        else if (isRegExp(src)) {
	            dst = new RegExp(src);
	        }
	        else if (isError(src)) {
	            dst = { message: src.message };
	        }
	        else if (isBoolean(src)) {
	            dst = new Boolean(src);
	        }
	        else if (isNumber(src)) {
	            dst = new Number(src);
	        }
	        else if (isString(src)) {
	            dst = new String(src);
	        }
	        else if (Object.create && Object.getPrototypeOf) {
	            dst = Object.create(Object.getPrototypeOf(src));
	        }
	        else if (src.constructor === Object) {
	            dst = {};
	        }
	        else {
	            var proto =
	                (src.constructor && src.constructor.prototype)
	                || src.__proto__
	                || {}
	            ;
	            var T = function () {};
	            T.prototype = proto;
	            dst = new T;
	        }
	        
	        forEach(objectKeys(src), function (key) {
	            dst[key] = src[key];
	        });
	        return dst;
	    }
	    else return src;
	}
	
	var objectKeys = Object.keys || function keys (obj) {
	    var res = [];
	    for (var key in obj) res.push(key)
	    return res;
	};
	
	function toS (obj) { return Object.prototype.toString.call(obj) }
	function isDate (obj) { return toS(obj) === '[object Date]' }
	function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
	function isError (obj) { return toS(obj) === '[object Error]' }
	function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
	function isNumber (obj) { return toS(obj) === '[object Number]' }
	function isString (obj) { return toS(obj) === '[object String]' }
	
	var isArray = Array.isArray || function isArray (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};
	
	forEach(objectKeys(Traverse.prototype), function (key) {
	    traverse[key] = function (obj) {
	        var args = [].slice.call(arguments, 1);
	        var t = new Traverse(obj);
	        return t[key].apply(t, args);
	    };
	});
	
	var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
	    return key in obj;
	};


/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _uri_template = __webpack_require__(170);
	
	var _uri_template2 = _interopRequireDefault(_uri_template);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = {
	
	  fetchSignedUrlConditionally: function fetchSignedUrlConditionally(extension, room_id, urlTemplateValues) {
	    if (extension.authentication === 'none') {
	      var template = new _uri_template2.default(extension.url);
	      var url = template.replaceVariables(urlTemplateValues);
	      _app_dispatcher2.default.dispatch('signed-extension-url-fetched', {
	        extension: extension,
	        room_id: room_id,
	        signed_url: _utils2.default.addConnectApiVersionToUrl(url)
	      });
	    } else {
	      this.fetchSignedUrl(extension, room_id, urlTemplateValues);
	    }
	  },
	
	  fetchSignedUrl: function fetchSignedUrl(extension, room_id, urlTemplateValues) {
	
	    _app_dispatcher2.default.dispatch('signed-extension-url-fetching', {
	      extension: extension,
	      room_id: room_id,
	      url_template_values: urlTemplateValues
	    });
	
	    this.fetchSignedUrlWithResult(extension, room_id, urlTemplateValues, function (data, result) {
	      if (!data || data.error || result.status >= 400) {
	        _logger2.default.error('[HC-Integrations]', 'Could not get a signed URL for ' + extension.full_key + '.');
	        _app_dispatcher2.default.dispatch('signed-extension-url-error', {
	          extension: extension,
	          room_id: room_id,
	          error: _.get(data, "error", "Error fetching signed url"),
	          status: result.status
	        });
	      } else {
	        var location = _utils2.default.addConnectApiVersionToUrl(data.location);
	        _app_dispatcher2.default.dispatch('signed-extension-url-fetched', {
	          extension: extension,
	          room_id: room_id,
	          signed_url: location
	        });
	      }
	    });
	  },
	
	  fetchSignedUrlWithResult: function fetchSignedUrlWithResult(extension, room_id, urlTemplateValues, callback) {
	    _app_dispatcher2.default.dispatch('API:get-signed-url', {
	      extension: extension,
	      room_id: room_id,
	      timeout: _app_config2.default.integrations.signed_url_timeout
	    }, urlTemplateValues || {}, callback);
	  },
	
	  iframeLoaded: function iframeLoaded(data) {
	    _app_dispatcher2.default.dispatch('integration-iframe-loaded', {
	      integration: data.integration,
	      room_id: data.room_id
	    });
	
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: "hipchat.client.integrations.view.iframe.loaded",
	      properties: {
	        room_id: data.room_id,
	        addon_key: data.integration.addon_key,
	        full_key: _integration_helper2.default.to_full_key(data.integration.addon_key, data.integration.key),
	        duration: data.duration
	      }
	    });
	  }
	
	};

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.open = open;
	exports.update = update;
	exports.updatePrimaryAction = updatePrimaryAction;
	exports.close = close;
	
	var _integration_dialog_actions = __webpack_require__(427);
	
	var _integration_dialog_actions2 = _interopRequireDefault(_integration_dialog_actions);
	
	var _integrations_actions = __webpack_require__(420);
	
	var _integrations_actions2 = _interopRequireDefault(_integrations_actions);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function open(data, callback) {
	  if (!data || !data.key) {
	    _logger2.default.error("[HC-Integrations]", "No key specified. Use open({key: 'dialog-key'}).");
	    return;
	  }
	  _integrations_actions2.default.openDialog(callback._context.extension.addon_key, data.key, {
	    options: data.options,
	    parameters: data.parameters,
	    urlTemplateValues: data.urlTemplateValues
	  }, "api");
	}
	
	function update(data, callback) {
	  _integration_dialog_actions2.default.update(data, callback._context.extension.addon_key);
	}
	
	function updatePrimaryAction(primaryAction, callback) {
	  _integration_dialog_actions2.default.update({
	    options: {
	      primaryAction: primaryAction
	    }
	  }, callback._context.extension.addon_key);
	}
	
	function close(callback) {
	  _integration_dialog_actions2.default.closeDialog(callback._context.extension.addon_key);
	}

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var DialogActions = __webpack_require__(95),
	    SimpleXDM = __webpack_require__(386),
	    AppDispatcher = __webpack_require__(9),
	    IntegrationDialogStore = __webpack_require__(428),
	    IntegrationEvents = __webpack_require__(198);
	
	module.exports = {
	
	  update: function update(dialog, origin) {
	    AppDispatcher.dispatch('update-integration-dialog', { dialog: dialog, origin: origin });
	  },
	
	  closeDialog: function closeDialog(origin) {
	    if (IntegrationDialogStore.isActiveDialogOwner(origin)) {
	      DialogActions.closeDialog();
	    }
	  },
	
	  _btnClickCallback: function _btnClickCallback(shouldSubmit) {
	    if (shouldSubmit !== false) {
	      DialogActions.closeDialog();
	    }
	  },
	
	  buttonClick: function buttonClick(integration, actionKey) {
	
	    var dispatched = SimpleXDM.dispatch(IntegrationEvents.DIALOG_CLICK, {
	      addon_key: integration.addon_key,
	      key: integration.key
	    }, { action: actionKey }, this._btnClickCallback);
	
	    var filtered = [];
	    if (dispatched) {
	      filtered = dispatched.filter(function (extension) {
	        if (!extension.registered_events) {
	          return false;
	        }
	        return extension.registered_events.indexOf(IntegrationEvents.DIALOG_CLICK) !== -1;
	      });
	    }
	
	    if (filtered.length === 0) {
	      DialogActions.closeDialog();
	    }
	  },
	
	  filterChange: function filterChange(integration, value) {
	    SimpleXDM.dispatch(IntegrationEvents.DIALOG_FILTER_CHANGED, {
	      addon_key: integration.addon_key,
	      key: integration.key
	    }, { value: value });
	  }
	
	};

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _modal_dialog_store = __webpack_require__(284);
	
	var _modal_dialog_store2 = _interopRequireDefault(_modal_dialog_store);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _integrations_keys = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var IntegrationDialogStore = function (_Store) {
	  (0, _inherits3.default)(IntegrationDialogStore, _Store);
	
	  function IntegrationDialogStore() {
	    (0, _classCallCheck3.default)(this, IntegrationDialogStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(IntegrationDialogStore).call(this));
	
	    _this.local = {
	      active_chat: ''
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(IntegrationDialogStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        title: "",
	        options: {}
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'update-integration-dialog': function updateIntegrationDialog(data) {
	          var dialog = _this2.getAll();
	          if (!data.origin || dialog.addon_key === data.origin) {
	            var customizedDialog = _.merge({ title: "", options: {} }, dialog, {
	              title: data.dialog.title,
	              options: data.dialog.options
	            });
	            _this2.set(customizedDialog);
	          }
	        },
	        'show-modal-dialog': function showModalDialog(data) {
	          if (data.dialog_type === "integration-dialog") {
	            _this2.set(_.merge({ title: "", options: {} }, data.dialog_data.integration));
	          }
	        },
	        'hide-modal-dialog': function hideModalDialog() {
	          _this2.reset();
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          if (!jid || jid && jid === _this2.local.active_chat) {
	            return;
	          }
	          _this2.local.active_chat = jid;
	          var current_dialog = _modal_dialog_store2.default.getCurrentModalDialog();
	          if (current_dialog === "integration-dialog") {
	            _dialog_actions2.default.closeDialog();
	          }
	        }
	      });
	
	      _app_dispatcher2.default.register(_integrations_keys.event_names.ON_INTEGRATIONS_REMOVED, function (data) {
	        var active_chat = _integrations_store2.default.get('active_chat');
	        if (!active_chat || !_.find(data.rooms, { id: active_chat.id })) {
	          return;
	        }
	
	        var addon_check = _.find(data.integrations, { 'addon_key': _this2.get('addon_key'), 'is_deleted': true });
	        if (addon_check) {
	          _dialog_actions2.default.closeDialog();
	        }
	      });
	    }
	  }, {
	    key: 'isActiveDialogOwner',
	    value: function isActiveDialogOwner(addonKey) {
	      return this.get('addon_key') === addonKey;
	    }
	  }]);
	  return IntegrationDialogStore;
	}(_store2.default);
	
	exports.default = new IntegrationDialogStore();
	module.exports = exports['default'];

/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getRoomDetails = exports.getParticipants = undefined;
	exports.create = create;
	exports.open = open;
	exports.invite = invite;
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _api = __webpack_require__(264);
	
	var _api2 = _interopRequireDefault(_api);
	
	var _path_parameter_converters = __webpack_require__(430);
	
	var _path_parameter_converters2 = _interopRequireDefault(_path_parameter_converters);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _scoped_api = __webpack_require__(431);
	
	var _scoped_api2 = _interopRequireDefault(_scoped_api);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var idToUserConverters = [_path_parameter_converters2.default.get("idToUser"), _path_parameter_converters2.default.get("jidToUser"), _path_parameter_converters2.default.get("mentionNameToUser")];
	var idToRoomConverters = [_path_parameter_converters2.default.get("idToRoom"), _path_parameter_converters2.default.get("jidToRoom"), _path_parameter_converters2.default.get("nameToRoom")];
	
	function renderUser(user) {
	  return {
	    mention_name: user.mention_name,
	    id: parseInt(user.id),
	    name: user.name,
	    presence: user.presence,
	    photo_url: user.photo_url,
	    is_admin: user.is_admin,
	    email: user.email
	  };
	}
	
	function renderRoom(room) {
	  return {
	    id: parseInt(room.id),
	    name: room.name,
	    privacy: room.privacy,
	    topic: room.topic
	  };
	}
	
	function convert(identifier, converters) {
	  return _.reduce(converters, function (accumulator, converter) {
	    if (_.isUndefined(accumulator) && converter.handle(identifier)) {
	      return converter.convert(identifier);
	    }
	    return accumulator;
	  }, undefined);
	}
	
	function create(room_name, room_topic, room_privacy) {
	  var room = typeof room_name === 'string' ? room_name : '';
	  var topic = typeof room_topic === 'string' ? room_topic : '';
	  var privacy = typeof room_privacy === 'string' ? room_privacy : 'public';
	  _api2.default.createRoom({
	    room_name: room,
	    room_topic: topic,
	    privacy: privacy
	  });
	}
	
	function open(_ref) {
	  var roomId = _ref.roomId;
	  var roomName = _ref.roomName;
	  var userId = _ref.userId;
	  var userMentionName = _ref.userMentionName;
	  var message = _ref.message;
	
	
	  var jid = void 0;
	  var roomIdentifier = roomId || roomName;
	  var userIdentifier = userId || userMentionName;
	
	  if (!_.isUndefined(roomIdentifier)) {
	    var room = convert(roomIdentifier, idToRoomConverters);
	
	    jid = _.get(room, "jid");
	  } else if (!_.isUndefined(userIdentifier)) {
	    var user = convert(userIdentifier, idToUserConverters);
	
	    jid = _.get(user, "jid");
	  } else {
	    _logger2.default.warn("[HC-Integrations]", "'roomId', 'roomName', 'userId' or 'userMentionName' parameter must be specified.");
	    return;
	  }
	
	  if (!_.isUndefined(jid)) {
	    _api2.default.openChat({
	      jid: jid
	    });
	  } else {
	    _logger2.default.warn("[HC-Integrations]", "Failed to open room, room or user was not found.");
	  }
	
	  if (typeof message === 'string') {
	    _api2.default.appendMessage({
	      text: message
	    });
	  }
	}
	
	function invite(userIds) {
	  var users = [];
	  userIds = _utils2.default.toArray(userIds);
	  userIds.forEach(function (userid) {
	    var user = convert(userid, idToUserConverters);
	    var jid = _.get(user, 'jid');
	    if (jid) {
	      users.push(jid);
	    }
	  });
	
	  _dialog_actions2.default.showInviteUsersDialog({
	    invite_users: users
	  });
	}
	
	var getParticipants = exports.getParticipants = (0, _scoped_api2.default)('view_room', function () {
	  return {
	    guests: _.map(_roster_store2.default.getSortedRosterByPresenceAndName(['guests']), renderUser),
	    members: _.map(_roster_store2.default.getSortedRosterByPresenceAndName(['members']), renderUser)
	  };
	});
	
	var getRoomDetails = exports.getRoomDetails = (0, _scoped_api2.default)('view_room', function () {
	  var activeChat = _api2.default.getActiveChat();
	
	  return renderRoom(activeChat);
	});

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AppStore = __webpack_require__(190),
	    Utils = __webpack_require__(99);
	
	var PathParameterConverterRegistry = function () {
	  function PathParameterConverterRegistry() {
	    (0, _classCallCheck3.default)(this, PathParameterConverterRegistry);
	
	    this.converters = {};
	  }
	
	  (0, _createClass3.default)(PathParameterConverterRegistry, [{
	    key: 'register',
	    value: function register(name, predicate, converter) {
	      this.converters[name] = {
	        handle: predicate,
	        convert: converter
	      };
	    }
	  }, {
	    key: 'get',
	    value: function get(name) {
	      return this.converters[name];
	    }
	  }]);
	  return PathParameterConverterRegistry;
	}();
	
	var parameter = {
	  isNumber: function isNumber(param) {
	    return !isNaN(Number(param));
	  },
	
	  isHalfJid: function isHalfJid(param) {
	    return (/\d+_[^@]+/.test(param)
	    );
	  },
	
	  isMention: function isMention(param) {
	    return param.indexOf('@') === 0;
	  },
	
	  isAnything: function isAnything() {
	    return true;
	  }
	};
	
	var idToRoom = function idToRoom(param) {
	  var paramAsString = param.toString();
	  return _.find(AppStore.get('allRooms'), function (room) {
	    return _.get(room, 'id', '').toString() === paramAsString;
	  });
	};
	
	var jidToRoom = function jidToRoom(param) {
	  return AppStore.get('allRooms')[param];
	};
	
	var halfJidToRoom = function halfJidToRoom(param) {
	  var conferenceServer = AppStore.get('conference_server');
	  var jid = param + '@' + conferenceServer;
	  return AppStore.get('allRooms')[jid];
	};
	
	var nameToRoom = function nameToRoom(param) {
	  return _.find(AppStore.get('allRooms'), function (room) {
	    return room.name === param;
	  });
	};
	
	var idToUser = function idToUser(param) {
	  var chatServer = AppStore.get('chat_server');
	  var groupId = AppStore.get('group_id');
	  var jid = groupId + '_' + param + '@' + chatServer;
	  return AppStore.get('roster')[jid];
	};
	
	var halfJidToUser = function halfJidToUser(param) {
	  var chatServer = AppStore.get('chat_server');
	  return AppStore.get('roster')[param + '@' + chatServer];
	};
	
	var jidToUser = function jidToUser(param) {
	  return AppStore.get('roster')[param];
	};
	
	var mentionNameToUser = function mentionNameToUser(param) {
	  var mentionName = param.substring(1);
	  return _.find(AppStore.get('roster'), function (user) {
	    return user.mention_name === mentionName;
	  });
	};
	
	var pathParameterConverterRegistry = new PathParameterConverterRegistry();
	
	pathParameterConverterRegistry.register("idToUser", parameter.isNumber, idToUser);
	pathParameterConverterRegistry.register("jidToUser", Utils.jid.is_private_chat, jidToUser);
	pathParameterConverterRegistry.register("halfJidToUser", parameter.isHalfJid, halfJidToUser);
	pathParameterConverterRegistry.register("mentionNameToUser", parameter.isMention, mentionNameToUser);
	
	pathParameterConverterRegistry.register("idToRoom", parameter.isNumber, idToRoom);
	pathParameterConverterRegistry.register("jidToRoom", Utils.jid.is_room, jidToRoom);
	pathParameterConverterRegistry.register("halfJidToRoom", parameter.isHalfJid, halfJidToRoom);
	pathParameterConverterRegistry.register("nameToRoom", parameter.isAnything, nameToRoom);
	
	module.exports = pathParameterConverterRegistry;

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = scopedAPIMethod;
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function scopedAPIMethod(scope, method) {
	  return function (callback) {
	    var call_context = _.last(arguments);
	    var addon_key = _.get(call_context, "_context.extension.addon_key");
	
	    if (addon_key) {
	      var scopes = _integrations_store2.default.getScopesForAddon(addon_key);
	
	      if (_.includes(scopes, scope)) {
	        var error = null,
	            returnValue = null;
	        try {
	          returnValue = method(_.slice(arguments, 0, arguments.length - 1));
	        } catch (ex) {
	          error = ex.message;
	          _logger2.default.error("[HC-Integrations]", 'Error executing API method - ' + ex + '.');
	        }
	
	        call_context(error, returnValue);
	      } else {
	        var _error = 'Error executing API method - insufficient scopes, needed ' + scope + ' have ' + scopes + '.';
	        call_context(_error);
	        _logger2.default.error("[HC-Integrations]", _error);
	      }
	    } else {
	      var _error2 = 'Error executing API method - could not find addon information for call.';
	      call_context(_error2);
	      _logger2.default.error("[HC-Integrations]", _error2);
	    }
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.openView = openView;
	exports.closeView = closeView;
	
	var _integrations_actions = __webpack_require__(420);
	
	var _integrations_actions2 = _interopRequireDefault(_integrations_actions);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function openView(data, callback) {
	  if (!data || !data.key) {
	    _logger2.default.error("[HC-Integrations]", "No key specified. Use open({key: 'sidebar-key'}).");
	    return;
	  }
	  _integrations_actions2.default.openSidebarView(callback._context.extension.addon_key, data.key, {
	    options: data.options,
	    parameters: data.parameters,
	    urlTemplateValues: data.urlTemplateValues
	  }, "api");
	}
	
	function closeView() {
	  _integrations_actions2.default.closeSidebarView("api");
	}

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getCurrentUser = undefined;
	exports.open = open;
	
	var _scoped_api = __webpack_require__(431);
	
	var _scoped_api2 = _interopRequireDefault(_scoped_api);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _room_module = __webpack_require__(429);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var getCurrentUser = exports.getCurrentUser = (0, _scoped_api2.default)('view_room', function () {
	  var current_user = _current_user_store2.default.getAll();
	  return {
	    mention_name: current_user.mention,
	    id: current_user.id,
	    name: current_user.user_name,
	    presence: { show: current_user.show },
	    photo_url: current_user.photo_large,
	    is_admin: current_user.is_admin,
	    is_guest: current_user.is_guest,
	    email: current_user.email,
	    title: current_user.title
	  };
	});
	
	function open(_ref) {
	  var userId = _ref.userId;
	  var userMentionName = _ref.userMentionName;
	  var message = _ref.message;
	
	  return (0, _room_module.open)({ userId: userId, userMentionName: userMentionName, message: message });
	}

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.openInFileViewer = openInFileViewer;
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function openInFileViewer(file, filesList) {
	  var data = {
	    file: file,
	    filesList: filesList || []
	  };
	
	  _file_viewer_actions2.default.openExternalFileInFileViewer(data);
	}

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  openInFileViewer: function openInFileViewer(data) {
	    _app_dispatcher2.default.dispatch('open-in-file-viewer', data);
	  },
	  openExternalFileInFileViewer: function openExternalFileInFileViewer(data) {
	    _app_dispatcher2.default.dispatch('open-external-file-in-file-viewer', data);
	  },
	  fileViewerClosed: function fileViewerClosed() {
	    _app_dispatcher2.default.dispatch('file-viewer-closed');
	  },
	  fetchSignedFile: function fetchSignedFile(data, successCb, rejectCb) {
	    _app_dispatcher2.default.dispatch('API:fetch-signed-file', data, successCb, rejectCb);
	  }
	}; /**
	    * FileViewerActions
	    */

	module.exports = exports['default'];

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Store = __webpack_require__(97),
	    AppDispatcher = __webpack_require__(9),
	    IntegrationHelper = __webpack_require__(167);
	
	var IntegrationsViewStore = function (_Store) {
	  (0, _inherits3.default)(IntegrationsViewStore, _Store);
	
	  function IntegrationsViewStore() {
	    (0, _classCallCheck3.default)(this, IntegrationsViewStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(IntegrationsViewStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(IntegrationsViewStore, [{
	    key: "getDefaults",
	    value: function getDefaults() {
	      return {};
	    }
	  }, {
	    key: "registerListeners",
	    value: function registerListeners() {
	      var _this2 = this;
	
	      AppDispatcher.register({
	        "signed-extension-url-fetching": function signedExtensionUrlFetching(data) {
	          _this2.set(_this2.fullKey(data.room_id, data.extension.full_key), {
	            signed_url: null,
	            signed_url_loading: true,
	            url_template_values: data.url_template_values,
	            error: null,
	            is_error: false
	          });
	        },
	        "signed-extension-url-fetched": function signedExtensionUrlFetched(data) {
	          _this2.set(_this2.fullKey(data.room_id, data.extension.full_key), {
	            signed_url: data.signed_url,
	            signed_url_loading: false
	          });
	        },
	        "signed-extension-url-error": function signedExtensionUrlError(data) {
	          var fullKey = _this2.fullKey(data.room_id, data.extension.full_key);
	          var url_template_values = _.get(_this2.get(fullKey), "url_template_values", {});
	          _this2.set(fullKey, {
	            error: data.error,
	            is_error: true,
	            status: data.status,
	            signed_url: null,
	            signed_url_loading: false,
	            url_template_values: url_template_values
	          });
	        },
	        "integration-iframe-loaded": function integrationIframeLoaded(data) {
	          var integration_full_key = IntegrationHelper.to_full_key(data.integration.addon_key, data.integration.key);
	          var fullKey = _this2.fullKey(data.room_id, integration_full_key);
	          _this2.set(fullKey, _.extend({
	            frame_loading: false
	          }, _this2.get(fullKey)));
	        }
	      });
	    }
	  }, {
	    key: "onIntegrationViewStatusChange",
	    value: function onIntegrationViewStatusChange(room_id, extension_full_key, callback) {
	      var key = this.fullKey(room_id, extension_full_key);
	      this.on("change:" + key, callback);
	    }
	  }, {
	    key: "offIntegrationViewStatusChange",
	    value: function offIntegrationViewStatusChange(room_id, extension_full_key, callback) {
	      var key = this.fullKey(room_id, extension_full_key);
	      this.off("change:" + key, callback);
	    }
	  }, {
	    key: "getIntegrationViewStatus",
	    value: function getIntegrationViewStatus(room_id, extension_full_key) {
	      var key = this.fullKey(room_id, extension_full_key);
	      return this.get(key);
	    }
	  }, {
	    key: "fullKey",
	    value: function fullKey(room_id, extension_full_key) {
	      return room_id + ":" + extension_full_key;
	    }
	  }]);
	  return IntegrationsViewStore;
	}(Store);
	
	module.exports = new IntegrationsViewStore();

/***/ },
/* 437 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  fetch_error: 'Couldn\'t load integrations',
	  retry: 'Try again',
	  glance_fetch_error: 'Can\'t load',
	  glance_loading: 'Loading...',
	  empty_message_actions: 'No actions available',
	  empty_message_actions_title: 'There are no actions available for this message.',
	  configure_integrations: 'Integrations',
	  add_integrations: 'Add integrations',
	  configure_integration: 'Configure integration',
	  update_integration: 'Update integration',
	  disabled_integrations: 'Disabled',
	  update: 'Update',
	  the_following_integrations_require_the_latest_version_of_hipchat: 'The following integrations require the latest version of HipChat.',
	  active: 'Active',
	  pending_updates: 'Pending Updates',
	  pending_updates_contact_admin: 'The following integrations require a room administrator to approve an update.',
	  pending_global_updates: 'Pending Global Updates',
	  pending_global_updates_contact_admin: 'The following integrations require a global administrator to approve an update.',
	  install_integrations: 'Install integrations',
	  install_new_integrations: 'Install new integrations',
	  install_integrations_tooltip_title: 'ADD AND CONFIGURE INTEGRATIONS',
	  install_integrations_tooltip_content: 'Just so you know, you can always add more integrations, or manage your existing ones here.',
	  got_it: 'Got it!',
	  installed_count: function installed_count(count) {
	    return count + ' installed';
	  },
	  pending_updates_count: function pending_updates_count(count) {
	    return count + ' pending update' + (count > 1 ? 's' : '');
	  },
	  integration_failed_to_load: 'Unable to load'
	};
	module.exports = exports['default'];

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _permissions_store = __webpack_require__(269);
	
	var _permissions_store2 = _interopRequireDefault(_permissions_store);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _integrations_management_dialog_empty_state = __webpack_require__(439);
	
	var _integrations_management_dialog_empty_state2 = _interopRequireDefault(_integrations_management_dialog_empty_state);
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	var _integrations_section = __webpack_require__(441);
	
	var _integrations_section2 = _interopRequireDefault(_integrations_section);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BITBUCKET_ADDON_KEY = 'com.atlassian.bitbucket.hipbucket';
	
	var integration_events = ['change:integrations', 'change:unsupported_integrations', 'change:active_chat', 'change:pending_updates'];
	
	exports.default = React.createClass({
	
	  displayName: 'IntegrationsDialog',
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  componentDidMount: function componentDidMount() {
	    _integrations_store2.default.on(integration_events, this._onChange);
	    _current_user_store2.default.on('change:id', this._onChange);
	    _configuration_store2.default.on('change:web_server', this._onChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _integrations_store2.default.off(integration_events, this._onChange);
	    _current_user_store2.default.off('change:id', this._onChange);
	    _configuration_store2.default.off('change:web_server', this._onChange);
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _getState: function _getState() {
	    var _IntegrationsStore$ge = _integrations_store2.default.getIntegrationStatusesForContext();
	
	    var pending_global = _IntegrationsStore$ge.pending_global;
	    var pending_room = _IntegrationsStore$ge.pending_room;
	    var disabled = _IntegrationsStore$ge.disabled;
	    var installed = _IntegrationsStore$ge.installed;
	
	
	    return {
	      active_chat: _integrations_store2.default.get('active_chat'),
	      pending_global: pending_global,
	      pending_room: pending_room,
	      disabled: disabled,
	      installed: installed,
	      integrations: _integrations_store2.default.getUniqueIntegrationsForContext(),
	      web_server: _configuration_store2.default.get('web_server'),
	      current_user_id: _current_user_store2.default.get('id')
	    };
	  },
	  _getConfigButton: function _getConfigButton(integration) {
	    var url = _integration_helper2.default.getIntegrationsConfigUrl(this.state.web_server, this.state.active_chat.id, integration.addon_key);
	    return React.createElement(
	      'a',
	      { href: url, target: '_blank', className: 'hc-integration-configure' },
	      React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-configure', 'aria-label': _integrations_strings2.default.configure_integration })
	    );
	  },
	  _getUpdateButton: function _getUpdateButton(integration) {
	    var global_context = integration.context === "global";
	    var chat_id = global_context ? -1 : this.state.active_chat.id;
	
	    var url = _integration_helper2.default.getIntegrationsUpdateUrl(this.state.web_server, chat_id, integration.addon_key);
	    return React.createElement(
	      'a',
	      { href: url, target: '_blank', className: 'hc-integration-update' },
	      _integrations_strings2.default.update
	    );
	  },
	  _getDisabledIntegrationsSection: function _getDisabledIntegrationsSection(integrations) {
	    return React.createElement(_integrations_section2.default, { title: _integrations_strings2.default.disabled_integrations,
	      section: 'unsupported',
	      description: _integrations_strings2.default.the_following_integrations_require_the_latest_version_of_hipchat,
	      integrations: integrations,
	      showGlobalLozenge: false });
	  },
	  _getInstalledIntegrationsSection: function _getInstalledIntegrationsSection(integrations) {
	    var actions = _.noop;
	
	    if (_permissions_store2.default.canUpdateRoomIntegrations()) {
	      actions = this._getConfigButton;
	    }
	
	    return React.createElement(_integrations_section2.default, { title: _integrations_strings2.default.active,
	      status: _integrations_strings2.default.installed_count(integrations.length),
	      section: 'installed',
	      integrations: integrations,
	      actions: actions,
	      showGlobalLozenge: true });
	  },
	  _getPendingRoomUpdatesSection: function _getPendingRoomUpdatesSection(integrations) {
	    var actions = _.noop;
	
	    if (_permissions_store2.default.canUpdateRoomIntegrations()) {
	      actions = this._getUpdateButton;
	    }
	
	    return React.createElement(_integrations_section2.default, { title: _integrations_strings2.default.pending_updates,
	      status: _integrations_strings2.default.pending_updates_count(integrations.length),
	      section: 'pending-room',
	      description: _permissions_store2.default.canUpdateRoomIntegrations() ? null : _integrations_strings2.default.pending_updates_contact_admin,
	      integrations: integrations,
	      actions: actions,
	      showGlobalLozenge: false });
	  },
	  _getPendingGlobalUpdatesSection: function _getPendingGlobalUpdatesSection(integrations) {
	    var actions = _.noop;
	
	    if (_permissions_store2.default.get('user_is_admin')) {
	      actions = this._getUpdateButton;
	    }
	
	    return React.createElement(_integrations_section2.default, { title: _integrations_strings2.default.pending_global_updates,
	      status: _integrations_strings2.default.pending_updates_count(integrations.length),
	      section: 'pending-global',
	      description: _permissions_store2.default.get('user_is_admin') ? null : _integrations_strings2.default.pending_global_updates_contact_admin,
	      integrations: integrations,
	      actions: actions,
	      showGlobalLozenge: false });
	  },
	  _getInstallNewIntegrationsSection: function _getInstallNewIntegrationsSection() {
	    if (!_permissions_store2.default.canManageRoomIntegrations()) {
	      return null;
	    }
	
	    var url = _integration_helper2.default.getIntegrationsUrl(this.state.web_server, this.state.active_chat.id, this.state.current_user_id, _integration_helper2.default.DIALOG_LINK_SOURCE_ID);
	
	    return React.createElement(
	      'div',
	      { className: 'hc-integration-section' },
	      React.createElement(
	        'a',
	        { href: url, target: '_blank', className: 'hc-install-link' },
	        React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-add-small' }),
	        React.createElement(
	          'span',
	          null,
	          _integrations_strings2.default.install_new_integrations
	        )
	      )
	    );
	  },
	  _isBitbucketInstalledButNotConfigured: function _isBitbucketInstalledButNotConfigured(integrations) {
	    var _this = this;
	
	    var is_bitbucket_configured = function is_bitbucket_configured() {
	      return _.find(_integrations_store2.default.getExtensionsByType('glance'), function (addon) {
	        return addon.addon_key === BITBUCKET_ADDON_KEY;
	      });
	    };
	    var is_bitbucket_disabled = function is_bitbucket_disabled() {
	      return _.find(_this.state.disabled, function (addon) {
	        return addon.addon_key === BITBUCKET_ADDON_KEY;
	      });
	    };
	
	    return integrations.length === 1 // Only one addon installed
	     && integrations[0].addon_key === BITBUCKET_ADDON_KEY // Addon is bitbucket
	     && !is_bitbucket_disabled() // Addon isn't disabled
	     && !is_bitbucket_configured(); // Addon isn't configured (no glance)
	  },
	  _shouldShowEmptyState: function _shouldShowEmptyState() {
	    var integrations = this.state.integrations;
	
	    if (integrations.length === 0) {
	      return true;
	    }
	
	    return this._isBitbucketInstalledButNotConfigured(integrations);
	  },
	  _getDialogBody: function _getDialogBody() {
	    if (this._shouldShowEmptyState()) {
	      var can_manage_integrations = _permissions_store2.default.canManageRoomIntegrations();
	      return React.createElement(_integrations_management_dialog_empty_state2.default, { active_chat_id: this.state.active_chat.id,
	        user_id: this.state.current_user_id,
	        web_server: this.state.web_server,
	        can_manage_integrations: can_manage_integrations });
	    }
	
	    return React.createElement(
	      'div',
	      null,
	      this._getInstallNewIntegrationsSection(),
	      this._getPendingRoomUpdatesSection(this.state.pending_room),
	      this._getPendingGlobalUpdatesSection(this.state.pending_global),
	      this._getDisabledIntegrationsSection(this.state.disabled),
	      this._getInstalledIntegrationsSection(this.state.installed)
	    );
	  },
	
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: 'integrations-management-dialog',
	      title: 'Integrations',
	      size: 'medium',
	      dialogBody: this._getDialogBody,
	      showFooter: false,
	      noCloseLink: true });
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _empty_state_strings = __webpack_require__(440);
	
	var _empty_state_strings2 = _interopRequireDefault(_empty_state_strings);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PropTypes = React.PropTypes;
	
	exports.default = React.createClass({
	
	  displayName: 'IntegrationsDialogEmptyState',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    active_chat_id: PropTypes.string,
	    user_id: PropTypes.number,
	    web_server: PropTypes.string,
	    can_manage_integrations: PropTypes.bool
	  },
	
	  render: function render() {
	    var url = this.props.can_manage_integrations ? _integration_helper2.default.getIntegrationsUrl(this.props.web_server, this.props.active_chat_id, this.props.user_id) : _integration_helper2.default.getIntegrationsBaseUrl(this.props.web_server);
	
	    return React.createElement(
	      'div',
	      { className: 'hc-integrations-empty-state' },
	      React.createElement('div', { className: 'hc-integrations-es-img' }),
	      React.createElement(
	        'p',
	        null,
	        _empty_state_strings2.default.empty_integrations_text
	      ),
	      React.createElement(
	        'p',
	        null,
	        React.createElement(
	          'a',
	          { className: 'aui-button aui-button-primary', href: url, target: '_blank' },
	          _empty_state_strings2.default.check_out_integrations
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  no_files: "No files shared yet",
	  no_links: "No links shared yet",
	  no_glance_integration: "No integration installed yet",
	  share_a_file: "Share the first file",
	  share_a_link: "Recently shared links will appear here.",
	  check_out_integrations: "Check out " + _common_strings2.default.app_name + " integrations",
	  empty_private_room: "You're the only one here",
	  invite_to_team: _common_strings2.default.app_name + " is awesome with teammates.",
	  invite_to_team_action: "Invite your team to join",
	  invite_to_room: "Rooms are more fun with teammates.",
	  invite_to_room_action: "Ask them to join you",
	  empty_lobby_title: "WELCOME TO " + _common_strings2.default.app_name.toUpperCase(),
	  empty_lobby_message: "It looks like you're just starting out, so things are a little bare.",
	  empty_search_lobby: "Sorry, nothing matches your search.",
	  empty_integrations_text: "Connect your team with the tools they love. With over 100 integrations, transform HipChat from simple chat to your team's command center."
	};
	module.exports = exports['default'];

/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _integration = __webpack_require__(442);
	
	var _integration2 = _interopRequireDefault(_integration);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PropTypes = React.PropTypes;
	
	var IntegrationsSection = React.createClass({
	  displayName: "IntegrationsSection",
	
	  defaultProps: {
	    showGlobalLozenge: false,
	    actions: _.noop
	  },
	
	  propTypes: {
	    actions: PropTypes.func,
	    showGlobalLozenge: PropTypes.bool,
	    section: PropTypes.string.isRequired,
	    status: PropTypes.string,
	    integrations: PropTypes.arrayOf(PropTypes.object).isRequired
	  },
	
	  render: function render() {
	    var _this = this;
	
	    if (this.props.integrations.length === 0) {
	      return null;
	    }
	
	    var description = null,
	        status = null;
	
	    if (this.props.description) {
	      description = React.createElement(
	        "div",
	        { className: "hc-integration-section-description" },
	        React.createElement(
	          "p",
	          null,
	          this.props.description
	        )
	      );
	    }
	
	    if (this.props.status) {
	      status = React.createElement(
	        "span",
	        { className: "hc-integrations-installed-count" },
	        this.props.status
	      );
	    }
	
	    var rendered_integrations = _.map(this.props.integrations, function (integration, i) {
	      return React.createElement(_integration2.default, { key: i,
	        integration: integration,
	        actions: _this.props.actions,
	        showGlobalLozenge: _this.props.showGlobalLozenge });
	    });
	
	    return React.createElement(
	      "div",
	      { className: "hc-integration-section hc-integration-section-" + this.props.section },
	      React.createElement(
	        "div",
	        { className: "hc-integration-section-title" },
	        React.createElement(
	          "h5",
	          null,
	          this.props.title
	        ),
	        status
	      ),
	      description,
	      React.createElement(
	        "ul",
	        { className: "hc-integrations-list" },
	        rendered_integrations
	      )
	    );
	  }
	});
	
	exports.default = IntegrationsSection;
	module.exports = exports['default'];

/***/ },
/* 442 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PropTypes = React.PropTypes;
	
	var Integration = React.createClass({
	  displayName: "Integration",
	
	  propTypes: {
	    actions: PropTypes.func.isRequired,
	    showGlobalLozenge: PropTypes.bool.isRequired,
	    integration: PropTypes.shape({
	      name: PropTypes.string,
	      icon: PropTypes.string
	    }).isRequired
	  },
	
	  render: function render() {
	    var actions = null,
	        icon = React.createElement("div", { className: "hc-integration-icon hc-integration-icon-default" }),
	        scope = null;
	
	    if (this.props.integration.icon) {
	      icon = React.createElement("img", { src: this.props.integration.icon, className: "hc-integration-icon" });
	    }
	
	    if (this.props.integration.context === "global" && this.props.showGlobalLozenge) {
	      scope = React.createElement(
	        "span",
	        { className: "aui-lozenge aui-lozenge-subtle" },
	        "Global"
	      );
	    }
	
	    if (this.props.actions) {
	      actions = this.props.actions(this.props.integration);
	    }
	
	    return React.createElement(
	      "li",
	      null,
	      icon,
	      React.createElement(
	        "div",
	        { className: "hc-integration-name" },
	        this.props.integration.name
	      ),
	      React.createElement(
	        "span",
	        { className: "hc-integration-management-right" },
	        scope,
	        actions
	      )
	    );
	  }
	});
	
	exports.default = Integration;
	module.exports = exports['default'];

/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _edit_message_form = __webpack_require__(444);
	
	var _edit_message_form2 = _interopRequireDefault(_edit_message_form);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _ie_submit_mixin = __webpack_require__(369);
	
	var _ie_submit_mixin2 = _interopRequireDefault(_ie_submit_mixin);
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "EditMessageDialog",
	
	  mixins: [_ie_submit_mixin2.default, _modal_dialog_visibility_mixin2.default],
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  _getState: function _getState() {
	    return {
	      dialogButtonInactive: true
	    };
	  },
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(_edit_message_form2.default, { message: this.props.message,
	      activateDialogButton: this._activateDialogButton,
	      deactivateDialogButton: this._deactivateDialogButton });
	  },
	
	  _activateDialogButton: function _activateDialogButton() {
	    this.setState({
	      dialogButtonInactive: false
	    });
	  },
	
	  _deactivateDialogButton: function _deactivateDialogButton() {
	    this.setState({
	      dialogButtonInactive: true
	    });
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { form: "edit-message-form", className: "aui-button aui-button-primary", "aria-disabled": this.state.dialogButtonInactive, type: "submit", onClick: this.ieSubmit },
	      _dialog_strings2.default.save
	    );
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: "edit-message-dialog",
	      title: _dialog_strings2.default.edit_message,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel" });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _aui_textarea_fieldgroup = __webpack_require__(363);
	
	var _aui_textarea_fieldgroup2 = _interopRequireDefault(_aui_textarea_fieldgroup);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "EditMessageForm",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    this._focusInput();
	    this.shouldAutoFocus = true;
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.dialogVisible && this.shouldAutoFocus) {
	      this._focusInput();
	      this.shouldAutoFocus = false;
	    }
	  },
	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    if (nextState.body !== this.props.message.body) {
	      this.props.activateDialogButton();
	    } else {
	      this.props.deactivateDialogButton();
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this.delayedFocus) {
	      clearTimeout(this.delayedFocus);
	    }
	  },
	  getInitialState: function getInitialState() {
	    var msg = this.props.message;
	    if (this.props.message.message_type === 'file' && this.props.message.body.indexOf('File uploaded') === 0 && this.props.message.rendered_body === '') {
	      msg = _.assign({}, this.props.message, { body: '' });
	    }
	    return msg;
	  },
	  _handleKeyDown: function _handleKeyDown(evt) {
	    if (evt.keyCode === _utils2.default.keyCode.Enter && !_utils2.default.keyCode.isModified(evt)) {
	      this._onSubmit(evt);
	    }
	  },
	  _onChange: function _onChange(evt) {
	    this.setState({
	      body: evt.target.value
	    });
	  },
	
	
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    _form_actions2.default.editMessage({
	      jid: this.state.from,
	      message: this.state.body,
	      original_mid: this.state.mid,
	      ts: this.state.ts
	    });
	    this._closeDialog();
	  },
	
	  _closeDialog: function _closeDialog() {
	    _dialog_actions2.default.closeDialog();
	  },
	  _focusInput: function _focusInput() {
	    var _this = this;
	
	    this.delayedFocus = _.delay(function () {
	      var textArea = ReactDOM.findDOMNode(_this).querySelector('#message-to-edit');
	      textArea.focus();
	      textArea.setSelectionRange(_this.state.body.length, _this.state.body.length);
	    }, _app_config2.default.modal_transition_allowance);
	  },
	  render: function render() {
	    return React.createElement(
	      "form",
	      { id: "edit-message-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(_aui_textarea_fieldgroup2.default, {
	        id: "message-to-edit",
	        label: this.state.sender,
	        rows: "5",
	        cols: "400",
	        maxLength: _app_config2.default.max_message_text_length,
	        value: this.state.body,
	        onKeyDown: this._handleKeyDown,
	        onChange: this._onChange }),
	      React.createElement(
	        "span",
	        { className: "edit-display-time" },
	        this.state.display_time
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _delete_message_form = __webpack_require__(446);
	
	var _delete_message_form2 = _interopRequireDefault(_delete_message_form);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'DeleteMessageDialog',
	
	  _dialogBody: function _dialogBody() {
	    return React.createElement(_delete_message_form2.default, { message: this.props.message });
	  },
	
	  _dialogFooterButtons: function _dialogFooterButtons() {
	    var btnClasses = (0, _classnames2.default)({
	      'aui-button': true
	    });
	
	    return React.createElement(
	      'button',
	      { form: 'delete-message-form', className: btnClasses, type: 'submit' },
	      _dialog_strings2.default.delete
	    );
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: 'delete-message-dialog',
	      isWarning: 'true',
	      title: _dialog_strings2.default.delete_message,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButtons,
	      closeLinkText: _dialog_strings2.default.cancel,
	      hint: _dialog_strings2.default.edit_message_hint });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _form_actions = __webpack_require__(286);
	
	var _form_actions2 = _interopRequireDefault(_form_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _message = __webpack_require__(447);
	
	var _message2 = _interopRequireDefault(_message);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'DeleteMessageForm',
	
	  _onSubmit: function _onSubmit(evt) {
	    evt.preventDefault();
	    _form_actions2.default.deleteMessage(this.props.message);
	    _dialog_actions2.default.closeDialog();
	  },
	  _renderMessage: function _renderMessage() {
	    var msg = this.props.message;
	    return React.createElement(_message2.default, { key: 'msg-' + msg.mid, ref: 'msg_' + msg.mid, msg: msg });
	  },
	  render: function render() {
	    var renderedMessage = this._renderMessage();
	    return React.createElement(
	      'form',
	      { id: 'delete-message-form',
	        ref: 'delete_message_form',
	        className: 'aui',
	        onSubmit: this._onSubmit },
	      renderedMessage
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _emoticons = __webpack_require__(110);
	
	var _emoticons2 = _interopRequireDefault(_emoticons);
	
	var _expando = __webpack_require__(448);
	
	var _expando2 = _interopRequireDefault(_expando);
	
	var _mention_emoticon_tooltip_mixin = __webpack_require__(449);
	
	var _mention_emoticon_tooltip_mixin2 = _interopRequireDefault(_mention_emoticon_tooltip_mixin);
	
	var _scrolling_media_observer_mixin = __webpack_require__(450);
	
	var _scrolling_media_observer_mixin2 = _interopRequireDefault(_scrolling_media_observer_mixin);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	var _quote = __webpack_require__(451);
	
	var _quote2 = _interopRequireDefault(_quote);
	
	var _code = __webpack_require__(452);
	
	var _code2 = _interopRequireDefault(_code);
	
	var _monospace = __webpack_require__(453);
	
	var _monospace2 = _interopRequireDefault(_monospace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PureRenderMixin = React.addons.PureRenderMixin;
	
	function getHtmlMsg(mid, body) {
	  return React.createElement('div', { 'data-mid': mid, dangerouslySetInnerHTML: { __html: body } });
	}
	
	function getCommonMsg(mid, body, rendered_body) {
	  if (_utils2.default.messageShouldBeTruncated(body)) {
	    return React.createElement(
	      _expando2.default,
	      { mid: mid },
	      React.createElement('div', { className: 'msg-wrap',
	        'data-copyable': '{"format": "plain-message", "mid": "' + mid + '"}',
	        dangerouslySetInnerHTML: { __html: rendered_body } })
	    );
	  }
	
	  return React.createElement('div', { className: 'msg-line',
	    'data-mid': mid,
	    'data-copyable': '{"format": "plain-message", "mid": "' + mid + '"}',
	    dangerouslySetInnerHTML: { __html: rendered_body } });
	}
	
	function getDeletedMsg(mid) {
	  return React.createElement(
	    'div',
	    { className: 'msg-line deleted', 'data-mid': mid },
	    React.createElement('div', { className: 'hc-msg-deleted-icon' }),
	    _chat_panel_strings2.default.message_deleted
	  );
	}
	
	function getRenderedMessage(msg) {
	  if (msg.is_deleted) {
	    return getDeletedMsg(msg.mid);
	  }
	
	  switch (msg.format) {
	    case 'code':
	      return React.createElement(_code2.default, { mid: msg.mid, body: msg.rendered_body });
	    case 'monospace':
	      return React.createElement(_monospace2.default, { mid: msg.mid, body: msg.rendered_body });
	    case 'quotation':
	      return React.createElement(_quote2.default, { mid: msg.mid, body: msg.body });
	    case 'html':
	      return getHtmlMsg(msg.mid, msg.xhtml_im_body);
	    default:
	      return getCommonMsg(msg.mid, msg.body, msg.rendered_body);
	  }
	}
	
	exports.default = React.createClass({
	
	  displayName: "MessageMessageType",
	
	  // Message instance changes only when message changes, so
	  // we can use PureRenderMixin here
	  mixins: [PureRenderMixin, _mention_emoticon_tooltip_mixin2.default, _scrolling_media_observer_mixin2.default],
	
	  propTypes: {
	    msg: React.PropTypes.shape({
	      body: React.PropTypes.string.isRequired,
	      rendered_body: React.PropTypes.string.isRequired,
	      format: React.PropTypes.string.isRequired,
	      mid: React.PropTypes.string.isRequired,
	      status: React.PropTypes.string.isRequired
	    })
	  },
	
	  componentDidMount: function componentDidMount() {
	    _emoticons2.default._replaceSpecials(ReactDOM.findDOMNode(this));
	  },
	  render: function render() {
	    var msg = this.props.msg,
	        renderedMessage = getRenderedMessage(msg);
	
	    return renderedMessage;
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ChatPanelStrings = __webpack_require__(185);
	var cx = __webpack_require__(313);
	
	
	module.exports = React.createClass({
	
	  displayName: "Expando",
	
	  getInitialState: function getInitialState() {
	    return {
	      truncated: true,
	      height: 0
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    var height = $(ReactDOM.findDOMNode(this.refs.expando)).height();
	    this.setState({
	      height: height,
	      truncated: height > 120 ? true : false
	    });
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    _chat_window_actions2.default.preserveScrollValue({ animation: false });
	  },
	
	  render: function render() {
	    var contentClasses = cx({
	      "msg-line": true,
	      "truncatable": true,
	      "truncated": this.state.truncated,
	      "expanded": !this.state.truncated
	    });
	    var toggleClasses = cx({
	      "truncatable": true,
	      "truncated": this.state.truncated,
	      "expanded": !this.state.truncated,
	      "hidden": this.state.height <= 120
	    });
	    return React.createElement(
	      'div',
	      { className: contentClasses + ' ' + this.props.className, 'data-mid': this.props.mid },
	      React.createElement(
	        'div',
	        { className: 'truncate-wrap' },
	        React.createElement(
	          'div',
	          { ref: 'expando', className: 'msg-wrap' },
	          this.props.children
	        )
	      ),
	      React.createElement(
	        'div',
	        { className: toggleClasses },
	        React.createElement(
	          'a',
	          { name: 'truncate', onClick: this._toggleTruncatedText },
	          this.state.truncated ? ChatPanelStrings.show_more : ChatPanelStrings.show_less
	        )
	      )
	    );
	  },
	
	  _toggleTruncatedText: function _toggleTruncatedText(e) {
	    e.preventDefault();
	    this.setState({
	      truncated: !this.state.truncated
	    });
	  }
	});

/***/ },
/* 449 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  _tooltipElements: function _tooltipElements() {
	    return ReactDOM.findDOMNode(this).querySelectorAll('.hc-mention-user, .remoticon');
	  },
	
	
	  // Put me in componentDidMount
	  _createTooltips: function _createTooltips() {
	    AJS.$(this._tooltipElements()).tooltip({
	      title: function title() {
	        var link = this.querySelector('a');
	        return link && link.getAttribute('data-title') || this.getAttribute('data-title') || this.alt || "";
	      }
	    });
	  },
	
	
	  // Put me in componentWillUnmount
	  _destroyTooltips: function _destroyTooltips() {
	    AJS.$(this._tooltipElements()).tooltip('destroy');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  getInitialState: function getInitialState() {
	    return {
	      failed: false
	    };
	  },
	
	
	  componentDidMount: function componentDidMount() {
	    _chat_window_actions2.default.preserveScrollValue({ animation: true });
	    this._observeMediaTags();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    _chat_window_actions2.default.preserveScrollValue({ animation: false });
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    this._cleanupMediaTagObservers();
	  },
	
	  _getIdForMediaTag: function _getIdForMediaTag(mediaTag) {
	    var id = mediaTag.getAttribute('data-reactid') || mediaTag.getAttribute('id');
	    if (!id) {
	      var fakeId = 'hc-fake-react-id-' + _.uniqueId();
	      mediaTag.id = fakeId;
	      id = fakeId;
	    }
	    return id;
	  },
	
	
	  _observeMediaTag: function _observeMediaTag(mediaTag) {
	    var _this = this;
	
	    var id = this._getIdForMediaTag(mediaTag);
	    var readyEvent = this._getReadyEvent(mediaTag);
	    if (!this.props.msg.media_loaded) {
	      mediaTag.style.display = 'none';
	      this._media_timeouts[id] = setTimeout(function () {
	        _this._onMediaTagFailed({ target: mediaTag });
	      }, _app_config2.default.message_image_loading_timeout);
	      if (this._isImageTag(mediaTag)) {
	        this._media_size_intervals[id] = setInterval(function () {
	          if (mediaTag.naturalHeight && mediaTag.naturalWidth) {
	            clearInterval(_this._media_size_intervals[id]);
	            delete _this._media_size_intervals[id];
	            _this._onMediaSizeKnown(mediaTag);
	          }
	        }, _app_config2.default.message_image_size_check_interval);
	      }
	      mediaTag.addEventListener(readyEvent, this._onMediaTagReady);
	      mediaTag.addEventListener('error', this._onMediaTagFailed);
	    } else {
	      mediaTag.addEventListener(readyEvent, this._onMediaTagReady);
	    }
	  },
	
	  _onMediaSizeKnown: function _onMediaSizeKnown(mediaTag) {
	
	    var $mediaTag = $(mediaTag),
	        $chatRow = $mediaTag.parents('.hc-chat-row'),
	        chatRowHeight = $chatRow.outerHeight();
	
	    mediaTag.style.display = '';
	
	    _chat_window_actions2.default.updateScrollPosition({
	      heightDiff: $chatRow.outerHeight() - chatRowHeight,
	      offsetTop: $chatRow[0] && $chatRow[0].offsetTop
	    });
	
	    _chat_window_actions2.default.messageMediaSizeFound({
	      jid: this.props.msg.room,
	      mid: this.props.msg.mid,
	      src: mediaTag.src,
	      size: {
	        width: $mediaTag.width(),
	        height: $mediaTag.height()
	      }
	    });
	  },
	  _getMedia: function _getMedia() {
	    var node = ReactDOM.findDOMNode(this);
	    var imgs = _.toArray(node.querySelectorAll('img'));
	    imgs = imgs.filter(function (img) {
	      // if no height or width attr and unknown actual height, then it may
	      // affect layout when loaded and needs to be observed
	      return !img.height && img.naturalHeight === 0 || !img.width && img.naturalWidth === 0;
	    });
	    var videos = _.toArray(node.querySelectorAll('video'));
	    return imgs.concat(videos);
	  },
	
	
	  _observeMediaTags: function _observeMediaTags() {
	    this._media = this._getMedia();
	    this._media_timeouts = {};
	    this._media_size_intervals = {};
	    this._media_count = this._media.length;
	    this._media.forEach(this._observeMediaTag);
	  },
	
	  _cleanupMediaTagObserver: function _cleanupMediaTagObserver(mediaTag) {
	    if (mediaTag) {
	      var id = this._getIdForMediaTag(mediaTag);
	      var readyEvent = this._getReadyEvent(mediaTag);
	      mediaTag.removeEventListener(readyEvent, this._onMediaTagReady);
	      mediaTag.removeEventListener('error', this._onMediaTagFailed);
	      if (this._media_timeouts[id]) {
	        clearTimeout(this._media_timeouts[id]);
	        delete this._media_timeouts[id];
	      }
	      if (this._media_size_intervals[id]) {
	        clearInterval(this._media_size_intervals[id]);
	        delete this._media_size_intervals[id];
	      }
	      this._media = _.without(this._media, mediaTag);
	    }
	  },
	
	  _getReadyEvent: function _getReadyEvent(mediaTag) {
	    return this._isImageTag(mediaTag) ? 'load' : 'loadedmetadata';
	  },
	
	  _isImageTag: function _isImageTag(mediaTag) {
	    return mediaTag.tagName.toLowerCase() !== 'video';
	  },
	
	
	  _cleanupMediaTagObservers: function _cleanupMediaTagObservers() {
	    if (this._media) {
	      this._media.forEach(this._cleanupMediaTagObserver);
	      delete this._media;
	    }
	  },
	
	  _onMediaTagReady: function _onMediaTagReady(evt) {
	    this._onMediaTagResolved(evt, true);
	  },
	
	  _onMediaTagFailed: function _onMediaTagFailed(evt) {
	    this._onMediaTagResolved(evt, false);
	  },
	
	  _onMediaTagResolved: function _onMediaTagResolved(evt, ready) {
	    var mediaTag = evt.target;
	    this._cleanupMediaTagObserver(mediaTag);
	    if (!this.props.msg.media_loaded) {
	      if (!ready) {
	        mediaTag.style.display = '';
	        this.setState({
	          failed: true
	        });
	      } else {
	        this._media_count--;
	        if (mediaTag.style.display !== '') {
	          this._onMediaSizeKnown(mediaTag);
	        }
	      }
	      if (!_.size(this._media)) {
	        if (!this._media_count) {
	          _chat_window_actions2.default.messageMediaLoaded({
	            jid: this.props.msg.room,
	            mid: this.props.msg.mid
	          });
	        }
	      }
	    }
	    _chat_window_actions2.default.preserveScrollValue({ animation: false });
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _expando = __webpack_require__(448);
	
	var _expando2 = _interopRequireDefault(_expando);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	  displayName: 'QuoteMessageType',
	
	  mixins: [React.addons.PureRenderMixin],
	
	  propTypes: {
	    mid: React.PropTypes.string.isRequired,
	    body: React.PropTypes.string.isRequired
	  },
	
	  render: function render() {
	    return React.createElement(
	      _expando2.default,
	      { mid: this.props.mid },
	      React.createElement(
	        'blockquote',
	        { 'data-copyable': '{"format": "quotation", "mid": "' + this.props.mid + '"}' },
	        this.props.body
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _expando = __webpack_require__(448);
	
	var _expando2 = _interopRequireDefault(_expando);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*global prettyPrintOne*/
	exports.default = React.createClass({
	  displayName: 'CodeMessageType',
	
	  mixins: [React.addons.PureRenderMixin],
	
	  propTypes: {
	    mid: React.PropTypes.string.isRequired,
	    body: React.PropTypes.string.isRequired
	  },
	
	  render: function render() {
	    var _props = this.props;
	    var mid = _props.mid;
	    var body = _props.body;
	    var linenums = _utils2.default.getNumberOfLines(body) > 1;
	    var html = prettyPrintOne('<pre class="prettyprint ' + (linenums ? 'linenums' : '') + '">' + _.escape(body) + '</pre>', undefined, linenums);
	    var content = void 0;
	
	    if (_utils2.default.messageShouldBeTruncated(body)) {
	      content = React.createElement(
	        _expando2.default,
	        { className: 'code', mid: mid },
	        React.createElement(
	          'div',
	          { className: 'msg-line',
	            'data-mid': mid,
	            'data-copyable': '{"format": "code", "mid": "' + mid + '"}' },
	          React.createElement('div', { className: 'pre-wrap', dangerouslySetInnerHTML: { __html: html } })
	        )
	      );
	    } else {
	      content = React.createElement(
	        'div',
	        { className: 'msg-line code',
	          'data-mid': mid,
	          'data-copyable': '{"format": "code", "mid": "' + mid + '"}' },
	        React.createElement('div', { className: 'pre-wrap', dangerouslySetInnerHTML: { __html: html } })
	      );
	    }
	
	    return content;
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _expando = __webpack_require__(448);
	
	var _expando2 = _interopRequireDefault(_expando);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	  displayName: 'MonospaceMessageType',
	
	  mixins: [React.addons.PureRenderMixin],
	
	  propTypes: {
	    mid: React.PropTypes.string.isRequired,
	    body: React.PropTypes.string.isRequired
	  },
	
	  render: function render() {
	    var _props = this.props;
	    var mid = _props.mid;
	    var body = _props.body;
	    var html = '<pre class="prettyprint">' + _.escape(body) + '</pre>';
	    var content = void 0;
	
	    if (_utils2.default.messageShouldBeTruncated(body)) {
	      content = React.createElement(
	        _expando2.default,
	        { className: 'monospace', mid: mid },
	        React.createElement(
	          'div',
	          { className: 'msg-line',
	            'data-mid': mid,
	            'data-copyable': '{"format": "monospace", "mid": "' + mid + '"}' },
	          React.createElement('div', { className: 'pre-wrap', dangerouslySetInnerHTML: { __html: html } })
	        )
	      );
	    } else {
	      content = React.createElement(
	        'div',
	        { className: 'msg-line monospace',
	          'data-mid': mid,
	          'data-copyable': '{"format": "monospace", "mid": "' + mid + '"}' },
	        React.createElement('div', { className: 'pre-wrap', dangerouslySetInnerHTML: { __html: html } })
	      );
	    }
	
	    return content;
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _ie_submit_mixin = __webpack_require__(369);
	
	var _ie_submit_mixin2 = _interopRequireDefault(_ie_submit_mixin);
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "NotEditableDialog",
	
	  mixins: [_ie_submit_mixin2.default, _modal_dialog_visibility_mixin2.default],
	
	  _dialogBody: function _dialogBody() {
	    var hourInMillis = 1000 * 60 * 60;
	    var thresholdInHours = Math.round(_app_config2.default.edit_message_threshold / hourInMillis);
	    return React.createElement(
	      "p",
	      null,
	      _dialog_strings2.default.not_editable_body(thresholdInHours)
	    );
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { form: "not-editable-message-form", className: "aui-button aui-button-primary", type: "submit", onClick: _dialog_actions2.default.closeDialog },
	      _dialog_strings2.default.OK
	    );
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: "not-editable-dialog",
	      title: _dialog_strings2.default.not_editable(this.props.action),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      noCloseLink: true });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modal_dialog = __webpack_require__(341);
	
	var _modal_dialog2 = _interopRequireDefault(_modal_dialog);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _modal_dialog_visibility_mixin = __webpack_require__(342);
	
	var _modal_dialog_visibility_mixin2 = _interopRequireDefault(_modal_dialog_visibility_mixin);
	
	var _welcome_store = __webpack_require__(456);
	
	var _welcome_store2 = _interopRequireDefault(_welcome_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _welcome_people_item = __webpack_require__(457);
	
	var _welcome_people_item2 = _interopRequireDefault(_welcome_people_item);
	
	var _welcome_rooms_item = __webpack_require__(459);
	
	var _welcome_rooms_item2 = _interopRequireDefault(_welcome_rooms_item);
	
	var _welcome_actions = __webpack_require__(458);
	
	var _welcome_actions2 = _interopRequireDefault(_welcome_actions);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _tooltip = __webpack_require__(460);
	
	var _tooltip2 = _interopRequireDefault(_tooltip);
	
	var _chat_input_store = __webpack_require__(270);
	
	var _chat_input_store2 = _interopRequireDefault(_chat_input_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "WelcomeDialog",
	
	  mixins: [_modal_dialog_visibility_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    _welcome_store2.default.on(['change'], this._onStoreChange);
	    _welcome_actions2.default.dialogRendered();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _welcome_store2.default.off(['change'], this._onStoreChange);
	  },
	
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    if (this.state.new_forced_caret_position) {
	      _utils2.default.setCaretPosition(ReactDOM.findDOMNode(this).querySelector(".textarea"), this.state.new_forced_caret_position);
	      _welcome_actions2.default.resetNewForcedCaretPosition();
	    }
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  _getState: function _getState() {
	    return _welcome_store2.default.getAll();
	  },
	
	  _onStoreChange: function _onStoreChange() {
	    this.setState(this._getState());
	  },
	
	  _getStarIcon: function _getStarIcon() {
	    return React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-star' });
	  },
	
	  _getInfoIcon: function _getInfoIcon() {
	    return React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-info' });
	  },
	
	  _dialogTitle: function _dialogTitle() {
	    var title = '';
	
	    switch (this.state.current_step) {
	      case 'welcome':
	        title = _dialog_strings2.default.welcome_to_hipchat;
	        break;
	      case 'people':
	        title = _dialog_strings2.default.choose_people_to_chat;
	        break;
	      case 'rooms':
	        title = _dialog_strings2.default.join_some_rooms;
	        break;
	      case 'message':
	        title = _dialog_strings2.default.introduce_yourself;
	        break;
	    }
	
	    return React.createElement(
	      'div',
	      { className: this.state.current_step === 'welcome' ? 'hc-welcome-dialog-title-center' : null },
	      title
	    );
	  },
	
	  _dialogBody: function _dialogBody() {
	    var content = null;
	
	    switch (this.state.current_step) {
	      case 'welcome':
	        content = this._getWelcomeStep();
	        break;
	      case 'people':
	        content = this._getPeopleStep();
	        break;
	      case 'rooms':
	        content = this._getRoomsStep();
	        break;
	      case 'message':
	        content = this._getMessageStep();
	        break;
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-welcome-dialog-content' },
	      content
	    );
	  },
	
	  _dialogFooterButton: function _dialogFooterButton() {
	    var buttons = [],
	        spinner = this._getSpinner();
	
	    switch (this.state.current_step) {
	      case 'welcome':
	        if (this._isFirstPeopleItemExist()) {
	          buttons = [this._getStartButton(), this._getSkipDialogButton()];
	        } else {
	          buttons = spinner;
	        }
	        break;
	      case 'people':
	        buttons = [this._getNextButton(), this._getSkipThisStepButton()];
	        break;
	      case 'rooms':
	        buttons = [this._getNextButton(), this._getSkipThisStepButton()];
	        break;
	      case 'message':
	        buttons = [this._getFinishButton(), this._getSkipThisStepButton()];
	        break;
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-welcome-footer-buttons' },
	      buttons
	    );
	  },
	
	  _getWelcomeStep: function _getWelcomeStep() {
	    return React.createElement(
	      'div',
	      null,
	      React.createElement('div', { className: 'hc-welcome-welcome-img' }),
	      React.createElement(
	        'div',
	        { className: 'hc-welcome-welcome-text' },
	        React.createElement(
	          'p',
	          null,
	          _dialog_strings2.default.we_ll_help_you
	        ),
	        React.createElement(
	          'p',
	          null,
	          _dialog_strings2.default.this_won_t_take_long
	        )
	      )
	    );
	  },
	
	  _getPeopleStep: function _getPeopleStep() {
	    var peopleArr = _.toArray(this.state.people);
	
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'p',
	        null,
	        _dialog_strings2.default.lets_put_together_a_list_of_people
	      ),
	      React.createElement(
	        'h6',
	        null,
	        _dialog_strings2.default.suggestions
	      ),
	      React.createElement(ReactList, {
	        itemRenderer: this._renderPeopleItem,
	        length: peopleArr.length,
	        selected: this.state.selected_people.length,
	        people: peopleArr,
	        threshold: 0,
	        pageSize: 20,
	        type: 'simple' })
	    );
	  },
	
	  _getRoomsStep: function _getRoomsStep() {
	    var roomsArr = _.toArray(this.state.rooms),
	        selectedPeopleLength = this.state.selected_people.length,
	        starPhrase = selectedPeopleLength === 1 ? _dialog_strings2.default.got_that_person_down : _dialog_strings2.default.got_those_people_down(selectedPeopleLength),
	        starTip = selectedPeopleLength ? React.createElement(
	      'p',
	      null,
	      this._getStarIcon(),
	      ' ',
	      starPhrase
	    ) : null;
	
	    return React.createElement(
	      'div',
	      null,
	      starTip,
	      React.createElement(
	        'p',
	        null,
	        _dialog_strings2.default.weve_got_a_few_sugg_on_rooms
	      ),
	      React.createElement(
	        'h6',
	        null,
	        _dialog_strings2.default.suggestions
	      ),
	      React.createElement(ReactList, {
	        itemRenderer: this._renderRoomsItem,
	        length: roomsArr.length,
	        selected: this.state.selected_rooms.length,
	        rooms: roomsArr,
	        threshold: 0,
	        pageSize: 20,
	        type: 'simple' })
	    );
	  },
	
	  _getMessageStep: function _getMessageStep() {
	    var selectedRoomsLength = this.state.selected_rooms.length,
	        starPhrase = selectedRoomsLength === 1 ? _dialog_strings2.default.that_is_a_good_roome_choice : _dialog_strings2.default.those_are_some_good_roome_choices,
	        starTip = selectedRoomsLength ? React.createElement(
	      'p',
	      null,
	      this._getStarIcon(),
	      ' ',
	      starPhrase
	    ) : null,
	        infoTip = React.createElement(
	      'p',
	      null,
	      this._getInfoIcon(),
	      ' ',
	      _dialog_strings2.default.use_here_in_tour_message
	    ),
	        lengthError = this.state.is_welcome_message_too_long ? React.createElement(
	      'p',
	      { className: 'error' },
	      _dialog_strings2.default.welcome_message_err(this.state.max_length_of_welcome_message)
	    ) : null;
	
	    return React.createElement(
	      'div',
	      null,
	      starTip,
	      React.createElement(
	        'p',
	        null,
	        _dialog_strings2.default.you_are_all_set
	      ),
	      infoTip,
	      React.createElement(
	        'h6',
	        null,
	        _dialog_strings2.default.message
	      ),
	      React.createElement(
	        'div',
	        { className: 'hc-welcome-message' },
	        React.createElement('textarea', {
	          rows: '2',
	          className: 'textarea',
	          onChange: this._onValueChange,
	          value: this.state.welcome_message }),
	        React.createElement(
	          'div',
	          { className: "hc-welcome-smiley-icon" + (selectedRoomsLength ? " star-toggled" : ""), onClick: this._onSmileyClick },
	          React.createElement(
	            'span',
	            { className: 'aui-icon hipchat-icon-small icon-emoticon' },
	            'Emoticons'
	          ),
	          React.createElement(_tooltip2.default, { type: 'smiley_selector' })
	        )
	      ),
	      lengthError
	    );
	  },
	
	  _onSmileyClick: function _onSmileyClick(evt) {
	    var className = evt.currentTarget.className;
	    if (! ~className.indexOf(' selected')) {
	      evt.currentTarget.className += ' selected';
	    } else {
	      evt.currentTarget.className = className.replace(' selected', '');
	    }
	    _welcome_actions2.default.toggleTooltip({
	      type: 'smiley_selector',
	      data: {
	        smileys: this.state.smileys
	      }
	    });
	  },
	
	  _renderPeopleItem: function _renderPeopleItem(index, key) {
	    var item = _.toArray(this.state.people)[index];
	    if (item.jid) {
	      return React.createElement(_welcome_people_item2.default, {
	        key: item.jid,
	        jid: item.jid,
	        name: item.name,
	        title: item.title,
	        user_id: item.id,
	        item_index: index,
	        is_selected: this.state.selected_people.indexOf(item.jid) !== -1,
	        is_first_selection: this.state.is_first_selection,
	        photo_url: item.photo_small,
	        presence_show: item.presence.show });
	    }
	  },
	
	  _renderRoomsItem: function _renderRoomsItem(index, key) {
	    var item = _.toArray(this.state.rooms)[index];
	    if (item.jid) {
	      return React.createElement(_welcome_rooms_item2.default, {
	        key: item.jid,
	        jid: item.jid,
	        name: item.name,
	        topic: item.topic,
	        privacy: item.privacy,
	        type: _utils2.default.room.detect_chat_type(item.jid),
	        is_selected: this.state.selected_rooms.indexOf(item.jid) !== -1,
	        avatar_url: item.avatar_url,
	        all_participants: item.participants_fetched,
	        roster: this.state.roster,
	        current_user_jid: this.state.current_user_jid,
	        max_amount_of_people_icons: this.state.max_amount_of_people_icons });
	    }
	  },
	
	  _onValueChange: function _onValueChange(evt) {
	    var maxLength = this.state.max_length_of_welcome_message;
	
	    if (evt.target.value.length < maxLength) {
	      _welcome_actions2.default.changeWelcomeMessage(evt.target.value);
	      if (this.state.is_welcome_message_too_long) {
	        _welcome_actions2.default.setIsWelcomeMessageTooLong(false);
	      }
	    } else {
	      _welcome_actions2.default.changeWelcomeMessage(evt.target.value.slice(0, maxLength));
	      _welcome_actions2.default.setIsWelcomeMessageTooLong(true);
	    }
	  },
	
	  _getStartButton: function _getStartButton() {
	    return React.createElement(
	      'button',
	      { key: 'start_button', className: 'aui-button aui-button-primary', onClick: this._nextStep },
	      _dialog_strings2.default.start_button
	    );
	  },
	
	  _getSkipDialogButton: function _getSkipDialogButton() {
	    return React.createElement(
	      'button',
	      { key: 'skip_button', className: 'aui-button aui-button-link', onClick: this._skipDialog },
	      _dialog_strings2.default.skip_dialog_button
	    );
	  },
	
	  _getNextButton: function _getNextButton() {
	    var nothingIsSelected = null;
	
	    switch (this.state.current_step) {
	      case 'people':
	        nothingIsSelected = this.state.selected_people.length === 0;
	        break;
	      case 'rooms':
	        nothingIsSelected = this.state.selected_rooms.length === 0;
	        break;
	    }
	
	    return React.createElement(
	      'button',
	      { key: 'next_button', className: 'aui-button aui-button-primary', disabled: nothingIsSelected, onClick: this._nextStep },
	      _dialog_strings2.default.next_button
	    );
	  },
	
	  _getSkipThisStepButton: function _getSkipThisStepButton() {
	    return React.createElement(
	      'button',
	      { key: 'skip_button', className: 'aui-button aui-button-link', onClick: this._skipThisStep },
	      _dialog_strings2.default.skip_this_step_button
	    );
	  },
	
	  _getFinishButton: function _getFinishButton() {
	    var nothingIsSelected = this.state.selected_people.length + this.state.selected_rooms.length === 0,
	        welcomeMessageIsEmpty = this.state.welcome_message.trim() === '';
	
	    return React.createElement(
	      'button',
	      { key: 'finish_button', className: 'aui-button aui-button-primary', disabled: nothingIsSelected || welcomeMessageIsEmpty, onClick: this._createChats },
	      _dialog_strings2.default.finish_and_send_button
	    );
	  },
	
	  _getSpinner: function _getSpinner() {
	    return React.createElement(_spinner2.default, { spin: true, size: "small", spinner_class: 'hc-loading-spinner' });
	  },
	
	  _skipDialog: function _skipDialog() {
	    _welcome_actions2.default.skipDialog();
	  },
	
	  _nextStep: function _nextStep() {
	    var currentStepIndex = this.state.steps.indexOf(this.state.current_step),
	        nextStepIndex = currentStepIndex + 1;
	
	    _welcome_actions2.default.nextStep(this.state.steps[nextStepIndex]);
	  },
	
	  _skipThisStep: function _skipThisStep() {
	    var currentStep = this.state.current_step,
	        currentStepIndex = this.state.steps.indexOf(currentStep),
	        nextStepIndex = currentStepIndex + 1;
	
	    switch (currentStep) {
	      case 'people':
	        _welcome_actions2.default.clearPeopleSelection();
	        _welcome_actions2.default.skipThisStep(this.state.steps[nextStepIndex]);
	        break;
	      case 'rooms':
	        _welcome_actions2.default.clearRoomsSelection();
	        _welcome_actions2.default.skipThisStep(this.state.steps[nextStepIndex]);
	        break;
	      case 'message':
	        this._createChats(false);
	        break;
	    }
	  },
	
	  _createChats: function _createChats() {
	    var _this = this;
	
	    var sendMessage = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	    var welcomeMessage = _utils2.default.strings.stripHiddenCharacters(this.state.welcome_message.trim());
	
	    this.state.selected_people.forEach(function (jid) {
	      _welcome_actions2.default.createChats({
	        jid: _this.state.people[jid].jid,
	        name: _this.state.people[jid].name,
	        type: _this.state.people[jid].type
	      });
	      if (sendMessage) {
	        _welcome_actions2.default.sendMessage({
	          text: welcomeMessage,
	          jid: _this.state.people[jid].jid,
	          id: _chat_input_store2.default.get('message_id'),
	          active_chat_id: _this.state.people[jid].id,
	          chat_type: _this.state.people[jid].type
	        });
	      }
	    });
	
	    this.state.selected_rooms.forEach(function (jid) {
	      _welcome_actions2.default.createChats({
	        jid: _this.state.rooms[jid].jid,
	        name: _this.state.rooms[jid].name,
	        type: _this.state.rooms[jid].type
	      });
	      if (sendMessage) {
	        _welcome_actions2.default.sendMessage({
	          text: welcomeMessage,
	          jid: _this.state.rooms[jid].jid,
	          id: _chat_input_store2.default.get('message_id'),
	          active_chat_id: _this.state.rooms[jid].id,
	          chat_type: _this.state.rooms[jid].type
	        });
	      }
	    });
	
	    _welcome_actions2.default.closeDialog();
	  },
	
	  _isFirstPeopleItemExist: function _isFirstPeopleItemExist() {
	    var peopleArr = _.toArray(this.state.people);
	
	    return peopleArr[0] && peopleArr[0].jid ? true : false;
	  },
	
	  render: function render() {
	    return React.createElement(_modal_dialog2.default, { dialogId: 'welcome-dialog',
	      title: this._dialogTitle(),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      noCloseLink: true });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var WelcomeStore = function (_Store) {
	  (0, _inherits3.default)(WelcomeStore, _Store);
	
	  function WelcomeStore() {
	    (0, _classCallCheck3.default)(this, WelcomeStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(WelcomeStore).call(this));
	
	    _this.local = {
	      welcome_init: false
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(WelcomeStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        steps: ['welcome', 'people', 'rooms', 'message'],
	        current_step: 'welcome',
	        people: {},
	        rooms: {},
	        selected_people: [],
	        selected_rooms: [],
	        welcome_message: _dialog_strings2.default.welcome_messages(),
	        is_first_selection: true,
	        current_user_jid: '',
	        max_length_of_welcome_message: _app_config2.default.welcome_dialog.max_length_of_welcome_message,
	        max_amount_of_people_icons: _app_config2.default.welcome_dialog.max_amount_of_people_icons,
	        is_welcome_message_too_long: false,
	        roster: {},
	        smileys: {},
	        new_forced_caret_position: 0
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(data) {
	          _this2.set({
	            current_user_jid: data.jid
	          });
	        },
	        'welcome-init': function welcomeInit() {
	          _this2.local.welcome_init = true;
	          _this2._handleRoster();
	          _this2._handleAllRooms();
	        }
	      });
	
	      _app_dispatcher2.default.register({
	        'updated:roster': function updatedRoster(roster) {
	          if (_this2.local.welcome_init) {
	            _this2._handleRoster(roster);
	          }
	        },
	        'updated:allRooms': function updatedAllRooms(allRooms) {
	          if (_this2.local.welcome_init) {
	            _this2._handleAllRooms(allRooms);
	          }
	        },
	        'updated:smileys': function updatedSmileys(data) {
	          var smileys = _.keyBy(_.keyBy(data, 'file'), 'shortcut');
	          _this2.set({ smileys: smileys });
	        },
	        'welcome-select-people': function welcomeSelectPeople(jid) {
	          _this2._selectPeople(jid);
	        },
	        'welcome-unselect-people': function welcomeUnselectPeople(jid) {
	          _this2._unselectPeople(jid);
	        },
	        'welcome-select-rooms': function welcomeSelectRooms(jid) {
	          _this2._selectRooms(jid);
	        },
	        'welcome-unselect-rooms': function welcomeUnselectRooms(jid) {
	          _this2._unselectRooms(jid);
	        },
	        'welcome-change-message': function welcomeChangeMessage(welcome_message) {
	          _this2._changeWelcomeMessage(welcome_message);
	        },
	        'smiley-chosen': function smileyChosen(data) {
	          _this2.handleSmileyChosen(data);
	        },
	        'reset-new-forced-caret-position': function resetNewForcedCaretPosition() {
	          _this2.set('new_forced_caret_position', 0);
	        },
	        'welcome-is-message-too-long': function welcomeIsMessageTooLong(data) {
	          _this2.set('is_welcome_message_too_long', data);
	        },
	        'welcome-change-current-step': function welcomeChangeCurrentStep(data) {
	          _this2.set('current_step', data);
	        },
	        'welcome-clear-people-selection': function welcomeClearPeopleSelection() {
	          _this2.set('selected_people', []);
	        },
	        'welcome-clear-rooms-selection': function welcomeClearRoomsSelection() {
	          _this2.set('selected_rooms', []);
	        }
	      });
	    }
	  }, {
	    key: '_handleRoster',
	    value: function _handleRoster() {
	      var _this3 = this;
	
	      var roster = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var people = this.data.people,
	          currentUserJid = this.data.current_user_jid,
	          maxDisplayedPeople = _app_config2.default.welcome_dialog.max_displayed_people;
	
	      if (_.isEmpty(roster)) {
	        roster = _application_store2.default.get('roster');
	      }
	
	      if (_.size(people) < maxDisplayedPeople && currentUserJid !== '') {
	
	        _.each(roster, function (value, key) {
	          if (_.size(people) < maxDisplayedPeople && currentUserJid !== key && !people[key]) {
	            people[key] = {};
	
	            _app_dispatcher2.default.dispatch('request-profile', key, function (response) {
	              people[key] = response.query;
	              people[key].jid = roster[key].jid;
	              people[key].id = roster[key].id;
	              people[key].presence = roster[key].presence;
	              _this3.set({
	                people: people
	              });
	            });
	          }
	        });
	      }
	      this.set({
	        roster: roster
	      });
	    }
	  }, {
	    key: '_handleAllRooms',
	    value: function _handleAllRooms() {
	      var _this4 = this;
	
	      var allRooms = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var rooms = this.data.rooms,
	          maxDisplayedRooms = _app_config2.default.welcome_dialog.max_displayed_rooms;
	
	      if (_.isEmpty(allRooms)) {
	        allRooms = _application_store2.default.get('allRooms');
	      }
	
	      if (_.size(rooms) < maxDisplayedRooms) {
	
	        _.each(allRooms, function (value, key) {
	          if (_.size(rooms) < maxDisplayedRooms && allRooms[key].privacy === 'public' && !rooms[key]) {
	            rooms[key] = {};
	
	            _app_dispatcher2.default.dispatch('fetch-room', key, function (nul, room) {
	              if (room) {
	                rooms[key].jid = room.jid;
	                rooms[key].name = room.name;
	                rooms[key].topic = room.topic;
	                rooms[key].privacy = room.privacy;
	                rooms[key].avatar_url = room.avatar_url;
	                _this4.set({
	                  rooms: rooms
	                });
	              }
	            });
	
	            _dal2.default.fetchParticipants(allRooms[key].id).then(function (response) {
	              rooms[key].participants_fetched = [];
	              _.each(response.participants, function (value1, key1) {
	                rooms[key].participants_fetched.push(value1.xmpp_jid);
	              });
	              _this4.set({
	                rooms: rooms
	              });
	            });
	          }
	        });
	      }
	    }
	  }, {
	    key: 'handleSmileyChosen',
	    value: function handleSmileyChosen(data) {
	      var welcome_message = this.data.welcome_message + data.shortcut + ' ';
	      this.set({
	        welcome_message: welcome_message,
	        new_forced_caret_position: welcome_message.length
	      });
	    }
	  }, {
	    key: '_selectPeople',
	    value: function _selectPeople(jid) {
	      var selectedPeople = this.get('selected_people');
	
	      if (selectedPeople.indexOf(jid) === -1) {
	        selectedPeople.push(jid);
	        this.set({
	          selected_people: selectedPeople
	        });
	      }
	
	      if (this.data.is_first_selection === true) {
	        this.set({
	          is_first_selection: false
	        });
	      }
	    }
	  }, {
	    key: '_unselectPeople',
	    value: function _unselectPeople(jid) {
	      var selectedPeople = this.get('selected_people');
	
	      if (selectedPeople.indexOf(jid) !== -1) {
	        this.set({
	          selected_people: selectedPeople.filter(function (value) {
	            return value !== jid;
	          })
	        });
	      }
	    }
	  }, {
	    key: '_selectRooms',
	    value: function _selectRooms(jid) {
	      var selectedRooms = this.get('selected_rooms');
	
	      if (selectedRooms.indexOf(jid) === -1) {
	        selectedRooms.push(jid);
	        this.set({
	          selected_rooms: selectedRooms
	        });
	      }
	    }
	  }, {
	    key: '_unselectRooms',
	    value: function _unselectRooms(jid) {
	      var selectedRooms = this.get('selected_rooms');
	
	      if (selectedRooms.indexOf(jid) !== -1) {
	        this.set({
	          selected_rooms: selectedRooms.filter(function (value) {
	            return value !== jid;
	          })
	        });
	      }
	    }
	  }, {
	    key: '_changeWelcomeMessage',
	    value: function _changeWelcomeMessage(message) {
	      this.set({
	        welcome_message: message
	      });
	    }
	  }]);
	  return WelcomeStore;
	}(_store2.default);
	
	exports.default = new WelcomeStore();
	module.exports = exports['default'];

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _welcome_actions = __webpack_require__(458);
	
	var _welcome_actions2 = _interopRequireDefault(_welcome_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'WelcomePeopleItem',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    if (this.props.item_index === 0 && this.props.is_first_selection) {
	      this.selectItem(this.props.jid);
	    }
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      key: '',
	      jid: '',
	      name: '',
	      title: '',
	      user_id: null,
	      item_index: 0,
	      is_selected: false,
	      photo_url: '',
	      presence_show: ''
	    };
	  },
	
	  propTypes: {
	    key: React.PropTypes.string.isRequired,
	    jid: React.PropTypes.string.isRequired,
	    name: React.PropTypes.string.isRequired,
	    title: React.PropTypes.string,
	    user_id: React.PropTypes.oneOfType([React.PropTypes.number, React.PropTypes.string]).isRequired,
	    item_index: React.PropTypes.number.isRequired,
	    is_selected: React.PropTypes.bool.isRequired,
	    photo_url: React.PropTypes.string.isRequired,
	    presence_show: React.PropTypes.string.isRequired
	  },
	
	  _onClick: function _onClick() {
	    var jid = this.props.jid;
	
	    if (this.props.is_selected) {
	      this.unselectItem(jid);
	    } else {
	      this.selectItem(jid);
	    }
	  },
	
	  selectItem: function selectItem(jid) {
	    _welcome_actions2.default.selectPeopleItem(jid);
	  },
	
	  unselectItem: function unselectItem(jid) {
	    _welcome_actions2.default.unselectPeopleItem(jid);
	  },
	
	  _getIcon: function _getIcon() {
	    return React.createElement(_person_avatar2.default, {
	      avatar_url: this.props.photo_url,
	      presence: this.props.presence_show,
	      size: 'medium',
	      uid: this.props.user_id,
	      active: true });
	  },
	
	  render: function render() {
	
	    var classes = (0, _classnames2.default)({
	      'hc-welcome-person-item': true,
	      'selected': this.props.is_selected
	    }),
	        icon = this._getIcon(),
	        name = this.props.name,
	        job_title = this.props.title;
	
	    return React.createElement(
	      'div',
	      { className: classes, onClick: this._onClick },
	      React.createElement(
	        'div',
	        { className: 'hc-welcome-person-icon' },
	        icon
	      ),
	      React.createElement(
	        'div',
	        { className: 'hc-welcome-person-info hc-welcome-person-info-ellipsis' },
	        React.createElement(
	          'span',
	          { className: 'hc-welcome-person-name' },
	          name
	        ),
	        React.createElement('br', null),
	        React.createElement(
	          'span',
	          { className: 'hc-welcome-person-job-title' },
	          job_title
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _welcome_store = __webpack_require__(456);
	
	var _welcome_store2 = _interopRequireDefault(_welcome_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  dialogRendered: function dialogRendered() {
	    _app_dispatcher2.default.dispatch('welcome-init');
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.welcome.dialog.render'
	    });
	  },
	
	  selectPeopleItem: function selectPeopleItem(jid) {
	    _app_dispatcher2.default.dispatch('welcome-select-people', jid);
	  },
	
	  unselectPeopleItem: function unselectPeopleItem(jid) {
	    _app_dispatcher2.default.dispatch('welcome-unselect-people', jid);
	  },
	
	  selectRoomsItem: function selectRoomsItem(jid) {
	    _app_dispatcher2.default.dispatch('welcome-select-rooms', jid);
	  },
	
	  unselectRoomsItem: function unselectRoomsItem(jid) {
	    _app_dispatcher2.default.dispatch('welcome-unselect-rooms', jid);
	  },
	
	  changeWelcomeMessage: function changeWelcomeMessage(welcome_message) {
	    _app_dispatcher2.default.dispatch('welcome-change-message', welcome_message);
	  },
	
	  createChats: function createChats(data) {
	    var welcomeMessage = _welcome_store2.default.get('welcome_message');
	
	    data.source = "welcome_dialog";
	    _analytics_dispatcher2.default.dispatch('analytics-open-room', data);
	
	    switch (true) {
	      case welcomeMessage === '':
	        _analytics_dispatcher2.default.dispatch("analytics-event", {
	          name: 'hipchat.client.welcome.dialog.message.skip',
	          properties: {
	            step: 'message',
	            message: welcomeMessage
	          }
	        });
	        break;
	      case welcomeMessage !== '':
	        _analytics_dispatcher2.default.dispatch("analytics-event", {
	          name: 'hipchat.client.welcome.dialog.message.finish',
	          properties: {
	            step: 'message',
	            message: welcomeMessage
	          }
	        });
	        break;
	    }
	
	    _app_dispatcher2.default.dispatch('set-multiple-routes', data);
	  },
	
	  closeDialog: function closeDialog() {
	    _app_dispatcher2.default.dispatch('hide-modal-dialog');
	  },
	
	  skipDialog: function skipDialog() {
	    _app_dispatcher2.default.dispatch('hide-modal-dialog');
	    _analytics_dispatcher2.default.dispatch("analytics-event", {
	      name: 'hipchat.client.welcome.dialog.welcome.skip',
	      properties: {
	        step: 'welcome'
	      }
	    });
	  },
	
	  resetNewForcedCaretPosition: function resetNewForcedCaretPosition() {
	    _app_dispatcher2.default.dispatch('reset-new-forced-caret-position');
	  },
	
	  toggleTooltip: function toggleTooltip(data) {
	    _app_dispatcher2.default.dispatch('toggle-tooltip', data);
	  },
	  setIsWelcomeMessageTooLong: function setIsWelcomeMessageTooLong(data) {
	    _app_dispatcher2.default.dispatch('welcome-is-message-too-long', data);
	  },
	  nextStep: function nextStep(data) {
	    var currentStep = _welcome_store2.default.get('current_step');
	
	    switch (currentStep) {
	      case 'welcome':
	        _analytics_dispatcher2.default.dispatch("analytics-event", {
	          name: 'hipchat.client.welcome.dialog.welcome.start',
	          properties: {
	            step: currentStep
	          }
	        });
	        break;
	      case 'people':
	        _analytics_dispatcher2.default.dispatch("analytics-event", {
	          name: 'hipchat.client.welcome.dialog.people.next',
	          properties: {
	            step: currentStep,
	            selected: _welcome_store2.default.get('selected_people').length
	          }
	        });
	        break;
	      case 'rooms':
	        _analytics_dispatcher2.default.dispatch("analytics-event", {
	          name: 'hipchat.client.welcome.dialog.rooms.next',
	          properties: {
	            step: currentStep,
	            selected: _welcome_store2.default.get('selected_rooms').length
	          }
	        });
	        break;
	    }
	
	    _app_dispatcher2.default.dispatch('welcome-change-current-step', data);
	  },
	  skipThisStep: function skipThisStep(data) {
	    var currentStep = _welcome_store2.default.get('current_step');
	
	    switch (currentStep) {
	      case 'people':
	        _analytics_dispatcher2.default.dispatch("analytics-event", {
	          name: 'hipchat.client.welcome.dialog.people.skip',
	          properties: {
	            step: currentStep
	          }
	        });
	        break;
	      case 'rooms':
	        _analytics_dispatcher2.default.dispatch("analytics-event", {
	          name: 'hipchat.client.welcome.dialog.rooms.skip',
	          properties: {
	            step: currentStep
	          }
	        });
	        break;
	    }
	
	    _app_dispatcher2.default.dispatch('welcome-change-current-step', data);
	  },
	  sendMessage: function sendMessage(data) {
	    _app_dispatcher2.default.dispatch('send-message', data);
	    _analytics_dispatcher2.default.dispatch('analytics-send-message', data);
	  },
	  clearPeopleSelection: function clearPeopleSelection() {
	    _app_dispatcher2.default.dispatch('welcome-clear-people-selection');
	  },
	  clearRoomsSelection: function clearRoomsSelection() {
	    _app_dispatcher2.default.dispatch('welcome-clear-rooms-selection');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _welcome_actions = __webpack_require__(458);
	
	var _welcome_actions2 = _interopRequireDefault(_welcome_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'WelcomeRoomsItem',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      key: '',
	      jid: '',
	      name: '',
	      topic: '',
	      privacy: '',
	      type: '',
	      is_selected: false,
	      avatar_url: '',
	      all_participants: [],
	      roster: {},
	      current_user_jid: '',
	      presence_show: '',
	      max_amount_of_people_icons: null
	    };
	  },
	
	  propTypes: {
	    key: React.PropTypes.string.isRequired,
	    jid: React.PropTypes.string.isRequired,
	    name: React.PropTypes.string.isRequired,
	    topic: React.PropTypes.string,
	    privacy: React.PropTypes.string.isRequired,
	    type: React.PropTypes.string.isRequired,
	    is_selected: React.PropTypes.bool.isRequired,
	    avatar_url: React.PropTypes.string.isRequired,
	    all_participants: React.PropTypes.array.isRequired,
	    roster: React.PropTypes.object.isRequired,
	    current_user_jid: React.PropTypes.string.isRequired,
	    presence_show: React.PropTypes.string.isRequired,
	    max_amount_of_people_icons: React.PropTypes.number.isRequired
	  },
	
	  _onClick: function _onClick() {
	    var jid = this.props.jid;
	
	    if (this.props.is_selected) {
	      this.unselectItem(jid);
	    } else {
	      this.selectItem(jid);
	    }
	  },
	
	  selectItem: function selectItem(jid) {
	    _welcome_actions2.default.selectRoomsItem(jid);
	  },
	
	  unselectItem: function unselectItem(jid) {
	    _welcome_actions2.default.unselectRoomsItem(jid);
	  },
	
	  _getIcon: function _getIcon() {
	    var icon = void 0;
	
	    if (this.props.type === 'groupchat' && this.props.avatar_url === '') {
	      icon = React.createElement('span', { className: 'aui-icon hipchat-icon-small icon-' + this.props.privacy });
	    } else {
	      icon = React.createElement(_person_avatar2.default, {
	        avatar_url: this.props.avatar_url,
	        show_presence: false,
	        size: 'medium' });
	    }
	
	    return icon;
	  },
	
	  _getParticipantsIcon: function _getParticipantsIcon() {
	    var _this = this;
	
	    var icons = [],
	        participants = this.props.all_participants;
	
	    if (participants.indexOf(this.props.current_user_jid) > -1) {
	      participants.splice(participants.indexOf(this.props.current_user_jid), 1);
	    }
	
	    participants.forEach(function (participantJid) {
	      if (icons.length < _this.props.max_amount_of_people_icons && participantJid in _this.props.roster) {
	
	        icons.push(React.createElement(_person_avatar2.default, {
	          key: _this.props.roster[participantJid].jid,
	          avatar_url: _this.props.roster[participantJid].photo_url,
	          show_presence: false,
	          size: 'small' }));
	      }
	    });
	
	    return icons;
	  },
	
	  render: function render() {
	
	    var classes = (0, _classnames2.default)({
	      'hc-welcome-room-item': true,
	      'selected': this.props.is_selected
	    }),
	        name = this.props.name,
	        icon = this._getIcon(),
	        participants_icons = this.props.all_participants ? this._getParticipantsIcon() : [],
	        topic = this.props.topic;
	
	    return React.createElement(
	      'div',
	      { className: classes, onClick: this._onClick },
	      React.createElement(
	        'div',
	        { className: 'hc-welcome-room-icon' },
	        icon
	      ),
	      React.createElement(
	        'div',
	        { className: 'hc-welcome-room-info hc-welcome-room-info-ellipsis' },
	        React.createElement(
	          'span',
	          { className: 'hc-welcome-room-name' },
	          name
	        ),
	        React.createElement('br', null),
	        React.createElement(
	          'span',
	          { className: 'hc-welcome-room-topic' },
	          topic
	        )
	      ),
	      React.createElement(
	        'div',
	        { className: 'hc-welcome-room-participants' },
	        participants_icons
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _smiley_selector = __webpack_require__(461);
	
	var _smiley_selector2 = _interopRequireDefault(_smiley_selector);
	
	var _upload_preview = __webpack_require__(463);
	
	var _upload_preview2 = _interopRequireDefault(_upload_preview);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'Tooltip',
	
	  propTypes: {
	    type: React.PropTypes.oneOf(['upload_preview', 'smiley_selector']).isRequired
	  },
	
	  componentDidMount: function componentDidMount() {
	    var _this = this;
	
	    _app_dispatcher2.default.register({
	      'toggle-tooltip': this._onToggle,
	      'close-tooltip': this._onClose,
	      'open-tooltip': this._onOpen
	    });
	    this.toggle = _.bind(function (e) {
	      if (!ReactDOM.findDOMNode(_this).parentNode.contains(e.target)) {
	        _this._onToggle({ type: _this.props.type });
	      }
	    });
	    this.outside_click_dismiss = this.props.type === 'smiley_selector';
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var _this2 = this;
	
	    var elem = ReactDOM.findDOMNode(this);
	    document.removeEventListener('click', this.toggle);
	    _app_dispatcher2.default.unregister({
	      'toggle-tooltip': this._onToggle,
	      'close-tooltip': this._onClose,
	      'open-tooltip': this._onOpen
	    });
	    [].map.call(elem.querySelectorAll('.file-preview'), function (element) {
	      return element;
	    }).forEach(function (preview) {
	      preview.removeEventListener('load', _this2._positionTooltip);
	    });
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.is_visible) {
	      this._positionTooltip();
	    }
	  },
	  getInitialState: function getInitialState() {
	    return {
	      is_visible: false
	    };
	  },
	  _getToolTip: function _getToolTip(type) {
	    var tooltip_types = {
	      smiley_selector: _smiley_selector2.default,
	      upload_preview: _upload_preview2.default
	    };
	
	    return tooltip_types[type];
	  },
	  render: function render() {
	
	    var ToolTip = this._getToolTip(this.props.type);
	
	    return React.createElement(
	      'div',
	      { className: 'hc-tooltip ' + (this.state.is_visible ? '' : 'hidden') },
	      React.createElement(
	        'div',
	        { className: 'hc-tooltip-content' },
	        React.createElement(ToolTip, { data: this.state.data })
	      ),
	      React.createElement('div', { className: 'aui-inline-dialog-arrow arrow aui-css-arrow' })
	    );
	  },
	  _onClose: function _onClose(args) {
	    if (!this.isMounted()) {
	      return;
	    }
	    if (args.type === this.props.type) {
	      if (this.outside_click_dismiss) {
	        document.removeEventListener('click', this.toggle);
	      }
	      this.setState({
	        is_visible: false
	      });
	    }
	    this._resetArrow();
	  },
	  _onOpen: function _onOpen(args) {
	    if (args.type === this.props.type) {
	      if (this.outside_click_dismiss) {
	        document.addEventListener('click', this.toggle);
	      }
	      this.setState({
	        is_visible: true,
	        data: args.data
	      });
	    }
	  },
	  _onToggle: function _onToggle(args) {
	    if (this.state.is_visible) {
	      this._onClose(args);
	    } else {
	      this._onOpen(args);
	    }
	  },
	  _resetArrow: function _resetArrow() {
	    ReactDOM.findDOMNode(this).querySelector('.arrow').classList.remove('right');
	  },
	  _positionTooltip: function _positionTooltip() {
	    var _this3 = this;
	
	    var elem = ReactDOM.findDOMNode(this),
	        parent = elem.parentElement,
	        bottom = parent.offsetHeight + 8,
	        left = Math.floor(-elem.offsetWidth / 2 + parent.offsetWidth / 2);
	    elem.style.bottom = bottom + 'px';
	    elem.style.left = left + 'px';
	
	    if (elem.getBoundingClientRect().right > window.innerWidth) {
	      // Tooltip extends beyond right side of window
	      elem.style.left = elem.offsetLeft - 8 - (elem.getBoundingClientRect().right - window.innerWidth) + 'px';
	      elem.querySelector('.arrow').classList.add('right');
	    }
	
	    [].map.call(elem.querySelectorAll('.file-preview'), function (element) {
	      return element;
	    }).forEach(function (preview) {
	      preview.addEventListener('load', _this3._positionTooltip);
	    });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var TooltipActions = __webpack_require__(298),
	    TooltipStrings = __webpack_require__(462),
	    emoticons = __webpack_require__(110);
	
	module.exports = React.createClass({
	
	  displayName: "TooltipTypeSmileySelector",
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      data: {
	        smileys: {},
	        user_is_admin: false
	      }
	    };
	  },
	
	  render: function render() {
	    var _this = this;
	
	    var custom_link;
	    if (this.props.data.user_is_admin) {
	      custom_link = React.createElement(
	        'div',
	        { className: 'smiley-custom-link' },
	        React.createElement(
	          'a',
	          { target: '_blank', href: 'https://' + this.props.data.web_server + '/admin/emoticons', onClick: this._onCustomClick },
	          TooltipStrings.custom_emoticon_link
	        )
	      );
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'smileys-selection' },
	      _.map(this.props.data.smileys, function (smiley) {
	        return React.createElement('span', { key: smiley.shortcut, onClick: _this._onSmileyClick, 'data-shortcut': smiley.shortcut, dangerouslySetInnerHTML: { __html: emoticons.render(smiley.shortcut === '>:-(' ? _.escape(smiley.shortcut) : smiley.shortcut) } });
	      }),
	      React.createElement('div', { className: 'clear' }),
	      React.createElement(
	        'div',
	        { className: this.props.data.user_is_admin ? "more-emoticons-link-admin" : "more-emoticons-link" },
	        React.createElement(
	          'a',
	          { target: '_blank', href: 'https://' + this.props.data.web_server + '/emoticons', onClick: this._onMoreClick },
	          TooltipStrings.emoticon_more_link
	        )
	      ),
	      custom_link
	    );
	  },
	
	  _onSmileyClick: function _onSmileyClick(e) {
	    TooltipActions.smileyChosen({ shortcut: e.currentTarget.getAttribute('data-shortcut') });
	  },
	
	  _onMoreClick: function _onMoreClick() {
	    TooltipActions.moreEmoticonsChosen();
	  },
	
	  _onCustomClick: function _onCustomClick() {
	    TooltipActions.customEmoticonsChosen();
	  }
	});

/***/ },
/* 462 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  emoticon_more_link: "More",
	  custom_emoticon_link: "Custom",
	  admin: "Room Admin",
	  status: "Status:",
	  message: "Message:"
	};
	module.exports = exports['default'];

/***/ },
/* 463 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = React.createClass({
	
	  displayName: "TooltipTypeUploadPreview",
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      data: {
	        file: {
	          src: '',
	          file_type: ''
	        }
	      }
	    };
	  },
	
	  render: function render() {
	    var previewMarkup = {
	      image: React.createElement('img', { className: 'file-preview', src: this.props.data.file.src_processed }),
	      text: React.createElement('iframe', { className: 'file-preview', src: this.props.data.file.src }),
	      video: React.createElement('video', { className: 'file-preview', src: this.props.data.file.src, autoPlay: true, muted: true }),
	      audio: React.createElement('audio', { className: 'file-preview', src: this.props.data.file.src, controls: true })
	    };
	
	    return previewMarkup[this.props.data.file.file_type] || React.createElement('div', null);
	  }
	
	});

/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ModalDialogVisibilityMixin = __webpack_require__(342);
	var DialogActions = __webpack_require__(95);
	
	module.exports = React.createClass({
	
	  displayName: "ModalDialogBackdrop",
	
	  mixins: [ModalDialogVisibilityMixin],
	
	  componentDidMount: function componentDidMount() {
	    document.querySelector("body").addEventListener('keydown', this._onKeydown);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    document.querySelector("body").removeEventListener('keydown', this._onKeydown);
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      btnLoading: false,
	      bgDismiss: true
	    };
	  },
	
	  _onKeydown: function _onKeydown(e) {
	    var intKey = window.Event ? e.which : e.keyCode;
	    if (intKey === 27 && !this.props.btnLoading) {
	      this.close();
	    }
	  },
	
	  _onClick: function _onClick() {
	    if (!this.props.btnLoading && this.props.bgDismiss) {
	      this.close();
	    }
	  },
	
	  close: function close() {
	    DialogActions.closeDialog();
	  },
	
	  render: function render() {
	    return React.createElement("div", { className: "aui-blanket",
	      "aria-hidden": !this.state.dialogVisible,
	      tabIndex: "0",
	      onClick: this._onClick });
	  }
	});

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _inline_dialog_store = __webpack_require__(278);
	
	var _inline_dialog_store2 = _interopRequireDefault(_inline_dialog_store);
	
	var _user_status_message_form = __webpack_require__(466);
	
	var _user_status_message_form2 = _interopRequireDefault(_user_status_message_form);
	
	var _connection_status_message = __webpack_require__(468);
	
	var _connection_status_message2 = _interopRequireDefault(_connection_status_message);
	
	var _guest_access_information = __webpack_require__(469);
	
	var _guest_access_information2 = _interopRequireDefault(_guest_access_information);
	
	var _add_integrations_discover = __webpack_require__(471);
	
	var _add_integrations_discover2 = _interopRequireDefault(_add_integrations_discover);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "InlineDialogContainer",
	
	  componentDidMount: function componentDidMount() {
	    _inline_dialog_store2.default.on('change', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _inline_dialog_store2.default.off('change', this._onChange);
	  },
	
	  getInitialState: function getInitialState() {
	    return _inline_dialog_store2.default.getAll();
	  },
	
	  _onChange: function _onChange() {
	    this.setState(_inline_dialog_store2.default.getAll());
	  },
	
	  _getDialog: function _getDialog() {
	    var currentDialogId = this.state.activeDialog;
	    var currentDialog = false;
	
	    if (currentDialogId) {
	      switch (currentDialogId) {
	
	        case "user-status-message-inline-dialog":
	          currentDialog = React.createElement(_user_status_message_form2.default, this.state.dialogData);
	          break;
	
	        case "connection-status-message-inline-dialog":
	          currentDialog = React.createElement(_connection_status_message2.default, this.state.dialogData);
	          break;
	
	        case "guest-access-information-inline-dialog":
	          currentDialog = React.createElement(_guest_access_information2.default, this.state.dialogData);
	          break;
	
	        case "add-integrations-help-dialog":
	          currentDialog = React.createElement(_add_integrations_discover2.default, this.state.dialogData);
	          break;
	      }
	    }
	
	    return currentDialog;
	  },
	
	  _isDialogInvisible: function _isDialogInvisible(dialogId) {
	    return this.state.activeDialog !== dialogId;
	  },
	
	  render: function render() {
	
	    var classes = (0, _classnames2.default)({
	      'banner-shown': this.state.bannerShown
	    });
	
	    var dialog = this._getDialog();
	
	    return React.createElement(
	      "div",
	      { className: classes },
	      dialog
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _inline_dialog = __webpack_require__(467);
	
	var _inline_dialog2 = _interopRequireDefault(_inline_dialog);
	
	var _presenceIcon = __webpack_require__(311);
	
	var _presenceIcon2 = _interopRequireDefault(_presenceIcon);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'UserStatusMessageForm',
	
	  getInitialState: function getInitialState() {
	    return {
	      text: this.props.status,
	      is_status_updated: false
	    };
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      visible: false
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    _app_dispatcher2.default.register('position-app-header-dialogs', this._positionDialog);
	    this._positionDialog();
	    this._focusAndSelect();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._positionDialog();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _app_dispatcher2.default.unregister('position-app-header-dialogs', this._positionDialog);
	
	    if (!this.state.is_status_updated) {
	      _current_user_actions2.default.changeStatus({
	        show: this.props.show,
	        status: '',
	        type: 'status'
	      });
	    }
	  },
	
	  _positionDialog: function _positionDialog() {
	    var anchor = this.props.anchor,
	        node = ReactDOM.findDOMNode(this),
	        top;
	
	    if (anchor) {
	      _.delay(function () {
	        top = anchor.getBoundingClientRect().bottom + 5;
	        $(node).css({
	          top: top + "px",
	          display: 'block'
	        });
	      }, _app_config2.default.notification_banner_slide);
	    }
	  },
	
	  _focusAndSelect: function _focusAndSelect() {
	    var input = this.refs.input;
	
	    // Using `_.delay` here as this component is set to 'display:none' initially,
	    // so wait until after it is revealed in `_positionDialog`.
	    _.delay(function () {
	      input.focus();
	      input.select();
	    }, _app_config2.default.notification_banner_slide);
	  },
	
	  _onSubmit: function _onSubmit(e) {
	    var _this = this;
	
	    e.preventDefault();
	    this.setState({ is_status_updated: true }, function () {
	      _current_user_actions2.default.changeStatus({
	        show: _this.props.show,
	        status: _this.state.text,
	        type: 'status'
	      });
	      _inline_dialog_actions2.default.hideInlineDialog();
	    });
	  },
	
	  render: function render() {
	    return React.createElement(
	      _inline_dialog2.default,
	      { dialogId: 'userStatusMessage' },
	      React.createElement(
	        'form',
	        { id: 'userStatusForm', className: 'aui aui-group', onSubmit: this._onSubmit },
	        React.createElement(
	          'div',
	          { className: 'aui-item status-icon' },
	          React.createElement(_presenceIcon2.default, { presence: this.props.show, uid: this.props.current_user_id })
	        ),
	        React.createElement(
	          'div',
	          { className: 'aui-item status-message' },
	          React.createElement('input', {
	            type: 'text',
	            className: 'text',
	            placeholder: 'Set your status',
	            maxLength: _app_config2.default.max_presence_text_length,
	            name: 'status-message',
	            value: this.state.text,
	            ref: 'input',
	            onChange: this._onChange })
	        ),
	        React.createElement(
	          'div',
	          { className: 'aui-item' },
	          React.createElement(
	            'button',
	            { className: 'aui-button aui-button-small', type: 'submit' },
	            'OK'
	          )
	        )
	      )
	    );
	  },
	
	  _onChange: function _onChange(e) {
	    this.setState({ text: e.target.value });
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var cx = __webpack_require__(313);
	
	module.exports = React.createClass({
	
	  displayName: "InlineDialog",
	
	  propTypes: {
	    onShow: React.PropTypes.func
	  },
	
	  componentDidMount: function componentDidMount() {
	    if (!this.props.invisible) {
	      this.props.onShow();
	    }
	  },
	
	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    if (prevProps.invisible === this.props.invisible) {
	      return;
	    }
	
	    if (this.props.invisible) {
	      this.props.onHide();
	    } else {
	      this.props.onShow();
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    if (!this.props.invisible) {
	      this.props.onHide();
	    }
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      invisible: false,
	      dialogId: "dialog",
	      dialog_callout: false,
	      onShow: _.noop,
	      onHide: _.noop,
	      onMouseOver: _.noop,
	      arrowLocation: "top"
	    };
	  },
	
	  render: function render() {
	    var classes = cx({
	      "aui-inline-dialog": true,
	      "dialog-callout": this.props.dialog_callout
	    });
	
	    var arrowClasses = cx("aui-inline-dialog-arrow arrow aui-css-arrow", {
	      "aui-bottom-arrow": this.props.arrowLocation === 'bottom'
	    });
	
	    var dialogClasses = cx("aui-inline-dialog-contents", {
	      "hc-tooltip-helper": this.props.tooltip_helper
	    });
	
	    return React.createElement(
	      "div",
	      { className: classes, "aria-hidden": this.props.invisible ? "true" : "false", id: this.props.dialogId, onMouseOver: this.props.onMouseOver },
	      React.createElement(
	        "div",
	        { className: dialogClasses },
	        this.props.children,
	        React.createElement("div", { className: arrowClasses })
	      )
	    );
	  }
	});

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _inline_dialog = __webpack_require__(467);
	
	var _inline_dialog2 = _interopRequireDefault(_inline_dialog);
	
	var _connection_notification_strings = __webpack_require__(323);
	
	var _connection_notification_strings2 = _interopRequireDefault(_connection_notification_strings);
	
	var _connection_status_store = __webpack_require__(326);
	
	var _connection_status_store2 = _interopRequireDefault(_connection_status_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _connection = __webpack_require__(327);
	
	var _connection2 = _interopRequireDefault(_connection);
	
	var _network = __webpack_require__(328);
	
	var _network2 = _interopRequireDefault(_network);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'ConnectionStatusMessage',
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  componentDidMount: function componentDidMount() {
	    _configuration_store2.default.on(["change:feature_flags"], this._onChange);
	    _connection_status_store2.default.on(["change:connection_status", "change:reconnectingIn"], this._onChange);
	    _app_dispatcher2.default.register('position-app-header-dialogs', this._positionDialog);
	    this._positionDialog();
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _configuration_store2.default.off(["change:feature_flags"], this._onChange);
	    _connection_status_store2.default.off(["change:connection_status", "change:reconnectingIn"], this._onChange);
	    _app_dispatcher2.default.unregister('position-app-header-dialogs', this._positionDialog);
	  },
	  render: function render() {
	    var content = this._getContent();
	    return React.createElement(
	      _inline_dialog2.default,
	      { dialogId: 'connectionStatusMessage' },
	      content
	    );
	  },
	  _getContent: function _getContent() {
	    switch (this.props.status) {
	
	      case _connection2.default.RECONNECT_DELAY:
	        return React.createElement(
	          'div',
	          null,
	          React.createElement(
	            'p',
	            null,
	            _connection_notification_strings2.default.check_network
	          )
	        );
	
	      case _connection2.default.DISCONNECTED:
	        return React.createElement(
	          'div',
	          null,
	          this.state.isBTF ? false : React.createElement('p', { dangerouslySetInnerHTML: { __html: _connection_notification_strings2.default.unable_to_connect_hipchat(_app_config2.default.status_page_url) } })
	        );
	
	      case _network2.default.OFFLINE:
	        return React.createElement(
	          'div',
	          null,
	          React.createElement(
	            'p',
	            null,
	            _connection_notification_strings2.default.offline_status
	          )
	        );
	
	      default:
	        return React.createElement('span', null);
	    }
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _getState: function _getState() {
	    var reconnectSeconds = Math.round(_connection_status_store2.default.get('reconnectingIn') / 1000);
	    return {
	      isBTF: _.get(_configuration_store2.default.get('feature_flags'), 'btf', false),
	      reconnectSeconds: reconnectSeconds
	    };
	  },
	  _positionDialog: function _positionDialog() {
	    var anchor = this.props.anchor,
	        node = ReactDOM.findDOMNode(this),
	        top,
	        left;
	
	    if (anchor) {
	      _.delay(function () {
	        top = anchor.getBoundingClientRect().bottom + 5;
	        left = anchor.getBoundingClientRect().right - $(node).width();
	        $(node).css({
	          top: top + "px",
	          left: left + "px"
	        });
	      }, _app_config2.default.notification_banner_slide);
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _inline_dialog = __webpack_require__(467);
	
	var _inline_dialog2 = _interopRequireDefault(_inline_dialog);
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _guest_access_information_strings = __webpack_require__(470);
	
	var _guest_access_information_strings2 = _interopRequireDefault(_guest_access_information_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "GuestAccessInformation",
	  debouncedMouseOut: null,
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      visible: false
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    var _this = this;
	
	    _app_dispatcher2.default.register('position-app-header-dialogs', this._positionDialog);
	    this._positionDialog();
	
	    this.debouncedMouseOut = _.debounce(function (e) {
	      return _this._onMouseOut(e);
	    }, _app_config2.default.guest_access_information.mouseout_delay);
	    document.addEventListener('mouseout', this.debouncedMouseOut);
	
	    _.delay(function () {
	      _this._focusAndSelectInput();
	    }, _app_config2.default.guest_access_information.focus_and_select_delay);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._positionDialog();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _app_dispatcher2.default.unregister('position-app-header-dialogs', this._positionDialog);
	
	    document.removeEventListener('mouseout', this.debouncedMouseOut);
	    this.debouncedMouseOut.cancel();
	    this.debouncedMouseOut = null;
	  },
	
	  _positionDialog: function _positionDialog() {
	    var anchor = this.props.anchor,
	        node = ReactDOM.findDOMNode(this),
	        rect = void 0,
	        top = void 0,
	        left = void 0;
	
	    if (anchor) {
	      _.delay(function () {
	        rect = anchor.getBoundingClientRect();
	        top = rect.bottom + 5;
	        left = rect.left + rect.width / 2;
	        $(node).css({
	          top: top + 'px',
	          left: left + 'px',
	          display: 'block'
	        });
	      }, _app_config2.default.notification_banner_slide);
	    }
	  },
	
	  _onMouseOut: function _onMouseOut() {
	    _inline_dialog_actions2.default.hideInlineDialog();
	  },
	  _onMouseOver: function _onMouseOver() {
	    this.debouncedMouseOut.cancel();
	  },
	  _focusAndSelectInput: function _focusAndSelectInput() {
	    if (this.isMounted()) {
	      var input = ReactDOM.findDOMNode(this.refs.input);
	      input.focus();
	      input.setSelectionRange(0, input.value.length);
	    }
	  },
	
	
	  render: function render() {
	    var description = _guest_access_information_strings2.default.share_this_link_to_invite;
	
	    return React.createElement(
	      _inline_dialog2.default,
	      { dialogId: 'guestAccessInformation', onMouseOver: this._onMouseOver },
	      React.createElement(
	        'form',
	        { className: 'aui aui-group' },
	        React.createElement(
	          'div',
	          { className: 'aui-item guest-access-url' },
	          React.createElement('input', { type: 'text', className: 'text', value: this.props.guest_url, ref: 'input', readOnly: true }),
	          React.createElement(
	            'div',
	            { className: 'description' },
	            description
	          )
	        )
	      )
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 470 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  share_this_link_to_invite: "Share this link to invite a guest"
	};
	module.exports = exports['default'];

/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	var _inline_dialog = __webpack_require__(467);
	
	var _inline_dialog2 = _interopRequireDefault(_inline_dialog);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "AddIntegrationsDiscoverTooltip",
	
	  componentDidMount: function componentDidMount() {
	    $(window).on('resize', this._positionDialog);
	    this._positionDialog();
	    _app_dispatcher2.default.register('set-right-sidebar-visible-width-is-changing', this._closeDialog);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._positionDialog();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    $(window).off('resize', this._positionDialog);
	    _app_dispatcher2.default.unregister('set-right-sidebar-visible-width-is-changing', this._closeDialog);
	  },
	
	  _positionDialog: function _positionDialog() {
	    var anchor = this.props.anchor,
	        node = ReactDOM.findDOMNode(this),
	        rect = void 0,
	        bottom = void 0,
	        left = void 0;
	
	    if (anchor) {
	      _.delay(function () {
	        rect = anchor.getBoundingClientRect();
	        bottom = 45;
	        left = rect.left - rect.width / 2;
	        $(node).css({
	          bottom: bottom + 'px',
	          left: left + 'px',
	          display: 'block'
	        });
	      }, _app_config2.default.notification_banner_slide);
	    }
	  },
	
	  _closeDialog: function _closeDialog() {
	    _inline_dialog_actions2.default.hideInlineDialog();
	  },
	
	  render: function render() {
	    return React.createElement(
	      _inline_dialog2.default,
	      { dialogId: 'add-integrations-discover-tooltip', tooltip_helper: 'hc-tooltip-helper', arrowLocation: 'bottom' },
	      React.createElement(
	        'div',
	        { className: 'add-integrations-tooltip' },
	        React.createElement(
	          'div',
	          { className: 'add-integrations-tooltip-title' },
	          _integrations_strings2.default.install_integrations_tooltip_title
	        ),
	        React.createElement(
	          'p',
	          { className: 'add-integration-tooltip-content' },
	          _integrations_strings2.default.install_integrations_tooltip_content
	        ),
	        React.createElement(
	          'p',
	          null,
	          React.createElement(
	            'a',
	            { className: 'add-integration-tooltip-close', onClick: this._closeDialog },
	            _integrations_strings2.default.got_it
	          )
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _read_only_store = __webpack_require__(334);
	
	var _read_only_store2 = _interopRequireDefault(_read_only_store);
	
	var _read_only_content = __webpack_require__(473);
	
	var _read_only_content2 = _interopRequireDefault(_read_only_content);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'ReadOnlyContainer',
	
	  componentDidMount: function componentDidMount() {
	    _read_only_store2.default.on('change', this._onChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _read_only_store2.default.off('change', this._onChange);
	  },
	  getInitialState: function getInitialState() {
	    return _read_only_store2.default.getAll();
	  },
	  _onChange: function _onChange() {
	    this.setState(_read_only_store2.default.getAll());
	  },
	  _getContent: function _getContent() {
	    return React.createElement(_read_only_content2.default, this.state);
	  },
	  _getSpinner: function _getSpinner() {
	    return React.createElement(_spinner2.default, { size: 'large', spin: true });
	  },
	  render: function render() {
	    var _state = this.state;
	    var read_only_mode = _state.read_only_mode;
	    var is_dismissed = _state.is_dismissed;
	    var is_visible = _state.is_visible;
	    var is_fetching = _state.is_fetching;
	    var is_fetched = _state.is_fetched;
	
	
	    if (!read_only_mode || is_dismissed || !is_visible || !is_fetching && !is_fetched) {
	      return React.createElement('div', null);
	    }
	
	    var content = is_fetching ? this._getSpinner() : this._getContent();
	
	    return React.createElement(
	      'div',
	      { className: 'hc-read-only-container' },
	      React.createElement(
	        'div',
	        { className: 'hc-read-only-inner' },
	        content
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _markdown_link = __webpack_require__(474);
	
	var _markdown_link2 = _interopRequireDefault(_markdown_link);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'ReadOnlyContent',
	
	  _onDismiss: function _onDismiss() {
	    _app_actions2.default.dismissReadOnlyModal();
	  },
	  _getIcon: function _getIcon() {
	    return React.createElement('img', { src: this.props.icon_url });
	  },
	  _getDownloadButton: function _getDownloadButton() {
	    return React.createElement(
	      'div',
	      { className: 'button-wrapper' },
	      React.createElement(
	        'a',
	        { className: 'aui-button aui-button-primary', href: this.props.button_url, target: '_blank' },
	        this.props.button_text
	      )
	    );
	  },
	  render: function render() {
	    var icon = this.props.icon_url ? this._getIcon() : null;
	    var downloadBtn = this.props.button_url ? this._getDownloadButton() : null;
	
	    return React.createElement(
	      'div',
	      { className: 'hc-read-only-content' },
	      React.createElement(
	        'h3',
	        null,
	        this.props.title
	      ),
	      React.createElement(
	        'p',
	        null,
	        this.props.text
	      ),
	      icon,
	      downloadBtn,
	      React.createElement('hr', null),
	      React.createElement(
	        'p',
	        null,
	        this.props.continue_text
	      ),
	      React.createElement(
	        'div',
	        { className: 'button-wrapper' },
	        React.createElement(
	          'a',
	          { className: 'aui-button', onClick: this._onDismiss },
	          this.props.continue_button
	        )
	      ),
	      React.createElement(
	        'p',
	        { className: 'help' },
	        React.createElement(
	          _markdown_link2.default,
	          null,
	          this.props.questions_markdown
	        ),
	        React.createElement('br', null),
	        React.createElement(
	          _markdown_link2.default,
	          null,
	          this.props.contact_markdown
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 474 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var link_re = /(.*)\[(.*?)\]\((.*?)\)(.*)/;
	
	exports.default = React.createClass({
	  displayName: "markdown_link",
	  render: function render() {
	    var text = this.props.children || '';
	
	    if (!text.match(link_re)) {
	      return React.createElement(
	        "span",
	        null,
	        text
	      );
	    }
	
	    var pre = void 0,
	        post = void 0,
	        link = void 0;
	    text.replace(link_re, function (match, p1, p2, p3, p4) {
	      pre = p1;
	      link = React.createElement(
	        "a",
	        { href: p3, target: "_blank" },
	        p2
	      );
	      post = p4;
	    });
	
	    return React.createElement(
	      "span",
	      null,
	      pre,
	      link,
	      post
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _flags_store = __webpack_require__(476);
	
	var _flags_store2 = _interopRequireDefault(_flags_store);
	
	var _flag = __webpack_require__(477);
	
	var _flag2 = _interopRequireDefault(_flag);
	
	var _video_popup_blocked_flag = __webpack_require__(478);
	
	var _video_popup_blocked_flag2 = _interopRequireDefault(_video_popup_blocked_flag);
	
	var _incoming_call_flag = __webpack_require__(479);
	
	var _incoming_call_flag2 = _interopRequireDefault(_incoming_call_flag);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'FlagsContainer',
	
	  componentDidMount: function componentDidMount() {
	    _flags_store2.default.on('change', this._onChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _flags_store2.default.off('change', this._onChange);
	  },
	  getInitialState: function getInitialState() {
	    return _flags_store2.default.getAll();
	  },
	  _onChange: function _onChange() {
	    this.setState(_flags_store2.default.getAll());
	  },
	  _getFlag: function _getFlag(data, index) {
	    var flag = void 0;
	    switch (data.type) {
	      case 'video':
	        flag = React.createElement(_incoming_call_flag2.default, {
	          ref: 'incoming_call_flag',
	          flag_index: index,
	          sender: data.sender,
	          photo: data.photo,
	          message: data.message,
	          service: data.service,
	          key: index });
	        break;
	      case 'video_popup_blocked':
	        flag = React.createElement(_video_popup_blocked_flag2.default, {
	          title: data.title,
	          body: data.body,
	          close: data.close,
	          promise: data.promise,
	          key: index });
	        break;
	      default:
	        flag = React.createElement(_flag2.default, (0, _extends3.default)({
	          flag_index: index
	        }, data, {
	          key: index }));
	        break;
	    }
	    return flag;
	  },
	  render: function render() {
	    var _this = this;
	
	    return React.createElement(
	      'div',
	      { className: 'hc-flags-container' },
	      _.map(this.state.flags, function (flag) {
	        return _this._getFlag(flag, _.uniqueId());
	      })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Store = __webpack_require__(97);
	var dispatcher = __webpack_require__(9);
	
	var FlagsStore = function (_Store) {
	  (0, _inherits3.default)(FlagsStore, _Store);
	
	  function FlagsStore() {
	    (0, _classCallCheck3.default)(this, FlagsStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(FlagsStore).call(this));
	
	    _this.data = {
	      flags: []
	    };
	
	    _this.flag_defaults = {
	      type: 'info',
	      close: 'manual',
	      title: '',
	      body: null,
	      image_url: null,
	      link_url: null,
	      link_text: null,
	      onClose: null
	    };
	
	    _this.register_listeners();
	    return _this;
	  }
	
	  (0, _createClass3.default)(FlagsStore, [{
	    key: "register_listeners",
	    value: function register_listeners() {
	      var _this2 = this;
	
	      dispatcher.register({
	        'show-flag': function showFlag(flag_data) {
	          _this2.add_flag(flag_data);
	        },
	        'remove-flag': function removeFlag(flag_index) {
	          _this2.remove_flag(flag_index);
	        }
	      });
	    }
	  }, {
	    key: "add_flag",
	    value: function add_flag(flag_data) {
	      this.data.flags.unshift(_.defaults(flag_data, this.flag_defaults));
	      this.set('flags', this.data.flags);
	    }
	  }, {
	    key: "remove_flag",
	    value: function remove_flag(flag_index) {
	      var idx = _.findIndex(this.data.flags, { id: flag_index });
	      if (idx) {
	        flag_index = idx;
	      }
	      this.data.flags.splice(flag_index, 1);
	      this.set('flags', this.data.flags);
	    }
	  }]);
	  return FlagsStore;
	}(Store);
	
	module.exports = new FlagsStore();

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'Flag',
	
	  propTypes: {
	    type: React.PropTypes.oneOf(['info', 'success', 'warning', 'error']).isRequired,
	    close: React.PropTypes.oneOf(['manual', 'auto', 'never']).isRequired
	  },
	
	  _isCloseable: function _isCloseable() {
	    return this.props.close !== 'never';
	  },
	  _getCloseButton: function _getCloseButton() {
	    return this._isCloseable() ? React.createElement('span', { onClick: this.close, className: 'aui-icon hipchat-icon-small icon-close', role: 'button', tabIndex: '0' }) : undefined;
	  },
	  _getImage: function _getImage() {
	    if (!this.props.image_url) {
	      return null;
	    }
	    return React.createElement(
	      'p',
	      { className: 'image' },
	      React.createElement('img', { src: this.props.image_url })
	    );
	  },
	  _getAction: function _getAction() {
	    if (!this.props.link_url || !this.props.link_text) {
	      return null;
	    }
	    return React.createElement(
	      'ul',
	      { className: 'aui-nav-actions-list' },
	      React.createElement(
	        'li',
	        null,
	        React.createElement(
	          'a',
	          { href: this.props.link_url, target: '_blank' },
	          this.props.link_text
	        )
	      )
	    );
	  },
	  close: function close() {
	    var flag_index = this.props.flag_index;
	    if (this.isMounted()) {
	      $(ReactDOM.findDOMNode(this)).attr('aria-hidden', true);
	    }
	    if (typeof this.props.onClose === 'function') {
	      this.props.onClose();
	    }
	    _.delay(function () {
	      // Wait for animation to complete before removing flag
	      _flag_actions2.default.removeFlag(flag_index);
	    }, _app_config2.default.flag_close_animation_time);
	  },
	  render: function render() {
	    var _cx;
	
	    var classes = (0, _classnames2.default)((_cx = {
	      'hc-message': true
	    }, (0, _defineProperty3.default)(_cx, 'hc-message-' + this.props.type, true), (0, _defineProperty3.default)(_cx, this.props.type, true), (0, _defineProperty3.default)(_cx, 'closeable', this._isCloseable()), _cx));
	
	    if (this.props.close === 'auto') {
	      _.delay(this.close, this.props.delay || 2000);
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-flag', 'data-flag-index': this.props.flag_index, 'aria-hidden': 'false' },
	      React.createElement(
	        'div',
	        { className: classes },
	        this._getImage(),
	        React.createElement(
	          'p',
	          { className: 'title' },
	          React.createElement(
	            'strong',
	            null,
	            this.props.title
	          )
	        ),
	        typeof this.props.body === 'function' ? this.props.body() : this.props.body,
	        this._getAction(),
	        this._getCloseButton()
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _dialog_strings = __webpack_require__(203);
	
	var _dialog_strings2 = _interopRequireDefault(_dialog_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'Flag',
	
	  propTypes: {
	    close: React.PropTypes.oneOf(['manual', 'auto', 'never']).isRequired,
	    promise: React.PropTypes.func.isRequired
	  },
	
	  _getCloseButton: function _getCloseButton() {
	    return React.createElement('span', { onClick: this.close, className: 'aui-icon hipchat-icon-small icon-close', role: 'button', tabIndex: '0' });
	  },
	  close: function close() {
	    var flag_index = this.props.flag_index;
	    if (this.isMounted()) {
	      $(ReactDOM.findDOMNode(this)).attr('aria-hidden', true);
	    }
	    _.delay(function () {
	      // Wait for animation to complete before removing flag
	      _flag_actions2.default.removeFlag(flag_index);
	    }, _app_config2.default.flag_close_animation_time);
	  },
	  _executePromise: function _executePromise() {
	    var _this = this;
	
	    this.props.promise().then(function (video_window) {
	      if (video_window) {
	        _this.close();
	      }
	    });
	  },
	  render: function render() {
	    var classes = 'hc-message hc-message-' + this.props.type + ' hc-message-info closeable';
	    var closeBtn = this._getCloseButton();
	    if (this.props.close === 'auto') {
	      _.delay(this.close, 2000);
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-flag', 'data-flag-index': this.props.flag_index, 'aria-hidden': 'false' },
	      React.createElement(
	        'div',
	        { className: classes },
	        typeof this.props.body === 'function' ? this.props.body() : this.props.body,
	        closeBtn,
	        React.createElement('br', null),
	        React.createElement(
	          'a',
	          { onClick: this._executePromise },
	          _dialog_strings2.default.try_again
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	var _incoming_call_actions = __webpack_require__(480);
	
	var _incoming_call_actions2 = _interopRequireDefault(_incoming_call_actions);
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'IncomingCallFlag',
	
	  componentDidMount: function componentDidMount() {
	    var _this = this;
	
	    this.closing = false;
	    this.missed_call_timeout = setTimeout(function () {
	      _this._close();
	    }, _app_config2.default.missed_video_call_timeout - _app_config2.default.flag_close_animation_time);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    clearTimeout(this.missed_call_timeout);
	    this.missed_call_timeout = null;
	  },
	  _onAnswer: function _onAnswer() {
	    if (this.closing) {
	      return;
	    }
	    _incoming_call_actions2.default.answerCall(this.props.message, this.props.service);
	    this._close();
	  },
	  _onIgnore: function _onIgnore() {
	    if (this.closing) {
	      return;
	    }
	    _incoming_call_actions2.default.declineCall(this.props.message, this.props.service);
	    this._close();
	  },
	  _close: function _close() {
	    this.closing = true;
	    clearTimeout(this.missed_call_timeout);
	    if (this.isMounted()) {
	      ReactDOM.findDOMNode(this).setAttribute('aria-hidden', true);
	    }
	  },
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'hc-flag', 'data-flag-index': this.props.flag_index, 'aria-hidden': 'false' },
	      React.createElement(
	        'div',
	        { className: 'hc-message hc-message-video info' },
	        React.createElement(
	          'h6',
	          null,
	          'Incoming call'
	        ),
	        React.createElement(
	          'div',
	          { className: 'sender-container' },
	          React.createElement(_person_avatar2.default, { avatar_url: this.props.photo, size: 'large', show_presence: false }),
	          React.createElement(
	            'h3',
	            { className: 'sender' },
	            this.props.sender
	          )
	        ),
	        React.createElement(
	          'button',
	          {
	            ref: 'answer',
	            className: 'aui-button aui-button-primary',
	            onClick: this._onAnswer },
	          _video_call_strings2.default.answer
	        ),
	        React.createElement(
	          'button',
	          {
	            ref: 'ignore',
	            className: 'aui-button',
	            onClick: this._onIgnore },
	          _video_call_strings2.default.ignore
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  answerCall: function answerCall(data, service) {
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: 'hipchat.client.user.oto.video.answer',
	      properties: {
	        service: service
	      }
	    });
	    _app_dispatcher2.default.dispatch(service + '.answer-audio-video-call', data);
	  },
	
	  declineCall: function declineCall(data, service) {
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: 'hipchat.client.user.oto.video.decline',
	      properties: {
	        service: service
	      }
	    });
	    _app_dispatcher2.default.dispatch(service + '.decline-audio-video-call', data);
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _general_errors_store = __webpack_require__(482);
	
	var _general_errors_store2 = _interopRequireDefault(_general_errors_store);
	
	var _layout_store = __webpack_require__(483);
	
	var _layout_store2 = _interopRequireDefault(_layout_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _sidebar = __webpack_require__(484);
	
	var _sidebar2 = _interopRequireDefault(_sidebar);
	
	var _main_col = __webpack_require__(498);
	
	var _main_col2 = _interopRequireDefault(_main_col);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _layout_actions = __webpack_require__(266);
	
	var _layout_actions2 = _interopRequireDefault(_layout_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "MainBodyLayout",
	
	  getInitialState: function getInitialState() {
	    return this.getState();
	  },
	
	  getState: function getState() {
	    return {
	      errors: _general_errors_store2.default.get('errors'),
	      ready: _layout_store2.default.get('ready'),
	      leftColumnWidth: _preferences_store2.default.get('leftColumnWidth'),
	      leftColumnVisible: _preferences_store2.default.get('showNavigationSidebar')
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    _general_errors_store2.default.on('change:errors', this._onChange);
	    _layout_store2.default.on('change:ready', this._onChange);
	    _preferences_store2.default.on(['change:leftColumnWidth', 'change:showNavigationSidebar'], this._onChange);
	    this._resizeColumns(this.state.leftColumnWidth);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.leftColumnVisible) {
	      this._resizeColumns(this.state.leftColumnWidth);
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _general_errors_store2.default.off('change:errors', this._onChange);
	    _layout_store2.default.off('change:ready', this._onChange);
	    _preferences_store2.default.off(['change:leftColumnWidth', 'change:showNavigationSidebar'], this._onChange);
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this.getState());
	  },
	
	  _getSidebar: function _getSidebar() {
	    var retVal = null;
	    if (this.state.leftColumnVisible) {
	      retVal = React.createElement(
	        'div',
	        { className: 'hc-left-sidebar-col', ref: 'left_column' },
	        React.createElement(_sidebar2.default, null),
	        React.createElement('div', { className: 'resize-handle', onMouseDown: this._onResizeStart })
	      );
	    }
	    return retVal;
	  },
	
	  render: function render() {
	    var body,
	        sidebar = this._getSidebar();
	    body = React.createElement(
	      'div',
	      { className: 'hc-layout' },
	      sidebar,
	      React.createElement(_main_col2.default, { ref: 'main_column', is_guest: this.props.is_guest })
	    );
	
	    return body;
	  },
	
	  _resizeColumns: function _resizeColumns(width) {
	    if (this.state.ready && !this.state.errors.length) {
	      $('.hc-unread-scroller').width(width);
	      this.refs.left_column.style.width = width + 'px';
	    }
	  },
	
	  _onResizeStart: function _onResizeStart(e) {
	    e.preventDefault();
	    this.beginX = e.pageX;
	    this.beginWidth = this.state.leftColumnWidth;
	    document.addEventListener('mouseup', this._onResizeEnd);
	    document.addEventListener('mousemove', this._onHandleDrag);
	  },
	
	  _onHandleDrag: function _onHandleDrag(e) {
	    var diff = e.pageX - this.beginX;
	    if (this.beginWidth + diff >= _app_config2.default.column_width_limits['left'].min && this.beginWidth + diff <= _app_config2.default.column_width_limits['left'].max) {
	      var width = Math.floor(this.beginWidth) + Math.floor(diff);
	      this._resizeColumns(width);
	      this.setState({
	        leftColumnWidth: width
	      });
	    }
	  },
	
	
	  _onResizeEnd: function _onResizeEnd(e) {
	    e.preventDefault();
	    document.removeEventListener('mouseup', this._onResizeEnd);
	    document.removeEventListener('mousemove', this._onHandleDrag);
	    _layout_actions2.default.saveLeftColumnWidth(this.state.leftColumnWidth);
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Store = __webpack_require__(97),
	    AppDispatcher = __webpack_require__(9);
	
	var GeneralErrorsStore = function (_Store) {
	  (0, _inherits3.default)(GeneralErrorsStore, _Store);
	
	  function GeneralErrorsStore() {
	    (0, _classCallCheck3.default)(this, GeneralErrorsStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(GeneralErrorsStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(GeneralErrorsStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        errors: [],
	        web_server: ''
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      AppDispatcher.register({
	        "general-error": function generalError(error) {
	          var errors = _this2.data.errors;
	          errors.push(error);
	          _this2.set('errors', errors);
	        },
	        'updated:web_server': function updatedWeb_server(server) {
	          _this2.data.web_server = server;
	        }
	      });
	    }
	  }]);
	  return GeneralErrorsStore;
	}(Store);
	
	module.exports = new GeneralErrorsStore();

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LayoutStore = function (_Store) {
	  (0, _inherits3.default)(LayoutStore, _Store);
	
	  function LayoutStore() {
	    (0, _classCallCheck3.default)(this, LayoutStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(LayoutStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(LayoutStore, [{
	    key: "getDefaults",
	    value: function getDefaults() {
	      return {
	        ready: false,
	        active_chat: null,
	        search_opened: false,
	        rightSidebarVisibleWidthIsChanging: false
	      };
	    }
	  }, {
	    key: "registerListeners",
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        'app-state-ready': function appStateReady() {
	          _this2.set("ready", true);
	        },
	        'updated:active_chat': function updatedActive_chat(data) {
	          _this2.set("active_chat", data);
	        },
	        'set-right-sidebar-visible-width-is-changing': function setRightSidebarVisibleWidthIsChanging(changing) {
	          _this2.set("rightSidebarVisibleWidthIsChanging", changing);
	        },
	        'search-history': function searchHistory() {
	          _this2.set('search_opened', true);
	        },
	        'remove-search-nav-item': function removeSearchNavItem() {
	          _this2.set('search_opened', false);
	        }
	      });
	    }
	  }]);
	  return LayoutStore;
	}(_store2.default);
	
	module.exports = new LayoutStore();

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var RoomsNav = __webpack_require__(485),
	    PermissionsStore = __webpack_require__(269),
	    UnreadScroller = __webpack_require__(496);
	
	function getState() {
	  return {
	    can_create_room: PermissionsStore.canCreateRoom(),
	    can_invite_users: PermissionsStore.canInviteUsersToGroup()
	  };
	}
	
	module.exports = React.createClass({
	
	  displayName: "LeftSideBar",
	
	  getInitialState: function getInitialState() {
	    return getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    PermissionsStore.on('change', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    PermissionsStore.off('change', this._onChange);
	  },
	
	  _onChange: function _onChange() {
	    this.setState(getState());
	  },
	
	  render: function render() {
	    return React.createElement(
	      UnreadScroller,
	      null,
	      React.createElement(RoomsNav, { can_create_room: this.state.can_create_room, can_invite_users: this.state.can_invite_users })
	    );
	  }
	});

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lobby_nav_item = __webpack_require__(486);
	
	var _lobby_nav_item2 = _interopRequireDefault(_lobby_nav_item);
	
	var _search_nav_item = __webpack_require__(487);
	
	var _search_nav_item2 = _interopRequireDefault(_search_nav_item);
	
	var _rooms_nav_people_list = __webpack_require__(488);
	
	var _rooms_nav_people_list2 = _interopRequireDefault(_rooms_nav_people_list);
	
	var _rooms_nav_room_list = __webpack_require__(493);
	
	var _rooms_nav_room_list2 = _interopRequireDefault(_rooms_nav_room_list);
	
	var _rooms_nav_store = __webpack_require__(368);
	
	var _rooms_nav_store2 = _interopRequireDefault(_rooms_nav_store);
	
	var _room_nav_actions = __webpack_require__(288);
	
	var _room_nav_actions2 = _interopRequireDefault(_room_nav_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getState() {
	  var rooms = _rooms_nav_store2.default.get('rooms');
	  return {
	    rooms: rooms["rooms"],
	    people: rooms["people"],
	    room_order: _rooms_nav_store2.default.get('room_order'),
	    active_chat: _rooms_nav_store2.default.get('active_chat'),
	    feature_flags: _rooms_nav_store2.default.get('feature_flags'),
	    group_name: _rooms_nav_store2.default.get('group_name'),
	    group_avatar_url: _rooms_nav_store2.default.get('group_avatar_url'),
	    group_avatar_bg: _rooms_nav_store2.default.get('group_avatar_bg'),
	    search_nav_item_visible: _rooms_nav_store2.default.get('search_nav_item_visible'),
	    drag_target: _rooms_nav_store2.default.get('drag_target'),
	    drag_over_target: _rooms_nav_store2.default.get('drag_over_target'),
	    drag_over_clientY: _rooms_nav_store2.default.get('drag_over_clientY'),
	    dragging: _rooms_nav_store2.default.get('dragging'),
	    ui_available: _rooms_nav_store2.default.get('ui_available')
	  };
	}
	
	module.exports = React.createClass({
	
	  displayName: "RoomsNav",
	
	  getInitialState: function getInitialState() {
	    return getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _rooms_nav_store2.default.on('change', this._onChange);
	    this.placeholder = document.createElement("li");
	    this.placeholder.className = "hc-sortable-placeholder";
	    this.launchToActiveChatCalled = false;
	  },
	
	  componentWillMount: function componentWillMount() {
	    _app_dispatcher2.default.register("after:restore-room-order", this._scrollToActiveChat);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _rooms_nav_store2.default.off('change', this._onChange);
	    this.placeholder = null;
	    _app_dispatcher2.default.unregister("after:restore-room-order", this._scrollToActiveChat);
	  },
	
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    if (this.state.ui_available && !this.launchToActiveChatCalled) {
	      // This should only fire once after the preloader has been removed
	      this._handleLaunchToActiveChatList();
	    }
	    if (prevState.active_chat !== this.state.active_chat && !_utils2.default.jid.is_search(this.state.active_chat)) {
	      this._scrollToActiveChat();
	    }
	    if (this.state.dragging && this.state.drag_over_target && this.state.drag_over_clientY) {
	      this._dragOver();
	    } else if (!this.state.dragging && this.state.drag_target) {
	      this._dragEnd();
	    }
	  },
	
	  _onChange: function _onChange() {
	    this.setState(getState());
	  },
	
	  _getChatCount: function _getChatCount() {
	    return this.state.rooms.length + this.state.people.length;
	  },
	
	  _handleLaunchToActiveChatList: function _handleLaunchToActiveChatList() {
	    _analytics_actions2.default.handleLaunchToActiveChatList({
	      size: this._getChatCount()
	    });
	    this.launchToActiveChatCalled = true;
	  },
	
	  _scrollToActiveChat: function _scrollToActiveChat() {
	    var element = $(ReactDOM.findDOMNode(this)).find("[data-jid='" + this.state.active_chat + "']"),
	        container = ReactDOM.findDOMNode(this).parentNode;
	
	    if (element && element.length) {
	      _utils2.default.scrollIntoViewIfNeeded(element[0], container);
	    }
	  },
	
	  _dragOver: function _dragOver() {
	    var $tabTarget = $(this.state.drag_over_target).closest(".hc-tab"),
	        $container = $tabTarget.closest(".hc-sortable"),
	        clientY = this.state.drag_over_clientY,
	        relY,
	        tabHeight = $tabTarget.height(),
	        height = tabHeight / 2;
	
	    if (this._allowDrop($container) && $tabTarget.length && ($tabTarget.hasClass('hc-room') || $tabTarget.hasClass('hc-person'))) {
	      relY = clientY - $tabTarget.offset().top;
	      if (relY > height) {
	        $tabTarget.after(this.placeholder);
	      } else if (relY < height) {
	        $tabTarget.before(this.placeholder);
	      }
	    }
	  },
	
	  _dragEnd: function _dragEnd() {
	    var jid_order = _.cloneDeep(this.state.room_order),
	        $placeholder = $(".hc-sortable").find(".hc-sortable-placeholder"),
	        end = _.indexOf(jid_order, $(this.state.drag_target).data('jid')),
	        start = Number($placeholder.index() - 1);
	
	    if (this.state.drag_target && this.state.drag_target.classList.contains("hc-person")) {
	      start = start + ReactDOM.findDOMNode(this).querySelectorAll(".hc-room").length;
	    }
	    $placeholder.remove();
	    if (end < start) {
	      start--;
	    }
	    jid_order.splice(start, 0, jid_order.splice(end, 1)[0]);
	    _room_nav_actions2.default.update_room_order(jid_order);
	  },
	
	  _allowDrop: function _allowDrop($container) {
	    // Prevent dropping rooms in people list & vice versa
	    return this.state.drag_target && (this.state.drag_target.classList.contains("hc-room") && $container.hasClass("hc-rooms") || this.state.drag_target.classList.contains("hc-person") && $container.hasClass("hc-people"));
	  },
	
	  _getLobbyItem: function _getLobbyItem() {
	    var lobby_is_active = !this.state.active_chat || _utils2.default.jid.is_lobby(this.state.active_chat);
	
	    return React.createElement(_lobby_nav_item2.default, { ref: 'lobby',
	      active: lobby_is_active,
	      group_avatar_url: this.state.group_avatar_url,
	      group_avatar_bg: this.state.group_avatar_bg,
	      group_name: this.state.group_name });
	  },
	
	  _getSearchItem: function _getSearchItem() {
	    return React.createElement(_search_nav_item2.default, { ref: 'search', active: _utils2.default.jid.is_search(this.state.active_chat) });
	  },
	
	  render: function render() {
	    var searchNavItem = this.state.search_nav_item_visible ? this._getSearchItem() : false,
	        lobbyNavItem = this._getLobbyItem();
	
	    return React.createElement(
	      'div',
	      { className: 'aui-navgroup-inner' },
	      lobbyNavItem,
	      searchNavItem,
	      React.createElement(_rooms_nav_room_list2.default, { rooms: this.state.rooms, active_chat: this.state.active_chat, can_create_room: this.props.can_create_room }),
	      React.createElement(_rooms_nav_people_list2.default, { people: this.state.people, active_chat: this.state.active_chat, can_invite_users: this.props.can_invite_users })
	    );
	  }
	
	});

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _room_nav_actions = __webpack_require__(288);
	
	var _room_nav_actions2 = _interopRequireDefault(_room_nav_actions);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'LobbyNavItem',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _onClick: function _onClick() {
	    _room_nav_actions2.default.select('lobby');
	    _analytics_actions2.default.lobbyRoomNavItemClicked();
	  },
	
	  _getLobbyIcon: function _getLobbyIcon() {
	    var icon;
	
	    if (_.isString(this.props.group_name)) {
	      icon = React.createElement(_person_avatar2.default, {
	        text: this.props.group_name.charAt(0),
	        avatar_url: this.props.group_avatar_url,
	        avatar_bg_color: this.props.group_avatar_bg,
	        size: 'xsmall',
	        show_presence: false });
	    } else {
	      icon = React.createElement('span', { className: 'aui-icon hipchat-icon-small icon-lobby' });
	    }
	
	    return icon;
	  },
	
	  _getLobbyText: function _getLobbyText() {
	    var text = _common_strings2.default.lobby;
	    if (_.isString(this.props.group_name)) {
	      text = this.props.group_name;
	    }
	    return React.createElement(
	      'span',
	      { className: 'aui-nav-item-label' },
	      text
	    );
	  },
	
	  _getLobbyContent: function _getLobbyContent() {
	    var lobbyText = this._getLobbyText(),
	        lobbyIcon = this._getLobbyIcon();
	
	    return React.createElement(
	      'a',
	      { ref: 'link', className: 'aui-nav-item', onClick: this._onClick },
	      lobbyIcon,
	      lobbyText
	    );
	  },
	
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      'hc-tab': true,
	      'aui-nav-selected': this.props.active
	    }),
	        lobbyContent = this._getLobbyContent();
	
	    return React.createElement(
	      'ul',
	      { className: 'aui-nav hc-sidebar-nav hc-lobby', 'data-skate-ignore': true },
	      React.createElement(
	        'li',
	        { className: classes, 'data-jid': 'lobby' },
	        lobbyContent
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _room_nav_actions = __webpack_require__(288);
	
	var _room_nav_actions2 = _interopRequireDefault(_room_nav_actions);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "SearchNavItem",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _closeSearch: function _closeSearch() {
	    _room_nav_actions2.default.closeSearchResults();
	  },
	
	  _showSearch: function _showSearch() {
	    _room_nav_actions2.default.openSearchResults();
	  },
	
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      'hc-tab': true,
	      'aui-nav-selected': this.props.active
	    });
	
	    return React.createElement(
	      "ul",
	      { className: "aui-nav hc-sidebar-nav hc-search-results", "data-skate-ignore": true },
	      React.createElement(
	        "li",
	        { className: classes, "data-jid": "search" },
	        React.createElement(
	          "a",
	          { className: "aui-nav-item aui-nav-selected", onClick: this._showSearch },
	          React.createElement("span", { className: "aui-icon hipchat-icon-small icon-search" }),
	          React.createElement(
	            "span",
	            { className: "aui-nav-item-label" },
	            _common_strings2.default.search_results
	          )
	        ),
	        React.createElement(
	          "a",
	          { className: "hc-tab-close", onClick: this._closeSearch },
	          React.createElement("span", { className: "aui-icon hipchat-icon-xsmall hc-close-icon icon-close" })
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var InviteUsersNavItem = __webpack_require__(489);
	var RoomsNavItemPerson = __webpack_require__(490);
	var RoomNavActions = __webpack_require__(288);
	var CommonStrings = __webpack_require__(183);
	
	module.exports = React.createClass({
	
	  displayName: "RoomsNavPeopleList",
	
	  _onDragOver: function _onDragOver(e) {
	    RoomNavActions.dragOver({
	      event: e
	    });
	  },
	
	  _getInviteUsers: function _getInviteUsers() {
	    return React.createElement(InviteUsersNavItem, null);
	  },
	
	  _getPeopleList: function _getPeopleList() {
	    var _this = this;
	
	    var peopleList = _.map(this.props.people, function (room) {
	      return React.createElement(RoomsNavItemPerson, { key: "RoomsNavPersonItem" + room.jid + room.type,
	        unreadCount: room.unreadCount,
	        isUpdating: room.isUpdatingUnreadCount,
	        active: _this.props.active_chat === room.jid,
	        name: room.name,
	        jid: room.jid,
	        type: room.type,
	        uid: room.id,
	        presence: room.presence.show,
	        status: room.presence.status,
	        mobile: room.mobile });
	    });
	    return peopleList;
	  },
	
	  _getPeopleContent: function _getPeopleContent(inviteUsersLink) {
	    var peopleList = this.props.people && this.props.people.length ? this._getPeopleList() : false;
	
	    return React.createElement(
	      'ul',
	      { ref: 'people_list', className: 'aui-nav hc-sidebar-nav hc-sortable hc-people', onDragOver: this._onDragOver, 'data-skate-ignore': true },
	      React.createElement(
	        'li',
	        { className: 'aui-nav-heading' },
	        React.createElement(
	          'strong',
	          null,
	          CommonStrings.people
	        )
	      ),
	      peopleList,
	      inviteUsersLink
	    );
	  },
	
	  render: function render() {
	    var inviteUsersLink = this.props.can_invite_users ? this._getInviteUsers() : false,
	        peopleContent = this.props.people && this.props.people.length || inviteUsersLink ? this._getPeopleContent(inviteUsersLink) : false;
	
	    return React.createElement(
	      'div',
	      { key: 'RoomsNavPeople' },
	      peopleContent
	    );
	  }
	});

/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _analytics_keys = __webpack_require__(197);
	
	var _analytics_keys2 = _interopRequireDefault(_analytics_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "InviteUsersNavItem",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _onClick: function _onClick() {
	    _dialog_actions2.default.showInviteTeammatesDialog({ type: _analytics_keys2.default.LEFT });
	    _analytics_actions2.default.inviteTeamClickedEvent("left.navigation");
	  },
	
	  render: function render() {
	    return React.createElement(
	      'li',
	      { className: 'hc-tab hc-add-item-link hc-invite-users-link' },
	      React.createElement(
	        'a',
	        { ref: 'link', className: 'aui-nav-item aui-inline-dialog-trigger', onClick: this._onClick },
	        React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-add-small' }),
	        React.createElement(
	          'span',
	          { className: 'room-name' },
	          _common_strings2.default.buttons.invite_team
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _presenceIcon = __webpack_require__(311);
	
	var _presenceIcon2 = _interopRequireDefault(_presenceIcon);
	
	var _unread_badge = __webpack_require__(491);
	
	var _unread_badge2 = _interopRequireDefault(_unread_badge);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _rooms_nav_item_mixin = __webpack_require__(492);
	
	var _rooms_nav_item_mixin2 = _interopRequireDefault(_rooms_nav_item_mixin);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RoomsNavItemPerson",
	
	  mixins: [_reactAddonsPureRenderMixin2.default, _rooms_nav_item_mixin2.default],
	
	  _getUnreadBadge: function _getUnreadBadge() {
	    return React.createElement(_unread_badge2.default, { unreadCount: this.props.unreadCount, hasMention: true, isUpdating: this.props.isUpdating });
	  },
	
	  render: function render() {
	    var hasBadge = this.props.unreadCount > 0 && !this.props.active,
	        unreadBadge = hasBadge ? this._getUnreadBadge() : false,
	        classes = (0, _classnames2.default)({
	      'hc-tab': true,
	      'aui-nav-selected': this.props.active,
	      'hc-has-badge': hasBadge,
	      'hc-person': true
	    });
	
	    return React.createElement(
	      'li',
	      { ref: 'nav_item', draggable: 'true', className: classes, onDragStart: this._onDragStart, onDragEnd: this._onDragEnd, 'data-jid': this.props.jid },
	      React.createElement(
	        'a',
	        { ref: 'link', className: 'aui-nav-item', onClick: this._onSelectTab, 'aria-label': this.props.name, 'data-tipsify-ignore': true },
	        React.createElement(_presenceIcon2.default, { active: true,
	          presence: this.props.presence,
	          mobile: this.props.mobile,
	          uid: this.props.uid }),
	        React.createElement(
	          'span',
	          { className: 'room-name' },
	          this.props.name
	        ),
	        unreadBadge
	      ),
	      React.createElement(
	        'a',
	        { ref: 'close_link', className: 'hc-tab-close', onClick: this._onCloseTab },
	        React.createElement('span', { className: 'aui-icon hipchat-icon-xsmall hc-close-icon icon-close' })
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MAX_UNREADS = _app_config2.default.max_unread_count;
	
	exports.default = React.createClass({
	
	  displayName: "UnreadBadge",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  render: function render() {
	    var count = this.props.unreadCount > MAX_UNREADS ? MAX_UNREADS + '+' : this.props.unreadCount,
	        classes = (0, _classnames2.default)({
	      'aui-badge': this.props.unreadCount > 0,
	      'hc-badge': true,
	      'hc-mention': this.props.hasMention ? true : false,
	      'hc-updating': this.props.isUpdating ? true : false
	    });
	    return React.createElement(
	      'span',
	      { className: classes },
	      count
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _room_nav_actions = __webpack_require__(288);
	
	var _room_nav_actions2 = _interopRequireDefault(_room_nav_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  _onDragStart: function _onDragStart(e) {
	    e.dataTransfer.effectAllowed = 'move';
	    try {
	      e.dataTransfer.setData('application/x-moz-node', e.currentTarget); // Required for Mozilla, breaks IE
	    } catch (err) {
	      e.dataTransfer.setData('text', 'IE node placeholder'); // IE only accepts 'text' or 'URL' as draggable types (but IE doesn't even care)
	    }
	    _room_nav_actions2.default.dragStart({
	      target: e.currentTarget
	    });
	  },
	
	  _onDragEnd: function _onDragEnd() {
	    _room_nav_actions2.default.dragEnd();
	  },
	
	  _onSelectTab: function _onSelectTab(e) {
	    if (e.nativeEvent.which === _utils2.default.mouseButton.middle) {
	      this._onCloseTab(e);
	    } else if (!this.props.active) {
	      _room_nav_actions2.default.select(this.props.jid, this.props.type);
	    }
	  },
	
	  _onCloseTab: function _onCloseTab() {
	    _room_nav_actions2.default.close(this.props.jid, this.props.type);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var CreateRoomNavItem = __webpack_require__(494);
	var RoomsNavItemRoom = __webpack_require__(495);
	var RoomNavActions = __webpack_require__(288);
	var CommonStrings = __webpack_require__(183);
	
	module.exports = React.createClass({
	
	  displayName: "RoomsNavRoomList",
	
	  _onDragOver: function _onDragOver(e) {
	    RoomNavActions.dragOver({
	      event: e
	    });
	  },
	
	  _getCreateRoomLink: function _getCreateRoomLink() {
	    return React.createElement(CreateRoomNavItem, null);
	  },
	
	  _getRoomList: function _getRoomList() {
	    var _this = this;
	
	    return _.map(this.props.rooms, function (room) {
	      return React.createElement(RoomsNavItemRoom, { key: "RoomsNavRoomItem" + room.jid + room.type,
	        unreadCount: room.unreadCount,
	        hasMention: room.hasMention,
	        isUpdating: room.isUpdatingUnreadCount,
	        active: _this.props.active_chat === room.jid,
	        name: room.name,
	        jid: room.jid,
	        type: room.type,
	        privacy: room.privacy });
	    });
	  },
	
	  _getRoomsContent: function _getRoomsContent(createRoomLink) {
	    var roomList = this.props.rooms && this.props.rooms.length ? this._getRoomList() : false;
	
	    return React.createElement(
	      'ul',
	      { ref: 'room_list', className: 'aui-nav hc-sidebar-nav hc-sortable hc-rooms', onDragOver: this._onDragOver, 'data-skate-ignore': true },
	      React.createElement(
	        'li',
	        { className: 'aui-nav-heading' },
	        React.createElement(
	          'strong',
	          null,
	          CommonStrings.rooms
	        )
	      ),
	      roomList,
	      createRoomLink
	    );
	  },
	
	  render: function render() {
	    var createRoomLink = this.props.can_create_room ? this._getCreateRoomLink() : false,
	        roomsContent = this.props.rooms && this.props.rooms.length || createRoomLink ? this._getRoomsContent(createRoomLink) : false;
	
	    return React.createElement(
	      'div',
	      { key: 'RoomsNavRooms' },
	      roomsContent
	    );
	  }
	});

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "CreateRoomNavItem",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _onClick: function _onClick() {
	    _dialog_actions2.default.showCreateRoomDialog();
	    _analytics_actions2.default.createRoomClickedEvent("left.navigation");
	  },
	
	  render: function render() {
	    return React.createElement(
	      'li',
	      { className: 'hc-tab hc-add-item-link' },
	      React.createElement(
	        'a',
	        { ref: 'link', className: 'aui-nav-item hc-create-room-link', onClick: this._onClick },
	        React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-add-small' }),
	        React.createElement(
	          'span',
	          { className: 'room-name' },
	          _common_strings2.default.buttons.create_room
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _unread_badge = __webpack_require__(491);
	
	var _unread_badge2 = _interopRequireDefault(_unread_badge);
	
	var _icon = __webpack_require__(312);
	
	var _icon2 = _interopRequireDefault(_icon);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _rooms_nav_item_mixin = __webpack_require__(492);
	
	var _rooms_nav_item_mixin2 = _interopRequireDefault(_rooms_nav_item_mixin);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RoomsNavItemRoom",
	
	  mixins: [_reactAddonsPureRenderMixin2.default, _rooms_nav_item_mixin2.default],
	
	  _getUnreadBadge: function _getUnreadBadge() {
	    return React.createElement(_unread_badge2.default, { unreadCount: this.props.unreadCount, hasMention: this.props.hasMention, isUpdating: this.props.isUpdating });
	  },
	
	  render: function render() {
	    var hasBadge = this.props.unreadCount > 0 && !this.props.active,
	        unreadBadge = hasBadge ? this._getUnreadBadge() : false,
	        classes = (0, _classnames2.default)({
	      'hc-tab': true,
	      'aui-nav-selected': this.props.active,
	      'hc-has-badge': hasBadge,
	      'hc-room': true
	    });
	
	    return React.createElement(
	      'li',
	      { ref: 'nav_item', draggable: 'true', className: classes, onDragStart: this._onDragStart, onDragEnd: this._onDragEnd, 'data-jid': this.props.jid },
	      React.createElement(
	        'a',
	        { ref: 'link', className: 'aui-nav-item', onClick: this._onSelectTab, 'aria-label': this.props.name, 'data-tipsify-ignore': true },
	        this.props.privacy ? React.createElement('span', { className: "aui-icon hipchat-icon-small icon-" + this.props.privacy }) : React.createElement(_icon2.default, { classes: { "aui-icon": true, "hipchat-icon-small": true }, iconName: 'dot' }),
	        React.createElement(
	          'span',
	          { className: 'room-name' },
	          this.props.name
	        ),
	        unreadBadge
	      ),
	      React.createElement(
	        'a',
	        { ref: 'close_link', className: 'hc-tab-close', onClick: this._onCloseTab },
	        React.createElement('span', { className: 'aui-icon hipchat-icon-xsmall hc-close-icon icon-close' })
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _rooms_nav_store = __webpack_require__(368);
	
	var _rooms_nav_store2 = _interopRequireDefault(_rooms_nav_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _sidebar_strings = __webpack_require__(497);
	
	var _sidebar_strings2 = _interopRequireDefault(_sidebar_strings);
	
	var _room_nav_actions = __webpack_require__(288);
	
	var _room_nav_actions2 = _interopRequireDefault(_room_nav_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//This constant describes vertical area size, where scroll starts while object dragging to box edge
	var DRAG_SCROLL_THRESHOLD = 20;
	
	//This constant is a scroll value for scroll while dragging.
	var DRAG_SCROLL_VALUE = 12;
	
	function isBelow(el, boundary) {
	  // offsetHeight coefficient controls what percentage of the nav item must be visible
	  // for the unread scroller to be considered "below" it
	  return el.offsetTop + el.offsetHeight * 0.5 > boundary;
	}
	
	function isAbove(el, boundary) {
	  // offsetHeight coefficient controls what percentage of the nav item must be visible
	  // for the unread scroller to be considered "above" it
	  return el.offsetTop + el.offsetHeight * 0.5 < boundary;
	}
	
	exports.default = React.createClass({
	
	  displayName: 'UnreadScroller',
	
	  getInitialState: function getInitialState() {
	    return {
	      hideTop: true,
	      hideBottom: true,
	      topMention: false,
	      bottomMention: false
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    this._throttledOnChange = _.throttle(this._onChange, 100, {
	      trailing: true,
	      leading: true
	    });
	    this._tabsAbove = [];
	    this._tabsBelow = [];
	    _rooms_nav_store2.default.on('change', this._throttledOnChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._throttledOnChange.cancel();
	    _rooms_nav_store2.default.off('change', this._throttledOnChange);
	  },
	  render: function render() {
	    var topClass = (0, _classnames2.default)({
	      'hidden': this.state.hideTop,
	      'has-mention': this.state.topMention
	    });
	    var bottomClass = (0, _classnames2.default)({
	      'hidden': this.state.hideBottom,
	      'has-mention': this.state.bottomMention
	    });
	    var autoScrollWhileDragBugPresent = _utils2.default.browser.is.firefox() || _utils2.default.browser.is.safari() || _utils2.default.browser.is.ie();
	    autoScrollWhileDragBugPresent = autoScrollWhileDragBugPresent || _utils2.default.browser.family() === "unknown";
	    var dragOverHandler = autoScrollWhileDragBugPresent ? this._dragOver : null;
	    return React.createElement(
	      'nav',
	      { className: 'aui-navgroup aui-navgroup-vertical hc-sidebar hc-sidebar-scroll', ref: 'target', onScroll: this._throttledOnChange, onDragOver: dragOverHandler },
	      React.createElement(
	        'div',
	        { className: 'hc-unread-scroller hc-unread-scroller-top ' + topClass },
	        React.createElement(
	          'a',
	          { href: '#', onClick: this._scrollUpToUnread },
	          React.createElement(
	            'span',
	            { className: 'aui-icon aui-icon-small aui-iconfont-arrows-up' },
	            _sidebar_strings2.default.scroll_up_to_unread
	          )
	        )
	      ),
	      this.props.children,
	      React.createElement(
	        'div',
	        { className: 'hc-unread-scroller hc-unread-scroller-bottom ' + bottomClass },
	        React.createElement(
	          'a',
	          { href: '#', onClick: this._scrollDownToUnread },
	          React.createElement(
	            'span',
	            { className: 'aui-icon aui-icon-small aui-iconfont-arrows-down' },
	            _sidebar_strings2.default.scroll_down_to_unread
	          )
	        )
	      )
	    );
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _getState: function _getState() {
	    var node = ReactDOM.findDOMNode(this.refs.target);
	    var tabs = $('.hc-badge').closest('.hc-tab');
	    this._tabsAbove = tabs.filter(function (idx, el) {
	      return isAbove(el, node.scrollTop);
	    });
	    this._tabsBelow = tabs.filter(function (idx, el) {
	      return isBelow(el, node.scrollTop + node.offsetHeight);
	    });
	    return {
	      hideTop: !this._tabsAbove.length,
	      hideBottom: !this._tabsBelow.length,
	      topMention: $(this._tabsAbove).find('.hc-mention').length,
	      bottomMention: $(this._tabsBelow).find('.hc-mention').length
	    };
	  },
	
	
	  _dragOver: function _dragOver(evt) {
	    var isScrollTopNeed = evt.currentTarget.scrollTop > 0;
	    var isScrollBottomNeed = evt.currentTarget.scrollHeight - evt.currentTarget.scrollTop - evt.currentTarget.clientHeight > 0;
	    var crect = evt.currentTarget.getBoundingClientRect();
	    var clientY = evt.clientY - crect.top;
	    if (isScrollTopNeed && clientY <= DRAG_SCROLL_THRESHOLD) {
	      evt.currentTarget.scrollTop -= DRAG_SCROLL_VALUE;
	    }
	    if (isScrollBottomNeed && evt.currentTarget.clientHeight - clientY <= DRAG_SCROLL_THRESHOLD) {
	      evt.currentTarget.scrollTop += DRAG_SCROLL_VALUE;
	    }
	  },
	
	  _scrollUpToUnread: function _scrollUpToUnread(evt) {
	    evt.preventDefault();
	    this.setState(this._getState());
	    if (this._tabsAbove.length > 0) {
	      var tab = this._tabsAbove.get(this._tabsAbove.length - 1),
	          jid = $(tab).data('jid'),
	          type = _utils2.default.jid.is_private_chat(jid) ? 'chat' : 'groupchat';
	      _utils2.default.scrollIntoViewIfNeeded(tab, ReactDOM.findDOMNode(this.refs.target));
	      _room_nav_actions2.default.select(jid, type);
	    }
	  },
	  _scrollDownToUnread: function _scrollDownToUnread(evt) {
	    evt.preventDefault();
	    this.setState(this._getState());
	    if (this._tabsBelow.length > 0) {
	      var tab = this._tabsBelow.get(0),
	          jid = $(tab).data('jid'),
	          type = _utils2.default.jid.is_private_chat(jid) ? 'chat' : 'groupchat';
	      _utils2.default.scrollIntoViewIfNeeded(tab, ReactDOM.findDOMNode(this.refs.target));
	      _room_nav_actions2.default.select(jid, type);
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 497 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  scroll_up_to_unread: "Scroll up to unread",
	  scroll_down_to_unread: "Scroll down to unread"
	};
	module.exports = exports['default'];

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lobby = __webpack_require__(499);
	
	var _lobby2 = _interopRequireDefault(_lobby);
	
	var _search_results = __webpack_require__(505);
	
	var _search_results2 = _interopRequireDefault(_search_results);
	
	var _sidebar = __webpack_require__(508);
	
	var _sidebar2 = _interopRequireDefault(_sidebar);
	
	var _chat_header = __webpack_require__(554);
	
	var _chat_header2 = _interopRequireDefault(_chat_header);
	
	var _chat_panel = __webpack_require__(566);
	
	var _chat_panel2 = _interopRequireDefault(_chat_panel);
	
	var _chat_input_box = __webpack_require__(604);
	
	var _chat_input_box2 = _interopRequireDefault(_chat_input_box);
	
	var _resizeOverlay = __webpack_require__(619);
	
	var _resizeOverlay2 = _interopRequireDefault(_resizeOverlay);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _layout_store = __webpack_require__(483);
	
	var _layout_store2 = _interopRequireDefault(_layout_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _layout_actions = __webpack_require__(266);
	
	var _layout_actions2 = _interopRequireDefault(_layout_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getState() {
	  var active_chat = _layout_store2.default.get("active_chat");
	  return {
	    active_chat: active_chat,
	    chat_type: _utils2.default.room.detect_chat_type(active_chat),
	    rightChatSidebarVisibility: _preferences_store2.default.shouldShowChatSidebar(),
	    rightGroupChatSidebarVisibility: _preferences_store2.default.shouldShowGroupChatSidebar(),
	    rightColumnWidth: _preferences_store2.default.getRightColumnWidth(),
	    search_opened: _layout_store2.default.get('search_opened'),
	    is_resizing: false
	  };
	}
	
	exports.default = React.createClass({
	
	  displayName: "MainColumn",
	
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(nextState, this.state);
	  },
	
	  getInitialState: getState,
	
	  componentDidMount: function componentDidMount() {
	    _preferences_store2.default.on(['change:showChatSidebar', 'change:showGroupChatSidebar', 'change:rightColumnWidth'], this._onChange);
	    _layout_store2.default.on(['change:active_chat', 'change:search_opened'], this._onChange);
	    if (_utils2.default.jid.is_chat(this.state.active_chat)) {
	      this._resizeColumns(this.state.rightColumnWidth);
	    }
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (_utils2.default.jid.is_chat(this.state.active_chat)) {
	      this._resizeColumns(this.state.rightColumnWidth);
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _preferences_store2.default.off(['change:showChatSidebar', 'change:showGroupChatSidebar', 'change:rightColumnWidth'], this._onChange);
	    _layout_store2.default.off(['change:active_chat', 'change:search_opened'], this._onChange);
	  },
	
	  _getRightSidebar: function _getRightSidebar() {
	    return React.createElement(
	      'div',
	      { className: 'hc-right-sidebar-col' },
	      React.createElement(_sidebar2.default, { is_guest: this.props.is_guest }),
	      React.createElement(_resizeOverlay2.default, { show_overlay: this.state.is_resizing }),
	      React.createElement('div', { className: 'resize-handle', onMouseDown: this._onResizeStart })
	    );
	  },
	
	  render: function render() {
	    var panel,
	        chatClasses = (0, _classnames2.default)({
	      'hc-rooms-container': true,
	      'hidden': !_utils2.default.jid.is_chat(this.state.active_chat)
	    }),
	        search_active = _utils2.default.jid.is_search(this.state.active_chat) && !this.props.is_guest,
	        rightSidebar = this._showRightSidebar() ? this._getRightSidebar() : false;
	
	    if (_utils2.default.jid.is_lobby(this.state.active_chat) && !this.props.is_guest) {
	      panel = React.createElement(_lobby2.default, null);
	    } else {
	      panel = React.createElement(
	        'div',
	        { className: chatClasses, 'data-skate-ignore': true },
	        React.createElement(
	          'div',
	          { className: 'hc-chat-panel-header-container' },
	          React.createElement(_chat_header2.default, { is_guest: this.props.is_guest })
	        ),
	        React.createElement(
	          'div',
	          { className: 'hc-chat-panel-container' },
	          React.createElement(
	            'div',
	            { className: 'hc-chat-panel-left-column' },
	            React.createElement(_chat_panel2.default, { is_guest: this.props.is_guest }),
	            React.createElement(_chat_input_box2.default, { is_guest: this.props.is_guest })
	          ),
	          React.createElement(
	            'div',
	            { className: 'hc-chat-panel-right-column', ref: 'right_column' },
	            rightSidebar
	          )
	        )
	      );
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-main-col' },
	      this.state.search_opened ? React.createElement(_search_results2.default, { visible: search_active }) : false,
	      search_active ? false : panel
	    );
	  },
	
	  _showRightSidebar: function _showRightSidebar() {
	    if (this.state.chat_type === "chat") {
	      return _preferences_store2.default.shouldShowChatSidebar();
	    } else if (this.state.chat_type === "groupchat") {
	      return _preferences_store2.default.shouldShowGroupChatSidebar();
	    }
	  },
	
	  _onChange: function _onChange() {
	    this.setState(getState());
	  },
	
	  _resizeColumns: function _resizeColumns(width) {
	    width = this._showRightSidebar() ? width + 'px' : '0px';
	    this.refs.right_column.style.width = width;
	  },
	
	  _onResizeStart: function _onResizeStart(e) {
	    e.preventDefault();
	    this.beginX = e.pageX;
	    this.beginWidth = this.state.rightColumnWidth;
	    document.addEventListener('mouseup', this._onResizeEnd);
	    document.addEventListener('mousemove', this._onHandleDrag);
	    _layout_actions2.default.setRightColumnWidthIsChanging(true);
	
	    this.setState({
	      is_resizing: true
	    });
	  },
	
	  _onHandleDrag: function _onHandleDrag(e) {
	    var diff = e.pageX - this.beginX;
	    if (this.beginWidth - diff >= 0 && this.beginWidth - diff <= _app_config2.default.column_width_limits['right'].max) {
	      var width = this.beginWidth - diff;
	      this._resizeColumns(width);
	      this.setState({
	        rightColumnWidth: width
	      });
	    }
	  },
	
	
	  _onResizeEnd: function _onResizeEnd(e) {
	    e.preventDefault();
	    document.removeEventListener('mouseup', this._onResizeEnd);
	    document.removeEventListener('mousemove', this._onHandleDrag);
	
	    // if you've resized the right sidebar beyond the width limit then hide it
	    if (ReactDOM.findDOMNode(this.refs.right_column).offsetWidth <= _app_config2.default.column_width_limits['right'].min) {
	      var visibility = false;
	      if (this.state.chat_type === "chat") {
	        _layout_actions2.default.setRightChatSidebarVisibility(visibility);
	      } else if (this.state.chat_type === "groupchat") {
	        _layout_actions2.default.setRightGroupChatSidebarVisibility(visibility);
	      }
	      _layout_actions2.default.saveRightColumnWidth(this.beginWidth);
	    } else {
	      _layout_actions2.default.saveRightColumnWidth(this.state.rightColumnWidth);
	    }
	    _layout_actions2.default.setRightColumnWidthIsChanging(false);
	
	    this.setState({
	      is_resizing: false
	    });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lobby_store = __webpack_require__(500);
	
	var _lobby_store2 = _interopRequireDefault(_lobby_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _permissions_store = __webpack_require__(269);
	
	var _permissions_store2 = _interopRequireDefault(_permissions_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _lobby_actions = __webpack_require__(296);
	
	var _lobby_actions2 = _interopRequireDefault(_lobby_actions);
	
	var _empty_state = __webpack_require__(501);
	
	var _empty_state2 = _interopRequireDefault(_empty_state);
	
	var _empty_search_state = __webpack_require__(502);
	
	var _empty_search_state2 = _interopRequireDefault(_empty_search_state);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _lobby_item = __webpack_require__(503);
	
	var _lobby_item2 = _interopRequireDefault(_lobby_item);
	
	var _lobby_message = __webpack_require__(504);
	
	var _lobby_message2 = _interopRequireDefault(_lobby_message);
	
	var _analytics_keys = __webpack_require__(197);
	
	var _analytics_keys2 = _interopRequireDefault(_analytics_keys);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "Lobby",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    this.debouncedFilter = _.debounce(this._debouncableFilter, 200);
	    _configuration_store2.default.on('change', this._onChange);
	    _lobby_store2.default.on('change', this._onChange);
	    _permissions_store2.default.on('change', this._onChange);
	    _app_dispatcher2.default.register('new-active-chat', this._roomSelected);
	    _lobby_actions2.default.lobbyMounted();
	    _lobby_actions2.default.resetSelectedItem();
	    this._focusInput();
	    this.throttledSetScrollPosition = _.throttle(this._setScrollPosition, 100, { leading: false, trailing: true });
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _configuration_store2.default.off('change', this._onChange);
	    _lobby_store2.default.off('change', this._onChange);
	    _permissions_store2.default.off('change', this._onChange);
	    _app_dispatcher2.default.unregister('new-active-chat', this._roomSelected);
	    this.throttledSetScrollPosition.cancel();
	  },
	
	  _onKeyDown: function _onKeyDown(evt) {
	
	    if (this.state.dialog_visible) {
	      return;
	    }
	
	    if (evt.keyCode === _utils2.default.keyCode.UpArrow || evt.keyCode === _utils2.default.keyCode.DownArrow) {
	
	      evt.preventDefault();
	      _mouse_position2.default.useLatest();
	
	      if (!this.state.rows.length) {
	        return;
	      }
	
	      if (evt.keyCode === _utils2.default.keyCode.UpArrow && this.state.selected_item > 0) {
	        _lobby_actions2.default.selectedPrevItem();
	      }
	
	      if (evt.keyCode === _utils2.default.keyCode.DownArrow && this.state.selected_item < this.state.rows.length - 1) {
	        _lobby_actions2.default.selectedNextItem();
	      }
	
	      this.throttledSetScrollPosition();
	    } else if (evt.keyCode === _utils2.default.keyCode.Enter) {
	
	      this._openChat(evt);
	    } else if (evt.keyCode === _utils2.default.keyCode.Esc) {
	
	      this._clearInput();
	    }
	  },
	
	  _setScrollPosition: function _setScrollPosition() {
	
	    var container = ReactDOM.findDOMNode(this.refs.scrollable),
	        rowHeight = document.getElementsByClassName('hc-lobby-list-item')[0].offsetHeight;
	
	    var start = Math.ceil(container.scrollTop / rowHeight);
	    var end = Math.floor((container.offsetHeight + container.scrollTop) / rowHeight);
	
	    if (this.state.selected_item < start || this.state.selected_item > end - 1) {
	      var selected_item = container.querySelector('.hc-lobby-list-item.selected');
	      if (!selected_item) {
	        selected_item = container.querySelector('.hc-lobby-list-item:last-child');
	      }
	      _utils2.default.scrollIntoViewIfNeeded(selected_item, container, false);
	    }
	  },
	
	  renderItem: function renderItem(index, key) {
	    var item = this.state.rows[index];
	    return React.createElement(_lobby_item2.default, {
	      key: item.jid,
	      jid: item.jid,
	      name: item.name,
	      user_id: item.id,
	      mention_name: item.mention_name,
	      privacy: item.privacy,
	      type: _utils2.default.room.detect_chat_type(item.jid),
	      name_match_markup: item.name_match_markup,
	      mention_match_markup: item.mention_match_markup,
	      item_index: index,
	      selected: this.state.selected_item === index,
	      photo_url: item.photo_url,
	      should_animate_avatar: this.state.should_animate_avatar,
	      presence_show: item.presence ? item.presence.show : 'unknown' });
	  },
	
	
	  render: function render() {
	
	    var container_class = (0, _classnames2.default)({
	      'filtered-lobby-content': !(this.state.filter.scope === 'all' && this.state.filter.query === ''),
	      'hc-lobby-panel': true,
	      'hc-lobby-panel-content': true
	    });
	
	    var content;
	
	    if (_.isEmpty(this.state.rows)) {
	
	      content = this.state.input_text ? React.createElement(_empty_search_state2.default, { inviteAction: this._inviteYourTeam,
	        userIsAdmin: this.state.userIsAdmin,
	        inviteUrl: this.state.inviteUrl,
	        inputText: this.state.input_text,
	        webServer: this.state.webServer }) : React.createElement(_empty_state2.default, null);
	    } else {
	
	      content = React.createElement(ReactList, {
	        itemRenderer: this.renderItem,
	        length: this.state.rows.length,
	        selected: this.state.selected_item,
	        filtered_time: this.state.filtered_time,
	        threshold: 10,
	        pageSize: 20,
	        type: 'simple' });
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-rooms-container', tabIndex: '1', onKeyDown: this._onKeyDown },
	      React.createElement(
	        'header',
	        { className: 'aui-page-header lobby-header' },
	        React.createElement(
	          'div',
	          { className: 'aui-page-header-inner' },
	          React.createElement(
	            'div',
	            { className: 'aui-page-header-main hc-lobby-search-content' },
	            React.createElement(
	              'form',
	              { className: 'aui hc-filter-form', onSubmit: this._onSubmit },
	              React.createElement(
	                'label',
	                { className: 'assistive', htmlFor: 'rosterfilter' },
	                _common_strings2.default.filter
	              ),
	              React.createElement('input', { ref: 'lobbySearchInput', type: 'text', placeholder: _common_strings2.default.filter, className: 'text hc-filter long-field mousetrap', onChange: this._onInputChange, value: this.state.input_text })
	            )
	          ),
	          React.createElement(
	            'div',
	            { className: 'aui-page-header-actions' },
	            React.createElement(
	              'div',
	              { className: 'aui-buttons' },
	              React.createElement(
	                'button',
	                { className: "aui-button aui-button-light " + (this.state.filter.scope === "all" ? "active" : ""), onClick: this._onFilter.bind(null, 'all') },
	                _common_strings2.default.all
	              ),
	              React.createElement(
	                'button',
	                { className: "aui-button aui-button-light " + (this.state.filter.scope === "rooms" ? "active" : ""), onClick: this._onFilter.bind(null, 'rooms') },
	                _common_strings2.default.rooms
	              ),
	              React.createElement(
	                'button',
	                { className: "aui-button aui-button-light " + (this.state.filter.scope === "people" ? "active" : ""), onClick: this._onFilter.bind(null, 'people') },
	                _common_strings2.default.people
	              )
	            ),
	            this._getCreateRoomButton(),
	            this._getInviteTeamButton()
	          )
	        )
	      ),
	      React.createElement(
	        'div',
	        { className: container_class, ref: 'scrollable' },
	        content
	      ),
	      this._getLobbyMessage()
	    );
	  },
	
	  _getLobbyMessage: function _getLobbyMessage() {
	    if (!this.state.isBTF && this.state.lobbyMessageEnabled) {
	      return React.createElement(_lobby_message2.default, { webServer: this.state.webServer, theme: this.state.theme });
	    }
	  },
	  _canCreateRoom: function _canCreateRoom() {
	    return this.state.can_create_room;
	  },
	  _canInviteTeam: function _canInviteTeam() {
	    return this.state.userIsAdmin || this.state.inviteUrl;
	  },
	  _getCreateRoomButton: function _getCreateRoomButton() {
	    return this._canCreateRoom() ? React.createElement(
	      'div',
	      { className: 'aui-buttons' },
	      React.createElement(
	        'button',
	        { onClick: this._onCreateRoom, className: 'aui-button aui-button-light', id: 'create-room-button' },
	        _common_strings2.default.buttons.create_room
	      )
	    ) : null;
	  },
	  _getInviteTeamButton: function _getInviteTeamButton() {
	    return this._canInviteTeam() ? React.createElement(
	      'div',
	      { className: 'aui-buttons' },
	      React.createElement(
	        'button',
	        { ref: 'invite_team_button', onClick: this._inviteYourTeam, className: 'aui-button aui-button-light aui-inline-dialog-trigger', id: 'invite-team-button' },
	        _common_strings2.default.buttons.invite_team
	      )
	    ) : null;
	  },
	
	
	  _getState: function _getState() {
	    return {
	      rows: _lobby_store2.default.get('filtered'),
	      filter: _lobby_store2.default.get('filter'),
	      filtered_time: _lobby_store2.default.get('filtered_time'),
	      userIsAdmin: _lobby_store2.default.get('user_is_admin'),
	      inviteUrl: _lobby_store2.default.get('invite_url'),
	      webServer: _lobby_store2.default.get('web_server'),
	      isBTF: _.get(_configuration_store2.default.get('feature_flags'), 'btf', false),
	      lobbyMessageEnabled: _.get(_configuration_store2.default.get('feature_flags'), 'web_client_lobby_message_enabled', false),
	      input_text: _lobby_store2.default.get('input_text'),
	      selected_item: _lobby_store2.default.get('selected_item'),
	      dialog_visible: _lobby_store2.default.get('dialog_visible'),
	      theme: _lobby_store2.default.get('theme'),
	      can_create_room: _permissions_store2.default.canCreateRoom(),
	      should_animate_avatar: _preferences_store2.default.shouldAnimateAvatars()
	    };
	  },
	
	  _openChat: function _openChat(e) {
	    var key = _.keys(this.state.rows)[this.state.selected_item];
	    if (key) {
	      e.preventDefault();
	      var data = _.cloneDeep(this.state.rows[key]);
	      data.query = this.state.filter.query;
	      _lobby_actions2.default.openChat(data);
	      _lobby_actions2.default.resetFilter();
	    }
	  },
	  _clearInput: function _clearInput() {
	    if (this.state.input_text) {
	      this._setInputText("");
	    }
	  },
	
	
	  _debouncableFilter: function _debouncableFilter() {
	    _lobby_actions2.default.applyFilter({
	      query: this.state.input_text,
	      scope: this.state.filter.scope
	    });
	  },
	
	  _onInputChange: function _onInputChange(evt) {
	    this._setInputText(evt.target.value);
	  },
	
	  _setInputText: function _setInputText(text) {
	    _lobby_actions2.default.setInputText(text);
	    this.debouncedFilter();
	    ReactDOM.findDOMNode(this.refs.scrollable).scrollTop = 0;
	  },
	
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _onFilter: function _onFilter(scope) {
	    _lobby_actions2.default.applyFilter({
	      query: this.state.input_text,
	      scope: scope
	    });
	    _lobby_actions2.default.resetSelectedItem();
	    ReactDOM.findDOMNode(this.refs.scrollable).scrollTop = 0;
	  },
	
	  _onCreateRoom: function _onCreateRoom(e) {
	    e.preventDefault();
	    _lobby_actions2.default.showCreateRoomDialog();
	  },
	
	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	  },
	
	  _roomSelected: function _roomSelected(data) {
	    if (_utils2.default.jid.is_lobby(data.jid)) {
	      this._focusInput();
	    }
	  },
	
	  _focusInput: function _focusInput() {
	    if (this.refs.lobbySearchInput !== document.activeElement) {
	      try {
	        this.refs.lobbySearchInput.select();
	      } catch (e) {
	        this.refs.lobbySearchInput.focus();
	      }
	    }
	  },
	
	  _inviteYourTeam: function _inviteYourTeam(evt) {
	    evt.preventDefault();
	    _dialog_actions2.default.showInviteTeammatesDialog({ type: _analytics_keys2.default.LOBBY, default_text: this.state.input_text });
	    _analytics_actions2.default.inviteTeamClickedEvent("lobby");
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _chat_search = __webpack_require__(273);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LobbyStore = function (_Store) {
	  (0, _inherits3.default)(LobbyStore, _Store);
	
	  function LobbyStore() {
	    (0, _classCallCheck3.default)(this, LobbyStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(LobbyStore).call(this));
	
	    _this.local = {
	      all: [],
	      active: [],
	      forceUpdate: false
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(LobbyStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        is_active: false,
	        filtered: [],
	        input_text: '',
	        filter: {
	          scope: "all",
	          query: ""
	        },
	        user_is_admin: false,
	        invite_url: false,
	        web_server: _app_config2.default.default_web_server,
	        selected_item: 0,
	        dialog_visible: false,
	        filtered_time: false,
	        theme: 'light'
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit(data) {
	          _this2.handleConfig(data);
	        }
	      });
	
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(config) {
	          _this2.handleConfig(config);
	        },
	        'updated:roster': function updatedRoster() {
	          _this2.populateAll();
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.handleNewActiveChat(jid);
	        },
	        'updated:allRooms': function updatedAllRooms() {
	          _this2.handleAllRoomsUpdate();
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          _this2.handleActiveRoomsUpdate(rooms);
	        },
	        'updated:preferences': function updatedPreferences(prefs) {
	          if (prefs.theme !== _this2.data.theme) {
	            _this2.set('theme', prefs.theme);
	          }
	        },
	        'room-deleted': function roomDeleted(room) {
	          _this2.handleRoomDeleted(room.jid);
	        },
	        'filter-lobby': function filterLobby(filter) {
	          _this2.handleFilter(true, filter);
	        },
	        'set-lobby-filter-text': function setLobbyFilterText(data) {
	          _this2.set('input_text', data.text);
	        },
	        'updated:web_server': function updatedWeb_server(web_server) {
	          _this2.set("web_server", web_server);
	        },
	        'lobby-reset-selected-item': function lobbyResetSelectedItem() {
	          _this2.set('selected_item', 0);
	        },
	        'lobby-item-hover': function lobbyItemHover(data) {
	          _this2.set({
	            selected_item: data.index
	          });
	        },
	        'lobby-select-next-item': function lobbySelectNextItem() {
	          _this2._selectNextItem();
	        },
	        'lobby-select-prev-item': function lobbySelectPrevItem() {
	          _this2._selectPrevItem();
	        },
	        'show-modal-dialog': function showModalDialog() {
	          _this2.set('dialog_visible', true);
	        },
	        'hide-modal-dialog': function hideModalDialog() {
	          _this2.set('dialog_visible', false);
	        }
	      });
	    }
	  }, {
	    key: 'handleConfig',
	    value: function handleConfig(config) {
	      this.set({
	        user_is_admin: _.get(config, "is_admin", false),
	        invite_url: _.get(config, "invite_url", false)
	      });
	    }
	  }, {
	    key: 'handleNewActiveChat',
	    value: function handleNewActiveChat(jid) {
	      this.data.is_active = _utils2.default.jid.is_lobby(jid);
	      if (this.data.is_active) {
	        this.populateAll();
	        this.handleFilter();
	      } else {
	        this.clearAll();
	      }
	    }
	  }, {
	    key: 'handleAllRoomsUpdate',
	    value: function handleAllRoomsUpdate() {
	      if (this.data.is_active) {
	        this.populateAll();
	        this.handleFilter();
	      }
	    }
	  }, {
	    key: 'handleActiveRoomsUpdate',
	    value: function handleActiveRoomsUpdate(rooms) {
	      var updated = _.keys(rooms);
	      var forceUpdate = !_.isEqual(this.local.active, updated);
	      this.local.active = updated;
	      if (this.data.is_active) {
	        this.handleFilter(forceUpdate);
	      }
	    }
	  }, {
	    key: 'clearAll',
	    value: function clearAll() {
	      this.local.all = [];
	    }
	  }, {
	    key: 'populateAll',
	    value: function populateAll() {
	
	      if (!this.data.is_active) {
	        return;
	      }
	
	      var roster = this.removeGuests(_application_store2.default.get("roster")),
	          rooms = _.toArray(_application_store2.default.get("allRooms")),
	          all = rooms.concat(roster),
	          updated = this.removeArchivedAndEmpty(all);
	
	      this.local.forceUpdate = !_.isEqual(this.local.all, updated);
	      this.local.all = updated;
	    }
	  }, {
	    key: 'handleFilter',
	    value: function handleFilter() {
	      var update = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	      var filter = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	      var chats_have_changed = update || this.local.forceUpdate,
	          chats = !chats_have_changed && this.data.filtered ? this.data.filtered : this.local.all,
	          scope = filter.scope || this.data.filter.scope,
	          is_scoped = scope === 'rooms' || scope === 'people',
	          query = _.isString(filter.query) ? filter.query : this.data.filter.query;
	
	      if (is_scoped && (chats_have_changed || filter.scope)) {
	        chats = _.filter(chats, function (item) {
	          if (scope === 'rooms') {
	            return _utils2.default.jid.is_room(item.jid);
	          }
	          if (scope === 'people') {
	            return _utils2.default.jid.is_private_chat(item.jid);
	          }
	          return false;
	        });
	      }
	
	      if (chats_have_changed || _.isString(filter.query)) {
	        chats = (0, _chat_search.chatSearch)(chats, query, this.local.active);
	      }
	
	      this.local.forceUpdate = false;
	
	      this.set({
	        filtered: chats,
	        filter: {
	          scope: scope || 'all',
	          query: query || ''
	        },
	        selected_item: chats_have_changed ? 0 : this.data.selected_item,
	        filtered_time: new Date().getTime()
	      });
	    }
	  }, {
	    key: 'removeGuests',
	    value: function removeGuests(roster) {
	      return _.reject(roster, _utils2.default.user.is_guest);
	    }
	  }, {
	    key: 'removeArchivedAndEmpty',
	    value: function removeArchivedAndEmpty(items) {
	      return _.reject(items, function (item) {
	        return !item || item.name === '' || _utils2.default.room.is_archived(item);
	      });
	    }
	  }, {
	    key: 'handleRoomDeleted',
	    value: function handleRoomDeleted(jid) {
	      if (this.data.is_active) {
	        this.local.all = _.reject(this.data.all, { jid: jid });
	        this.local.forceUpdate = true;
	        this.handleFilter();
	      }
	    }
	  }, {
	    key: '_selectNextItem',
	    value: function _selectNextItem() {
	      this.set('selected_item', this.data.selected_item + 1);
	    }
	  }, {
	    key: '_selectPrevItem',
	    value: function _selectPrevItem() {
	      this.set('selected_item', this.data.selected_item - 1);
	    }
	  }]);
	  return LobbyStore;
	}(_store2.default);
	
	module.exports = new LobbyStore();

/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _empty_state_strings = __webpack_require__(440);
	
	var _empty_state_strings2 = _interopRequireDefault(_empty_state_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "LobbyEmptyState",
	
	  shouldComponentUpdate: function shouldComponentUpdate() {
	    return false;
	  },
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "empty empty-lobby" },
	      React.createElement(
	        "div",
	        { className: "empty-state" },
	        React.createElement("div", { className: "empty-lobby-state-img" }),
	        React.createElement(
	          "div",
	          { className: "empty-state-msg" },
	          React.createElement(
	            "p",
	            { className: "empty-header" },
	            _empty_state_strings2.default.empty_lobby_title
	          ),
	          React.createElement(
	            "p",
	            { className: "empty-msg" },
	            _empty_state_strings2.default.empty_lobby_message
	          )
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	var _empty_state_strings = __webpack_require__(440);
	
	var _empty_state_strings2 = _interopRequireDefault(_empty_state_strings);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "LobbyEmptySearchState",
	
	  mixin: [_reactAddonsPureRenderMixin2.default],
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      inputText: ""
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    _analytics_actions2.default.lobbyNoResults(this.props.inputText);
	  },
	
	  _inviteLink: function _inviteLink() {
	
	    if (this.props.userIsAdmin || this.props.inviteUrl) {
	
	      var link = React.createElement(
	        'a',
	        { target: '_blank', className: 'aui-inline-dialog-trigger', onClick: this.props.inviteAction },
	        _common_strings2.default.buttons.invite_team_in_lobby
	      );
	
	      if (!this.props.inviteUrl) {
	        link = React.createElement(
	          'a',
	          { target: '_blank', className: 'aui-inline-dialog-trigger', href: 'https://' + this.props.webServer + '/admin' },
	          _common_strings2.default.buttons.invite_team_in_lobby
	        );
	      }
	
	      return React.createElement(
	        'p',
	        { className: 'empty-msg' },
	        link
	      );
	    }
	  },
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'empty empty-lobby empty-search-lobby' },
	      React.createElement(
	        'div',
	        { className: 'empty-state' },
	        React.createElement('div', { className: 'empty-search-lobby-state-img' }),
	        React.createElement(
	          'div',
	          { className: 'empty-state-msg' },
	          React.createElement(
	            'p',
	            { className: 'empty-header' },
	            _empty_state_strings2.default.empty_search_lobby
	          ),
	          this._inviteLink()
	        )
	      )
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _lobby_actions = __webpack_require__(296);
	
	var _lobby_actions2 = _interopRequireDefault(_lobby_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'LobbyItem',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _onMouseEnter: function _onMouseEnter(evt) {
	    if (_mouse_position2.default.hasChanged(evt)) {
	      _lobby_actions2.default.itemHovered({
	        index: this.props.item_index
	      });
	    }
	  },
	
	  _onOpenChat: function _onOpenChat() {
	    _lobby_actions2.default.openChat({
	      jid: this.props.jid,
	      name: this.props.name,
	      type: this.props.type
	    });
	  },
	
	  _getIcon: function _getIcon() {
	    var icon = void 0;
	
	    if (this.props.type === 'groupchat') {
	      icon = React.createElement('span', { className: 'aui-icon hipchat-icon-small icon-' + this.props.privacy });
	    } else {
	      icon = React.createElement(_person_avatar2.default, { avatar_url: this.props.photo_url,
	        presence: this.props.presence_show,
	        size: 'small',
	        uid: this.props.user_id,
	        shouldAnimate: this.props.should_animate_avatar,
	        active: true });
	    }
	
	    return icon;
	  },
	
	  _getMention: function _getMention() {
	    var mention = this.props.mention_match_markup || this.props.mention_name,
	        mention_markup = { __html: '@' + mention };
	
	    return React.createElement('span', { className: 'hc-lobby-list-mention-name', dangerouslySetInnerHTML: mention_markup });
	  },
	
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      'hc-lobby-list-item': true,
	      'selected': this.props.selected
	    }),
	        icon = this._getIcon(),
	        mention = this.props.mention_name ? this._getMention() : null;
	
	    return React.createElement(
	      'div',
	      { className: classes, onClick: this._onOpenChat, onMouseEnter: this._onMouseEnter },
	      React.createElement(
	        'div',
	        { className: 'hc-lobby-list-icon' },
	        icon
	      ),
	      React.createElement(
	        'div',
	        { className: 'hc-lobby-list-names' },
	        React.createElement('span', { className: 'hc-lobby-list-name ' + this.props.type, dangerouslySetInnerHTML: { __html: this.props.name_match_markup || _.escape(this.props.name) } }),
	        mention
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "LobbyMessage",
	
	  mixin: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    webServer: React.PropTypes.string.isRequired,
	    theme: React.PropTypes.string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      webServer: '',
	      theme: 'light'
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    var $iframe = this._getIframe();
	    $iframe.hide();
	    $iframe.on('load', this._onIframeLoad);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._getIframe().off('load', this._onIframeLoad);
	  },
	  _getIframe: function _getIframe() {
	    return $(ReactDOM.findDOMNode(this.refs.blog_info));
	  },
	  _getIframeBody: function _getIframeBody() {
	    return _.get(this._getIframe().get(0), 'contentWindow.document.body');
	  },
	  _onIframeLoad: function _onIframeLoad() {
	
	    _logger2.default.type('blog-info-iframe').log('Iframe was loaded');
	
	    var $iframe = this._getIframe(),
	        contentCheck = $iframe.contents().has("#blog-info").length;
	
	    if (contentCheck) {
	
	      var $body = $(this._getIframeBody()),
	          hasContent = $body.children().length;
	
	      if (hasContent) {
	        $iframe.show();
	        var height = $iframe.contents().find("html").outerHeight();
	        $iframe.height(height);
	        $body.find("a").on("click", this._handleIframeClick);
	        _logger2.default.type('blog-info-iframe').log('Iframe is shown with height:', height);
	      } else {
	        _logger2.default.type('blog-info-iframe').log('Iframe is hidden because content is not found');
	      }
	    } else {
	      _logger2.default.type('blog-info-iframe').log('Iframe is hidden because error occurred');
	    }
	  },
	  _handleIframeClick: function _handleIframeClick(e) {
	
	    var $target = $(e.currentTarget),
	        href = $target.attr('href'),
	        analyticsEvent = $target.attr('analytics');
	
	    e.preventDefault();
	
	    if (href) {
	      window.open(href, '_blank');
	      _logger2.default.type('blog-info-iframe').log('Link opened: ', href);
	    }
	
	    if (analyticsEvent) {
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: analyticsEvent
	      });
	    }
	  },
	  render: function render() {
	    return React.createElement('iframe', { ref: 'blog_info', id: 'blog-info-iframe', src: 'https://' + this.props.webServer + '/blog_info?theme=' + this.props.theme });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _search_store = __webpack_require__(506);
	
	var _search_store2 = _interopRequireDefault(_search_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _search_actions = __webpack_require__(507);
	
	var _search_actions2 = _interopRequireDefault(_search_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var cssVersion = new Date().getTime();
	
	exports.default = React.createClass({
	
	  displayName: "SearchResults",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  _getState: function _getState() {
	    return {
	      apiv1_token: _configuration_store2.default.get("apiv1_token"),
	      text: _search_store2.default.get("text"),
	      jid: _search_store2.default.get("jid"),
	      web_server: _search_store2.default.get("web_server"),
	      active_chat: _search_store2.default.get('active_chat'),
	      theme: _preferences_store2.default.getTheme()
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    _search_store2.default.on(['change:text', 'change:jid', 'change:web_server', 'change:active_chat'], this._onChange);
	    _configuration_store2.default.on(['change:apiv1_token'], this._onChange);
	    _preferences_store2.default.on(['change:theme'], this._onChange);
	    this.previousSearchURL = this._getSearchUrl();
	    this._bindIframeLoad();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _search_store2.default.off(['change:text', 'change:jid', 'change:web_server', 'change:active_chat'], this._onChange);
	    _configuration_store2.default.off(['change:apiv1_token'], this._onChange);
	    _preferences_store2.default.off(['change:theme'], this._onChange);
	    this._unbindIframeLoad();
	  },
	
	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    if (nextState.active_chat !== this.state.active_chat && _utils2.default.jid.is_search(this.state.active_chat) && !_utils2.default.jid.is_search(nextState.active_chat)) {
	      $(this._getIframeBody()).find("#select2-drop-mask").click();
	    }
	  },
	
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    var _this = this;
	
	    if (prevState.text !== this.state.text || prevState.jid !== this.state.jid) {
	      this._hideIframe();
	    }
	
	    if (prevState.apiv1_token !== this.state.apiv1_token) {
	      // this delay is to ensure the native app has time to update the cookie
	      _.delay(function () {
	        $(_this._getIframe()).attr('src', _this.previousSearchURL);
	        $(_this._getIframe()).show();
	      }, 1000);
	    }
	
	    if (prevState.theme !== this.state.theme) {
	      this._unbindIframeLoad();
	      this._bindIframeLoad();
	      this._reloadIframe();
	    }
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _bindIframeLoad: function _bindIframeLoad() {
	    this._getIframe().on("load", this._onIframeLoad);
	  },
	
	  _unbindIframeLoad: function _unbindIframeLoad() {
	    this._getIframe().off("load", this._onIframeLoad);
	  },
	
	  _reloadIframe: function _reloadIframe() {
	    var location = _.get(this._getIframe().get(0), 'contentWindow.location');
	    if (location && typeof location.reload === 'function') {
	      location.reload(true);
	    }
	  },
	
	  _getIframe: function _getIframe() {
	    return $(ReactDOM.findDOMNode(this.refs.search_results));
	  },
	
	  _getIframeHead: function _getIframeHead() {
	    return _.get(this._getIframe().get(0), 'contentWindow.document.head');
	  },
	
	  _getIframeBody: function _getIframeBody() {
	    return _.get(this._getIframe().get(0), 'contentWindow.document.body');
	  },
	
	  _onIframeLoad: function _onIframeLoad() {
	    var $body = $(this._getIframeBody()),
	        $iframe = this._getIframe();
	
	    // If our API V1 token is invalid the server redirects to the sign in page. Users shouldn't see this.
	    if (_app_config2.default.login_page_redirect_regex.test(_.get($iframe.get(0), 'contentWindow.location.pathname', ''))) {
	      return this._handleLoginRedirect();
	    }
	
	    this.previousSearchURL = _.get($iframe.get(0), 'contentWindow.location.href');
	
	    if (!$body.hasClass("embedded-search-page")) {
	      $body.addClass("embedded-search-page");
	    }
	
	    $body.find("form").on("submit", this._hideIframe);
	    $body.find("a").on("click", this._handleIframeClick);
	    $body.find("form [type=text]").on("keydown", function (e) {
	      if (e.keyCode === _utils2.default.keyCode.Esc) {
	        $body.find("form [type=text]").val("");
	      } else if (e.keyCode === _utils2.default.keyCode.Enter) {
	        _analytics_actions2.default.searchInputSubmitted($body.find("#chat-select").val());
	      }
	    });
	
	    if (this.state.theme !== "light") {
	      var $head = $(this._getIframeHead()),
	          themeStyles = this._getThemeStyles();
	      $head.append(themeStyles);
	    }
	
	    $iframe.show();
	  },
	
	  _handleIframeClick: function _handleIframeClick(e) {
	    var $target = $(e.currentTarget),
	        href = $target.attr('href');
	    if ($target.attr("target") !== "_blank" && !$target.parent().hasClass("file-meta") && $target.parents('.hc-chat-row').length && !$target.parents('.hc-chat-time').length) {
	
	      // hide/show links
	      if (href.indexOf('javascript') === 0) {
	        e.preventDefault();
	      } else if (href) {
	        _logger2.default.type('search-results').log('Target contains external link, it will be opened in new window: ', href);
	        e.preventDefault();
	        window.open(href, '_blank');
	      } else {
	        this._hideIframe();
	      }
	    } else {
	      if (!href) {
	        _logger2.default.type('search-results').log('Link is empty and it skipped.');
	        e.preventDefault();
	      }
	    }
	  },
	
	  _hideIframe: function _hideIframe() {
	    $(this._getIframe()).hide();
	  },
	
	  /**
	   * In the rare occurance that your API v1 token becomes invalid and user attempts to search
	   * we request a new token and reload the search page.
	   */
	  _handleLoginRedirect: function _handleLoginRedirect() {
	    this._hideIframe();
	    _search_actions2.default.updateAPIV1Token();
	  },
	
	  _getThemeStyles: function _getThemeStyles() {
	    var url = 'https://' + this.state.web_server + '/wc/' + this.state.theme + '.css?v=' + cssVersion;
	    return '<link rel=\'stylesheet\' href=\'' + url + '\' type=\'text/css\'>';
	  },
	
	  _getSearchUrl: function _getSearchUrl() {
	    if (this.state.jid) {
	      var jid = this.state.jid,
	          url = 'https://' + this.state.web_server + '/embedded/search?adg=true&q=' + this.state.text;
	
	      if (_utils2.default.jid.is_chat(jid) && _utils2.default.jid.is_private_chat(jid)) {
	        url += '&t=uid-' + _utils2.default.jid.user_id(jid);
	      } else if (_utils2.default.jid.is_chat(jid) && _utils2.default.jid.is_room(jid)) {
	        url += '&r=' + _utils2.default.jid.room_name(jid);
	      }
	
	      return encodeURI(url);
	    }
	  },
	
	  render: function render() {
	    var containerClasses = (0, _classnames2.default)({
	      "hc-rooms-container": true,
	      "hc-rooms-container-hidden": !this.props.visible
	    }),
	        iframeStyles = {
	      display: this.state.theme !== "light" ? 'none' : "block"
	    };
	
	    return React.createElement(
	      'div',
	      { className: containerClasses },
	      React.createElement('iframe', { ref: 'search_results', id: 'search-container', src: this._getSearchUrl(), style: iframeStyles })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AppDispatcher = __webpack_require__(9);
	var AppActions = __webpack_require__(195);
	var Store = __webpack_require__(97);
	var utils = __webpack_require__(99);
	var AppConfig = __webpack_require__(121);
	
	var SearchStore = function (_Store) {
	  (0, _inherits3.default)(SearchStore, _Store);
	
	  function SearchStore() {
	    (0, _classCallCheck3.default)(this, SearchStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SearchStore).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(SearchStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        jid: "",
	        text: "",
	        web_server: AppConfig.default_web_server,
	        url: "",
	        active_chat: ""
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      AppDispatcher.register({
	        'search-history': function searchHistory(search) {
	          _this2.handleSearch(search);
	        },
	        'search-history-externally': function searchHistoryExternally(search) {
	          _this2.handleSearchExternally(search);
	        },
	        'updated:web_server': function updatedWeb_server(web_server) {
	          _this2.set("web_server", web_server);
	        },
	        'updated:active_chat': function updatedActive_chat(active_chat) {
	          _this2.set("active_chat", active_chat);
	        }
	      });
	    }
	  }, {
	    key: 'handleSearch',
	    value: function handleSearch(search) {
	      this.set({
	        'jid': search.jid,
	        'text': search.text
	      });
	    }
	  }, {
	    key: 'handleSearchExternally',
	    value: function handleSearchExternally(search) {
	      var jid = search.jid,
	          url = 'https://' + this.data.web_server + '/search?q=' + search.text;
	
	      if (jid && utils.jid.is_chat(jid) && utils.jid.is_private_chat(jid)) {
	        url += '&t=uid-' + utils.jid.user_id(jid);
	      } else if (jid && utils.jid.is_chat(jid) && utils.jid.is_room(jid)) {
	        url += '&r=' + utils.jid.room_name(jid);
	      }
	      url = encodeURI(url);
	      AppActions.openExternalWindow(url, '_blank');
	      this.set({
	        'url': url,
	        'jid': search.jid,
	        'text': search.text
	      });
	    }
	  }]);
	  return SearchStore;
	}(Store);
	
	module.exports = new SearchStore();

/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SearchActions
	 */
	exports.default = {
	  updateAPIV1Token: function updateAPIV1Token() {
	    _app_dispatcher2.default.dispatch('apiv1-token-update-requested');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _roster = __webpack_require__(509);
	
	var _roster2 = _interopRequireDefault(_roster);
	
	var _files = __webpack_require__(515);
	
	var _files2 = _interopRequireDefault(_files);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _links = __webpack_require__(519);
	
	var _links2 = _interopRequireDefault(_links);
	
	var _integrations = __webpack_require__(522);
	
	var _integrations2 = _interopRequireDefault(_integrations);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getPanelState() {
	  var integrationsEnabled = _roster_store2.default.get('web_client_integrations_enabled');
	  return {
	    groupchat_active_panel: _preferences_store2.default.getGroupChatActivePanel(),
	    chat_active_panel: _preferences_store2.default.getChatActivePanel(),
	    chat_type: _roster_store2.default.get('chat_type'),
	    loading: _roster_store2.default.get('loading') && !integrationsEnabled,
	    initialized: _roster_store2.default.get('initialized'),
	    web_client_integrations: integrationsEnabled,
	    guest_url: _roster_store2.default.get('guest_url'),
	    active_chat: _roster_store2.default.get('active_chat')
	  };
	}
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBar",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return getPanelState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _roster_store2.default.on('change', this._onChange);
	    _preferences_store2.default.on(['change'], this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _roster_store2.default.off('change', this._onChange);
	    _preferences_store2.default.off(['change'], this._onChange);
	  },
	
	  _getActivePanel: function _getActivePanel() {
	    var panel;
	    if (this.state.chat_type === "chat") {
	      switch (this.state.chat_active_panel) {
	        case "files":
	          panel = this._filesPanel();
	          break;
	        case "links":
	          panel = this._linksPanel();
	          break;
	        case "integrations":
	          if (this.state.web_client_integrations) {
	            panel = this._integrationsPanel();
	          }
	          break;
	      }
	    } else if (this.state.chat_type === "groupchat") {
	      switch (this.state.groupchat_active_panel) {
	        case "roster":
	          panel = this._rosterPanel();
	          break;
	        case "files":
	          panel = this._filesPanel();
	          break;
	        case "links":
	          panel = this._linksPanel();
	          break;
	        case "integrations":
	          if (this.state.web_client_integrations) {
	            panel = this._integrationsPanel();
	          }
	          break;
	      }
	    }
	    return panel;
	  },
	
	  _rosterPanel: function _rosterPanel() {
	    return React.createElement(_roster2.default, { is_guest: this.props.is_guest });
	  },
	
	  _filesPanel: function _filesPanel() {
	    return React.createElement(_files2.default, { is_guest: this.props.is_guest });
	  },
	
	  _linksPanel: function _linksPanel() {
	    return React.createElement(_links2.default, { is_guest: this.props.is_guest });
	  },
	
	  _integrationsPanel: function _integrationsPanel() {
	    return React.createElement(_integrations2.default, null);
	  },
	
	  _onChange: function _onChange() {
	    this.setState(getPanelState());
	  },
	
	  _shouldHidePanelWhenLoading: function _shouldHidePanelWhenLoading() {
	    return this.state.chat_active_panel !== "files" && this.state.chat_active_panel !== "links";
	  },
	
	
	  render: function render() {
	    var panel = this.state.loading && this._shouldHidePanelWhenLoading() ? "" : this._getActivePanel();
	    return React.createElement(
	      'div',
	      { className: 'hc-roster-container' },
	      React.createElement(_spinner2.default, { spin: this.state.loading && this.state.initialized, zIndex: 1 }),
	      panel
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _person_helper = __webpack_require__(510);
	
	var _person_helper2 = _interopRequireDefault(_person_helper);
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _roster_empty_state = __webpack_require__(511);
	
	var _roster_empty_state2 = _interopRequireDefault(_roster_empty_state);
	
	var _roster_panel_strings = __webpack_require__(512);
	
	var _roster_panel_strings2 = _interopRequireDefault(_roster_panel_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _permissions_store = __webpack_require__(269);
	
	var _permissions_store2 = _interopRequireDefault(_permissions_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _right_panel_actions = __webpack_require__(513);
	
	var _right_panel_actions2 = _interopRequireDefault(_right_panel_actions);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _sidebar_actions = __webpack_require__(514);
	
	var _sidebar_actions2 = _interopRequireDefault(_sidebar_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _room_size = __webpack_require__(272);
	
	var _room_size2 = _interopRequireDefault(_room_size);
	
	var _app_config = __webpack_require__(121);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "RightSideBarRoster",
	
	  propTypes: {
	    is_guest: React.PropTypes.bool.isRequired
	  },
	
	  getInitialState: function getInitialState() {
	    return _.assign(this._getState(), {
	      selectedPerson: false
	    });
	  },
	
	  componentDidMount: function componentDidMount() {
	    var size = 0;
	
	    var members = _.get(this.state, "participants.members");
	    if (members) {
	      size = members.length;
	    }
	
	    _roster_store2.default.on(['change'], this._onChange);
	
	    var id = _roster_store2.default.get('active_chat');
	    _right_panel_actions2.default.rosterMounted({ id: id, size: size });
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _roster_store2.default.off(['change'], this._onChange);
	  },
	
	  _getState: function _getState() {
	    return {
	      can_view_guest_access: _permissions_store2.default.canViewGuestAccess(),
	      should_animate_gif_avatars: !_configuration_store2.default.get('feature_flags').web_client_freeze_gifs,
	      active_chat_privacy: _roster_store2.default.get('active_chat_privacy'),
	      admins: _roster_store2.default.get('admins'),
	      owner: _roster_store2.default.get('owner'),
	      participants: _roster_store2.default.get('participants'),
	      users: _roster_store2.default.get('users'),
	      current_user: _roster_store2.default.get("current_user"),
	      user_is_admin: _roster_store2.default.get('user_is_admin'),
	      guest_url: _roster_store2.default.get('guest_url'),
	      invite_url: _roster_store2.default.get('invite_url'),
	      active_chat: _roster_store2.default.get('active_chat'),
	      size: _roster_store2.default.get('size'),
	      roster: _roster_store2.default.getRoster()
	    };
	  },
	
	  _onChange: function _onChange() {
	    var newState = _.assign(this._getState(), {
	      selectedPerson: this.state.selectedPerson
	    });
	
	    if (this.isMounted()) {
	      this.setState(newState);
	    }
	  },
	
	  _onClick: function _onClick(jid) {
	    this.setState({
	      selectedPerson: jid
	    });
	  },
	
	  _onDoubleClick: function _onDoubleClick(jid, name) {
	    if (_.find(this.state.participants.members, { jid: jid }) && !this.props.is_guest) {
	      _sidebar_actions2.default.openChat({ jid: jid, name: name });
	    }
	  },
	
	  _showEmptyState: function _showEmptyState() {
	    var current_user_jid = this.state.current_user.user_jid,
	        members = this.state.participants['members'],
	        guests = this.state.participants['guests'],
	        result;
	
	    if (members.length === 1 && !guests.length) {
	      result = _.find(members, { jid: current_user_jid });
	    } else if (guests.length === 1 && !members.length) {
	      result = _.find(guests, { jid: current_user_jid });
	    }
	    return result ? true : false;
	  },
	
	  _isAdmin: function _isAdmin(user) {
	    return _utils2.default.user.is_admin(this.state.admins, false, user);
	  },
	
	  _isOwner: function _isOwner(user) {
	    var id = _.get(user, 'user_id') || _.get(user, 'id');
	    return Number(id) === Number(this.state.owner);
	  },
	
	  _hasMembersAndGuests: function _hasMembersAndGuests() {
	    return _.size(this.state.participants['members']) && _.size(this.state.participants['guests']);
	  },
	
	  _getTooltip: function _getTooltip(user) {
	    return _person_helper2.default.get_user_tooltip({
	      name: user.name,
	      mention_name: user.mention_name,
	      is_admin: this._isAdmin(user),
	      is_owner: this._isOwner(user),
	      presence: user.presence
	    });
	  },
	
	
	  _renderItem: function _renderItem(index, key) {
	    var item = this.state.roster[index],
	        style = {
	      'height': _app_config.roster_panel.group_title_item_height + 'px'
	    };
	
	    if (item.group_title) {
	      return React.createElement(
	        'li',
	        { key: key, className: 'aui-nav-heading', style: style },
	        React.createElement(
	          'div',
	          { className: 'uppercase' },
	          _roster_panel_strings2.default[item.group_title]
	        )
	      );
	    } else if (item.letter) {
	      return React.createElement(
	        'li',
	        { key: key, className: 'aui-nav-heading', style: style },
	        React.createElement(
	          'div',
	          { className: 'uppercase' },
	          item.letter
	        )
	      );
	    }
	
	    return this._getPerson(item, key);
	  },
	
	  _getPerson: function _getPerson(user, key) {
	    var presence = _.get(user, 'presence', {}),
	        tooltip = this._getTooltip(user),
	        linkClasses = (0, _classnames2.default)({
	      'hc-roster-link': true,
	      'hc-roster-admin': this._isAdmin(user)
	    }),
	        rosterItemClasses = (0, _classnames2.default)({
	      'hc-roster-item': true,
	      'aui-nav-selected': this.state.selectedPerson === user.jid
	    }),
	        style = {
	      height: 'auto'
	    },
	        id = user.id || _utils2.default.jid.user_id(user.jid);
	
	    if (this.state.size !== _room_size2.default.SMALL) {
	      style.height = _app_config.roster_panel.person_item_height + 'px';
	    }
	
	    return React.createElement(
	      'li',
	      { key: 'user-' + id,
	        className: rosterItemClasses,
	        'data-status': presence.show,
	        onClick: this._onClick.bind(this, user.jid),
	        onDoubleClick: this._onDoubleClick.bind(this, user.jid, user.name),
	        style: style },
	      React.createElement(
	        'div',
	        { className: 'aui-nav-item' },
	        React.createElement(_person_avatar2.default, { avatar_url: user.photo_url,
	          name: user.name,
	          presence: presence.show,
	          size: this._getAvatarSize(),
	          shouldAnimate: this.state.should_animate_gif_avatars,
	          uid: user.id }),
	        React.createElement(
	          'a',
	          { className: linkClasses, 'aria-label': tooltip },
	          user.name
	        )
	      )
	    );
	  },
	
	
	  _getItemSize: function _getItemSize(index) {
	    var item = this.state.roster[index];
	
	    if (item.group_title || item.letter) {
	      return _app_config.roster_panel.group_title_item_height;
	    }
	    return _app_config.roster_panel.person_item_height;
	  },
	
	  _getAvatarSize: function _getAvatarSize() {
	    if (this.state.size === _room_size2.default.SMALL) {
	      return 'small';
	    }
	    return 'xsmall';
	  },
	  _onClickQuickSwitcher: function _onClickQuickSwitcher() {
	    _dialog_actions2.default.showQuickSwitcherDialog();
	  },
	  _getXLargeState: function _getXLargeState() {
	    return React.createElement(
	      'div',
	      { className: 'hc-roster-xlarge-msg' },
	      _roster_panel_strings2.default.xlarge_message,
	      ' ',
	      React.createElement(
	        'a',
	        { onClick: this._onClickQuickSwitcher },
	        _roster_panel_strings2.default.quick_switcher
	      ),
	      '.'
	    );
	  },
	  _getEmptyState: function _getEmptyState() {
	    return React.createElement(_roster_empty_state2.default, { room_privacy: this.state.active_chat_privacy,
	      isAdmin: this._isAdmin(this.state.users[this.state.current_user.user_jid]),
	      invite_url: this.state.invite_url,
	      user_is_admin: this.state.user_is_admin });
	  },
	  _getList: function _getList() {
	    if (this.state.size === _room_size2.default.XLARGE) {
	      return null;
	    } else if (this.state.size === _room_size2.default.LARGE) {
	      return this._getDynamicList();
	    }
	    return this._getStaticList();
	  },
	  _getStaticList: function _getStaticList() {
	    var _this = this;
	
	    return _.map(this.state.roster, function (user, u) {
	      return _this._renderItem(u, u);
	    });
	  },
	  _getDynamicList: function _getDynamicList() {
	    return React.createElement(ReactList, {
	      itemRenderer: this._renderItem,
	      itemSizeGetter: this._getItemSize,
	      items: this.state.roster,
	      length: this.state.roster.length,
	      selected: this.state.selectedPerson,
	      threshold: 200,
	      useTranslate3d: false,
	      type: 'variable' });
	  },
	
	
	  render: function render() {
	    var guestAccessEnabled = this.state.guest_url && !this.props.is_guest && this.state.can_view_guest_access,
	        emptyState = this._showEmptyState() ? this._getEmptyState() : null,
	        xLargeState = this.state.size === _room_size2.default.XLARGE ? this._getXLargeState() : null,
	        guest_url_message = void 0;
	
	    var rosterWrapClasses = (0, _classnames2.default)({
	      'roster-wrap': true,
	      'guest-access-enabled': guestAccessEnabled
	    });
	
	    var rosterClasses = (0, _classnames2.default)({
	      'hc-roster': true,
	      'hc-sidebar-scroll': true
	    });
	
	    var listClasses = (0, _classnames2.default)({
	      'aui-nav': true,
	      'aui-navgroup-vertical': true,
	      'roster-list': true
	    });
	
	    var list = this._getList();
	
	    if (guestAccessEnabled) {
	      var guest_url_string = this.state.guest_url.split('://').pop();
	      guest_url_message = React.createElement(
	        'div',
	        { className: 'guest-access' },
	        React.createElement(
	          'strong',
	          null,
	          _roster_panel_strings2.default.guest_access_enabled
	        ),
	        React.createElement('br', null),
	        React.createElement(
	          'a',
	          { href: this.state.guest_url, target: '_blank' },
	          guest_url_string
	        )
	      );
	    }
	
	    return React.createElement(
	      'div',
	      { className: rosterWrapClasses },
	      React.createElement(
	        'div',
	        { className: rosterClasses },
	        xLargeState,
	        React.createElement(
	          'ul',
	          { className: listClasses, 'data-skate-ignore': true },
	          list
	        ),
	        emptyState
	      ),
	      guest_url_message
	    );
	  }
	});

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _tooltip_strings = __webpack_require__(462);
	
	var _tooltip_strings2 = _interopRequireDefault(_tooltip_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  get_user_tooltip_flat: function get_user_tooltip_flat(user_name, user_mention_name, user_is_admin, user_presence_show, user_presence_status, user_presence_idle_time) {
	    var title = user_name + '\n' + ('@' + user_mention_name + '\n') + (_tooltip_strings2.default.status + ' ' + _utils2.default.user.get_user_status(user_presence_show));
	
	    if (user_presence_show === _presence2.default.IDLE && user_presence_idle_time) {
	      title += ' - ' + user_presence_idle_time;
	    }
	    if (user_is_admin) {
	      title += '\n' + _tooltip_strings2.default.admin;
	    }
	    if (user_presence_status) {
	      title += '\n' + this._splitToLines(_tooltip_strings2.default.message + ' ' + user_presence_status);
	    }
	    return title;
	  },
	
	  _splitToLines: function _splitToLines(str) {
	    var maxLength = arguments.length <= 1 || arguments[1] === undefined ? 50 : arguments[1];
	
	    var sumLength = 0;
	    if (str.length <= maxLength) {
	      return str;
	    }
	    return str.split(' ').reduce(function (acc, part, index, arr) {
	      sumLength += part.length;
	      if (index === arr.length - 1) {
	        acc.push(part);
	      } else if (sumLength > maxLength) {
	        acc.push(part + '\n');
	        sumLength = 0;
	      } else {
	        acc.push(part + ' ');
	        sumLength = part.match('\n') ? 0 : sumLength;
	      }
	
	      return acc;
	    }, []).join('');
	  },
	
	
	  get_user_tooltip: function get_user_tooltip(user) {
	    var presence = user.presence || {};
	    return this.get_user_tooltip_flat(user.name, user.mention_name, user.is_admin, presence.show, presence.status, presence.idleTime);
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _empty_state_strings = __webpack_require__(440);
	
	var _empty_state_strings2 = _interopRequireDefault(_empty_state_strings);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _analytics_keys = __webpack_require__(197);
	
	var _analytics_keys2 = _interopRequireDefault(_analytics_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBarRosterEmptyState",
	
	  _openInviteUsers: function _openInviteUsers(e) {
	    e.preventDefault();
	    _dialog_actions2.default.showInviteUsersDialog({ type: _analytics_keys2.default.RIGHT_SIDEBAR });
	    _analytics_actions2.default.inviteUserToRoomClickedEvent("roster");
	    _analytics_actions2.default.inviteToRoomRightSidebarClicked();
	  },
	
	  _openInviteTeam: function _openInviteTeam(e) {
	    e.preventDefault();
	    _dialog_actions2.default.showInviteTeammatesDialog();
	    _analytics_actions2.default.inviteTeamClickedEvent("roster");
	  },
	
	  _getInviteMessage: function _getInviteMessage() {
	    var message;
	    if (this.props.room_privacy === "private" && !this.props.isAdmin) {
	      message = React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "div",
	          { className: "hc-tab-es-title" },
	          _empty_state_strings2.default.empty_private_room
	        )
	      );
	    } else {
	      var inviteAction, inviteMessage, inviteActionMessage;
	
	      if (_.size(this.props.users) === 1 && (this.props.user_is_admin || this.props.invite_url)) {
	        inviteAction = this._openInviteTeam;
	        inviteMessage = _empty_state_strings2.default.invite_to_team;
	        inviteActionMessage = _empty_state_strings2.default.invite_to_team_action;
	      } else {
	        inviteAction = this._openInviteUsers;
	        inviteMessage = _empty_state_strings2.default.invite_to_room;
	        inviteActionMessage = _empty_state_strings2.default.invite_to_room_action;
	      }
	
	      message = React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "div",
	          { className: "hc-tab-es-title" },
	          inviteMessage
	        ),
	        React.createElement(
	          "div",
	          { className: "hc-tab-es-msg" },
	          React.createElement(
	            "a",
	            { className: "hc-tab-es-invite aui-inline-dialog-trigger", onClick: inviteAction },
	            inviteActionMessage
	          )
	        )
	      );
	    }
	    return message;
	  },
	
	  render: function render() {
	    var inviteMessage = this._getInviteMessage();
	    return React.createElement(
	      "div",
	      { className: "hc-tab-es" },
	      React.createElement("div", { className: "hc-tab-es-img roster" }),
	      inviteMessage
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  members: 'members',
	  guests: 'guests',
	  guest_access_enabled: 'Room publicly available',
	  xlarge_message: 'This room has ' + _app_config2.default.roster_panel.breakpoints.large + ' or more members. Thats too many to show. Looking for specific people? Try ',
	  quick_switcher: 'searching for them'
	};
	module.exports = exports['default'];

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  filesMounted: function filesMounted(data) {
	    _analytics_dispatcher2.default.dispatch('analytics-files-mount', data);
	  },
	
	  rosterMounted: function rosterMounted(data) {
	    _analytics_dispatcher2.default.dispatch('analytics-roster-mount', data);
	  },
	
	  fetchFilesHistory: function fetchFilesHistory() {
	    _app_dispatcher2.default.dispatch('fetch-files-history');
	  },
	  fetchLinksHistory: function fetchLinksHistory() {
	    _app_dispatcher2.default.dispatch('fetch-links-history');
	  },
	  setPanelScrollTopPosition: function setPanelScrollTopPosition(data) {
	    _app_dispatcher2.default.dispatch('set-right-sidebar-panel-scrolltop', data);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var AppDispatcher = __webpack_require__(9);
	var AnalyticsDispatcher = __webpack_require__(173);
	
	var SidebarActions = {
	  openChat: function openChat(data) {
	    AppDispatcher.dispatch('set-route', { jid: data.jid });
	    data.source = "sidebar";
	    AnalyticsDispatcher.dispatch('analytics-open-room', data);
	  }
	};
	
	module.exports = SidebarActions;

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _file = __webpack_require__(516);
	
	var _file2 = _interopRequireDefault(_file);
	
	var _files_empty_state = __webpack_require__(517);
	
	var _files_empty_state2 = _interopRequireDefault(_files_empty_state);
	
	var _right_panel_actions = __webpack_require__(513);
	
	var _right_panel_actions2 = _interopRequireDefault(_right_panel_actions);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _sidebar_list_spinner = __webpack_require__(518);
	
	var _sidebar_list_spinner2 = _interopRequireDefault(_sidebar_list_spinner);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'RightSideBarFiles',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    is_guest: React.PropTypes.bool
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  componentDidMount: function componentDidMount() {
	    _roster_store2.default.on(['change:files', 'change:rooms', 'change:panels_scroll_top', 'change:active_chat'], this._onChange);
	    _preferences_store2.default.on(['change:' + _preferences_keys2.default.USE_24_HR_FORMAT], this._onChange);
	    _right_panel_actions2.default.filesMounted({ id: _.uniqueId(), size: this.state.size });
	    this.debouncedSetScrollPosition = _.debounce(this._setScrollPosition, 200, { leading: false, trailing: true });
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _roster_store2.default.off(['change:files', 'change:rooms', 'change:panels_scroll_top', 'change:active_chat'], this._onChange);
	    _preferences_store2.default.off(['change:' + _preferences_keys2.default.USE_24_HR_FORMAT], this._onChange);
	    this.debouncedSetScrollPosition.cancel();
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    if (prevState.room !== this.state.room) {
	      if (this.state.files_fetched && this.state.size > 0) {
	        var index = this._getInitialIndex();
	        this.refs.list.scrollTo(index);
	        _logger2.default.type('files-panel').log('Scrolled to index: ', index);
	      }
	    }
	  },
	  _getState: function _getState() {
	    var _RosterStore$getAll = _roster_store2.default.getAll();
	
	    var room = _RosterStore$getAll.active_chat;
	    var files = _RosterStore$getAll.files;
	    var can_share_files = _RosterStore$getAll.can_share_files;
	    var panels_scroll_top = _RosterStore$getAll.panels_scroll_top;
	    var rooms = _RosterStore$getAll.rooms;
	
	
	    var scroll_top = _.get(panels_scroll_top[room], 'files', 0),
	        files_fetched = _.get(rooms[room], 'files_fetched', false),
	        files_fetching = _.get(rooms[room], 'files_fetching', false),
	        all_files_fetched = _.get(rooms[room], 'all_files_fetched', false),
	        size = files.length;
	
	    return {
	      room: room,
	      scroll_top: scroll_top,
	      files_fetched: files_fetched,
	      files_fetching: files_fetching,
	      all_files_fetched: all_files_fetched,
	      files: files,
	      size: size,
	      can_share_files: can_share_files,
	      use24hrTime: _preferences_store2.default.shouldUse24HrTime()
	    };
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	  _getRowHeight: function _getRowHeight() {
	    return 42;
	  },
	  _getInitialIndex: function _getInitialIndex(scroll_top) {
	    var rowHeight = this._getRowHeight();
	    return Math.floor((scroll_top || this.state.scroll_top) / rowHeight);
	  },
	  _getFile: function _getFile(index, key) {
	    var file = this.state.files[index];
	    if (!file) {
	      return React.createElement(_sidebar_list_spinner2.default, { key: key, height: this._getRowHeight() });
	    }
	    return React.createElement(_file2.default, { key: key,
	      file: file,
	      use_24hr_time: this.state.use24hrTime });
	  },
	  _filesBody: function _filesBody() {
	    return React.createElement(
	      'ul',
	      { className: 'aui-nav aui-navgroup-vertical', 'data-skate-ignore': true },
	      React.createElement(ReactList, {
	        ref: 'list',
	        itemRenderer: this._getFile,
	        length: this._getListSize(),
	        use_24hr_time: this.state.use24hrTime,
	        initialIndex: this._getInitialIndex(),
	        threshold: 0,
	        pageSize: 50,
	        itemSizeGetter: this._getRowHeight,
	        type: 'variable' })
	    );
	  },
	  _getListSize: function _getListSize() {
	    var size = this.state.size;
	    if (this.state.files_fetching) {
	      size++;
	    }
	    return size;
	  },
	  _setScrollPosition: function _setScrollPosition() {
	    var node = this.refs.scrollbox;
	
	    if (!node) {
	      return;
	    }
	
	    _right_panel_actions2.default.setPanelScrollTopPosition({
	      room: this.state.room,
	      type: 'files',
	      scroll_top: node.scrollTop
	    });
	
	    var index = this._getInitialIndex(node.scrollTop);
	    _logger2.default.type('files-panel').log('Scrolled to index:', index);
	  },
	  _onScroll: function _onScroll() {
	    this.debouncedSetScrollPosition();
	
	    if (this.state.all_files_fetched || this.state.files_fetching) {
	      return;
	    }
	
	    var node = this.refs.scrollbox;
	
	    if (node.scrollHeight - node.offsetHeight < node.scrollTop + node.offsetHeight) {
	      _right_panel_actions2.default.fetchFilesHistory();
	    }
	  },
	  render: function render() {
	    if (!this.props.is_guest && !this.state.files_fetched) {
	      return null;
	    }
	
	    var fileClasses = (0, _classnames2.default)({
	      'hc-files': true,
	      'hc-sidebar-scroll': true
	    }),
	        files_display = _.isEmpty(this.state.files) ? React.createElement(_files_empty_state2.default, { can_share_files: this.state.can_share_files }) : this._filesBody();
	
	    return React.createElement(
	      'div',
	      { className: fileClasses, ref: 'scrollbox', onScroll: this._onScroll },
	      files_display
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBarFile",
	
	  propTypes: {
	    file: React.PropTypes.object.isRequired,
	    use_24hr_time: React.PropTypes.bool.isRequired
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  render: function render() {
	
	    var time = _utils2.default.format_time(this.props.file.date, this.props.use_24hr_time);
	    return React.createElement(
	      'li',
	      { className: 'hc-roster-item' },
	      React.createElement(
	        'div',
	        { className: 'aui-nav-item', title: this.props.file.file_name },
	        React.createElement(
	          'a',
	          { className: 'hc-file-link', target: '_blank', rel: 'noreferrer',
	            href: this.props.file.url,
	            onClick: this._onClick },
	          React.createElement('span', { className: "hc-file-icon " + this.props.file.icon_class }),
	          React.createElement(
	            'span',
	            { className: 'hc-file-name' },
	            this.props.file.file_name
	          )
	        ),
	        React.createElement(
	          'span',
	          { className: 'hc-roster-user-name' },
	          this.props.file.user_name
	        ),
	        React.createElement(
	          'span',
	          { className: 'hc-roster-date' },
	          time
	        )
	      )
	    );
	  },
	
	  _onClick: function _onClick(evt) {
	    if (_file_helper2.default.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      if (evt.metaKey) {
	        _app_actions2.default.openExternalWindow(this.props.file.url, '_blank');
	      } else {
	        _file_viewer_actions2.default.openInFileViewer(this.props.file);
	      }
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _empty_state_strings = __webpack_require__(440);
	
	var _empty_state_strings2 = _interopRequireDefault(_empty_state_strings);
	
	var _file_uploader_actions = __webpack_require__(260);
	
	var _file_uploader_actions2 = _interopRequireDefault(_file_uploader_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "RightSideBarEmptyFileState",
	
	  _openFilePicker: function _openFilePicker(evt) {
	    evt.preventDefault();
	    _file_uploader_actions2.default.openFilePicker();
	  },
	
	  _getShareFileLink: function _getShareFileLink() {
	    var link = void 0;
	    if (this.props.can_share_files) {
	      link = React.createElement(
	        'a',
	        { href: '#', onClick: this._openFilePicker },
	        _empty_state_strings2.default.share_a_file
	      );
	    }
	    return link;
	  },
	
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'hc-tab-es' },
	      React.createElement('div', { className: 'hc-tab-es-img files' }),
	      React.createElement(
	        'div',
	        { className: 'hc-tab-es-title' },
	        _empty_state_strings2.default.no_files
	      ),
	      React.createElement(
	        'div',
	        { className: 'hc-tab-es-msg' },
	        this._getShareFileLink()
	      )
	    );
	  }
	});

/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'SidebarListSpinner',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  render: function render() {
	    return React.createElement(
	      'li',
	      { className: 'hc-roster-item hc-spinner-item', style: { height: this.props.height } },
	      React.createElement(_spinner2.default, { key: this.props.key, size: 'small', spin: true, zIndex: 1 })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _link = __webpack_require__(520);
	
	var _link2 = _interopRequireDefault(_link);
	
	var _links_empty_state = __webpack_require__(521);
	
	var _links_empty_state2 = _interopRequireDefault(_links_empty_state);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _right_panel_actions = __webpack_require__(513);
	
	var _right_panel_actions2 = _interopRequireDefault(_right_panel_actions);
	
	var _video_actions = __webpack_require__(172);
	
	var _video_actions2 = _interopRequireDefault(_video_actions);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _video_utils = __webpack_require__(132);
	
	var _video_utils2 = _interopRequireDefault(_video_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _sidebar_list_spinner = __webpack_require__(518);
	
	var _sidebar_list_spinner2 = _interopRequireDefault(_sidebar_list_spinner);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBarLinks",
	
	  propTypes: {
	    is_guest: React.PropTypes.bool
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _roster_store2.default.on(['change:links', 'change:rooms', 'change:panels_scroll_top', 'change:active_chat'], this._onChange);
	    _preferences_store2.default.on(['change:' + _preferences_keys2.default.USE_24_HR_FORMAT], this._onChange);
	    this.throttledSetScrollPosition = _.throttle(this._setScrollPosition, 200, { leading: false, trailing: true });
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _roster_store2.default.off(['change:links', 'change:rooms', 'change:panels_scroll_top', 'change:active_chat'], this._onChange);
	    _preferences_store2.default.off(['change:' + _preferences_keys2.default.USE_24_HR_FORMAT], this._onChange);
	    this.throttledSetScrollPosition.cancel();
	  },
	
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    if (prevState.room !== this.state.room) {
	      if (this.state.links_fetched && this.state.size > 0) {
	        var index = this._getInitialIndex();
	        this.refs.list.scrollTo(index);
	        _logger2.default.type('links-panel').log('Scrolled to index: ', index);
	      }
	    }
	  },
	  onScrollStop: function onScrollStop() {
	
	    var node = this.refs.scrollbox;
	
	    _right_panel_actions2.default.setPanelScrollTopPosition({
	      room: this.state.room,
	      type: 'links',
	      scroll_top: node.scrollTop
	    });
	
	    if (!this.state.all_links_fetched && node.scrollHeight <= node.scrollTop + node.offsetHeight) {
	      _right_panel_actions2.default.fetchLinksHistory();
	    }
	
	    var index = this._getInitialIndex(node.scrollTop);
	    _logger2.default.type('links-panel').log('Scroll is stopped on index:', index);
	  },
	
	
	  _getState: function _getState() {
	    var _RosterStore$getAll = _roster_store2.default.getAll();
	
	    var room = _RosterStore$getAll.active_chat;
	    var links = _RosterStore$getAll.links;
	    var panels_scroll_top = _RosterStore$getAll.panels_scroll_top;
	    var rooms = _RosterStore$getAll.rooms;
	
	
	    var scroll_top = _.get(panels_scroll_top[room], 'links', 0),
	        links_fetched = _.get(rooms[room], 'links_fetched', false),
	        links_fetching = _.get(rooms[room], 'links_fetching', false),
	        all_links_fetched = _.get(rooms[room], 'all_links_fetched', false),
	        room_id = _.get(rooms[room], 'id'),
	        size = links.length;
	
	    return {
	      room: room,
	      room_id: room_id,
	      scroll_top: scroll_top,
	      links_fetched: links_fetched,
	      all_links_fetched: all_links_fetched,
	      links_fetching: links_fetching,
	      links: links,
	      size: size,
	      use24hrTime: _preferences_store2.default.shouldUse24HrTime()
	    };
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _onClick: function _onClick(evt) {
	    var isLink = _.get(evt, 'target.tagName', '').toLowerCase() === 'a';
	    var url = _.get(evt, 'target.href', null);
	    var jid = this.state.room;
	    var room_id = this.state.room_id;
	
	    if (!this.props.is_guest && isLink && !!url && _video_utils2.default.isVideoLink(url)) {
	      evt.preventDefault();
	      _video_actions2.default.joinRoomVideoCall({ url: url, jid: jid, room_id: room_id });
	    }
	  },
	
	
	  _getLink: function _getLink(index, key) {
	
	    var link = this.state.links[index];
	    if (!link) {
	      return React.createElement(_sidebar_list_spinner2.default, { key: key, height: this._getRowHeight() });
	    }
	
	    return React.createElement(_link2.default, { key: key,
	      name: link.user_name,
	      url: link.url,
	      date: link.date,
	      use_24hr_time: this.state.use24hrTime,
	      display_url: link.display_url });
	  },
	
	  _getRowHeight: function _getRowHeight() {
	    return 42;
	  },
	  _getInitialIndex: function _getInitialIndex(scroll_top) {
	    var rowHeight = this._getRowHeight();
	    return Math.floor((scroll_top || this.state.scroll_top) / rowHeight);
	  },
	  _linksBody: function _linksBody() {
	    return React.createElement(
	      'ul',
	      { className: 'aui-nav aui-navgroup-vertical', 'data-skate-ignore': true },
	      React.createElement(ReactList, {
	        ref: 'list',
	        itemRenderer: this._getLink,
	        length: this._getListSize(),
	        initialIndex: this._getInitialIndex(),
	        use_24hr_time: this.state.use24hrTime,
	        threshold: 0,
	        pageSize: 50,
	        type: 'variable' })
	    );
	  },
	  _getListSize: function _getListSize() {
	    var size = this.state.size;
	    if (this.state.links_fetching) {
	      size++;
	    }
	    return size;
	  },
	  _setScrollPosition: function _setScrollPosition() {
	
	    var node = this.refs.scrollbox;
	
	    if (!node) {
	      return;
	    }
	
	    _right_panel_actions2.default.setPanelScrollTopPosition({
	      room: this.state.room,
	      type: 'links',
	      scroll_top: node.scrollTop
	    });
	
	    var index = this._getInitialIndex(node.scrollTop);
	    _logger2.default.type('links-panel').log('Scrolled to index:', index);
	  },
	  _onScroll: function _onScroll() {
	
	    this.throttledSetScrollPosition();
	
	    if (this.state.all_links_fetched || this.state.links_fetching) {
	      return;
	    }
	
	    var node = this.refs.scrollbox;
	
	    if (node.scrollHeight - node.offsetHeight < node.scrollTop + node.offsetHeight) {
	      _right_panel_actions2.default.fetchLinksHistory();
	    }
	  },
	  render: function render() {
	
	    if (!this.props.is_guest && !this.state.links_fetched) {
	      return null;
	    }
	
	    var linkClasses = (0, _classnames2.default)({
	      'hc-links': true,
	      'hc-sidebar-scroll': true,
	      'hc-bg-striped': !_.isEmpty(this.state.links)
	    }),
	        links_display = _.isEmpty(this.state.links) ? React.createElement(_links_empty_state2.default, null) : this._linksBody();
	
	    return React.createElement(
	      'div',
	      { className: linkClasses, ref: 'scrollbox', onClick: this._onClick, onScroll: this._onScroll },
	      links_display
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBarLink",
	
	  propTypes: {
	    url: React.PropTypes.string.isRequired,
	    display_url: React.PropTypes.string.isRequired,
	    name: React.PropTypes.string.isRequired,
	    date: React.PropTypes.instanceOf(Date).isRequired,
	    use_24hr_time: React.PropTypes.bool.isRequired
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  render: function render() {
	
	    var time = _utils2.default.format_time(this.props.date, this.props.use_24hr_time);
	
	    return React.createElement(
	      "li",
	      { className: "hc-roster-item" },
	      React.createElement(
	        "div",
	        { className: "aui-nav-item", title: this.props.url },
	        React.createElement(
	          "a",
	          { className: "hc-link", target: "_blank", rel: "noopener noreferrer", href: this.props.url },
	          this.props.display_url
	        ),
	        React.createElement(
	          "span",
	          { className: "hc-roster-user-name" },
	          this.props.name
	        ),
	        React.createElement(
	          "span",
	          { className: "hc-roster-date" },
	          time
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var strings = __webpack_require__(440);
	
	module.exports = React.createClass({
	
	  displayName: "RightSideBarLinksEmptyState",
	
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-tab-es" },
	      React.createElement("div", { className: "hc-tab-es-img links" }),
	      React.createElement(
	        "div",
	        { className: "hc-tab-es-title" },
	        strings.no_links
	      ),
	      React.createElement(
	        "div",
	        { className: "hc-tab-es-msg" },
	        strings.share_a_link
	      )
	    );
	  }
	});

/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _permissions_store = __webpack_require__(269);
	
	var _permissions_store2 = _interopRequireDefault(_permissions_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _glances_metadata_store = __webpack_require__(523);
	
	var _glances_metadata_store2 = _interopRequireDefault(_glances_metadata_store);
	
	var _glance_actions = __webpack_require__(535);
	
	var _glance_actions2 = _interopRequireDefault(_glance_actions);
	
	var _glance = __webpack_require__(546);
	
	var _glance2 = _interopRequireDefault(_glance);
	
	var _add_integrations_glance = __webpack_require__(548);
	
	var _add_integrations_glance2 = _interopRequireDefault(_add_integrations_glance);
	
	var _integration_view = __webpack_require__(549);
	
	var _integration_view2 = _interopRequireDefault(_integration_view);
	
	var _integrations_actions = __webpack_require__(420);
	
	var _integrations_actions2 = _interopRequireDefault(_integrations_actions);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _integrations_configure_button = __webpack_require__(550);
	
	var _integrations_configure_button2 = _interopRequireDefault(_integrations_configure_button);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _roster = __webpack_require__(509);
	
	var _roster2 = _interopRequireDefault(_roster);
	
	var _roster_mini = __webpack_require__(551);
	
	var _roster_mini2 = _interopRequireDefault(_roster_mini);
	
	var _files = __webpack_require__(515);
	
	var _files2 = _interopRequireDefault(_files);
	
	var _links = __webpack_require__(519);
	
	var _links2 = _interopRequireDefault(_links);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var internalModules = {
	  people: function people() {
	    return React.createElement(_roster2.default, { is_guest: _application_store2.default.get("current_user").is_guest });
	  },
	  files: function files() {
	    return React.createElement(_files2.default, null);
	  },
	  links: function links() {
	    return React.createElement(_links2.default, null);
	  }
	};
	
	var GLANCE_VISIBLE_THRESHOLD = 3;
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBarIntegrations",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _integrations_store2.default.on(['change:integrations', 'change:active_chat', 'change:loading', 'change:error'], this._onChange);
	    _preferences_store2.default.on(['change:' + _client_preferences_keys2.default.ACTIVE_CHAT_INTEGRATION, 'change:' + _client_preferences_keys2.default.ACTIVE_GROUPCHAT_INTEGRATION], this._onChange);
	    _glances_metadata_store2.default.on(['change:dynamic_glances', 'change:visible_glances'], this._onChange);
	    _roster_store2.default.on('change:loading', this._onChange);
	    _integrations_store2.default.on(['change:state'], this._onConnectionChange);
	    _preferences_store2.default.on(['change:' + _preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE], this._onChange);
	  },
	
	  componentWillMount: function componentWillMount() {
	    this._fetchGlanceData();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _integrations_store2.default.off(['change:integrations', 'change:active_chat', 'change:loading', 'change:error'], this._onChange);
	    _preferences_store2.default.off(['change:' + _client_preferences_keys2.default.ACTIVE_CHAT_INTEGRATION, 'change:' + _client_preferences_keys2.default.ACTIVE_GROUPCHAT_INTEGRATION], this._onChange);
	    _glances_metadata_store2.default.off(['change:dynamic_glances', 'change:visible_glances'], this._onChange);
	    _roster_store2.default.off('change:loading', this._onChange);
	    _integrations_store2.default.off(['change:state'], this._onConnectionChange);
	    _preferences_store2.default.off(['change:' + _preferences_keys2.default.IGNORE_ADD_INTEGRATIONS_GLANCE], this._onChange);
	  },
	
	  _fetchGlanceData: function _fetchGlanceData() {
	    var current_glances = _glances_metadata_store2.default.get('dynamic_glances');
	    var active_chat = _integrations_store2.default.get('active_chat');
	
	    if (active_chat && _.has(active_chat, "id")) {
	      // Active chat can be null. For example if you're in the lobby and hit refresh.
	      current_glances.forEach(function (g) {
	        var room_glance = _integrations_store2.default.getExtensionByKey(g.full_key);
	        var isInRoom = !_.isEmpty(room_glance);
	        if (isInRoom && _glances_metadata_store2.default.shouldFetch(active_chat.id, g.full_key)) {
	          _glance_actions2.default.fetchGlanceMetadata(active_chat.id, g);
	        }
	      });
	    }
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	    this._fetchGlanceData();
	  },
	
	  _onConnectionChange: function _onConnectionChange(newValue) {
	
	    if (newValue === _integrations_store2.default.states.STARTED) {
	      this._onChange();
	    }
	  },
	
	  _getState: function _getState() {
	    var activeChat = _integrations_store2.default.get('active_chat');
	    var glances = _glances_metadata_store2.default.get('visible_glances');
	    var dynamic_glances = _glances_metadata_store2.default.get('dynamic_glances');
	    var feature_flags = _configuration_store2.default.get('feature_flags');
	
	    var chatType = _roster_store2.default.get('chat_type');
	    var isGroupChat = chatType === 'groupchat' && activeChat && activeChat.id;
	
	    return {
	      roomId: isGroupChat ? activeChat.id : undefined,
	      glances: isGroupChat ? glances : [],
	      dynamic_glances: isGroupChat ? dynamic_glances : [],
	      internal_glances: this._getInternalGlances(chatType),
	      active_integration: _integrations_store2.default.getActiveIntegration(chatType),
	      loading: _integrations_store2.default.get('loading'),
	      error: _integrations_store2.default.get('error'),
	      chat_type: chatType,
	      loading_internal: _roster_store2.default.get('loading'),
	      show_integrations_glance: this._setShowAddIntegrationsGlance(activeChat, glances.length, feature_flags)
	    };
	  },
	
	  _renderSummaryView: function _renderSummaryView(glance) {
	    if (glance.full_key === _app_config2.default.people_glance.full_key) {
	      return React.createElement(_roster_mini2.default, { max_items_to_render: _app_config2.default.people_glance.max_items_to_render_collapsed });
	    }
	    return false;
	  },
	
	
	  _getGlanceBody: function _getGlanceBody(glance) {
	    if (!glance) {
	      return false;
	    }
	
	    var key = '' + glance.full_key;
	    return React.createElement(
	      'li',
	      { key: key },
	      React.createElement(
	        _glance2.default,
	        { glance: glance, room_id: this.state.roomId },
	        this._renderSummaryView(glance)
	      )
	    );
	  },
	
	  _getRenderedGlances: function _getRenderedGlances() {
	    var glances = _.union(this.state.internal_glances, this.state.glances);
	    return _.map(glances, this._getGlanceBody);
	  },
	
	  _glancesBody: function _glancesBody(renderedGlances) {
	    var addIntegrationsGlance;
	    if (this.state.show_integrations_glance) {
	      addIntegrationsGlance = React.createElement(
	        'li',
	        null,
	        React.createElement(_add_integrations_glance2.default, { room_id: this.state.roomId })
	      );
	    }
	
	    return React.createElement(
	      'ul',
	      { className: 'aui-nav aui-navgroup-vertical hc-glances', 'data-skate-ignore': true },
	      renderedGlances,
	      addIntegrationsGlance
	    );
	  },
	
	  _setShowAddIntegrationsGlance: function _setShowAddIntegrationsGlance(activeRoomObject, numberOfGlances, featureFlags) {
	    if (!activeRoomObject) {
	      return;
	    }
	
	    var shouldShowIntegrationsGlance = false;
	    if (activeRoomObject.type === 'groupchat') {
	      var ignoredRooms = _preferences_store2.default.getIgnoreAddIntegrationGlanceRooms();
	
	      if (activeRoomObject.id && !_.includes(ignoredRooms, parseInt(activeRoomObject.id))) {
	        if (this._shouldShowIntegrationsDiscoveryGlance(numberOfGlances, featureFlags)) {
	          shouldShowIntegrationsGlance = true;
	        }
	      }
	    }
	    return shouldShowIntegrationsGlance;
	  },
	
	  _shouldShowIntegrationsDiscoveryGlance: function _shouldShowIntegrationsDiscoveryGlance(numberOfGlances, featureFlags) {
	    return _.get(featureFlags, "web_client_enable_integration_discovery_glance") && _permissions_store2.default.canManageRoomIntegrations() && numberOfGlances < GLANCE_VISIBLE_THRESHOLD;
	  },
	
	  _getIntegrationsConfigureButton: function _getIntegrationsConfigureButton() {
	    if (this.state.chat_type === 'chat' || !_permissions_store2.default.canManageRoomIntegrations()) {
	      return null;
	    }
	    return React.createElement(_integrations_configure_button2.default, { room_id: this.state.roomId });
	  },
	
	  _renderGlanceList: function _renderGlanceList() {
	    var rendered_glances = this._getRenderedGlances(),
	        glances_display = !_.isEmpty(rendered_glances) ? this._glancesBody(rendered_glances) : null,
	        classNames = (0, _classnames2.default)({
	      'hc-integrations-wrap': true,
	      'hc-can-manage-integrations': _permissions_store2.default.canManageRoomIntegrations()
	    });
	
	    return React.createElement(
	      'div',
	      { className: classNames },
	      glances_display
	    );
	  },
	
	  _hideIntegrationView: function _hideIntegrationView() {
	    _integrations_actions2.default.closeSidebarView("sidebar");
	  },
	
	  _renderIntegrationView: function _renderIntegrationView(integration, activeIntegrationKey) {
	
	    if (_.isNull(integration) || _.isUndefined(integration)) {
	      _logger2.default.warn('[HC-Integrations]', 'Unknown integration view ' + activeIntegrationKey + '.');
	      return null;
	    }
	
	    if (integration.internal) {
	      return this._renderInternalIntegrationView(integration);
	    }
	
	    var key = this.state.roomId + ':' + integration.full_key;
	    var glance = _integrations_store2.default.getExtensionByKey(_.get(this.state.active_integration, "glance_key"));
	
	    return React.createElement(_integration_view2.default, { integration: integration,
	      room_id: this.state.roomId,
	      url_template_values: this.state.active_integration.url_template_values,
	      init_event: this.state.active_integration.init_event,
	      hideIntegrationView: this._hideIntegrationView,
	      glance: glance,
	      key: key });
	  },
	
	  _renderInternalIntegrationView: function _renderInternalIntegrationView(integration) {
	
	    var internalModule = internalModules[integration.key];
	
	    return React.createElement(
	      _integration_view2.default,
	      { integration: integration,
	        room_id: this.state.roomId,
	        hideIntegrationView: this._hideIntegrationView,
	        key: integration.key,
	        glance: integration,
	        loading: this.state.loading_internal },
	      internalModule()
	    );
	  },
	
	  /**
	   * HipChat provides default integrations such as files, links and people
	   *
	   * All of our internal integration are marked with internal : true
	   * The key is mapped to the internalModules array in integrations.js
	   */
	  _getInternalGlances: function _getInternalGlances(chatType) {
	    var type = chatType || this.state.chat_type;
	    if (_.isEqual(this.props.internal, "false")) {
	      return [];
	    }
	
	    if (type === 'chat') {
	      return _integrations_store2.default.getInternalExtensionsOTO();
	    }
	
	    return _integrations_store2.default.getInternalExtensions();
	  },
	
	
	  _getIntegration: function _getIntegration(activeIntegrationKey) {
	    var extension = _integrations_store2.default.getExtensionByKey(activeIntegrationKey);
	    return extension || _.find(this._getInternalGlances(), function (integration) {
	      return integration.full_key === activeIntegrationKey;
	    });
	  },
	
	  render: function render() {
	
	    var integrationClasses,
	        integrations_display,
	        activeIntegrationKey = _.get(this.state.active_integration, "key", null),
	        integration = this._getIntegration(activeIntegrationKey),
	        activeIntegrationExists = !_.isUndefined(integration) && !_.isNull(integration),
	        hasActiveIntegration = !(_.isNull(activeIntegrationKey) || !activeIntegrationExists),
	        configureButton = hasActiveIntegration ? null : this._getIntegrationsConfigureButton();
	
	    if (!hasActiveIntegration) {
	      integrations_display = this._renderGlanceList();
	      integrationClasses = (0, _classnames2.default)({ 'hc-integrations': true });
	    } else {
	      integrations_display = this._renderIntegrationView(integration, activeIntegrationKey);
	      integrationClasses = (0, _classnames2.default)({ 'hc-integrations': true, 'glance-selected': true });
	    }
	
	    return React.createElement(
	      'div',
	      { className: integrationClasses },
	      React.createElement(_spinner2.default, { spin: this.state.loading, zIndex: 1 }),
	      integrations_display,
	      configureButton
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _current_user_store = __webpack_require__(292);
	
	var _current_user_store2 = _interopRequireDefault(_current_user_store);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _html_sanitizer = __webpack_require__(524);
	
	var _html_sanitizer2 = _interopRequireDefault(_html_sanitizer);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _conditions = __webpack_require__(423);
	
	var _conditions2 = _interopRequireDefault(_conditions);
	
	var _glance_helper = __webpack_require__(534);
	
	var _glance_helper2 = _interopRequireDefault(_glance_helper);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _api_integration_events = __webpack_require__(198);
	
	var _integrations_keys = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var glanceHtmlSanitizer = new _html_sanitizer2.default(["b", "strong", "em", "i"]);
	
	var GlancesMetadataStore = function (_Store) {
	  (0, _inherits3.default)(GlancesMetadataStore, _Store);
	
	  function GlancesMetadataStore() {
	    (0, _classCallCheck3.default)(this, GlancesMetadataStore);
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(GlancesMetadataStore).call(this));
	  }
	
	  (0, _createClass3.default)(GlancesMetadataStore, [{
	    key: "getDefaults",
	    value: function getDefaults() {
	      return {
	        active_rooms: {},
	        visible_glances: [],
	        dynamic_glances: [],
	        room_state: {},
	        integrations_state: _integrations_keys.states.INIT,
	        active_chat: ""
	      };
	    }
	  }, {
	    key: "registerListeners",
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.register({
	        "fetch-glance-metadata": function fetchGlanceMetadata(room_id, glance) {
	          var reload_errors = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	          _this2._fetchGlanceMetadata(room_id, glance, reload_errors);
	        },
	        "glance-metadata-loading": function glanceMetadataLoading(room_id, glance_key, data) {
	          _this2._setGlanceLoading(room_id, glance_key);
	          _this2._updateGlances();
	        },
	        "glance-metadata-fetched": function glanceMetadataFetched(room_id, glance_key, data) {
	          var sanitizedData = _this2._sanitizeMetadata(data);
	          _this2._setRoomMetadata(room_id, glance_key, sanitizedData);
	          _this2._updateGlances();
	        },
	        "glances-finished-loading-for-room": function glancesFinishedLoadingForRoom(room_id, success) {
	          _this2._finishLoadingForRoom(room_id, success);
	        },
	        "glance-metadata-pushed": function glanceMetadataPushed(push_data) {
	          _.each(push_data, function (data) {
	            var glance_key = _integration_helper2.default.to_full_key(data.addon_key, data.key);
	            var sanitizedContent = _this2._sanitizeMetadata(data.content);
	
	            _app_dispatcher2.default.dispatch("integration-iframe-event", _api_integration_events.GLANCE_UPDATE, {
	              addon_key: data.addon_key
	            }, {
	              addon_key: data.addon_key,
	              module_key: data.key,
	              metadata: _.get(data, "content.metadata", {})
	            });
	
	            if (data.room_id) {
	              _this2._setRoomMetadata(data.room_id, glance_key, sanitizedContent);
	            } else {
	              _this2._setGlobalMetadata(glance_key, sanitizedContent);
	            }
	          });
	          _this2._updateGlances();
	        },
	        "integrations-updated": function integrationsUpdated(integrations) {
	          _this2._updateGlances();
	        },
	        "updated:activeRooms": function updatedActiveRooms(rooms) {
	          _this2._handleActiveRoomsUpdate(rooms);
	        },
	        "after:updated:active_chat": function afterUpdatedActive_chat(jid) {
	          // We're listening to after:updated:active_chat instead of updated:active_chat so we're sure that
	          // integrations_store is aware of the current room
	          // TODO: change update glance and integrationstore to take an active room parameter when needed
	          _this2._handleActiveChatUpdate(jid);
	        }
	      });
	
	      _app_dispatcher2.default.register(_integrations_keys.event_names.REMOVE_DATA_FOR_ROOMS, function (data) {
	        _this2._cleanMetadataForRooms(data.rooms);
	      });
	
	      _app_dispatcher2.default.register(_integrations_keys.event_names.ON_INTEGRATIONS_REMOVED, function (data) {
	        _.each(data.integrations, function (integration) {
	          _this2._handleUninstalledIntegration(integration, data.rooms);
	        });
	      });
	
	      _integrations_store2.default.on('change:state', function (state, old_state) {
	        _this2.set('integrations_state', state);
	
	        if (state === _integrations_keys.states.STARTED || state === _integrations_keys.states.ERROR) {
	          _this2._handleActiveChatUpdate(_this2.data.active_chat);
	        } else if (state === _integrations_keys.states.STOPPED) {
	          _this2.setDirty();
	        }
	      });
	    }
	  }, {
	    key: "onGlanceMetadataChange",
	    value: function onGlanceMetadataChange(room_id, glance_key, callback) {
	      var key = this.fullKey(room_id, glance_key);
	      this.on("change:" + key, callback);
	    }
	  }, {
	    key: "offGlanceMetadataChange",
	    value: function offGlanceMetadataChange(room_id, glance_key, callback) {
	      var key = this.fullKey(room_id, glance_key);
	      this.off("change:" + key, callback);
	    }
	  }, {
	    key: "getValidCachedMetadata",
	    value: function getValidCachedMetadata(room_id, glance_key) {
	      var cachedMetadata = this.get(this.fullKey(room_id, glance_key));
	      if (!_.isUndefined(cachedMetadata) && _.isEmpty(cachedMetadata.error)) {
	        return cachedMetadata;
	      }
	      return undefined;
	    }
	  }, {
	    key: "getCachedMetadata",
	    value: function getCachedMetadata(room_id, glance_key) {
	      var cachedMetadata = this.get(this.fullKey(room_id, glance_key));
	      if (_.isUndefined(cachedMetadata)) {
	        return {};
	      }
	
	      if (!cachedMetadata.error) {
	        cachedMetadata.error = null;
	      }
	
	      return cachedMetadata;
	    }
	  }, {
	    key: "fullKey",
	    value: function fullKey(room_id, glance_key) {
	      return room_id + ":" + glance_key;
	    }
	  }, {
	    key: "setDirty",
	    value: function setDirty() {
	      this.set('room_state', _.mapValues(this.data.room_state, _.constant(_integrations_keys.glance_room_states.DIRTY)));
	    }
	  }, {
	    key: "shouldFetch",
	    value: function shouldFetch(room_id, glance_key) {
	      var cachedMetadata = this.getCachedMetadata(room_id, glance_key);
	      return _.isEmpty(cachedMetadata) || cachedMetadata.dirty === true && !cachedMetadata.loading;
	    }
	  }, {
	    key: "_setGlanceLoading",
	    value: function _setGlanceLoading(room_id, glance_key) {
	      var fullKey = this.fullKey(room_id, glance_key);
	      var cachedMetadata = this.getCachedMetadata(room_id, glance_key);
	      if (_.isUndefined(cachedMetadata)) {
	        cachedMetadata = {};
	      }
	      cachedMetadata.error = null;
	      cachedMetadata.loading = true;
	      this.set(fullKey, cachedMetadata);
	    }
	  }, {
	    key: "_updateGlances",
	    value: function _updateGlances() {
	      var _this3 = this;
	
	      var allGlances = _integrations_store2.default.getExtensionsByType(_integrations_keys.extension_types.GLANCE);
	      var visibleGlances = allGlances.filter(function (g) {
	        return _this3._shouldDisplayGlance(g);
	      });
	      var dynamicGlances = allGlances.filter(function (g) {
	        return !_.isUndefined(g.query_url);
	      });
	      this.set({
	        visible_glances: visibleGlances,
	        dynamic_glances: dynamicGlances
	      });
	    }
	  }, {
	    key: "_shouldDisplayGlance",
	    value: function _shouldDisplayGlance(glance) {
	
	      var active_chat = _integrations_store2.default.get('active_chat');
	      if (_.isEmpty(active_chat)) {
	        return false;
	      }
	
	      var glance_data = this.getCachedMetadata(active_chat.id, glance.full_key);
	
	      if (_.isEmpty(glance.conditions) || !_.isEmpty(glance_data.error)) {
	        return true;
	      }
	
	      var current_user = _current_user_store2.default.getAll();
	      var context = new _conditions2.default().withRoom(active_chat).withUser(current_user);
	
	      if (context.canEvaluate(glance.conditions)) {
	        return context.evaluate(glance.conditions);
	      }
	
	      //If glance is loading, and has conditions, we might want to display it later
	      if (_.isUndefined(glance_data) || glance_data.loading) {
	        return false;
	      }
	
	      return context.withGlanceData(glance_data).evaluate(glance.conditions);
	    }
	  }, {
	    key: "_setRoomMetadata",
	    value: function _setRoomMetadata(room_id, glance_key, data) {
	      this.set(this.fullKey(room_id, glance_key), _.merge({ loading: false, dirty: false }, data));
	    }
	  }, {
	    key: "_setGlobalMetadata",
	    value: function _setGlobalMetadata(glance_key, data) {
	      var _this4 = this;
	
	      _.each(this._getAllActiveRoomIds(), function (room_id) {
	        _this4._setRoomMetadata(room_id, glance_key, data);
	      });
	    }
	  }, {
	    key: "_sanitizeMetadata",
	    value: function _sanitizeMetadata(data) {
	      data.label = this._sanitizeMetadataContent(data.label);
	      data.status = this._sanitizeMetadataContent(data.status);
	
	      return data;
	    }
	  }, {
	    key: "_sanitizeMetadataContent",
	    value: function _sanitizeMetadataContent(content) {
	      if (!_.isObject(content)) {
	        return {};
	      }
	
	      switch (content.type) {
	        case "html":
	          content.type = "safe_html";
	          content.value = glanceHtmlSanitizer.sanitize(content.value);
	          break;
	        default:
	          break;
	      }
	
	      return content;
	    }
	  }, {
	    key: "_handleActiveRoomsUpdate",
	    value: function _handleActiveRoomsUpdate(rooms) {
	      var jids_to_room_ids = {};
	      for (var item in rooms) {
	        if (rooms[item].type === "groupchat" && rooms[item].id) {
	          jids_to_room_ids[item] = rooms[item].id;
	        }
	      }
	
	      this.set({
	        "active_rooms": jids_to_room_ids
	      });
	    }
	  }, {
	    key: "_getMetadataKeysMatching",
	    value: function _getMetadataKeysMatching(prefix) {
	      return _.filter(_.keys(this.data), function (key) {
	        return _.startsWith(key, prefix);
	      });
	    }
	  }, {
	    key: "_clearMetadataForContext",
	    value: function _clearMetadataForContext(rooms, prefix) {
	      var _this5 = this;
	
	      var metadataKeys = _.map(rooms, function (room) {
	        var prefixedRoom = prefix(room);
	        return _this5._getMetadataKeysMatching(prefixedRoom);
	      });
	
	      var flattenKeys = _.flatten(metadataKeys);
	      flattenKeys.forEach(function (key) {
	        return _this5.unset(key);
	      });
	    }
	  }, {
	    key: "_cleanMetadataForRooms",
	    value: function _cleanMetadataForRooms(rooms) {
	      var _this6 = this;
	
	      this._clearMetadataForContext(rooms, function (room) {
	        return room.id + ":";
	      });
	      var ids = _.map(rooms, "id");
	      this.set("room_state", _.pickBy(this.data.room_state, function (v, id) {
	        if (_.includes(ids, id)) {
	          _logger2.default.debug('[HC-Integrations]', "glances:" + id + " state transition from " + _.get(_this6.data.room_state, id, _integrations_keys.glance_room_states.INIT) + " -> unloaded");
	          return false;
	        }
	      }));
	    }
	  }, {
	    key: "_handleUninstalledIntegration",
	    value: function _handleUninstalledIntegration(integration, rooms) {
	      this._clearMetadataForContext(rooms, function (room) {
	        return room.id + ":" + integration.addon_key + ":";
	      });
	    }
	  }, {
	    key: "_handleActiveChatUpdate",
	    value: function _handleActiveChatUpdate(jid) {
	      var activeRoom = this.data.active_rooms[jid];
	
	      if (activeRoom) {
	        var state = this._getRoomState(activeRoom);
	
	        if (state === _integrations_keys.glance_room_states.INIT || state === _integrations_keys.glance_room_states.DIRTY) {
	          this._setRoomState(activeRoom, _integrations_keys.glance_room_states.LOADING);
	        }
	      }
	      this.set('active_chat', jid);
	      this._updateGlances();
	    }
	  }, {
	    key: "_getAllActiveRoomIds",
	    value: function _getAllActiveRoomIds() {
	      return _.values(this.data.active_rooms);
	    }
	  }, {
	    key: "_getRoomState",
	    value: function _getRoomState(id) {
	      if (this.data.integrations_state === _integrations_keys.states.STARTED || this.data.integrations_state === _integrations_keys.states.ERROR) {
	        return _.get(this.data.room_state, id, _integrations_keys.glance_room_states.INIT);
	      }
	      return _integrations_keys.glance_room_states.WAITING;
	    }
	  }, {
	    key: "_setRoomState",
	    value: function _setRoomState(id, state) {
	      var current_state = _.get(this.data.room_state, id, _integrations_keys.glance_room_states.INIT);
	
	      if (current_state !== state) {
	        if (state === _integrations_keys.glance_room_states.LOADING) {
	          //Fetch glance metadata
	
	          _glance_helper2.default.fetchGlanceMetadataForRoom(id);
	        }
	
	        var updated_states = _.clone(this.data.room_state);
	        updated_states[id] = state;
	        _logger2.default.debug('[HC-Integrations]', "glances:" + id + " state transition from " + current_state + " -> " + state);
	        this.set({ room_state: updated_states });
	      }
	    }
	  }, {
	    key: "_fetchGlanceMetadata",
	    value: function _fetchGlanceMetadata(room_id, glance, reload_errors) {
	      var metadata = this.get(this.fullKey(room_id, glance.full_key));
	      var shouldReload = _.get(metadata, 'dirty', false);
	      if (_.isUndefined(metadata) && _integrations_keys.glance_room_states.LOADED === this._getRoomState(room_id)) {
	        _logger2.default.debug('[HC-Integrations]', "Fetching single glance as no metadata exists and room was already loaded - glances:" + room_id + ":" + glance.full_key);
	        shouldReload = true;
	      }
	
	      if (_.get(metadata, 'error', false) && reload_errors) {
	        _logger2.default.debug('[HC-Integrations]', "Fetching single glance as currently in error state and reload was triggered - glances:" + room_id + ":" + glance.full_key);
	        shouldReload = true;
	      }
	
	      if (shouldReload) {
	        this._setGlanceLoading(room_id, glance.full_key);
	        _glance_helper2.default.fetchGlanceRemoteMetadata(room_id, glance);
	      }
	    }
	  }, {
	    key: "_finishLoadingForRoom",
	    value: function _finishLoadingForRoom(room_id, success) {
	      var _this7 = this;
	
	      if (!success) {
	        // Mark as failed
	        _integrations_store2.default.getExtensionsByTypeAndRoom(_integrations_keys.extension_types.GLANCE, room_id).forEach(function (e) {
	          if (e.query_url) {
	            _this7.set(_this7.fullKey(room_id, e.full_key), {
	              loading: false,
	              error: "Failed to load glance"
	            });
	          }
	        });
	
	        this._updateGlances();
	      }
	
	      this._setRoomState(room_id, _integrations_keys.glance_room_states.LOADED);
	    }
	  }]);
	  return GlancesMetadataStore;
	}(_store2.default);
	
	exports.default = new GlancesMetadataStore();
	module.exports = exports['default'];

/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _set = __webpack_require__(525);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var sanitizer = __webpack_require__(532);
	
	var HtmlSanitizer = function () {
	  function HtmlSanitizer(tagWhitelist, attributeWhitelist) {
	    (0, _classCallCheck3.default)(this, HtmlSanitizer);
	
	    var whitelistSet = new _set2.default(tagWhitelist);
	    var attributeWhitelistSet = new _set2.default(attributeWhitelist);
	    var basicPolicy = sanitizer.makeTagPolicy();
	
	    this.customPolicy = function (tagName, attribs) {
	
	      var filteredAttributes = [];
	      for (var i = 0; i < attribs.length; i += 2) {
	        var attribName = attribs[i];
	        var value = attribs[i + 1];
	
	        if (attributeWhitelistSet.has(attribName)) {
	          filteredAttributes.push(attribName, value);
	        }
	      }
	
	      if (whitelistSet.has(tagName)) {
	        return basicPolicy(tagName, filteredAttributes);
	      }
	    };
	  }
	
	  (0, _createClass3.default)(HtmlSanitizer, [{
	    key: 'sanitize',
	    value: function sanitize(input) {
	      return sanitizer.sanitizeWithPolicy(input, this.customPolicy);
	    }
	  }]);
	  return HtmlSanitizer;
	}();
	
	module.exports = HtmlSanitizer;

/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(526), __esModule: true };

/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(46);
	__webpack_require__(61);
	__webpack_require__(67);
	__webpack_require__(527);
	__webpack_require__(530);
	module.exports = __webpack_require__(18).Set;

/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(528);
	
	// 23.2 Set Objects
	__webpack_require__(529)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(8)
	  , hide         = __webpack_require__(30)
	  , redefineAll  = __webpack_require__(86)
	  , ctx          = __webpack_require__(19)
	  , strictNew    = __webpack_require__(73)
	  , defined      = __webpack_require__(14)
	  , forOf        = __webpack_require__(74)
	  , $iterDefine  = __webpack_require__(64)
	  , step         = __webpack_require__(70)
	  , ID           = __webpack_require__(35)('id')
	  , $has         = __webpack_require__(27)
	  , isObject     = __webpack_require__(44)
	  , setSpecies   = __webpack_require__(87)
	  , DESCRIPTORS  = __webpack_require__(28)
	  , isExtensible = Object.isExtensible || isObject
	  , SIZE         = DESCRIPTORS ? '_s' : 'size'
	  , id           = 0;
	
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!$has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	};
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = $.create(null); // index
	      that._f = undefined;      // first entry
	      that._l = undefined;      // last entry
	      that[SIZE] = 0;           // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $              = __webpack_require__(8)
	  , global         = __webpack_require__(17)
	  , $export        = __webpack_require__(16)
	  , fails          = __webpack_require__(21)
	  , hide           = __webpack_require__(30)
	  , redefineAll    = __webpack_require__(86)
	  , forOf          = __webpack_require__(74)
	  , strictNew      = __webpack_require__(73)
	  , isObject       = __webpack_require__(44)
	  , setToStringTag = __webpack_require__(33)
	  , DESCRIPTORS    = __webpack_require__(28);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	  } else {
	    C = wrapper(function(target, iterable){
	      strictNew(target, C, NAME);
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(16);
	
	$export($export.P, 'Set', {toJSON: __webpack_require__(531)('Set')});

/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var forOf   = __webpack_require__(74)
	  , classof = __webpack_require__(72);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    var arr = [];
	    forOf(this, false, arr.push, arr);
	    return arr;
	  };
	};

/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	var html4 = __webpack_require__(533);
	var URI = __webpack_require__(143);
	
	// Copyright (C) 2006 Google Inc.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//      http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	
	/**
	 * @fileoverview
	 * An HTML sanitizer that can satisfy a variety of security policies.
	 *
	 * <p>
	 * The HTML sanitizer is built around a SAX parser and HTML element and
	 * attributes schemas.
	 *
	 * If the cssparser is loaded, inline styles are sanitized using the
	 * css property and value schemas.  Else they are remove during
	 * sanitization.
	 *
	 * If it exists, uses parseCssDeclarations, sanitizeCssProperty,  cssSchema
	 *
	 * @author mikesamuel@gmail.com
	 * @author jasvir@gmail.com
	 * \@requires html4, URI
	 * \@overrides window
	 * \@provides html, html_sanitize
	 */
	
	// The Turkish i seems to be a non-issue, but abort in case it is.
	if ('I'.toLowerCase() !== 'i') { throw 'I/i problem'; }
	
	/**
	 * \@namespace
	 */
	var html = (function(html4) {
	
	    // For closure compiler
	    var parseCssDeclarations, sanitizeCssProperty, cssSchema;
	    if ('undefined' !== typeof window) {
	        parseCssDeclarations = window['parseCssDeclarations'];
	        sanitizeCssProperty = window['sanitizeCssProperty'];
	        cssSchema = window['cssSchema'];
	    }
	
	    // The keys of this object must be 'quoted' or JSCompiler will mangle them!
	    // This is a partial list -- lookupEntity() uses the host browser's parser
	    // (when available) to implement full entity lookup.
	    // Note that entities are in general case-sensitive; the uppercase ones are
	    // explicitly defined by HTML5 (presumably as compatibility).
	    var ENTITIES = {
	        'lt': '<',
	        'LT': '<',
	        'gt': '>',
	        'GT': '>',
	        'amp': '&',
	        'AMP': '&',
	        'quot': '"',
	        'apos': '\'',
	        'nbsp': '\u00a0'
	    };
	
	    // Patterns for types of entity/character reference names.
	    var decimalEscapeRe = /^#(\d+)$/;
	    var hexEscapeRe = /^#x([0-9A-Fa-f]+)$/;
	    // contains every entity per http://www.w3.org/TR/2011/WD-html5-20110113/named-character-references.html
	    var safeEntityNameRe = /^[A-Za-z][A-za-z0-9]+$/;
	    // Used as a hook to invoke the browser's entity parsing. <textarea> is used
	    // because its content is parsed for entities but not tags.
	    // TODO(kpreid): This retrieval is a kludge and leads to silent loss of
	    // functionality if the document isn't available.
	    var entityLookupElement =
	        ('undefined' !== typeof window && window['document'])
	            ? window['document'].createElement('textarea') : null;
	    /**
	     * Decodes an HTML entity.
	     *
	     * {\@updoc
	     * $ lookupEntity('lt')
	     * # '<'
	     * $ lookupEntity('GT')
	     * # '>'
	     * $ lookupEntity('amp')
	     * # '&'
	     * $ lookupEntity('nbsp')
	     * # '\xA0'
	     * $ lookupEntity('apos')
	     * # "'"
	     * $ lookupEntity('quot')
	     * # '"'
	     * $ lookupEntity('#xa')
	     * # '\n'
	     * $ lookupEntity('#10')
	     * # '\n'
	     * $ lookupEntity('#x0a')
	     * # '\n'
	     * $ lookupEntity('#010')
	     * # '\n'
	     * $ lookupEntity('#x00A')
	     * # '\n'
	     * $ lookupEntity('Pi')      // Known failure
	     * # '\u03A0'
	     * $ lookupEntity('pi')      // Known failure
	     * # '\u03C0'
	     * }
	     *
	     * @param {string} name the content between the '&' and the ';'.
	     * @return {string} a single unicode code-point as a string.
	     */
	    function lookupEntity(name) {
	        // TODO: entity lookup as specified by HTML5 actually depends on the
	        // presence of the ";".
	        if (ENTITIES.hasOwnProperty(name)) { return ENTITIES[name]; }
	        var m = name.match(decimalEscapeRe);
	        if (m) {
	            return String.fromCharCode(parseInt(m[1], 10));
	        } else if (!!(m = name.match(hexEscapeRe))) {
	            return String.fromCharCode(parseInt(m[1], 16));
	        } else if (entityLookupElement && safeEntityNameRe.test(name)) {
	            entityLookupElement.innerHTML = '&' + name + ';';
	            var text = entityLookupElement.textContent;
	            ENTITIES[name] = text;
	            return text;
	        } else {
	            return '&' + name + ';';
	        }
	    }
	
	    function decodeOneEntity(_, name) {
	        return lookupEntity(name);
	    }
	
	    var nulRe = /\0/g;
	    function stripNULs(s) {
	        return s.replace(nulRe, '');
	    }
	
	    var ENTITY_RE_1 = /&(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/g;
	    var ENTITY_RE_2 = /^(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/;
	    /**
	     * The plain text of a chunk of HTML CDATA which possibly containing.
	     *
	     * {\@updoc
	     * $ unescapeEntities('')
	     * # ''
	     * $ unescapeEntities('hello World!')
	     * # 'hello World!'
	     * $ unescapeEntities('1 &lt; 2 &amp;&AMP; 4 &gt; 3&#10;')
	     * # '1 < 2 && 4 > 3\n'
	     * $ unescapeEntities('&lt;&lt <- unfinished entity&gt;')
	     * # '<&lt <- unfinished entity>'
	     * $ unescapeEntities('/foo?bar=baz&copy=true')  // & often unescaped in URLS
	     * # '/foo?bar=baz&copy=true'
	     * $ unescapeEntities('pi=&pi;&#x3c0;, Pi=&Pi;\u03A0') // FIXME: known failure
	     * # 'pi=\u03C0\u03c0, Pi=\u03A0\u03A0'
	     * }
	     *
	     * @param {string} s a chunk of HTML CDATA.  It must not start or end inside
	     *     an HTML entity.
	     */
	    function unescapeEntities(s) {
		if(s) {
		    return s.replace(ENTITY_RE_1, decodeOneEntity);
		}
		else {
		    return s;
		}
	    }
	
	    var ampRe = /&/g;
	    var looseAmpRe = /&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;
	    var ltRe = /[<]/g;
	    var gtRe = />/g;
	    var quotRe = /\"/g;
	
	    /**
	     * Escapes HTML special characters in attribute values.
	     *
	     * {\@updoc
	     * $ escapeAttrib('')
	     * # ''
	     * $ escapeAttrib('"<<&==&>>"')  // Do not just escape the first occurrence.
	     * # '&#34;&lt;&lt;&amp;&#61;&#61;&amp;&gt;&gt;&#34;'
	     * $ escapeAttrib('Hello <World>!')
	     * # 'Hello &lt;World&gt;!'
	     * }
	     */
	    function escapeAttrib(s) {
		if(s) {
		    return ('' + s).replace(ampRe, '&amp;').replace(ltRe, '&lt;')
	            .replace(gtRe, '&gt;').replace(quotRe, '&#34;');
		}
		else {
		    return s;
		}
	        
	    }
	
	    /**
	     * Escape entities in RCDATA that can be escaped without changing the meaning.
	     * {\@updoc
	     * $ normalizeRCData('1 < 2 &&amp; 3 > 4 &amp;& 5 &lt; 7&8')
	     * # '1 &lt; 2 &amp;&amp; 3 &gt; 4 &amp;&amp; 5 &lt; 7&amp;8'
	     * }
	     */
	    function normalizeRCData(rcdata) {
		if(rcdata) {
		    return rcdata
	                .replace(looseAmpRe, '&amp;$1')
	                .replace(ltRe, '&lt;')
	                .replace(gtRe, '&gt;');
		}
		else {
		    return rcdata;
		}
	    }
	
	    // TODO(felix8a): validate sanitizer regexs against the HTML5 grammar at
	    // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html
	    // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html
	    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
	    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html
	
	    // We initially split input so that potentially meaningful characters
	    // like '<' and '>' are separate tokens, using a fast dumb process that
	    // ignores quoting.  Then we walk that token stream, and when we see a
	    // '<' that's the start of a tag, we use ATTR_RE to extract tag
	    // attributes from the next token.  That token will never have a '>'
	    // character.  However, it might have an unbalanced quote character, and
	    // when we see that, we combine additional tokens to balance the quote.
	
	    var ATTR_RE = new RegExp(
	        '^\\s*' +
	            '([-.:\\w]+)' +             // 1 = Attribute name
	            '(?:' + (
	            '\\s*(=)\\s*' +           // 2 = Is there a value?
	                '(' + (                   // 3 = Attribute value
	                // TODO(felix8a): maybe use backref to match quotes
	                '(\")[^\"]*(\"|$)' +    // 4, 5 = Double-quoted string
	                    '|' +
	                    '(\')[^\']*(\'|$)' +    // 6, 7 = Single-quoted string
	                    '|' +
	                    // Positive lookahead to prevent interpretation of
	                    // <foo a= b=c> as <foo a='b=c'>
	                    // TODO(felix8a): might be able to drop this case
	                    '(?=[a-z][-\\w]*\\s*=)' +
	                    '|' +
	                    // Unquoted value that isn't an attribute name
	                    // (since we didn't match the positive lookahead above)
	                    '[^\"\'\\s]*' ) +
	                ')' ) +
	            ')?',
	        'i');
	
	    // false on IE<=8, true on most other browsers
	    var splitWillCapture = ('a,b'.split(/(,)/).length === 3);
	
	    // bitmask for tags with special parsing, like <script> and <textarea>
	    var EFLAGS_TEXT = html4.eflags['CDATA'] | html4.eflags['RCDATA'];
	
	    /**
	     * Given a SAX-like event handler, produce a function that feeds those
	     * events and a parameter to the event handler.
	     *
	     * The event handler has the form:{@code
	     * {
	   *   // Name is an upper-case HTML tag name.  Attribs is an array of
	   *   // alternating upper-case attribute names, and attribute values.  The
	   *   // attribs array is reused by the parser.  Param is the value passed to
	   *   // the saxParser.
	   *   startTag: function (name, attribs, param) { ... },
	   *   endTag:   function (name, param) { ... },
	   *   pcdata:   function (text, param) { ... },
	   *   rcdata:   function (text, param) { ... },
	   *   cdata:    function (text, param) { ... },
	   *   startDoc: function (param) { ... },
	   *   endDoc:   function (param) { ... }
	   * }}
	     *
	     * @param {Object} handler a record containing event handlers.
	     * @return {function(string, Object)} A function that takes a chunk of HTML
	     *     and a parameter.  The parameter is passed on to the handler methods.
	     */
	    function makeSaxParser(handler) {
	        // Accept quoted or unquoted keys (Closure compat)
	        var hcopy = {
	            cdata: handler.cdata || handler['cdata'],
	            comment: handler.comment || handler['comment'],
	            endDoc: handler.endDoc || handler['endDoc'],
	            endTag: handler.endTag || handler['endTag'],
	            pcdata: handler.pcdata || handler['pcdata'],
	            rcdata: handler.rcdata || handler['rcdata'],
	            startDoc: handler.startDoc || handler['startDoc'],
	            startTag: handler.startTag || handler['startTag']
	        };
	        return function(htmlText, param) {
	            return parse(htmlText, hcopy, param);
	        };
	    }
	
	    // Parsing strategy is to split input into parts that might be lexically
	    // meaningful (every ">" becomes a separate part), and then recombine
	    // parts if we discover they're in a different context.
	
	    // TODO(felix8a): Significant performance regressions from -legacy,
	    // tested on
	    //    Chrome 18.0
	    //    Firefox 11.0
	    //    IE 6, 7, 8, 9
	    //    Opera 11.61
	    //    Safari 5.1.3
	    // Many of these are unusual patterns that are linearly slower and still
	    // pretty fast (eg 1ms to 5ms), so not necessarily worth fixing.
	
	    // TODO(felix8a): "<script> && && && ... <\/script>" is slower on all
	    // browsers.  The hotspot is htmlSplit.
	
	    // TODO(felix8a): "<p title='>>>>...'><\/p>" is slower on all browsers.
	    // This is partly htmlSplit, but the hotspot is parseTagAndAttrs.
	
	    // TODO(felix8a): "<a><\/a><a><\/a>..." is slower on IE9.
	    // "<a>1<\/a><a>1<\/a>..." is faster, "<a><\/a>2<a><\/a>2..." is faster.
	
	    // TODO(felix8a): "<p<p<p..." is slower on IE[6-8]
	
	    var continuationMarker = {};
	    function parse(htmlText, handler, param) {
	        var m, p, tagName;
	        var parts = htmlSplit(htmlText);
	        var state = {
	            noMoreGT: false,
	            noMoreEndComments: false
	        };
	        parseCPS(handler, parts, 0, state, param);
	    }
	
	    function continuationMaker(h, parts, initial, state, param) {
	        return function () {
	            parseCPS(h, parts, initial, state, param);
	        };
	    }
	
	    function parseCPS(h, parts, initial, state, param) {
	        try {
	            if (h.startDoc && initial == 0) { h.startDoc(param); }
	            var m, p, tagName;
	            for (var pos = initial, end = parts.length; pos < end;) {
	                var current = parts[pos++];
	                var next = parts[pos];
	                switch (current) {
	                    case '&':
	                        if (ENTITY_RE_2.test(next)) {
	                            if (h.pcdata) {
	                                h.pcdata('&' + next, param, continuationMarker,
	                                    continuationMaker(h, parts, pos, state, param));
	                            }
	                            pos++;
	                        } else {
	                            if (h.pcdata) { h.pcdata("&amp;", param, continuationMarker,
	                                continuationMaker(h, parts, pos, state, param));
	                            }
	                        }
	                        break;
	                    case '<\/':
	                        if ((m = /^([-\w:]+)[^\'\"]*/.exec(next))) {
	                            if (m[0].length === next.length && parts[pos + 1] === '>') {
	                                // fast case, no attribute parsing needed
	                                pos += 2;
	                                tagName = m[1].toLowerCase();
	                                if (h.endTag) {
	                                    h.endTag(tagName, param, continuationMarker,
	                                        continuationMaker(h, parts, pos, state, param));
	                                }
	                            } else {
	                                // slow case, need to parse attributes
	                                // TODO(felix8a): do we really care about misparsing this?
	                                pos = parseEndTag(
	                                    parts, pos, h, param, continuationMarker, state);
	                            }
	                        } else {
	                            if (h.pcdata) {
	                                h.pcdata('&lt;/', param, continuationMarker,
	                                    continuationMaker(h, parts, pos, state, param));
	                            }
	                        }
	                        break;
	                    case '<':
	                        if (m = /^([-\w:]+)\s*\/?/.exec(next)) {
	                            if (m[0].length === next.length && parts[pos + 1] === '>') {
	                                // fast case, no attribute parsing needed
	                                pos += 2;
	                                tagName = m[1].toLowerCase();
	                                if (h.startTag) {
	                                    h.startTag(tagName, [], param, continuationMarker,
	                                        continuationMaker(h, parts, pos, state, param));
	                                }
	                                // tags like <script> and <textarea> have special parsing
	                                var eflags = html4.ELEMENTS[tagName];
	                                if (eflags & EFLAGS_TEXT) {
	                                    var tag = { name: tagName, next: pos, eflags: eflags };
	                                    pos = parseText(
	                                        parts, tag, h, param, continuationMarker, state);
	                                }
	                            } else {
	                                // slow case, need to parse attributes
	                                pos = parseStartTag(
	                                    parts, pos, h, param, continuationMarker, state);
	                            }
	                        } else {
	                            if (h.pcdata) {
	                                h.pcdata('&lt;', param, continuationMarker,
	                                    continuationMaker(h, parts, pos, state, param));
	                            }
	                        }
	                        break;
	                    case '<\!--':
	                        // The pathological case is n copies of '<\!--' without '-->', and
	                        // repeated failure to find '-->' is quadratic.  We avoid that by
	                        // remembering when search for '-->' fails.
	                        if (!state.noMoreEndComments) {
	                            // A comment <\!--x--> is split into three tokens:
	                            //   '<\!--', 'x--', '>'
	                            // We want to find the next '>' token that has a preceding '--'.
	                            // pos is at the 'x--'.
	                            for (p = pos + 1; p < end; p++) {
	                                if (parts[p] === '>' && /--$/.test(parts[p - 1])) { break; }
	                            }
	                            if (p < end) {
	                                if (h.comment) {
	                                    var comment = parts.slice(pos, p).join('');
	                                    h.comment(
	                                        comment.substr(0, comment.length - 2), param,
	                                        continuationMarker,
	                                        continuationMaker(h, parts, p + 1, state, param));
	                                }
	                                pos = p + 1;
	                            } else {
	                                state.noMoreEndComments = true;
	                            }
	                        }
	                        if (state.noMoreEndComments) {
	                            if (h.pcdata) {
	                                h.pcdata('&lt;!--', param, continuationMarker,
	                                    continuationMaker(h, parts, pos, state, param));
	                            }
	                        }
	                        break;
	                    case '<\!':
	                        if (!/^\w/.test(next)) {
	                            if (h.pcdata) {
	                                h.pcdata('&lt;!', param, continuationMarker,
	                                    continuationMaker(h, parts, pos, state, param));
	                            }
	                        } else {
	                            // similar to noMoreEndComment logic
	                            if (!state.noMoreGT) {
	                                for (p = pos + 1; p < end; p++) {
	                                    if (parts[p] === '>') { break; }
	                                }
	                                if (p < end) {
	                                    pos = p + 1;
	                                } else {
	                                    state.noMoreGT = true;
	                                }
	                            }
	                            if (state.noMoreGT) {
	                                if (h.pcdata) {
	                                    h.pcdata('&lt;!', param, continuationMarker,
	                                        continuationMaker(h, parts, pos, state, param));
	                                }
	                            }
	                        }
	                        break;
	                    case '<?':
	                        // similar to noMoreEndComment logic
	                        if (!state.noMoreGT) {
	                            for (p = pos + 1; p < end; p++) {
	                                if (parts[p] === '>') { break; }
	                            }
	                            if (p < end) {
	                                pos = p + 1;
	                            } else {
	                                state.noMoreGT = true;
	                            }
	                        }
	                        if (state.noMoreGT) {
	                            if (h.pcdata) {
	                                h.pcdata('&lt;?', param, continuationMarker,
	                                    continuationMaker(h, parts, pos, state, param));
	                            }
	                        }
	                        break;
	                    case '>':
	                        if (h.pcdata) {
	                            h.pcdata("&gt;", param, continuationMarker,
	                                continuationMaker(h, parts, pos, state, param));
	                        }
	                        break;
	                    case '':
	                        break;
	                    default:
	                        if (h.pcdata) {
	                            h.pcdata(current, param, continuationMarker,
	                                continuationMaker(h, parts, pos, state, param));
	                        }
	                        break;
	                }
	            }
	            if (h.endDoc) { h.endDoc(param); }
	        } catch (e) {
	            if (e !== continuationMarker) { throw e; }
	        }
	    }
	
	    // Split str into parts for the html parser.
	    function htmlSplit(str) {
	        // can't hoist this out of the function because of the re.exec loop.
	        var re = /(<\/|<\!--|<[!?]|[&<>])/g;
	        str += '';
	        if (splitWillCapture) {
	            return str.split(re);
	        } else {
	            var parts = [];
	            var lastPos = 0;
	            var m;
	            while ((m = re.exec(str)) !== null) {
	                parts.push(str.substring(lastPos, m.index));
	                parts.push(m[0]);
	                lastPos = m.index + m[0].length;
	            }
	            parts.push(str.substring(lastPos));
	            return parts;
	        }
	    }
	
	    function parseEndTag(parts, pos, h, param, continuationMarker, state) {
	        var tag = parseTagAndAttrs(parts, pos);
	        // drop unclosed tags
	        if (!tag) { return parts.length; }
	        if (h.endTag) {
	            h.endTag(tag.name, param, continuationMarker,
	                continuationMaker(h, parts, pos, state, param));
	        }
	        return tag.next;
	    }
	
	    function parseStartTag(parts, pos, h, param, continuationMarker, state) {
	        var tag = parseTagAndAttrs(parts, pos);
	        // drop unclosed tags
	        if (!tag) { return parts.length; }
	        if (h.startTag) {
	            h.startTag(tag.name, tag.attrs, param, continuationMarker,
	                continuationMaker(h, parts, tag.next, state, param));
	        }
	        // tags like <script> and <textarea> have special parsing
	        if (tag.eflags & EFLAGS_TEXT) {
	            return parseText(parts, tag, h, param, continuationMarker, state);
	        } else {
	            return tag.next;
	        }
	    }
	
	    var endTagRe = {};
	
	    // Tags like <script> and <textarea> are flagged as CDATA or RCDATA,
	    // which means everything is text until we see the correct closing tag.
	    function parseText(parts, tag, h, param, continuationMarker, state) {
	        var end = parts.length;
	        if (!endTagRe.hasOwnProperty(tag.name)) {
	            endTagRe[tag.name] = new RegExp('^' + tag.name + '(?:[\\s\\/]|$)', 'i');
	        }
	        var re = endTagRe[tag.name];
	        var first = tag.next;
	        var p = tag.next + 1;
	        for (; p < end; p++) {
	            if (parts[p - 1] === '<\/' && re.test(parts[p])) { break; }
	        }
	        if (p < end) { p -= 1; }
	        var buf = parts.slice(first, p).join('');
	        if (tag.eflags & html4.eflags['CDATA']) {
	            if (h.cdata) {
	                h.cdata(buf, param, continuationMarker,
	                    continuationMaker(h, parts, p, state, param));
	            }
	        } else if (tag.eflags & html4.eflags['RCDATA']) {
	            if (h.rcdata) {
	                h.rcdata(normalizeRCData(buf), param, continuationMarker,
	                    continuationMaker(h, parts, p, state, param));
	            }
	        } else {
	            throw new Error('bug');
	        }
	        return p;
	    }
	
	    // at this point, parts[pos-1] is either "<" or "<\/".
	    function parseTagAndAttrs(parts, pos) {
	        var m = /^([-\w:]+)/.exec(parts[pos]);
	        var tag = {};
	        tag.name = m[1].toLowerCase();
	        tag.eflags = html4.ELEMENTS[tag.name];
	        var buf = parts[pos].substr(m[0].length);
	        // Find the next '>'.  We optimistically assume this '>' is not in a
	        // quoted context, and further down we fix things up if it turns out to
	        // be quoted.
	        var p = pos + 1;
	        var end = parts.length;
	        for (; p < end; p++) {
	            if (parts[p] === '>') { break; }
	            buf += parts[p];
	        }
	        if (end <= p) { return void 0; }
	        var attrs = [];
	        while (buf !== '') {
	            m = ATTR_RE.exec(buf);
	            if (!m) {
	                // No attribute found: skip garbage
	                buf = buf.replace(/^[\s\S][^a-z\s]*/, '');
	
	            } else if ((m[4] && !m[5]) || (m[6] && !m[7])) {
	                // Unterminated quote: slurp to the next unquoted '>'
	                var quote = m[4] || m[6];
	                var sawQuote = false;
	                var abuf = [buf, parts[p++]];
	                for (; p < end; p++) {
	                    if (sawQuote) {
	                        if (parts[p] === '>') { break; }
	                    } else if (0 <= parts[p].indexOf(quote)) {
	                        sawQuote = true;
	                    }
	                    abuf.push(parts[p]);
	                }
	                // Slurp failed: lose the garbage
	                if (end <= p) { break; }
	                // Otherwise retry attribute parsing
	                buf = abuf.join('');
	                continue;
	
	            } else {
	                // We have an attribute
	                var aName = m[1].toLowerCase();
	                var aValue = m[2] ? decodeValue(m[3]) : '';
	                attrs.push(aName, aValue);
	                buf = buf.substr(m[0].length);
	            }
	        }
	        tag.attrs = attrs;
	        tag.next = p + 1;
	        return tag;
	    }
	
	    function decodeValue(v) {
	        var q = v.charCodeAt(0);
	        if (q === 0x22 || q === 0x27) { // " or '
	            v = v.substr(1, v.length - 2);
	        }
	        return unescapeEntities(stripNULs(v));
	    }
	
	    /**
	     * Returns a function that strips unsafe tags and attributes from html.
	     * @param {function(string, Array.<string>): ?Array.<string>} tagPolicy
	     *     A function that takes (tagName, attribs[]), where tagName is a key in
	     *     html4.ELEMENTS and attribs is an array of alternating attribute names
	     *     and values.  It should return a record (as follows), or null to delete
	     *     the element.  It's okay for tagPolicy to modify the attribs array,
	     *     but the same array is reused, so it should not be held between calls.
	     *     Record keys:
	     *        attribs: (required) Sanitized attributes array.
	     *        tagName: Replacement tag name.
	     * @return {function(string, Array)} A function that sanitizes a string of
	     *     HTML and appends result strings to the second argument, an array.
	     */
	    function makeHtmlSanitizer(tagPolicy) {
	        var stack;
	        var ignoring;
	        var emit = function (text, out) {
	            if (!ignoring) { out.push(text); }
	        };
	        return makeSaxParser({
	            'startDoc': function(_) {
	                stack = [];
	                ignoring = false;
	            },
	            'startTag': function(tagNameOrig, attribs, out) {
	                if (ignoring) { return; }
	                if (!html4.ELEMENTS.hasOwnProperty(tagNameOrig)) { return; }
	                var eflagsOrig = html4.ELEMENTS[tagNameOrig];
	                if (eflagsOrig & html4.eflags['FOLDABLE']) {
	                    return;
	                }
	
	                var decision = tagPolicy(tagNameOrig, attribs);
	                if (!decision) {
	                    ignoring = !(eflagsOrig & html4.eflags['EMPTY']);
	                    return;
	                } else if (typeof decision !== 'object') {
	                    throw new Error('tagPolicy did not return object (old API?)');
	                }
	                if ('attribs' in decision) {
	                    attribs = decision['attribs'];
	                } else {
	                    throw new Error('tagPolicy gave no attribs');
	                }
	                var eflagsRep;
	                var tagNameRep;
	                if ('tagName' in decision) {
	                    tagNameRep = decision['tagName'];
	                    eflagsRep = html4.ELEMENTS[tagNameRep];
	                } else {
	                    tagNameRep = tagNameOrig;
	                    eflagsRep = eflagsOrig;
	                }
	                // TODO(mikesamuel): relying on tagPolicy not to insert unsafe
	                // attribute names.
	
	                // If this is an optional-end-tag element and either this element or its
	                // previous like sibling was rewritten, then insert a close tag to
	                // preserve structure.
	                if (eflagsOrig & html4.eflags['OPTIONAL_ENDTAG']) {
	                    var onStack = stack[stack.length - 1];
	                    if (onStack && onStack.orig === tagNameOrig &&
	                        (onStack.rep !== tagNameRep || tagNameOrig !== tagNameRep)) {
	                        out.push('<\/', onStack.rep, '>');
	                    }
	                }
	
	                if (!(eflagsOrig & html4.eflags['EMPTY'])) {
	                    stack.push({orig: tagNameOrig, rep: tagNameRep});
	                }
	
	                out.push('<', tagNameRep);
	                for (var i = 0, n = attribs.length; i < n; i += 2) {
	                    var attribName = attribs[i],
	                        value = attribs[i + 1];
	                    if (value !== null && value !== void 0) {
	                        out.push(' ', attribName, '="', escapeAttrib(value), '"');
	                    }
	                }
	                out.push('>');
	
	                if ((eflagsOrig & html4.eflags['EMPTY'])
	                    && !(eflagsRep & html4.eflags['EMPTY'])) {
	                    // replacement is non-empty, synthesize end tag
	                    out.push('<\/', tagNameRep, '>');
	                }
	            },
	            'endTag': function(tagName, out) {
	                if (ignoring) {
	                    ignoring = false;
	                    return;
	                }
	                if (!html4.ELEMENTS.hasOwnProperty(tagName)) { return; }
	                var eflags = html4.ELEMENTS[tagName];
	                if (!(eflags & (html4.eflags['EMPTY'] | html4.eflags['FOLDABLE']))) {
	                    var index;
	                    if (eflags & html4.eflags['OPTIONAL_ENDTAG']) {
	                        for (index = stack.length; --index >= 0;) {
	                            var stackElOrigTag = stack[index].orig;
	                            if (stackElOrigTag === tagName) { break; }
	                            if (!(html4.ELEMENTS[stackElOrigTag] &
	                                html4.eflags['OPTIONAL_ENDTAG'])) {
	                                // Don't pop non optional end tags looking for a match.
	                                return;
	                            }
	                        }
	                    } else {
	                        for (index = stack.length; --index >= 0;) {
	                            if (stack[index].orig === tagName) { break; }
	                        }
	                    }
	                    if (index < 0) { return; }  // Not opened.
	                    for (var i = stack.length; --i > index;) {
	                        var stackElRepTag = stack[i].rep;
	                        if (!(html4.ELEMENTS[stackElRepTag] &
	                            html4.eflags['OPTIONAL_ENDTAG'])) {
	                            out.push('<\/', stackElRepTag, '>');
	                        }
	                    }
	                    if (index < stack.length) {
	                        tagName = stack[index].rep;
	                    }
	                    stack.length = index;
	                    out.push('<\/', tagName, '>');
	                }
	            },
	            'pcdata': emit,
	            'rcdata': emit,
	            'cdata': emit,
	            'endDoc': function(out) {
	                for (; stack.length; stack.length--) {
	                    out.push('<\/', stack[stack.length - 1].rep, '>');
	                }
	            }
	        });
	    }
	
	    var ALLOWED_URI_SCHEMES = /^(?:https?|mailto)$/i;
	
	    function safeUri(uri, effect, ltype, hints, naiveUriRewriter) {
	        if (!naiveUriRewriter) { return null; }
	        try {
	            var parsed = URI.parse('' + uri);
	            if (parsed) {
	                if (!parsed.hasScheme() ||
	                    ALLOWED_URI_SCHEMES.test(parsed.getScheme())) {
	                    var safe = naiveUriRewriter(parsed, effect, ltype, hints);
	                    return safe ? safe.toString() : null;
	                }
	            }
	        } catch (e) {
	            return null;
	        }
	        return null;
	    }
	
	    function log(logger, tagName, attribName, oldValue, newValue) {
	        if (!attribName) {
	            logger(tagName + " removed", {
	                change: "removed",
	                tagName: tagName
	            });
	        }
	        if (oldValue !== newValue) {
	            var changed = "changed";
	            if (oldValue && !newValue) {
	                changed = "removed";
	            } else if (!oldValue && newValue)  {
	                changed = "added";
	            }
	            logger(tagName + "." + attribName + " " + changed, {
	                change: changed,
	                tagName: tagName,
	                attribName: attribName,
	                oldValue: oldValue,
	                newValue: newValue
	            });
	        }
	    }
	
	    function lookupAttribute(map, tagName, attribName) {
	        var attribKey;
	        attribKey = tagName + '::' + attribName;
	        if (map.hasOwnProperty(attribKey)) {
	            return map[attribKey];
	        }
	        attribKey = '*::' + attribName;
	        if (map.hasOwnProperty(attribKey)) {
	            return map[attribKey];
	        }
	        return void 0;
	    }
	    function getAttributeType(tagName, attribName) {
	        return lookupAttribute(html4.ATTRIBS, tagName, attribName);
	    }
	    function getLoaderType(tagName, attribName) {
	        return lookupAttribute(html4.LOADERTYPES, tagName, attribName);
	    }
	    function getUriEffect(tagName, attribName) {
	        return lookupAttribute(html4.URIEFFECTS, tagName, attribName);
	    }
	
	    /**
	     * Sanitizes attributes on an HTML tag.
	     * @param {string} tagName An HTML tag name in lowercase.
	     * @param {Array.<?string>} attribs An array of alternating names and values.
	     * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
	     *     apply to URI attributes; it can return a new string value, or null to
	     *     delete the attribute.  If unspecified, URI attributes are deleted.
	     * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
	     *     to attributes containing HTML names, element IDs, and space-separated
	     *     lists of classes; it can return a new string value, or null to delete
	     *     the attribute.  If unspecified, these attributes are kept unchanged.
	     * @return {Array.<?string>} The sanitized attributes as a list of alternating
	     *     names and values, where a null value means to omit the attribute.
	     */
	    function sanitizeAttribs(tagName, attribs,
	        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
	        // TODO(felix8a): it's obnoxious that domado duplicates much of this
	        // TODO(felix8a): maybe consistently enforce constraints like target=
	        for (var i = 0; i < attribs.length; i += 2) {
	            var attribName = attribs[i];
	            var value = attribs[i + 1];
	            var oldValue = value;
	            var atype = null, attribKey;
	            if ((attribKey = tagName + '::' + attribName,
	                html4.ATTRIBS.hasOwnProperty(attribKey)) ||
	                (attribKey = '*::' + attribName,
	                    html4.ATTRIBS.hasOwnProperty(attribKey))) {
	                atype = html4.ATTRIBS[attribKey];
	            }
	            if (atype !== null) {
	                switch (atype) {
	                    case html4.atype['NONE']: break;
	                    case html4.atype['SCRIPT']:
	                        value = null;
	                        if (opt_logger) {
	                            log(opt_logger, tagName, attribName, oldValue, value);
	                        }
	                        break;
	                    case html4.atype['STYLE']:
	                        if ('undefined' === typeof parseCssDeclarations) {
	                            value = null;
	                            if (opt_logger) {
	                                log(opt_logger, tagName, attribName, oldValue, value);
	                            }
	                            break;
	                        }
	                        var sanitizedDeclarations = [];
	                        parseCssDeclarations(
	                            value,
	                            {
	                                'declaration': function (property, tokens) {
	                                    var normProp = property.toLowerCase();
	                                    sanitizeCssProperty(
	                                        normProp, tokens,
	                                        opt_naiveUriRewriter
	                                            ? function (url) {
	                                            return safeUri(
	                                                url, html4.ueffects.SAME_DOCUMENT,
	                                                html4.ltypes.SANDBOXED,
	                                                {
	                                                    "TYPE": "CSS",
	                                                    "CSS_PROP": normProp
	                                                }, opt_naiveUriRewriter);
	                                        }
	                                            : null);
	                                    if (tokens.length) {
	                                        sanitizedDeclarations.push(
	                                            normProp + ': ' + tokens.join(' '));
	                                    }
	                                }
	                            });
	                        value = sanitizedDeclarations.length > 0 ?
	                            sanitizedDeclarations.join(' ; ') : null;
	                        if (opt_logger) {
	                            log(opt_logger, tagName, attribName, oldValue, value);
	                        }
	                        break;
	                    case html4.atype['ID']:
	                    case html4.atype['IDREF']:
	                    case html4.atype['IDREFS']:
	                    case html4.atype['GLOBAL_NAME']:
	                    case html4.atype['LOCAL_NAME']:
	                    case html4.atype['CLASSES']:
	                        value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
	                        if (opt_logger) {
	                            log(opt_logger, tagName, attribName, oldValue, value);
	                        }
	                        break;
	                    case html4.atype['URI']:
	                        value = safeUri(value,
	                            getUriEffect(tagName, attribName),
	                            getLoaderType(tagName, attribName),
	                            {
	                                "TYPE": "MARKUP",
	                                "XML_ATTR": attribName,
	                                "XML_TAG": tagName
	                            }, opt_naiveUriRewriter);
	                        if (opt_logger) {
	                            log(opt_logger, tagName, attribName, oldValue, value);
	                        }
	                        break;
	                    case html4.atype['URI_FRAGMENT']:
	                        if (value && '#' === value.charAt(0)) {
	                            value = value.substring(1);  // remove the leading '#'
	                            value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
	                            if (value !== null && value !== void 0) {
	                                value = '#' + value;  // restore the leading '#'
	                            }
	                        } else {
	                            value = null;
	                        }
	                        if (opt_logger) {
	                            log(opt_logger, tagName, attribName, oldValue, value);
	                        }
	                        break;
	                    default:
	                        value = null;
	                        if (opt_logger) {
	                            log(opt_logger, tagName, attribName, oldValue, value);
	                        }
	                        break;
	                }
	            } else {
	                value = null;
	                if (opt_logger) {
	                    log(opt_logger, tagName, attribName, oldValue, value);
	                }
	            }
	            attribs[i + 1] = value;
	        }
	        return attribs;
	    }
	
	    /**
	     * Creates a tag policy that omits all tags marked UNSAFE in html4-defs.js
	     * and applies the default attribute sanitizer with the supplied policy for
	     * URI attributes and NMTOKEN attributes.
	     * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
	     *     apply to URI attributes.  If not given, URI attributes are deleted.
	     * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
	     *     to attributes containing HTML names, element IDs, and space-separated
	     *     lists of classes.  If not given, such attributes are left unchanged.
	     * @return {function(string, Array.<?string>)} A tagPolicy suitable for
	     *     passing to html.sanitize.
	     */
	    function makeTagPolicy(
	        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
	        return function(tagName, attribs) {
	            if (!(html4.ELEMENTS[tagName] & html4.eflags['UNSAFE'])) {
	                return {
	                    'attribs': sanitizeAttribs(tagName, attribs,
	                        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger)
	                };
	            } else {
	                if (opt_logger) {
	                    log(opt_logger, tagName, undefined, undefined, undefined);
	                }
	            }
	        };
	    }
	
	    /**
	     * Sanitizes HTML tags and attributes according to a given policy.
	     * @param {string} inputHtml The HTML to sanitize.
	     * @param {function(string, Array.<?string>)} tagPolicy A function that
	     *     decides which tags to accept and sanitizes their attributes (see
	     *     makeHtmlSanitizer above for details).
	     * @return {string} The sanitized HTML.
	     */
	    function sanitizeWithPolicy(inputHtml, tagPolicy) {
	        var outputArray = [];
	        makeHtmlSanitizer(tagPolicy)(inputHtml, outputArray);
	        return outputArray.join('');
	    }
	
	    /**
	     * Strips unsafe tags and attributes from HTML.
	     * @param {string} inputHtml The HTML to sanitize.
	     * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
	     *     apply to URI attributes.  If not given, URI attributes are deleted.
	     * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
	     *     to attributes containing HTML names, element IDs, and space-separated
	     *     lists of classes.  If not given, such attributes are left unchanged.
	     */
	    function sanitize(inputHtml,
	        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
	        var tagPolicy = makeTagPolicy(
	            opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);
	        return sanitizeWithPolicy(inputHtml, tagPolicy);
	    }
	
	    // Export both quoted and unquoted names for Closure linkage.
	    var html = {};
	    html.escapeAttrib = html['escapeAttrib'] = escapeAttrib;
	    html.makeHtmlSanitizer = html['makeHtmlSanitizer'] = makeHtmlSanitizer;
	    html.makeSaxParser = html['makeSaxParser'] = makeSaxParser;
	    html.makeTagPolicy = html['makeTagPolicy'] = makeTagPolicy;
	    html.normalizeRCData = html['normalizeRCData'] = normalizeRCData;
	    html.sanitize = html['sanitize'] = sanitize;
	    html.sanitizeAttribs = html['sanitizeAttribs'] = sanitizeAttribs;
	    html.sanitizeWithPolicy = html['sanitizeWithPolicy'] = sanitizeWithPolicy;
	    html.unescapeEntities = html['unescapeEntities'] = unescapeEntities;
	    return html;
	})(html4);
	
	var html_sanitize = html['sanitize'];
	
	// Exports for Closure compiler.  Note this file is also cajoled
	// for domado and run in an environment without 'window'
	if (typeof window !== 'undefined') {
	    window['html'] = html;
	    window['html_sanitize'] = html_sanitize;
	}
	
	var Sanitizer = {};
	
	// Ensure backwards compatibility
	Sanitizer.escapeAttrib = html.escapeAttrib;
	Sanitizer.makeHtmlSanitizer = html.makeHtmlSanitizer;
	Sanitizer.makeSaxParser = html.makeSaxParser;
	Sanitizer.makeTagPolicy = html.makeTagPolicy;
	Sanitizer.normalizeRCData = html.normalizeRCData
	Sanitizer.sanitizeAttribs = html.sanitizeAttribs
	Sanitizer.sanitizeWithPolicy = html.sanitizeWithPolicy
	Sanitizer.unescapeEntities = html.unescapeEntities
	Sanitizer.escape = html.escapeAttrib;
	
	// https://github.com/theSmaw/Caja-HTML-Sanitizer/issues/8
	Sanitizer.sanitize = function(inputHtml, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
	    if (typeof(inputHtml) === "string") {
	        inputHtml = inputHtml.replace(/<([a-zA-Z]+)([^>]*)\/>/g, '<$1$2></$1>');
	    }
	    
	    if (inputHtml) {
	        return html.sanitize(inputHtml, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);
	    }
	    else {
	        return inputHtml;
	    }
	    
	}
	
	// the browser, add 'Sanitizer' as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	        exports = module.exports = Sanitizer;
	    }
	    exports.Sanitizer = Sanitizer;
	} else {
	    this.Sanitizer = Sanitizer;
	}


/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright Google Inc.
	 * Licensed under the Apache Licence Version 2.0
	 * Autogenerated at Fri Aug 13 11:26:55 PDT 2010
	 * @provides html4
	 */
	var html4 = {};
	html4 .atype = {
	    'NONE': 0,
	    'URI': 1,
	    'URI_FRAGMENT': 11,
	    'SCRIPT': 2,
	    'STYLE': 3,
	    'ID': 4,
	    'IDREF': 5,
	    'IDREFS': 6,
	    'GLOBAL_NAME': 7,
	    'LOCAL_NAME': 8,
	    'CLASSES': 9,
	    'FRAME_TARGET': 10
	};
	html4 .ATTRIBS = {
	    '*::class': 9,
	    '*::dir': 0,
	    '*::id': 4,
	    '*::lang': 0,
	    '*::onclick': 2,
	    '*::ondblclick': 2,
	    '*::onkeydown': 2,
	    '*::onkeypress': 2,
	    '*::onkeyup': 2,
	    '*::onload': 2,
	    '*::onmousedown': 2,
	    '*::onmousemove': 2,
	    '*::onmouseout': 2,
	    '*::onmouseover': 2,
	    '*::onmouseup': 2,
	    '*::style': 3,
	    '*::title': 0,
	    'a::accesskey': 0,
	    'a::coords': 0,
	    'a::href': 1,
	    'a::hreflang': 0,
	    'a::name': 7,
	    'a::onblur': 2,
	    'a::onfocus': 2,
	    'a::rel': 0,
	    'a::rev': 0,
	    'a::shape': 0,
	    'a::tabindex': 0,
	    'a::target': 10,
	    'a::type': 0,
	    'area::accesskey': 0,
	    'area::alt': 0,
	    'area::coords': 0,
	    'area::href': 1,
	    'area::nohref': 0,
	    'area::onblur': 2,
	    'area::onfocus': 2,
	    'area::shape': 0,
	    'area::tabindex': 0,
	    'area::target': 10,
	    'bdo::dir': 0,
	    'blockquote::cite': 1,
	    'br::clear': 0,
	    'button::accesskey': 0,
	    'button::disabled': 0,
	    'button::name': 8,
	    'button::onblur': 2,
	    'button::onfocus': 2,
	    'button::tabindex': 0,
	    'button::type': 0,
	    'button::value': 0,
	    'caption::align': 0,
	    'col::align': 0,
	    'col::char': 0,
	    'col::charoff': 0,
	    'col::span': 0,
	    'col::valign': 0,
	    'col::width': 0,
	    'colgroup::align': 0,
	    'colgroup::char': 0,
	    'colgroup::charoff': 0,
	    'colgroup::span': 0,
	    'colgroup::valign': 0,
	    'colgroup::width': 0,
	    'del::cite': 1,
	    'del::datetime': 0,
	    'dir::compact': 0,
	    'div::align': 0,
	    'dl::compact': 0,
	    'font::color': 0,
	    'font::face': 0,
	    'font::size': 0,
	    'form::accept': 0,
	    'form::action': 1,
	    'form::autocomplete': 0,
	    'form::enctype': 0,
	    'form::method': 0,
	    'form::name': 7,
	    'form::onreset': 2,
	    'form::onsubmit': 2,
	    'form::target': 10,
	    'h1::align': 0,
	    'h2::align': 0,
	    'h3::align': 0,
	    'h4::align': 0,
	    'h5::align': 0,
	    'h6::align': 0,
	    'hr::align': 0,
	    'hr::noshade': 0,
	    'hr::size': 0,
	    'hr::width': 0,
	    'iframe::align': 0,
	    'iframe::frameborder': 0,
	    'iframe::height': 0,
	    'iframe::marginheight': 0,
	    'iframe::marginwidth': 0,
	    'iframe::width': 0,
	    'img::align': 0,
	    'img::alt': 0,
	    'img::border': 0,
	    'img::height': 0,
	    'img::hspace': 0,
	    'img::ismap': 0,
	    'img::name': 7,
	    'img::src': 1,
	    'img::usemap': 11,
	    'img::vspace': 0,
	    'img::width': 0,
	    'input::accept': 0,
	    'input::accesskey': 0,
	    'input::align': 0,
	    'input::alt': 0,
	    'input::autocomplete': 0,
	    'input::checked': 0,
	    'input::disabled': 0,
	    'input::ismap': 0,
	    'input::maxlength': 0,
	    'input::name': 8,
	    'input::onblur': 2,
	    'input::onchange': 2,
	    'input::onfocus': 2,
	    'input::onselect': 2,
	    'input::readonly': 0,
	    'input::size': 0,
	    'input::src': 1,
	    'input::tabindex': 0,
	    'input::type': 0,
	    'input::usemap': 11,
	    'input::value': 0,
	    'ins::cite': 1,
	    'ins::datetime': 0,
	    'label::accesskey': 0,
	    'label::for': 5,
	    'label::onblur': 2,
	    'label::onfocus': 2,
	    'legend::accesskey': 0,
	    'legend::align': 0,
	    'li::type': 0,
	    'li::value': 0,
	    'map::name': 7,
	    'menu::compact': 0,
	    'ol::compact': 0,
	    'ol::start': 0,
	    'ol::type': 0,
	    'optgroup::disabled': 0,
	    'optgroup::label': 0,
	    'option::disabled': 0,
	    'option::label': 0,
	    'option::selected': 0,
	    'option::value': 0,
	    'p::align': 0,
	    'pre::width': 0,
	    'q::cite': 1,
	    'select::disabled': 0,
	    'select::multiple': 0,
	    'select::name': 8,
	    'select::onblur': 2,
	    'select::onchange': 2,
	    'select::onfocus': 2,
	    'select::size': 0,
	    'select::tabindex': 0,
	    'table::align': 0,
	    'table::bgcolor': 0,
	    'table::border': 0,
	    'table::cellpadding': 0,
	    'table::cellspacing': 0,
	    'table::frame': 0,
	    'table::rules': 0,
	    'table::summary': 0,
	    'table::width': 0,
	    'tbody::align': 0,
	    'tbody::char': 0,
	    'tbody::charoff': 0,
	    'tbody::valign': 0,
	    'td::abbr': 0,
	    'td::align': 0,
	    'td::axis': 0,
	    'td::bgcolor': 0,
	    'td::char': 0,
	    'td::charoff': 0,
	    'td::colspan': 0,
	    'td::headers': 6,
	    'td::height': 0,
	    'td::nowrap': 0,
	    'td::rowspan': 0,
	    'td::scope': 0,
	    'td::valign': 0,
	    'td::width': 0,
	    'textarea::accesskey': 0,
	    'textarea::cols': 0,
	    'textarea::disabled': 0,
	    'textarea::name': 8,
	    'textarea::onblur': 2,
	    'textarea::onchange': 2,
	    'textarea::onfocus': 2,
	    'textarea::onselect': 2,
	    'textarea::readonly': 0,
	    'textarea::rows': 0,
	    'textarea::tabindex': 0,
	    'tfoot::align': 0,
	    'tfoot::char': 0,
	    'tfoot::charoff': 0,
	    'tfoot::valign': 0,
	    'th::abbr': 0,
	    'th::align': 0,
	    'th::axis': 0,
	    'th::bgcolor': 0,
	    'th::char': 0,
	    'th::charoff': 0,
	    'th::colspan': 0,
	    'th::headers': 6,
	    'th::height': 0,
	    'th::nowrap': 0,
	    'th::rowspan': 0,
	    'th::scope': 0,
	    'th::valign': 0,
	    'th::width': 0,
	    'thead::align': 0,
	    'thead::char': 0,
	    'thead::charoff': 0,
	    'thead::valign': 0,
	    'tr::align': 0,
	    'tr::bgcolor': 0,
	    'tr::char': 0,
	    'tr::charoff': 0,
	    'tr::valign': 0,
	    'ul::compact': 0,
	    'ul::type': 0
	};
	html4 .eflags = {
	    'OPTIONAL_ENDTAG': 1,
	    'EMPTY': 2,
	    'CDATA': 4,
	    'RCDATA': 8,
	    'UNSAFE': 16,
	    'FOLDABLE': 32,
	    'SCRIPT': 64,
	    'STYLE': 128
	};
	html4 .ELEMENTS = {
	    'a': 0,
	    'abbr': 0,
	    'acronym': 0,
	    'address': 0,
	    'applet': 16,
	    'area': 2,
	    'b': 0,
	    'base': 18,
	    'basefont': 18,
	    'bdo': 0,
	    'big': 0,
	    'blockquote': 0,
	    'body': 49,
	    'br': 2,
	    'button': 0,
	    'caption': 0,
	    'center': 0,
	    'cite': 0,
	    'code': 0,
	    'col': 2,
	    'colgroup': 1,
	    'dd': 1,
	    'del': 0,
	    'dfn': 0,
	    'dir': 0,
	    'div': 0,
	    'dl': 0,
	    'dt': 1,
	    'em': 0,
	    'fieldset': 0,
	    'font': 0,
	    'form': 0,
	    'frame': 18,
	    'frameset': 16,
	    'h1': 0,
	    'h2': 0,
	    'h3': 0,
	    'h4': 0,
	    'h5': 0,
	    'h6': 0,
	    'head': 49,
	    'hr': 2,
	    'html': 49,
	    'i': 0,
	    'iframe': 4,
	    'img': 2,
	    'input': 2,
	    'ins': 0,
	    'isindex': 18,
	    'kbd': 0,
	    'label': 0,
	    'legend': 0,
	    'li': 1,
	    'link': 18,
	    'map': 0,
	    'menu': 0,
	    'meta': 18,
	    'noframes': 20,
	    'noscript': 20,
	    'object': 16,
	    'ol': 0,
	    'optgroup': 0,
	    'option': 1,
	    'p': 1,
	    'param': 18,
	    'pre': 0,
	    'q': 0,
	    's': 0,
	    'samp': 0,
	    'script': 84,
	    'select': 0,
	    'small': 0,
	    'span': 0,
	    'strike': 0,
	    'strong': 0,
	    'style': 148,
	    'sub': 0,
	    'sup': 0,
	    'table': 0,
	    'tbody': 1,
	    'td': 1,
	    'textarea': 8,
	    'tfoot': 1,
	    'th': 1,
	    'thead': 1,
	    'title': 24,
	    'tr': 1,
	    'tt': 0,
	    'u': 0,
	    'ul': 0,
	    'var': 0
	};
	
	html4 .URIEFFECTS = {
	
	};
	html4 .LOADERTYPES = {}
	
	if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	        exports = module.exports = html4;
	    }
	    exports.URI = html4;
	} else {
	
	    // Exports for closure compiler.
	    if (typeof window !== 'undefined') {
	        window['html4'] = html4;
	    }
	}


/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _glance_actions = __webpack_require__(535);
	
	var _glance_actions2 = _interopRequireDefault(_glance_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _jsonschema = __webpack_require__(536);
	
	var _glance_metadata = __webpack_require__(545);
	
	var _glance_metadata2 = _interopRequireDefault(_glance_metadata);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var jsonValidator = new _jsonschema.Validator();
	
	var GlanceHelper = function () {
	  function GlanceHelper() {
	    (0, _classCallCheck3.default)(this, GlanceHelper);
	  }
	
	  (0, _createClass3.default)(GlanceHelper, [{
	    key: "fetchGlanceMetadataForRoom",
	    value: function fetchGlanceMetadataForRoom(room_id) {
	      var _this = this;
	
	      var startTimestamp = _utils2.default.timings.now();
	
	      _app_dispatcher2.default.dispatch('API:fetch-all-glances-for-room', {
	        room_id: room_id,
	        timeout: _app_config2.default.integrations.glance_remote_metadata_timeout
	      }, function (fetch_result) {
	        fetch_result.then(function (glances) {
	          glances.forEach(function (_ref) {
	            var promise = _ref.promise;
	            var key = _ref.key;
	
	            _glance_actions2.default.glanceMetadataLoading(room_id, key);
	            promise.then(function (_ref2) {
	              var path = _ref2.path;
	              var data = _ref2.data;
	              var result = _ref2.result;
	
	              var glance = _this._createGlanceFromKey(key, path);
	              _this._processGlanceReturnedData(room_id, glance, data, result, startTimestamp);
	            });
	          });
	          _glance_actions2.default.roomFinishedLoading(room_id, true);
	        }).catch(function (err) {
	          _logger2.default.warn('[HC-Integrations]', "Failed to fetch signed url for room " + room_id + " " + err);
	          _glance_actions2.default.roomFinishedLoading(room_id, false);
	        });
	      });
	    }
	  }, {
	    key: "fetchGlanceRemoteMetadata",
	    value: function fetchGlanceRemoteMetadata(room_id, glance) {
	      var _this2 = this;
	
	      var startTimestamp = _utils2.default.timings.now();
	      _app_dispatcher2.default.dispatch('API:request-with-signed-url', {
	        extension: glance,
	        attribute: 'query_url',
	        room_id: room_id,
	        timeout: _app_config2.default.integrations.glance_remote_metadata_timeout
	      }, {}, function (data, result) {
	        _this2._processGlanceReturnedData(room_id, glance, data, result, startTimestamp);
	      });
	    }
	  }, {
	    key: "_processGlanceReturnedData",
	    value: function _processGlanceReturnedData(room_id, glance, data, result, startTimestamp) {
	      var duration = Math.floor(_utils2.default.timings.now() - startTimestamp);
	      if (!data || data.error || result.status >= 400) {
	
	        _glance_actions2.default.glanceMetadataError(room_id, glance, "Could not load data for this glance.", duration);
	      } else {
	        if (!this._validateMetadataFromRemote(data, glance)) {
	          _glance_actions2.default.glanceMetadataError(room_id, glance, "Could not validate data for this glance.", duration);
	          return;
	        }
	
	        _glance_actions2.default.glanceMetadataFetched(room_id, glance, data, duration);
	      }
	    }
	  }, {
	    key: "_validateMetadataFromRemote",
	    value: function _validateMetadataFromRemote(data, glance) {
	      var result = jsonValidator.validate(data, _glance_metadata2.default);
	      if (result.errors.length > 0) {
	        _logger2.default.warn('[HC-Integrations]', "Invalid schema from " + glance.query_url + " for Glance " + glance.full_key + ": " + result);
	        return false;
	      }
	
	      return true;
	    }
	  }, {
	    key: "_createGlanceFromKey",
	    value: function _createGlanceFromKey(key, path) {
	      return { full_key: key, query_url: path, addon_key: _integration_helper2.default.split_full_key(key)[0] };
	    }
	  }]);
	  return GlanceHelper;
	}();
	
	exports.default = new GlanceHelper();
	module.exports = exports['default'];

/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var AppDispatcher = __webpack_require__(9),
	    AnalyticsDispatcher = __webpack_require__(173),
	    logger = __webpack_require__(90);
	
	exports.default = {
	
	  fetchGlanceMetadata: function fetchGlanceMetadata(room_id, glance) {
	    var reload_errors = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	    AppDispatcher.dispatch('fetch-glance-metadata', room_id, glance, reload_errors);
	  },
	
	  glanceMetadataLoading: function glanceMetadataLoading(room_id, glance_key) {
	    AppDispatcher.dispatch('glance-metadata-loading', room_id, glance_key);
	  },
	
	  glanceMetadataFetched: function glanceMetadataFetched(room_id, glance, data, duration) {
	    AppDispatcher.dispatch("glance-metadata-fetched", room_id, glance.full_key, data);
	
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.integrations.glance.fetch.success",
	      properties: {
	        room_id: room_id,
	        addon_key: glance.addon_key,
	        glance_full_key: glance.full_key,
	        duration: duration
	      }
	    });
	  },
	
	  glanceMetadataError: function glanceMetadataError(room_id, glance, error, duration) {
	    logger.warn('[HC-Integrations]', error);
	
	    AppDispatcher.dispatch('glance-metadata-fetched', room_id, glance.full_key, {
	      error: error
	    });
	
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.integrations.glance.fetch.error",
	      properties: {
	        room_id: room_id,
	        addon_key: glance.addon_key,
	        glance_full_key: glance.full_key,
	        error: error,
	        duration: duration
	      }
	    });
	  },
	
	
	  roomFinishedLoading: function roomFinishedLoading(room_id, success) {
	    AppDispatcher.dispatch('glances-finished-loading-for-room', room_id, success);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Validator = module.exports.Validator = __webpack_require__(537);
	
	module.exports.ValidatorResult = __webpack_require__(544).ValidatorResult;
	module.exports.ValidationError = __webpack_require__(544).ValidationError;
	module.exports.SchemaError = __webpack_require__(544).SchemaError;
	
	module.exports.validate = function (instance, schema, options) {
	  var v = new Validator();
	  return v.validate(instance, schema, options);
	};


/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var urilib = __webpack_require__(538);
	
	var attribute = __webpack_require__(543);
	var helpers = __webpack_require__(544);
	var ValidatorResult = helpers.ValidatorResult;
	var SchemaError = helpers.SchemaError;
	var SchemaContext = helpers.SchemaContext;
	
	/**
	 * Creates a new Validator object
	 * @name Validator
	 * @constructor
	 */
	var Validator = function Validator () {
	  // Allow a validator instance to override global custom formats or to have their
	  // own custom formats.
	  this.customFormats = Object.create(Validator.prototype.customFormats);
	  this.schemas = {};
	  this.unresolvedRefs = [];
	
	  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.
	  this.types = Object.create(types);
	  this.attributes = Object.create(attribute.validators);
	};
	
	// Allow formats to be registered globally.
	Validator.prototype.customFormats = {};
	
	// Hint at the presence of a property
	Validator.prototype.schemas = null;
	Validator.prototype.types = null;
	Validator.prototype.attributes = null;
	Validator.prototype.unresolvedRefs = null;
	
	/**
	 * Adds a schema with a certain urn to the Validator instance.
	 * @param schema
	 * @param urn
	 * @return {Object}
	 */
	Validator.prototype.addSchema = function addSchema (schema, uri) {
	  if (!schema) {
	    return null;
	  }
	  var ourUri = uri || schema.id;
	  this.addSubSchema(ourUri, schema);
	  if (ourUri) {
	    this.schemas[ourUri] = schema;
	  }
	  return this.schemas[ourUri];
	};
	
	Validator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {
	  if(!schema || typeof schema!='object') return;
	  // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined
	  if(schema.$ref){
	    var resolvedUri = urilib.resolve(baseuri, schema.$ref);
	    // Only mark unknown schemas as unresolved
	    if (this.schemas[resolvedUri] === undefined) {
	      this.schemas[resolvedUri] = null;
	      this.unresolvedRefs.push(resolvedUri);
	    }
	    return;
	  }
	  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);
	  var ourBase = ourUri || baseuri;
	  if (ourUri) {
	    if(this.schemas[ourUri]){
	      if(!helpers.deepCompareStrict(this.schemas[ourUri], schema)){
	        throw new Error('Schema <'+schema+'> already exists with different definition');
	      }
	      return this.schemas[ourUri];
	    }
	    this.schemas[ourUri] = schema;
	    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');
	    this.schemas[documentUri] = schema;
	  }
	  this.addSubSchemaArray(ourBase, ((schema.items instanceof Array)?schema.items:[schema.items]));
	  this.addSubSchemaArray(ourBase, ((schema.extends instanceof Array)?schema.extends:[schema.extends]));
	  this.addSubSchema(ourBase, schema.additionalItems);
	  this.addSubSchemaObject(ourBase, schema.properties);
	  this.addSubSchema(ourBase, schema.additionalProperties);
	  this.addSubSchemaObject(ourBase, schema.definitions);
	  this.addSubSchemaObject(ourBase, schema.patternProperties);
	  this.addSubSchemaObject(ourBase, schema.dependencies);
	  this.addSubSchemaArray(ourBase, schema.disallow);
	  this.addSubSchemaArray(ourBase, schema.allOf);
	  this.addSubSchemaArray(ourBase, schema.anyOf);
	  this.addSubSchemaArray(ourBase, schema.oneOf);
	  this.addSubSchema(ourBase, schema.not);
	  return this.schemas[ourUri];
	};
	
	Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
	  if(!(schemas instanceof Array)) return;
	  for(var i=0; i<schemas.length; i++){
	    this.addSubSchema(baseuri, schemas[i]);
	  }
	};
	
	Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
	  if(!schemas || typeof schemas!='object') return;
	  for(var p in schemas){
	    this.addSubSchema(baseuri, schemas[p]);
	  }
	};
	
	
	
	/**
	 * Sets all the schemas of the Validator instance.
	 * @param schemas
	 */
	Validator.prototype.setSchemas = function setSchemas (schemas) {
	  this.schemas = schemas;
	};
	
	/**
	 * Returns the schema of a certain urn
	 * @param urn
	 */
	Validator.prototype.getSchema = function getSchema (urn) {
	  return this.schemas[urn];
	};
	
	/**
	 * Validates instance against the provided schema
	 * @param instance
	 * @param schema
	 * @param [options]
	 * @param [ctx]
	 * @return {Array}
	 */
	Validator.prototype.validate = function validate (instance, schema, options, ctx) {
	  if (!options) {
	    options = {};
	  }
	  var propertyName = options.propertyName || 'instance';
	  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI
	  var base = urilib.resolve(options.base||'/', schema.id||'');
	  if(!ctx){
	    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));
	    if (!ctx.schemas[base]) {
	      ctx.schemas[base] = schema;
	    }
	  }
	  if (schema) {
	    var result = this.validateSchema(instance, schema, options, ctx);
	    if (!result) {
	      throw new Error('Result undefined');
	    }
	    return result;
	  }
	  throw new SchemaError('no schema specified', schema);
	};
	
	/**
	 * Validates an instance against the schema (the actual work horse)
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @private
	 * @return {ValidatorResult}
	 */
	Validator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {
	  var self = this;
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!schema) {
	    throw new Error("schema is undefined");
	  }
	
	  /**
	  * @param Object schema
	  * @return mixed schema uri or false
	  */
	  function shouldResolve(schema) {
	    var ref = (typeof schema === 'string') ? schema : schema.$ref;
	    if (typeof ref=='string') return ref;
	    return false;
	  }
	  /**
	  * @param Object schema
	  * @param SchemaContext ctx
	  * @returns Object schema or resolved schema
	  */
	  function resolve(schema, ctx) {
	    var ref;
	    if(ref = shouldResolve(schema)) {
	      return self.resolve(schema, ref, ctx).subschema;
	    }
	    return schema;
	  }
	
	  if (schema['extends']) {
	    if (schema['extends'] instanceof Array) {
	      schema['extends'].forEach(function (s) {
	        schema = helpers.deepMerge(schema, resolve(s, ctx));
	      });
	    } else {
	      schema = helpers.deepMerge(schema, resolve(schema['extends'], ctx));
	    }
	  }
	
	  var switchSchema;
	  if (switchSchema = shouldResolve(schema)) {
	    var resolved = this.resolve(schema, switchSchema, ctx);
	    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);
	    return this.validateSchema(instance, resolved.subschema, options, subctx);
	  }
	
	  var skipAttributes = options && options.skipAttributes || [];
	  // Validate each schema attribute against the instance
	  for (var key in schema) {
	    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
	      var validatorErr = null;
	      var validator = self.attributes[key];
	      if (validator) {
	        validatorErr = validator.call(self, instance, schema, options, ctx);
	      } else if (options.allowUnknownAttributes === false) {
	        // This represents an error with the schema itself, not an invalid instance
	        throw new SchemaError("Unsupported attribute: " + key, schema);
	      }
	      if (validatorErr) {
	        result.importErrors(validatorErr);
	      }
	    }
	  }
	
	  if (typeof options.rewrite == 'function') {
	    var value = options.rewrite.call(this, instance, schema, options, ctx);
	    result.instance = value;
	  }
	  return result;
	};
	
	/**
	* @private
	* @param Object schema
	* @param Object switchSchema
	* @param SchemaContext ctx
	* @return Object resolved schemas {subschema:String, switchSchema: String}
	* @thorws SchemaError
	*/
	Validator.prototype.resolve = function resolve (schema, switchSchema, ctx) {
	  switchSchema = ctx.resolve(switchSchema);
	  // First see if the schema exists under the provided URI
	  if (ctx.schemas[switchSchema]) {
	    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};
	  }
	  // Else try walking the property pointer
	  var parsed = urilib.parse(switchSchema);
	  var fragment = parsed && parsed.hash;
	  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
	  if (!document || !ctx.schemas[document]) {
	    throw new SchemaError("no such schema <" + switchSchema + ">", schema);
	  }
	  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
	  if(subschema===undefined){
	    throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
	  }
	  return {subschema: subschema, switchSchema: switchSchema};
	};
	
	/**
	 * Tests whether the instance if of a certain type.
	 * @private
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @param type
	 * @return {boolean}
	 */
	Validator.prototype.testType = function validateType (instance, schema, options, ctx, type) {
	  if (typeof this.types[type] == 'function') {
	    return this.types[type].call(this, instance);
	  }
	  if (type && typeof type == 'object') {
	    var res = this.validateSchema(instance, type, options, ctx);
	    return res === undefined || !(res && res.errors.length);
	  }
	  // Undefined or properties not on the list are acceptable, same as not being defined
	  return true;
	};
	
	var types = Validator.prototype.types = {};
	types.string = function testString (instance) {
	  return typeof instance == 'string';
	};
	types.number = function testNumber (instance) {
	  // isFinite returns false for NaN, Infinity, and -Infinity
	  return typeof instance == 'number' && isFinite(instance);
	};
	types.integer = function testInteger (instance) {
	  return (typeof instance == 'number') && instance % 1 === 0;
	};
	types.boolean = function testBoolean (instance) {
	  return typeof instance == 'boolean';
	};
	types.array = function testArray (instance) {
	  return instance instanceof Array;
	};
	types['null'] = function testNull (instance) {
	  return instance === null;
	};
	types.date = function testDate (instance) {
	  return instance instanceof Date;
	};
	types.any = function testAny (instance) {
	  return true;
	};
	types.object = function testObject (instance) {
	  // TODO: fix this - see #15
	  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);
	};
	
	module.exports = Validator;


/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__(539);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(540);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(104)(module), (function() { return this; }())))

/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(541);
	exports.encode = exports.stringify = __webpack_require__(542);


/***/ },
/* 541 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 542 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var helpers = __webpack_require__(544);
	
	/** @type ValidatorResult */
	var ValidatorResult = helpers.ValidatorResult;
	/** @type SchemaError */
	var SchemaError = helpers.SchemaError;
	
	var attribute = {};
	
	attribute.ignoreProperties = {
	  // informative properties
	  'id': true,
	  'default': true,
	  'description': true,
	  'title': true,
	  // arguments to other properties
	  'exclusiveMinimum': true,
	  'exclusiveMaximum': true,
	  'additionalItems': true,
	  // special-handled properties
	  '$schema': true,
	  '$ref': true,
	  'extends': true
	};
	
	/**
	 * @name validators
	 */
	var validators = attribute.validators = {};
	
	/**
	 * Validates whether the instance if of a certain type
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {ValidatorResult|null}
	 */
	validators.type = function validateType (instance, schema, options, ctx) {
	  // Ignore undefined instances
	  if (instance === undefined) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var types = (schema.type instanceof Array) ? schema.type : [schema.type];
	  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
	    var list = types.map(function (v) {
	      return v.id && ('<' + v.id + '>') || (v+'');
	    });
	    result.addError({
	      name: 'type',
	      argument: list,
	      message: "is not of a type(s) " + list,
	    });
	  }
	  return result;
	};
	
	function testSchema(instance, options, ctx, schema){
	  return this.validateSchema(instance, schema, options, ctx).valid;
	}
	
	/**
	 * Validates whether the instance matches some of the given schemas
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {ValidatorResult|null}
	 */
	validators.anyOf = function validateAnyOf (instance, schema, options, ctx) {
	  // Ignore undefined instances
	  if (instance === undefined) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!(schema.anyOf instanceof Array)){
	    throw new SchemaError("anyOf must be an array");
	  }
	  if (!schema.anyOf.some(testSchema.bind(this, instance, options, ctx))) {
	    var list = schema.anyOf.map(function (v, i) {
	      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
	    });
	    result.addError({
	      name: 'anyOf',
	      argument: list,
	      message: "is not any of " + list.join(','),
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance matches every given schema
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {String|null}
	 */
	validators.allOf = function validateAllOf (instance, schema, options, ctx) {
	  // Ignore undefined instances
	  if (instance === undefined) {
	    return null;
	  }
	  if (!(schema.allOf instanceof Array)){
	    throw new SchemaError("allOf must be an array");
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var self = this;
	  schema.allOf.forEach(function(v, i){
	    var valid = self.validateSchema(instance, v, options, ctx);
	    if(!valid.valid){
	      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
	      result.addError({
	        name: 'allOf',
	        argument: { id: msg, length: valid.errors.length, valid: valid },
	        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',
	      });
	      result.importErrors(valid);
	    }
	  });
	  return result;
	};
	
	/**
	 * Validates whether the instance matches exactly one of the given schemas
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {String|null}
	 */
	validators.oneOf = function validateOneOf (instance, schema, options, ctx) {
	  // Ignore undefined instances
	  if (instance === undefined) {
	    return null;
	  }
	  if (!(schema.oneOf instanceof Array)){
	    throw new SchemaError("oneOf must be an array");
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var count = schema.oneOf.filter(testSchema.bind(this, instance, options, ctx)).length;
	  var list = schema.oneOf.map(function (v, i) {
	    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
	  });
	  if (count!==1) {
	    result.addError({
	      name: 'oneOf',
	      argument: list,
	      message: "is not exactly one from " + list.join(','),
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates properties
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {String|null|ValidatorResult}
	 */
	validators.properties = function validateProperties (instance, schema, options, ctx) {
	  if(instance === undefined || !(instance instanceof Object)) return;
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var properties = schema.properties || {};
	  for (var property in properties) {
	    var prop = (instance || undefined) && instance[property];
	    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));
	    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
	    result.importErrors(res);
	  }
	  return result;
	};
	
	/**
	 * Test a specific property within in instance against the additionalProperties schema attribute
	 * This ignores properties with definitions in the properties schema attribute, but no other attributes.
	 * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)
	 * @private
	 * @return {boolean}
	 */
	function testAdditionalProperty (instance, schema, options, ctx, property, result) {
	  if (schema.properties && schema.properties[property] !== undefined) {
	    return;
	  }
	  if (schema.additionalProperties === false) {
	    result.addError({
	      name: 'additionalProperties',
	      argument: property,
	      message: "additionalProperty " + JSON.stringify(property) + " exists in instance when not allowed",
	    });
	  } else {
	    var additionalProperties = schema.additionalProperties || {};
	    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
	    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
	    result.importErrors(res);
	  }
	}
	
	/**
	 * Validates patternProperties
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {String|null|ValidatorResult}
	 */
	validators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {
	  if(instance === undefined) return;
	  if(!this.types.object(instance)) return;
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var patternProperties = schema.patternProperties || {};
	
	  for (var property in instance) {
	    var test = true;
	    for (var pattern in patternProperties) {
	      var expr = new RegExp(pattern);
	      if (!expr.test(property)) {
	        continue;
	      }
	      test = false;
	      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));
	      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
	      result.importErrors(res);
	    }
	    if (test) {
	      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
	    }
	  }
	
	  return result;
	};
	
	/**
	 * Validates additionalProperties
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {String|null|ValidatorResult}
	 */
	validators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {
	  if(instance === undefined) return;
	  if(!this.types.object(instance)) return;
	  // if patternProperties is defined then we'll test when that one is called instead
	  if (schema.patternProperties) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  for (var property in instance) {
	    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.minProperties = function validateMinProperties (instance, schema, options, ctx) {
	  if (!instance || typeof instance !== 'object') {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var keys = Object.keys(instance);
	  if (!(keys.length >= schema.minProperties)) {
	    result.addError({
	      name: 'minProperties',
	      argument: schema.minProperties,
	      message: "does not meet minimum property length of " + schema.minProperties,
	    })
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {
	  if (!instance || typeof instance !== 'object') {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var keys = Object.keys(instance);
	  if (!(keys.length <= schema.maxProperties)) {
	    result.addError({
	      name: 'maxProperties',
	      argument: schema.maxProperties,
	      message: "does not meet maximum property length of " + schema.maxProperties,
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates items when instance is an array
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {String|null|ValidatorResult}
	 */
	validators.items = function validateItems (instance, schema, options, ctx) {
	  if (!(instance instanceof Array)) {
	    return null;
	  }
	  var self = this;
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (instance === undefined || !schema.items) {
	    return result;
	  }
	  instance.every(function (value, i) {
	    var items = (schema.items instanceof Array) ? (schema.items[i] || schema.additionalItems) : schema.items;
	    if (items === undefined) {
	      return true;
	    }
	    if (items === false) {
	      result.addError({
	        name: 'items',
	        message: "additionalItems not permitted",
	      });
	      return false;
	    }
	    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));
	    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;
	    result.importErrors(res);
	    return true;
	  });
	  return result;
	};
	
	/**
	 * Validates minimum and exclusiveMinimum when the type of the instance value is a number.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.minimum = function validateMinimum (instance, schema, options, ctx) {
	  if (typeof instance !== 'number') {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var valid = true;
	  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
	    valid = instance > schema.minimum;
	  } else {
	    valid = instance >= schema.minimum;
	  }
	  if (!valid) {
	    result.addError({
	      name: 'minimum',
	      argument: schema.minimum,
	      message: "must have a minimum value of " + schema.minimum,
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates maximum and exclusiveMaximum when the type of the instance value is a number.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.maximum = function validateMaximum (instance, schema, options, ctx) {
	  if (typeof instance !== 'number') {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var valid;
	  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
	    valid = instance < schema.maximum;
	  } else {
	    valid = instance <= schema.maximum;
	  }
	  if (!valid) {
	    result.addError({
	      name: 'maximum',
	      argument: schema.maximum,
	      message: "must have a maximum value of " + schema.maximum,
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates divisibleBy when the type of the instance value is a number.
	 * Of course, this is susceptible to floating point error since it compares the floating points
	 * and not the JSON byte sequences to arbitrary precision.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {
	  if (typeof instance !== 'number') {
	    return null;
	  }
	
	  if (schema.divisibleBy == 0) {
	    throw new SchemaError("divisibleBy cannot be zero");
	  }
	
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (instance / schema.divisibleBy % 1) {
	    result.addError({
	      name: 'divisibleBy',
	      argument: schema.divisibleBy,
	      message: "is not divisible by (multiple of) " + JSON.stringify(schema.divisibleBy),
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates divisibleBy when the type of the instance value is a number.
	 * Of course, this is susceptible to floating point error since it compares the floating points
	 * and not the JSON byte sequences to arbitrary precision.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {
	  if (typeof instance !== 'number') {
	    return null;
	  }
	
	  if (schema.multipleOf == 0) {
	    throw new SchemaError("multipleOf cannot be zero");
	  }
	
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (instance / schema.multipleOf % 1) {
	    result.addError({
	      name: 'multipleOf',
	      argument:  schema.multipleOf,
	      message: "is not a multiple of (divisible by) " + JSON.stringify(schema.multipleOf),
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value is present.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.required = function validateRequired (instance, schema, options, ctx) {
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (instance === undefined && schema.required === true) {
	    result.addError({
	      name: 'required',
	      message: "is required"
	    });
	  } else if (instance && typeof instance==='object' && Array.isArray(schema.required)) {
	    schema.required.forEach(function(n){
	      if(instance[n]===undefined){
	        result.addError({
	          name: 'required',
	          argument: n,
	          message: "requires property " + JSON.stringify(n),
	        });
	      }
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value matches the regular expression, when the instance value is a string.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.pattern = function validatePattern (instance, schema, options, ctx) {
	  if (typeof instance !== 'string') {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!instance.match(schema.pattern)) {
	    result.addError({
	      name: 'pattern',
	      argument: schema.pattern,
	      message: "does not match pattern " + JSON.stringify(schema.pattern),
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value is of a certain defined format or a custom
	 * format.
	 * The following formats are supported for string types:
	 *   - date-time
	 *   - date
	 *   - time
	 *   - ip-address
	 *   - ipv6
	 *   - uri
	 *   - color
	 *   - host-name
	 *   - alpha
	 *   - alpha-numeric
	 *   - utc-millisec
	 * @param instance
	 * @param schema
	 * @param [options]
	 * @param [ctx]
	 * @return {String|null}
	 */
	validators.format = function validateFormat (instance, schema, options, ctx) {
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
	    result.addError({
	      name: 'format',
	      argument: schema.format,
	      message: "does not conform to the " + JSON.stringify(schema.format) + " format",
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.minLength = function validateMinLength (instance, schema, options, ctx) {
	  if (!(typeof instance === 'string')) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!(instance.length >= schema.minLength)) {
	    result.addError({
	      name: 'minLength',
	      argument: schema.minLength,
	      message: "does not meet minimum length of " + schema.minLength,
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.maxLength = function validateMaxLength (instance, schema, options, ctx) {
	  if (!(typeof instance === 'string')) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!(instance.length <= schema.maxLength)) {
	    result.addError({
	      name: 'maxLength',
	      argument: schema.maxLength,
	      message: "does not meet maximum length of " + schema.maxLength,
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether instance contains at least a minimum number of items, when the instance is an Array.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.minItems = function validateMinItems (instance, schema, options, ctx) {
	  if (!(instance instanceof Array)) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!(instance.length >= schema.minItems)) {
	    result.addError({
	      name: 'minItems',
	      argument: schema.minItems,
	      message: "does not meet minimum length of " + schema.minItems,
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.
	 * @param instance
	 * @param schema
	 * @return {String|null}
	 */
	validators.maxItems = function validateMaxItems (instance, schema, options, ctx) {
	  if (!(instance instanceof Array)) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!(instance.length <= schema.maxItems)) {
	    result.addError({
	      name: 'maxItems',
	      argument: schema.maxItems,
	      message: "does not meet maximum length of " + schema.maxItems,
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates that every item in an instance array is unique, when instance is an array
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {String|null|ValidatorResult}
	 */
	validators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!(instance instanceof Array)) {
	    return result;
	  }
	  function testArrays (v, i, a) {
	    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {
	      return false;
	    }
	    return true;
	  }
	  if (!instance.every(testArrays)) {
	    result.addError({
	      name: 'uniqueItems',
	      message: "contains duplicate item",
	    });
	  }
	  return result;
	};
	
	/**
	 * Deep compares arrays for duplicates
	 * @param v
	 * @param i
	 * @param a
	 * @private
	 * @return {boolean}
	 */
	function testArrays (v, i, a) {
	  var j, len = a.length;
	  for (j = i + 1, len; j < len; j++) {
	    if (helpers.deepCompareStrict(v, a[j])) {
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Validates whether there are no duplicates, when the instance is an Array.
	 * @param instance
	 * @return {String|null}
	 */
	validators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {
	  if (!(instance instanceof Array)) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!instance.every(testArrays)) {
	    result.addError({
	      name: 'uniqueItems',
	      message: "contains duplicate item",
	    });
	  }
	  return result;
	};
	
	/**
	 * Validate for the presence of dependency properties, if the instance is an object.
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {null|ValidatorResult}
	 */
	validators.dependencies = function validateDependencies (instance, schema, options, ctx) {
	  if (!instance || typeof instance != 'object') {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  for (var property in schema.dependencies) {
	    if (instance[property] === undefined) {
	      continue;
	    }
	    var dep = schema.dependencies[property];
	    var childContext = ctx.makeChild(dep, property);
	    if (typeof dep == 'string') {
	      dep = [dep];
	    }
	    if (dep instanceof Array) {
	      dep.forEach(function (prop) {
	        if (instance[prop] === undefined) {
	          result.addError({
	            // FIXME there's two different "dependencies" errors here with slightly different outputs
	            // Can we make these the same? Or should we create different error types?
	            name: 'dependencies',
	            argument: childContext.propertyPath,
	            message: "property " + prop + " not found, required by " + childContext.propertyPath,
	          });
	        }
	      });
	    } else {
	      var res = this.validateSchema(instance, dep, options, childContext);
	      if(result.instance !== res.instance) result.instance = res.instance;
	      if (res && res.errors.length) {
	        result.addError({
	          name: 'dependencies',
	          argument: childContext.propertyPath,
	          message: "does not meet dependency required by " + childContext.propertyPath,
	        });
	        result.importErrors(res);
	      }
	    }
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance value is one of the enumerated values.
	 *
	 * @param instance
	 * @param schema
	 * @return {ValidatorResult|null}
	 */
	validators['enum'] = function validateEnum (instance, schema, options, ctx) {
	  if (!(schema['enum'] instanceof Array)) {
	    throw new SchemaError("enum expects an array", schema);
	  }
	  if (instance === undefined) {
	    return null;
	  }
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {
	    result.addError({
	      name: 'enum',
	      argument: schema['enum'],
	      message: "is not one of enum values: " + schema['enum'].join(','),
	    });
	  }
	  return result;
	};
	
	/**
	 * Validates whether the instance if of a prohibited type.
	 * @param instance
	 * @param schema
	 * @param options
	 * @param ctx
	 * @return {null|ValidatorResult}
	 */
	validators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {
	  var self = this;
	  if(instance===undefined) return null;
	  var result = new ValidatorResult(instance, schema, options, ctx);
	  var notTypes = schema.not || schema.disallow;
	  if(!notTypes) return null;
	  if(!(notTypes instanceof Array)) notTypes=[notTypes];
	  notTypes.forEach(function (type) {
	    if (self.testType(instance, schema, options, ctx, type)) {
	      var schemaId = type && type.id && ('<' + type.id + '>') || type;
	      result.addError({
	        name: 'not',
	        argument: schemaId,
	        message: "is of prohibited type " + schemaId,
	      });
	    }
	  });
	  return result;
	};
	
	module.exports = attribute;


/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var uri = __webpack_require__(538);
	
	var ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {
	  if (propertyPath) {
	    this.property = propertyPath;
	  }
	  if (message) {
	    this.message = message;
	  }
	  if (schema) {
	    if (schema.id) {
	      this.schema = schema.id;
	    } else {
	      this.schema = schema;
	    }
	  }
	  if (instance) {
	    this.instance = instance;
	  }
	  this.name = name;
	  this.argument = argument;
	  this.stack = this.toString();
	};
	
	ValidationError.prototype.toString = function toString() {
	  return this.property + ' ' + this.message;
	};
	
	var ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {
	  this.instance = instance;
	  this.schema = schema;
	  this.propertyPath = ctx.propertyPath;
	  this.errors = [];
	  this.throwError = options && options.throwError;
	  this.disableFormat = options && options.disableFormat === true;
	};
	
	ValidatorResult.prototype.addError = function addError(detail) {
	  var err;
	  if (typeof detail == 'string') {
	    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);
	  } else {
	    if (!detail) throw new Error('Missing error detail');
	    if (!detail.message) throw new Error('Missing error message');
	    if (!detail.name) throw new Error('Missing validator type');
	    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);
	  }
	
	  if (this.throwError) {
	    throw err;
	  }
	  this.errors.push(err);
	  return err;
	};
	
	ValidatorResult.prototype.importErrors = function importErrors(res) {
	  if (typeof res == 'string' || (res && res.validatorType)) {
	    this.addError(res);
	  } else if (res && res.errors) {
	    var errs = this.errors;
	    res.errors.forEach(function (v) {
	      errs.push(v);
	    });
	  }
	};
	
	ValidatorResult.prototype.toString = function toString(res) {
	  return this.errors.map(function(v,i){ return i+': '+v.toString()+'\n'; }).join('');
	};
	
	Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
	  return !this.errors.length;
	} });
	
	/**
	 * Describes a problem with a Schema which prevents validation of an instance
	 * @name SchemaError
	 * @constructor
	 */
	var SchemaError = exports.SchemaError = function SchemaError (msg, schema) {
	  this.message = msg;
	  this.schema = schema;
	  Error.call(this, msg);
	  Error.captureStackTrace(this, SchemaError);
	};
	SchemaError.prototype = Object.create(Error.prototype,
	  { constructor: {value: SchemaError, enumerable: false}
	  , name: {value: 'SchemaError', enumerable: false}
	  });
	
	var SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {
	  this.schema = schema;
	  this.options = options;
	  this.propertyPath = propertyPath;
	  this.base = base;
	  this.schemas = schemas;
	};
	
	SchemaContext.prototype.resolve = function resolve (target) {
	  return uri.resolve(this.base, target);
	};
	
	SchemaContext.prototype.makeChild = function makeChild(schema, propertyName){
	  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);
	  var base = uri.resolve(this.base, schema.id||'');
	  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));
	  if(schema.id && !ctx.schemas[base]){
	    ctx.schemas[base] = schema;
	  }
	  return ctx;
	}
	
	var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
	  'date-time': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
	  'date': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
	  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,
	
	  'email': /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
	  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
	  'ipv6': /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
	  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/,
	
	  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,
	
	  // hostname regex from: http://stackoverflow.com/a/1420225/5628
	  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
	  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
	
	  'alpha': /^[a-zA-Z]+$/,
	  'alphanumeric': /^[a-zA-Z0-9]+$/,
	  'utc-millisec': function (input) {
	    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
	  },
	  'regex': function (input) {
	    var result = true;
	    try {
	      new RegExp(input);
	    } catch (e) {
	      result = false;
	    }
	    return result;
	  },
	  'style': /\s*(.+?):\s*([^;]+);?/g,
	  'phone': /^\+(?:[0-9] ?){6,14}[0-9]$/
	};
	
	FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
	FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
	FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];
	
	exports.isFormat = function isFormat (input, format, validator) {
	  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {
	    if (FORMAT_REGEXPS[format] instanceof RegExp) {
	      return FORMAT_REGEXPS[format].test(input);
	    }
	    if (typeof FORMAT_REGEXPS[format] === 'function') {
	      return FORMAT_REGEXPS[format](input);
	    }
	  } else if (validator && validator.customFormats &&
	      typeof validator.customFormats[format] === 'function') {
	    return validator.customFormats[format](input);
	  }
	  return true;
	};
	
	var makeSuffix = exports.makeSuffix = function makeSuffix (key) {
	  key = key.toString();
	  // This function could be capable of outputting valid a ECMAScript string, but the
	  // resulting code for testing which form to use would be tens of thousands of characters long
	  // That means this will use the name form for some illegal forms
	  if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
	    return '.' + key;
	  }
	  if (key.match(/^\d+$/)) {
	    return '[' + key + ']';
	  }
	  return '[' + JSON.stringify(key) + ']';
	};
	
	exports.deepCompareStrict = function deepCompareStrict (a, b) {
	  if (typeof a !== typeof b) {
	    return false;
	  }
	  if (a instanceof Array) {
	    if (!(b instanceof Array)) {
	      return false;
	    }
	    if (a.length !== b.length) {
	      return false;
	    }
	    return a.every(function (v, i) {
	      return deepCompareStrict(a[i], b[i]);
	    });
	  }
	  if (typeof a === 'object') {
	    if (!a || !b) {
	      return a === b;
	    }
	    var aKeys = Object.keys(a);
	    var bKeys = Object.keys(b);
	    if (aKeys.length !== bKeys.length) {
	      return false;
	    }
	    return aKeys.every(function (v) {
	      return deepCompareStrict(a[v], b[v]);
	    });
	  }
	  return a === b;
	};
	
	module.exports.deepMerge = function deepMerge (target, src) {
	  var array = Array.isArray(src);
	  var dst = array && [] || {};
	
	  if (array) {
	    target = target || [];
	    dst = dst.concat(target);
	    src.forEach(function (e, i) {
	      if (typeof e === 'object') {
	        dst[i] = deepMerge(target[i], e)
	      } else {
	        if (target.indexOf(e) === -1) {
	          dst.push(e)
	        }
	      }
	    });
	  } else {
	    if (target && typeof target === 'object') {
	      Object.keys(target).forEach(function (key) {
	        dst[key] = target[key];
	      });
	    }
	    Object.keys(src).forEach(function (key) {
	      if (typeof src[key] !== 'object' || !src[key]) {
	        dst[key] = src[key];
	      }
	      else {
	        if (!target[key]) {
	          dst[key] = src[key];
	        } else {
	          dst[key] = deepMerge(target[key], src[key])
	        }
	      }
	    });
	  }
	
	  return dst;
	};
	
	/**
	 * Validates instance against the provided schema
	 * Implements URI+JSON Pointer encoding, e.g. "%7e"="~0"=>"~", "~1"="%2f"=>"/"
	 * @param o
	 * @param s The path to walk o along
	 * @return any
	 */
	exports.objectGetPath = function objectGetPath(o, s) {
	  var parts = s.split('/').slice(1);
	  var k;
	  while (typeof (k=parts.shift()) == 'string') {
	    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));
	    if (!(n in o)) return;
	    o = o[n];
	  }
	  return o;
	};
	
	/**
	 * Accept an Array of property names and return a JSON Pointer URI fragment
	 * @param Array a
	 * @return {String}
	 */
	exports.encodePath = function encodePointer(a){
		// ~ must be encoded explicitly because hacks
		// the slash is encoded by encodeURIComponent
		return a.map(function(v){ return '/'+encodeURIComponent(v).replace(/~/g,'%7E'); }).join('');
	};


/***/ },
/* 545 */
/***/ function(module, exports) {

	module.exports = {
		"additionalProperties": true,
		"required": [
			"label"
		],
		"type": "object",
		"properties": {
			"status": {
				"type": [
					{
						"description": "A lozenge with a label text. See https://docs.atlassian.com/aui/latest/docs/lozenges.html",
						"required": [
							"type",
							"value"
						],
						"additionalProperties": true,
						"type": "object",
						"properties": {
							"type": {
								"enum": [
									"lozenge"
								],
								"type": "string"
							},
							"value": {
								"additionalProperties": true,
								"required": [
									"type",
									"label"
								],
								"type": "object",
								"properties": {
									"type": {
										"enum": [
											"default",
											"success",
											"error",
											"current",
											"new",
											"moved"
										],
										"type": "string"
									},
									"label": {
										"minLength": 1,
										"type": "string",
										"maxLength": 20
									}
								}
							}
						}
					},
					{
						"description": "The icon for the glance",
						"required": [
							"type",
							"value"
						],
						"additionalProperties": true,
						"type": "object",
						"properties": {
							"type": {
								"enum": [
									"icon"
								],
								"type": "string"
							},
							"value": {
								"additionalProperties": true,
								"required": [
									"url",
									"url@2x"
								],
								"type": "object",
								"properties": {
									"url": {
										"type": "string",
										"description": "An URL to the icon"
									},
									"url@2x": {
										"type": "string",
										"description": "An URL to the high resolution icon"
									}
								}
							}
						}
					}
				]
			},
			"metadata": {
				"additionalProperties": true,
				"type": "object",
				"description": "Glance metadata for conditions"
			},
			"label": {
				"description": "Free form html label",
				"required": [
					"type",
					"value"
				],
				"additionalProperties": true,
				"type": "object",
				"properties": {
					"type": {
						"enum": [
							"html"
						],
						"type": "string"
					},
					"value": {
						"minLength": 1,
						"type": "string",
						"maxLength": 1000
					}
				}
			}
		}
	};

/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _integrations_actions = __webpack_require__(420);
	
	var _integrations_actions2 = _interopRequireDefault(_integrations_actions);
	
	var _glance_actions = __webpack_require__(535);
	
	var _glance_actions2 = _interopRequireDefault(_glance_actions);
	
	var _glances_metadata_store = __webpack_require__(523);
	
	var _glances_metadata_store2 = _interopRequireDefault(_glances_metadata_store);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _icon = __webpack_require__(547);
	
	var _icon2 = _interopRequireDefault(_icon);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBarGlance",
	
	  propTypes: {
	    glance: React.PropTypes.shape({
	      name: React.PropTypes.string.isRequired,
	      full_key: React.PropTypes.string.isRequired,
	      addon_key: React.PropTypes.string.isRequired,
	      key: React.PropTypes.string.isRequired,
	      icon: React.PropTypes.object,
	      query_url: React.PropTypes.string,
	      target: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.object]),
	      dynamic: React.PropTypes.bool,
	      internal: React.PropTypes.bool
	    }).isRequired,
	    room_id: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number])
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return {
	      loading: this._isDynamic(),
	      error: null,
	      label: {
	        value: this.props.glance.name
	      },
	      room_id: null,
	      condition: null,
	      status: {}
	    };
	  },
	
	  componentWillMount: function componentWillMount() {
	    var cachedData = _glances_metadata_store2.default.getCachedMetadata(this.props.room_id, this.props.glance.full_key);
	    if (!_.isEmpty(cachedData) && !cachedData.loading) {
	      this.setState(cachedData);
	    }
	  },
	
	  componentDidMount: function componentDidMount() {
	    if (this._isDynamic()) {
	      _glances_metadata_store2.default.onGlanceMetadataChange(this.props.room_id, this.props.glance.full_key, this._onChange);
	    }
	  },
	
	  componentWillUpdate: function componentWillUpdate() {
	    if (this._isDynamic()) {
	      _glances_metadata_store2.default.offGlanceMetadataChange(this.props.room_id, this.props.glance.full_key, this._onChange);
	    }
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (this._isDynamic()) {
	      _glances_metadata_store2.default.onGlanceMetadataChange(this.props.room_id, this.props.glance.full_key, this._onChange);
	    }
	    if (this.isMounted()) {
	      this._onChange();
	    }
	  },
	
	
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._isDynamic()) {
	      _glances_metadata_store2.default.offGlanceMetadataChange(this.props.room_id, this.props.glance.full_key, this._onChange);
	    }
	  },
	
	  _fetchMetadata: function _fetchMetadata() {
	    _glance_actions2.default.fetchGlanceMetadata(this.props.room_id, this.props.glance, true);
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _getState: function _getState() {
	    return _glances_metadata_store2.default.getCachedMetadata(this.props.room_id, this.props.glance.full_key) || this.getInitialState();
	  },
	
	  _onClick: function _onClick() {
	    _integrations_actions2.default.open(this.props.glance.addon_key, this.props.glance.key, {}, null, "glance");
	  },
	
	  _renderErrorGlance: function _renderErrorGlance() {
	    var classes = (0, _classnames2.default)({
	      "hc-glance": true,
	      "error": true
	    });
	
	    return React.createElement(
	      'div',
	      { className: classes,
	        ref: this.props.glance.full_key + '_link' },
	      React.createElement(
	        'div',
	        { className: 'aui-nav-item', 'aria-label': this.props.glance.name, 'data-tipsify-ignore': true },
	        this._renderIcon(),
	        React.createElement(
	          'div',
	          { className: 'hc-glance-content' },
	          React.createElement(
	            'div',
	            { className: 'hc-glance-label' },
	            this.props.glance.name
	          ),
	          React.createElement(
	            'div',
	            { className: 'hc-glance-status', onClick: this._fetchMetadata },
	            _integrations_strings2.default.glance_fetch_error,
	            React.createElement(
	              'button',
	              { className: 'aui-button aui-button-link' },
	              _integrations_strings2.default.retry
	            )
	          )
	        )
	      )
	    );
	  },
	
	  _isDynamic: function _isDynamic() {
	    return !_.isEmpty(this.props.glance.query_url);
	  },
	
	  _renderLabel: function _renderLabel() {
	    if (this.state.loading) {
	      return React.createElement(
	        'span',
	        { className: 'hc-glance-label' },
	        _integrations_strings2.default.glance_loading
	      );
	    }
	
	    var labelHtml = void 0;
	    if (this.state.label.type === "safe_html") {
	      labelHtml = React.createElement('span', { className: 'hc-glance-label', dangerouslySetInnerHTML: { __html: this.state.label.value } });
	    } else {
	      labelHtml = React.createElement(
	        'span',
	        { className: 'hc-glance-label' },
	        this.props.glance.name
	      );
	    }
	
	    return labelHtml;
	  },
	
	  _renderLozenge: function _renderLozenge(lozenge) {
	    var classNames = "aui-lozenge aui-lozenge-" + lozenge.type;
	
	    return React.createElement(
	      'span',
	      { className: classNames },
	      lozenge.label
	    );
	  },
	
	  _renderStatusElement: function _renderStatusElement() {
	    switch (this.state.status.type) {
	      case "lozenge":
	        var lozenge = this.state.status.value;
	        return this._renderLozenge(lozenge);
	      case "icon":
	        return React.createElement(_icon2.default, { icon: this.state.status.value });
	      case "text":
	        return React.createElement(
	          'span',
	          { className: "hc-glance-status-text" },
	          this.state.status.value
	        );
	      default:
	        return null;
	    }
	  },
	
	  _renderStatus: function _renderStatus() {
	    return React.createElement(
	      'span',
	      { className: 'hc-glance-status' },
	      this._renderStatusElement()
	    );
	  },
	
	  _renderChildren: function _renderChildren() {
	    return React.createElement(
	      'div',
	      { className: 'hc-glance-children' },
	      this.props.children
	    );
	  },
	
	  _renderIcon: function _renderIcon() {
	    return this.props.glance.icon ? React.createElement(_icon2.default, { icon: this.props.glance.icon }) : null;
	  },
	
	  render: function render() {
	
	    if (!_.isNull(this.state.error)) {
	      return this._renderErrorGlance();
	    }
	
	    var classes = (0, _classnames2.default)({
	      "hc-glance": true,
	      "loading": this.state.loading,
	      "clickable": !_.isUndefined(this.props.glance.target)
	    });
	
	    return React.createElement(
	      'div',
	      { className: classes,
	        ref: this.props.glance.full_key + '_link',
	        onClick: this.props.glance.target ? this._onClick : null },
	      React.createElement(
	        'div',
	        { className: 'aui-nav-item', 'aria-label': this.props.glance.name, 'data-tipsify-ignore': true },
	        React.createElement(
	          'div',
	          { className: 'hc-glance-content' },
	          this._renderIcon(),
	          this._renderLabel(),
	          this._renderStatus(),
	          React.createElement(
	            'div',
	            { className: 'hc-spinner-container' },
	            React.createElement(_spinner2.default, { size: 'small', spin: this.state.loading, zIndex: 1 })
	          )
	        )
	      ),
	      this._renderChildren()
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var mixedValidator = function mixedValidator(props, propName, componentName) {
	  if (_.isUndefined(props.aui_icon) && _.isUndefined(props[propName])) {
	    return new Error(propName + " parameter is mandatory in IntegrationIcon");
	  }
	}; /*global HC*/
	
	
	exports.default = React.createClass({
	
	  displayName: "IntegrationIcon",
	
	  propTypes: {
	    icon: React.PropTypes.shape({
	      "url": mixedValidator,
	      "url@2x": mixedValidator,
	      "aui_icon": React.PropTypes.string
	    }).isRequired
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return {
	      error: false
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    $(ReactDOM.findDOMNode(this)).on('error', this._onError);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    $(ReactDOM.findDOMNode(this)).off('error', this._onError);
	  },
	
	  _onError: function _onError() {
	    this.setState({ error: true });
	  },
	
	  render: function render() {
	
	    if (_.get(this.props.icon, "aui_icon")) {
	      var auiClasses = (0, _classnames2.default)("aui-icon", this.props.icon.aui_icon);
	      return React.createElement('span', { className: auiClasses });
	    }
	
	    var icon = void 0;
	    if (this.state.error) {
	      icon = _application_store2.default.get('asset_base_uri') + 'assets/svgs/fail_avatar.svg';
	    } else {
	      icon = HC.resolution > 1 ? _.get(this.props.icon, "url@2x") : _.get(this.props.icon, "url");
	    }
	
	    return React.createElement('img', { className: 'aui-icon', src: icon });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _preferences_actions = __webpack_require__(265);
	
	var _preferences_actions2 = _interopRequireDefault(_preferences_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _api = __webpack_require__(264);
	
	var _api2 = _interopRequireDefault(_api);
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'AddIntegrationsGlance',
	
	  _dismissAction: function _dismissAction(event) {
	    event.stopPropagation();
	    _analytics_actions2.default.roomIntegrationsGlanceDismissed();
	    _preferences_actions2.default.addRoomToIntegrationDiscoveryIgnoreList(this.props.room_id);
	
	    _inline_dialog_actions2.default.showAddIntegrationsHelperDialog({
	      anchor: document.getElementById('hc-integrations-link')
	    });
	  },
	  _openIntegrationsPage: function _openIntegrationsPage() {
	    _analytics_actions2.default.roomIntegrationsGlanceClicked();
	    _api2.default.openIntegrationsWindow();
	  },
	
	
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      "hc-integration-advertisement": true,
	      "hc-glance": true,
	      "clickable": true
	    });
	
	    return React.createElement(
	      'div',
	      { className: classes },
	      React.createElement(
	        'div',
	        { className: 'aui-nav-item', onClick: this._openIntegrationsPage },
	        React.createElement(
	          'div',
	          { className: 'hc-glance-content' },
	          React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-add' }),
	          React.createElement(
	            'div',
	            { className: 'hc-glance-label' },
	            _integrations_strings2.default.add_integrations,
	            React.createElement('a', { 'data-aui-trigger': true, onClick: this._dismissAction,
	              className: 'hc-discovery-glance-close aui-icon aui-icon-small aui-iconfont-remove' })
	          ),
	          React.createElement('div', { className: 'hc-glance-status' })
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _integration_frame = __webpack_require__(413);
	
	var _integration_frame2 = _interopRequireDefault(_integration_frame);
	
	var _glance = __webpack_require__(546);
	
	var _glance2 = _interopRequireDefault(_glance);
	
	var _integrations_view_store = __webpack_require__(436);
	
	var _integrations_view_store2 = _interopRequireDefault(_integrations_view_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _integrations_view_actions = __webpack_require__(425);
	
	var _integrations_view_actions2 = _interopRequireDefault(_integrations_view_actions);
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "RightSideBarIntegrationView",
	
	  propTypes: {
	    hideIntegrationView: React.PropTypes.func.isRequired,
	    integration: React.PropTypes.shape({
	      full_key: React.PropTypes.string.isRequired,
	      addon_key: React.PropTypes.string.isRequired,
	      key: React.PropTypes.string.isRequired,
	      name: React.PropTypes.string.isRequired
	    }).isRequired,
	    room_id: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
	    glance: React.PropTypes.shape({
	      name: React.PropTypes.string.isRequired,
	      full_key: React.PropTypes.string.isRequired,
	      addon_key: React.PropTypes.string.isRequired,
	      key: React.PropTypes.string.isRequired,
	      icon: React.PropTypes.object.isRequired,
	      query_url: React.PropTypes.string,
	      target: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.object])
	    }),
	    url_template_values: React.PropTypes.object,
	    init_event: React.PropTypes.object,
	    loading: React.PropTypes.bool
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    var theme = _preferences_store2.default.get('theme');
	    return _.extend({
	      signed_url_loading: true,
	      frame_loading: true,
	      theme: theme
	    }, this._getState());
	  },
	
	  componentDidMount: function componentDidMount() {
	    _integrations_view_store2.default.onIntegrationViewStatusChange(this.props.room_id, this.props.integration.full_key, this._onChange);
	    _preferences_store2.default.on('change:theme', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _integrations_view_store2.default.offIntegrationViewStatusChange(this.props.room_id, this.props.integration.full_key, this._onChange);
	    _preferences_store2.default.off('change:theme', this._onChange);
	  },
	
	  _renderStaticHeader: function _renderStaticHeader() {
	    // We use the view as a static glance (name+icon if available)
	    return React.createElement(_glance2.default, { glance: this.props.integration, room_id: this.props.room_id });
	  },
	
	
	  render: function render() {
	
	    var header = void 0;
	    if (_.isObject(this.props.glance)) {
	      header = React.createElement(_glance2.default, { glance: this.props.glance, room_id: this.props.room_id });
	    } else {
	      header = this._renderStaticHeader();
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-integration-view-sidebar' },
	      React.createElement(
	        'div',
	        { className: 'hc-integration-sidebar-header' },
	        React.createElement(
	          'div',
	          { className: 'hc-integration-view-name' },
	          header,
	          React.createElement('span', { ref: 'close_button',
	            onClick: this.props.hideIntegrationView,
	            className: 'aui-icon aui-icon-small aui-iconfont-close-dialog close' })
	        )
	      ),
	      React.createElement(_spinner2.default, { spin: this._loading(), zIndex: 1, delay: this._spinnerDelay() }),
	      this._content()
	    );
	  },
	
	  _loading: function _loading() {
	    if (this.props.integration.internal) {
	      return this.props.loading;
	    }
	    return this.state.signed_url_loading || this.state.signed_url && this.state.frame_loading;
	  },
	  _content: function _content() {
	    if (this.state.is_error) {
	      return React.createElement(
	        'div',
	        { className: 'hc-integrations-error' },
	        React.createElement('div', { className: 'hc-integrations-error-image' }),
	        React.createElement(
	          'p',
	          null,
	          _integrations_strings2.default.integration_failed_to_load
	        ),
	        React.createElement(
	          'button',
	          { onClick: this._retryLoadingPanel, className: 'aui-button aui-button-primary' },
	          _integrations_strings2.default.retry
	        )
	      );
	    }
	
	    if (!this.props.integration.internal && this.state.signed_url) {
	      return this._renderIntegrationFrame();
	    }
	
	    if (this.props.integration.internal) {
	      return this.props.children;
	    }
	
	    return null;
	  },
	
	
	  _renderIntegrationFrame: function _renderIntegrationFrame() {
	    var signed_url = _utils2.default.appendQueryParameter(this.state.signed_url, "theme", this.state.theme);
	
	    return React.createElement(_integration_frame2.default, { integration: this.props.integration,
	      signed_url: signed_url,
	      room_id: this.props.room_id,
	      init_event: this.props.init_event });
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _getState: function _getState() {
	    var theme = _preferences_store2.default.get('theme');
	    var integrationViewStatus = _integrations_view_store2.default.getIntegrationViewStatus(this.props.room_id, this.props.integration.full_key) || {};
	    integrationViewStatus.theme = theme;
	    return integrationViewStatus;
	  },
	
	  _retryLoadingPanel: function _retryLoadingPanel() {
	    if (this.state.is_error) {
	      _integrations_view_actions2.default.fetchSignedUrl(this.props.integration, this.props.room_id, this.state.url_template_values);
	    }
	  },
	
	
	  _spinnerDelay: function _spinnerDelay() {
	    var isLoadingPossiblyCachedContents = this.state.signed_url && this.state.frame_loading && this.props.integration.authentication === 'none';
	    return isLoadingPossiblyCachedContents ? _app_config2.default.integrations.spinner_delay : 0;
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _chat_header_store = __webpack_require__(267);
	
	var _chat_header_store2 = _interopRequireDefault(_chat_header_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'IntegrationsConfigureButton',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _application_store2.default.on(['change:web_server', 'change:current_user'], this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _application_store2.default.off(['change:web_server', 'change:current_user'], this._onChange);
	  },
	
	  _getState: function _getState() {
	    var current_user = _application_store2.default.get("current_user");
	
	    return {
	      user_id: current_user.user_id,
	      web_server: _application_store2.default.get("web_server")
	    };
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _onIntegrationsClick: function _onIntegrationsClick() {
	    var chat = _chat_header_store2.default.get('chat');
	    _dialog_actions2.default.showIntegrationsManagementDialog({
	      jid: chat.jid,
	      room_name: chat.name
	    });
	    _analytics_actions2.default.roomIntegrationsLinkClicked();
	  },
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'hc-integration-sidebar-footer hc-integrations-configure-button' },
	      React.createElement(
	        'div',
	        null,
	        React.createElement(
	          'a',
	          { id: 'hc-integrations-link', onClick: this._onIntegrationsClick, target: '_blank', className: 'aui-nav-item' },
	          React.createElement('span', { className: 'aui-icon aui-icon-small aui-iconfont-configure ' }),
	          React.createElement(
	            'span',
	            null,
	            _integrations_strings2.default.configure_integrations
	          )
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _layout_store = __webpack_require__(483);
	
	var _layout_store2 = _interopRequireDefault(_layout_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _roster_mini_expander = __webpack_require__(552);
	
	var _roster_mini_expander2 = _interopRequireDefault(_roster_mini_expander);
	
	var _roster_mini_item = __webpack_require__(553);
	
	var _roster_mini_item2 = _interopRequireDefault(_roster_mini_item);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "RightSideBarRosterMini",
	
	  propTypes: {
	    max_items_to_render: React.PropTypes.number,
	    force_update: React.PropTypes.bool
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      max_items_to_render: 32,
	      force_update: false
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return _.assign(this._getState(), {
	      hide_expander: false,
	      capacity: 0
	    });
	  },
	
	  _getContainerWidth: function _getContainerWidth() {
	    var container = this.refs.roster_mini_container;
	    if (!container) {
	      return 0;
	    }
	    return container.offsetWidth;
	  },
	
	  _getItemWidth: function _getItemWidth() {
	    var domNode = this.refs.roster_mini_container;
	    if (!domNode || domNode.childNodes.length < 1) {
	      return 0;
	    }
	    return domNode.childNodes[0].offsetWidth;
	  },
	
	  _getCapacity: function _getCapacity() {
	    var container_width = this._getContainerWidth();
	    if (container_width === 0) {
	      return undefined;
	    }
	    var item_width = this._getItemWidth();
	    if (item_width === 0) {
	      return undefined;
	    }
	    var numbers_in_each_row = Math.max(1, Math.floor(container_width / item_width));
	    return numbers_in_each_row * 2;
	  },
	
	  _getNumberOfPeopleToShow: function _getNumberOfPeopleToShow() {
	    if (!this.state.capacity) {
	      return 0;
	    }
	    var number_of_positions = this.props.max_items_to_render < this.state.capacity ? this.props.max_items_to_render : this.state.capacity;
	    return Math.max(0, this.state.total_number_of_people <= number_of_positions ? this.state.total_number_of_people : number_of_positions - 1);
	  },
	
	  _shouldTheListBeTrimmed: function _shouldTheListBeTrimmed() {
	    // We need to cut the list short if we are showing less than we have space for.
	    if (!this.state.capacity) {
	      return false;
	    }
	    return this.props.max_items_to_render < this.state.capacity && this.props.max_items_to_render < this.state.total_number_of_people;
	  },
	
	  _isRightSideBarWidthChanging: function _isRightSideBarWidthChanging() {
	    return _layout_store2.default.get('rightSidebarVisibleWidthIsChanging');
	  },
	
	  _reOrderExpander: function _reOrderExpander() {
	    var capacity = this._getCapacity();
	    var is_changing = this._isRightSideBarWidthChanging();
	    this.setState(_.assign(this._getState(), {
	      hide_expander: is_changing,
	      capacity: capacity
	    }));
	  },
	
	  componentDidMount: function componentDidMount() {
	    _roster_store2.default.on(['change:participants', 'change:admins'], this._onChange);
	    _preferences_store2.default.on(['change:rightColumnWidth'], this._reOrderExpander);
	    _layout_store2.default.on(['change:rightSidebarVisibleWidthIsChanging'], this._reOrderExpander);
	    this._reOrderExpander();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._reOrderExpander();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _roster_store2.default.off(['change:participants', 'change:admins'], this._onChange);
	    _preferences_store2.default.off(['change:rightColumnWidth'], this._reOrderExpander);
	    _layout_store2.default.off(['change:rightSidebarVisibleWidthIsChanging'], this._reOrderExpander);
	  },
	
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return this.props.force_update || nextProps.max_items_to_render !== this.props.max_items_to_render || !_.isEqual(nextState.admins, this.state.admins) || !_.isEqual(nextState.all_people_to_show, this.state.all_people_to_show) || nextState.total_number_of_people !== this.state.total_number_of_people || nextState.hide_expander !== this.state.hide_expander || nextState.capacity !== this.state.capacity;
	  },
	
	  _getState: function _getState() {
	    return {
	      admins: _roster_store2.default.get('admins'),
	      should_animate_gif_avatars: !_configuration_store2.default.get('feature_flags').web_client_freeze_gifs,
	      all_people_to_show: this.getAllPeopleFromStore(),
	      total_number_of_people: this.getNumberOfPeopleFromStore()
	    };
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	  _isAdmin: function _isAdmin(user) {
	    return _utils2.default.user.is_admin(this.state.admins, false, user);
	  },
	
	  _copyUser: function _copyUser(user) {
	    return {
	      id: user.id,
	      user_id: user.user_id,
	      jid: user.jid,
	      presence: {
	        show: user.presence ? user.presence.show : undefined,
	        status: user.presence ? user.presence.status : undefined
	      },
	      name: user.name,
	      mention_name: user.mention_name,
	      photo_url: user.photo_url,
	      subscription: user.subscription
	    };
	  },
	
	  getAllPeopleFromStore: function getAllPeopleFromStore() {
	    return _roster_store2.default.getSortedRosterByPresenceAndName(['members', 'guests']).slice(0, this.props.max_items_to_render).map(this._copyUser);
	  },
	
	  getNumberOfPeopleFromStore: function getNumberOfPeopleFromStore() {
	    return _roster_store2.default.getRosterCount(['members', 'guests']).total;
	  },
	
	  render: function render() {
	    var _this = this;
	
	    var rosterWrapClasses = (0, _classnames2.default)({
	      'roster-wrap': true
	    });
	
	    var rosterClasses = (0, _classnames2.default)({
	      'hc-roster-mini': true,
	      'hc-sidebar-noscroll': true
	    });
	
	    var number_of_people_visible = this._getNumberOfPeopleToShow();
	    var trim_the_list = this._shouldTheListBeTrimmed();
	    var index = 0;
	    return React.createElement(
	      'div',
	      { className: rosterWrapClasses },
	      React.createElement(
	        'div',
	        { className: rosterClasses },
	        React.createElement(
	          'div',
	          { ref: 'roster_mini_container', className: 'roster-mini-flex-list roster_mini_container', 'data-skate-ignore': true },
	          _.map(this.state.all_people_to_show, function (user) {
	            // We need to cut the list short if we are showing less than we have space for.
	            if (trim_the_list && index >= number_of_people_visible) {
	              return false;
	            }
	            var order = index < number_of_people_visible ? "show" : "overflow";
	            index++;
	            return React.createElement(_roster_mini_item2.default, { size: 'small',
	              order: order,
	              key: index,
	              user_is_admin: _this._isAdmin(user),
	              user_name: user.name,
	              user_mention_name: user.mention_name,
	              user_presence_show: user.presence.show,
	              user_presence_status: user.presence.status,
	              user_photo_url: user.photo_url,
	              user_jid: user.jid,
	              user_id: user.id,
	              shouldAnimate: _this.state.should_animate_gif_avatars });
	          }),
	          React.createElement(_roster_mini_expander2.default, { size: 'small', total_number_of_people: this.state.total_number_of_people,
	            number_of_people_visible: number_of_people_visible, hide: this.state.hide_expander })
	        )
	      )
	    );
	  }
	});

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'RosterMiniExpander',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    size: React.PropTypes.string,
	    hide: React.PropTypes.bool,
	    total_number_of_people: React.PropTypes.number,
	    number_of_people_visible: React.PropTypes.number
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      size: 'small',
	      hide: false,
	      total_number_of_people: 0,
	      number_of_people_visible: 0
	    };
	  },
	
	  _getNumberToShow: function _getNumberToShow() {
	    var number_to_show = Math.max(0, this.props.total_number_of_people - this.props.number_of_people_visible);
	    return number_to_show > 99 ? '99+' : number_to_show.toString();
	  },
	
	  render: function render() {
	    if (this.props.hide) {
	      return false;
	    }
	    if (this.props.number_of_people_visible === 0 || this.props.total_number_of_people === 0) {
	      return false;
	    }
	    if (this.props.number_of_people_visible >= this.props.total_number_of_people) {
	      return false;
	    }
	
	    var classes = 'aui-avatar aui-avatar-project aui-avatar-' + this.props.size;
	    return React.createElement(
	      'div',
	      { className: 'hc-roster-mini-expander', 'data-order': 'expander' },
	      React.createElement(
	        'span',
	        { className: classes },
	        React.createElement(
	          'span',
	          { className: 'aui-avatar-inner' },
	          React.createElement(
	            'div',
	            { className: 'hc-default-avatar' },
	            this._getNumberToShow()
	          )
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _person_helper = __webpack_require__(510);
	
	var _person_helper2 = _interopRequireDefault(_person_helper);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'RosterMiniItem',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    size: React.PropTypes.string,
	    order: React.PropTypes.string,
	    user_is_admin: React.PropTypes.bool,
	    user_name: React.PropTypes.string.isRequired,
	    user_mention_name: React.PropTypes.string.isRequired,
	    user_presence_show: React.PropTypes.string,
	    user_presence_status: React.PropTypes.string,
	    user_photo_url: React.PropTypes.string,
	    user_jid: React.PropTypes.string,
	    user_id: React.PropTypes.oneOfType([React.PropTypes.number, React.PropTypes.string]),
	    shouldAnimate: React.PropTypes.bool
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      size: 'small',
	      order: 'show',
	      user_is_admin: false,
	      user_presence_show: 'unknown',
	      user_presence_status: ''
	    };
	  },
	
	  _getTooltip: function _getTooltip() {
	    return _person_helper2.default.get_user_tooltip_flat(this.props.user_name, this.props.user_mention_name, this.props.user_is_admin, this.props.user_presence_show, this.props.user_presence_status);
	  },
	  _getAvatar: function _getAvatar() {
	    return React.createElement(_person_avatar2.default, { avatar_url: this.props.user_photo_url,
	      presence: this.props.user_presence_show,
	      name: this.props.user_name,
	      size: this.props.size,
	      shouldAnimate: this.props.shouldAnimate,
	      uid: this.props.user_id });
	  },
	
	
	  render: function render() {
	    var avatar = this._getAvatar(),
	        tooltip = this._getTooltip();
	    return React.createElement(
	      'div',
	      { ref: 'person', key: 'user-' + this.props.user_id, className: 'hc-roster-mini-item', 'data-order': this.props.order,
	        'data-status': this.props.user_presence_show, 'data-name': this.props.user_name, 'aria-label': tooltip },
	      avatar
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _groupchat_header = __webpack_require__(555);
	
	var _groupchat_header2 = _interopRequireDefault(_groupchat_header);
	
	var _oto_header = __webpack_require__(563);
	
	var _oto_header2 = _interopRequireDefault(_oto_header);
	
	var _chat_header_store = __webpack_require__(267);
	
	var _chat_header_store2 = _interopRequireDefault(_chat_header_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _permissions_store = __webpack_require__(269);
	
	var _permissions_store2 = _interopRequireDefault(_permissions_store);
	
	var _read_only_store = __webpack_require__(334);
	
	var _read_only_store2 = _interopRequireDefault(_read_only_store);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var integration_events = ['change:should_show_warning_icon'];
	
	function getState() {
	  var chat = _chat_header_store2.default.get('chat'),
	      presence = chat.presence || {};
	
	  return {
	    type: _chat_header_store2.default.get('type'),
	    initialized: _chat_header_store2.default.get('initialized'),
	    path_prefix: _chat_header_store2.default.get('path_prefix'),
	    name: chat.name,
	    jid: _chat_header_store2.default.get('active_chat'),
	    room_id: chat.id,
	    privacy: chat.privacy,
	    topic: chat.topic,
	    guest_url: chat.guest_url,
	    is_archived: chat.is_archived,
	    title: chat.title,
	    photo_large: chat.photo_large,
	    loading_profile: chat.loading_profile,
	    presence_status: presence.status,
	    presence_show: presence.show,
	    mention_name: chat.mention_name,
	    time: chat.time,
	    email: chat.email,
	    active_chat: _chat_header_store2.default.get('active_chat'),
	    do_emoticons: _preferences_store2.default.shouldReplaceTextEmoticons(),
	    should_animate_avatar: _preferences_store2.default.shouldAnimateAvatars(),
	    groupchat_active_panel: _preferences_store2.default.getGroupChatActivePanel(),
	    groupchat_show_sidebar: _preferences_store2.default.shouldShowGroupChatSidebar(),
	    chat_active_panel: _preferences_store2.default.getChatActivePanel(),
	    chat_show_sidebar: _preferences_store2.default.shouldShowChatSidebar(),
	    topic_editing: _chat_header_store2.default.get('topic_editing'),
	    topic_input_value: chat.topic,
	    can_create_room: _permissions_store2.default.canCreateRoom(),
	    can_manage_room_integrations: _permissions_store2.default.canManageRoomIntegrations(),
	    can_view_guest_access: _permissions_store2.default.canViewGuestAccess(),
	    can_toggle_guest_access: _permissions_store2.default.canToggleGuestAccess(),
	    read_only_mode: _read_only_store2.default.get('read_only_mode'),
	    video_enabled: _chat_header_store2.default.get('video_enabled'),
	    user_is_admin: _permissions_store2.default.get('user_is_room_admin'),
	    per_room_notifications_enabled: _chat_header_store2.default.get('per_room_notifications_enabled'),
	    web_client_integrations_enabled: _chat_header_store2.default.get('web_client_integrations_enabled'),
	    web_client_addlive_video_enabled: _chat_header_store2.default.get('web_client_addlive_video_enabled'),
	    web_client_enso_video_enabled: _chat_header_store2.default.get('web_client_enso_video_enabled'),
	    web_client_enso_room_video_enabled: _chat_header_store2.default.get('web_client_enso_room_video_enabled'),
	    show_integrations_warning_icon: _integrations_store2.default.get('should_show_warning_icon')
	  };
	}
	
	module.exports = React.createClass({
	
	  displayName: "ChatHeader",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _chat_header_store2.default.on('change', this._onChange);
	    _preferences_store2.default.on('change', this._onChange);
	    _permissions_store2.default.on('change', this._onChange);
	    _integrations_store2.default.on(integration_events, this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _chat_header_store2.default.off('change', this._onChange);
	    _preferences_store2.default.off('change', this._onChange);
	    _permissions_store2.default.off('change', this._onChange);
	    _integrations_store2.default.off(integration_events, this._onChange);
	  },
	
	  _onChange: function _onChange() {
	    this.setState(getState());
	  },
	
	  _getHeader: function _getHeader() {
	    if (this.state.type === 'chat') {
	      return React.createElement(_oto_header2.default, { photo_large: this.state.photo_large,
	        jid: this.state.jid,
	        id: this.state.room_id,
	        active_panel: this.state.chat_active_panel,
	        show_sidebar: this.state.chat_show_sidebar,
	        name: this.state.name,
	        mention_name: this.state.mention_name,
	        loading_profile: this.state.loading_profile,
	        presence_status: this.state.presence_status,
	        presence_show: this.state.presence_show,
	        time: this.state.time,
	        email: this.state.email,
	        title: this.state.title,
	        video_enabled: this.state.video_enabled,
	        should_animate_avatar: this.state.should_animate_avatar,
	        read_only_mode: this.state.read_only_mode,
	        web_client_enso_video_enabled: this.state.web_client_enso_video_enabled,
	        web_client_addlive_video_enabled: this.state.web_client_addlive_video_enabled,
	        web_client_integrations_enabled: this.state.web_client_integrations_enabled });
	    } else if (this.state.type === 'groupchat') {
	      return React.createElement(_groupchat_header2.default, { name: this.state.name,
	        jid: this.state.jid,
	        path_prefix: this.state.path_prefix,
	        room_id: this.state.room_id,
	        privacy: this.state.privacy,
	        type: this.state.type,
	        guest_url: this.state.guest_url,
	        is_archived: this.state.is_archived,
	        topic: this.state.topic,
	        initialized: this.state.initialized,
	        topic_editing: this.state.topic_editing,
	        topic_input_value: this.state.topic_input_value,
	        active_panel: this.state.groupchat_active_panel,
	        show_sidebar: this.state.groupchat_show_sidebar,
	        do_emoticons: this.state.do_emoticons,
	        is_guest: this.props.is_guest,
	        can_create_room: this.state.can_create_room,
	        can_view_guest_access: this.state.can_view_guest_access,
	        can_toggle_guest_access: this.state.can_toggle_guest_access,
	        can_manage_room_integrations: this.state.can_manage_room_integrations,
	        per_room_notifications_enabled: this.state.per_room_notifications_enabled,
	        user_is_admin: this.state.user_is_admin,
	        video_enabled: this.state.video_enabled,
	        read_only_mode: this.state.read_only_mode,
	        web_client_enso_video_enabled: this.state.web_client_enso_video_enabled,
	        web_client_enso_room_video_enabled: this.state.web_client_enso_room_video_enabled,
	        web_client_integrations_enabled: this.state.web_client_integrations_enabled,
	        show_integrations_warning_icon: this.state.show_integrations_warning_icon });
	    }
	    return React.createElement('div', null);
	  },
	
	  render: function render() {
	    var header = this._getHeader();
	
	    return React.createElement(
	      'header',
	      { className: 'aui-page-header room-header' },
	      header
	    );
	  }
	
	});

/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _topic_input = __webpack_require__(556);
	
	var _topic_input2 = _interopRequireDefault(_topic_input);
	
	var _groupchat_header_buttons = __webpack_require__(557);
	
	var _groupchat_header_buttons2 = _interopRequireDefault(_groupchat_header_buttons);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _chat_header_actions = __webpack_require__(285);
	
	var _chat_header_actions2 = _interopRequireDefault(_chat_header_actions);
	
	var _video_actions = __webpack_require__(172);
	
	var _video_actions2 = _interopRequireDefault(_video_actions);
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _emoticons = __webpack_require__(110);
	
	var _emoticons2 = _interopRequireDefault(_emoticons);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _groupchat_header_actions = __webpack_require__(562);
	
	var _groupchat_header_actions2 = _interopRequireDefault(_groupchat_header_actions);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "GroupChatHeader",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    do_emoticons: React.PropTypes.bool
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    _emoticons2.default._replaceSpecials(ReactDOM.findDOMNode(this));
	  },
	
	  _getTopic: function _getTopic() {
	    var topic;
	
	    if (this.props.topic_editing) {
	      topic = this._getTopicInput();
	    } else {
	      topic = this._getTopicText();
	    }
	    return topic;
	  },
	
	  _getTopicInput: function _getTopicInput() {
	    return React.createElement(_topic_input2.default, { topic_input_value: this.props.topic_input_value });
	  },
	
	  _getTopicText: function _getTopicText() {
	    var topic,
	        escapedTopic,
	        defaultTopicText = this.props.is_guest ? "" : _chat_header_strings2.default.default_topic;
	
	    // Topic is still loading, show spinner
	    if (this.props.topic === null) {
	      topic = React.createElement(
	        "div",
	        { className: "topic-spinner" },
	        React.createElement(_spinner2.default, { size: "small",
	          spin: true,
	          left: "0",
	          top: "0" })
	      );
	      // Topic is loaded, but empty
	    } else if (this.props.topic === '') {
	        topic = React.createElement(
	          "i",
	          { className: "hc-page-header-topic",
	            onDoubleClick: this._onTopicDoubleClick },
	          defaultTopicText
	        );
	        // Topic is loaded, not empty
	      } else {
	          escapedTopic = _utils2.default.escapeAndLinkify(this.props.topic, {
	            escape_whitespace: true,
	            do_word_breaks: false,
	            do_emoticons: this.props.do_emoticons && this.props.initialized
	          });
	          topic = React.createElement("div", { className: "hc-page-header-topic",
	            title: this.props.topic,
	            onClick: this._onClick,
	            onDoubleClick: this._onTopicDoubleClick,
	            onCopy: this._onCopy,
	            dangerouslySetInnerHTML: { __html: '<span>' + escapedTopic + '</span>' } });
	        }
	
	    return topic;
	  },
	
	  _onCopy: function _onCopy() {
	    if (_utils2.default.link.identify_invite_link(window.getSelection().toString())) {
	      _analytics_actions2.default.userInviteURLCopied();
	    }
	  },
	
	  _onClick: function _onClick(evt) {
	    var isLink = _.get(evt, 'target.tagName', '').toLowerCase() === 'a';
	    var url = _.get(evt, 'target.href', null);
	    var jid = this.props.jid;
	    var room_id = this.props.room_id;
	
	    if (!this.props.is_guest && isLink && !!url && _utils2.default.video.isVideoLink(url)) {
	      evt.preventDefault();
	      _video_actions2.default.joinRoomVideoCall({ url: url, jid: jid, room_id: room_id });
	    }
	  },
	
	
	  _onTopicDoubleClick: function _onTopicDoubleClick() {
	    if (!this.props.is_guest) {
	      _chat_header_actions2.default.editTopicInChatHeader();
	    }
	  },
	
	  _getGroupChatButtons: function _getGroupChatButtons() {
	    return React.createElement(_groupchat_header_buttons2.default, this.props);
	  },
	  _getGuestAccessLozenge: function _getGuestAccessLozenge() {
	    if (!this.props.guest_url) {
	      return null;
	    }
	
	    return React.createElement(
	      "span",
	      { id: "guest_access", className: "guest-access-lozenge aui-lozenge aui-lozenge-complete aui-lozenge-subtle", onMouseOver: this._showGuestAccessInformation },
	      _chat_header_strings2.default.guest_access_on
	    );
	  },
	  _showGuestAccessInformation: function _showGuestAccessInformation() {
	    _groupchat_header_actions2.default.showGuestAccessInformation({
	      anchor: document.getElementById('guest_access'),
	      guest_url: this.props.guest_url
	    });
	  },
	
	
	  render: function render() {
	    var headerClasses = (0, _classnames2.default)({
	      'aui-page-header-main': true,
	      'hc-page-header-main': true,
	      'hc-integrations-enabled': this.props.web_client_integrations_enabled
	    }),
	        iconClasses = (0, _classnames2.default)({
	      'aui-icon': true,
	      'hipchat-icon-huge': true,
	      'icon-private': this.props.privacy === "private",
	      'icon-public': this.props.privacy === "public",
	      'icon-dot': !this.props.privacy
	    }),
	        topic = this._getTopic(),
	        groupChatButtons = this._getGroupChatButtons(),
	        guestAccess = this._getGuestAccessLozenge();
	
	    return React.createElement(
	      "div",
	      { className: "aui-page-header-inner hc-groupchat" },
	      React.createElement(
	        "div",
	        { className: "page-header-icon" },
	        React.createElement("span", { className: iconClasses })
	      ),
	      React.createElement(
	        "div",
	        { className: headerClasses },
	        React.createElement(
	          "div",
	          { className: "hc-groupchat-header" },
	          React.createElement(
	            "h3",
	            null,
	            this.props.name
	          ),
	          guestAccess,
	          React.createElement("br", null)
	        ),
	        topic
	      ),
	      groupChatButtons
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chat_header_actions = __webpack_require__(285);
	
	var _chat_header_actions2 = _interopRequireDefault(_chat_header_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _link_utils = __webpack_require__(108);
	
	var _link_utils2 = _interopRequireDefault(_link_utils);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "TopicInput",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    ReactDOM.findDOMNode(this.refs.topicInput).select();
	    document.addEventListener("click", this._onBlur);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    document.removeEventListener("click", this._onBlur);
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      topic_editing_value: null
	    };
	  },
	
	  _handleTopicSubmit: function _handleTopicSubmit(e) {
	    e.preventDefault();
	    if (this.state.topic_editing_value !== null) {
	      // Only set topic if changes were made
	      this._setTopic();
	    }
	    this._dismissTopicEdit();
	  },
	
	  _onKeydown: function _onKeydown(evt) {
	    if (evt.keyCode === 27) {
	      this._dismissTopicEdit();
	    }
	  },
	
	  _onKeyPressCancel: function _onKeyPressCancel(e) {
	    if (e.keyCode === 13) {
	      this._dismissTopicEdit();
	    }
	  },
	
	  _onBlur: function _onBlur(e) {
	    var $target = $(e.target);
	
	    if (!$target.is(".change-topic-action > a")) {
	      this._dismissTopicEdit();
	    }
	  },
	
	  _preventBubbling: function _preventBubbling(evt) {
	    evt.nativeEvent.stopImmediatePropagation();
	  },
	
	  _setTopic: function _setTopic() {
	    _chat_header_actions2.default.changeTopic(this.state.topic_editing_value);
	    this.state.topic_editing_value = null;
	  },
	
	  _dismissTopicEdit: function _dismissTopicEdit() {
	    this.topic_editing_value = null;
	    _chat_header_actions2.default.dismissTopicEdit();
	  },
	
	  _onValueChange: function _onValueChange(evt) {
	    this.setState({
	      topic_editing_value: evt.target.value
	    });
	  },
	
	  _onCopy: function _onCopy() {
	    if (_link_utils2.default.identify_invite_link(window.getSelection().toString())) {
	      _analytics_actions2.default.userInviteURLCopied();
	    }
	  },
	
	  render: function render() {
	    var inputValue = this.state.topic_editing_value !== null ? this.state.topic_editing_value : this.props.topic_input_value,
	        inputClasses = (0, _classnames2.default)({
	      'text': true,
	      'topic-edit-input': true,
	      'mousetrap': true
	    });
	
	    return React.createElement(
	      'form',
	      { ref: 'topicForm', className: 'aui', onSubmit: this._handleTopicSubmit, onKeyDown: this._onKeydown, onClick: this._preventBubbling },
	      React.createElement('input', { type: 'text',
	        ref: 'topicInput',
	        id: 'topic-input',
	        maxLength: _app_config2.default.max_topic_text_length,
	        className: inputClasses,
	        value: inputValue,
	        onCopy: this._onCopy,
	        onChange: this._onValueChange }),
	      React.createElement(
	        'button',
	        { id: 'topic-submit-btn', type: 'submit', className: 'aui-button' },
	        React.createElement(
	          'span',
	          { className: 'aui-icon aui-icon-small aui-iconfont-success' },
	          'Success '
	        )
	      ),
	      React.createElement(
	        'button',
	        { id: 'topic-cancel-btn', type: 'button', className: 'aui-button', onKeyDown: this._onKeyPressCancel, onClick: this._dismissTopicEdit },
	        React.createElement(
	          'span',
	          { className: 'aui-icon hipchat-icon-xsmall hc-close-icon icon-close' },
	          'Close '
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _chat_header_actions = __webpack_require__(285);
	
	var _chat_header_actions2 = _interopRequireDefault(_chat_header_actions);
	
	var _groupchat_room_dropdown = __webpack_require__(558);
	
	var _groupchat_room_dropdown2 = _interopRequireDefault(_groupchat_room_dropdown);
	
	var _notification_icon = __webpack_require__(560);
	
	var _notification_icon2 = _interopRequireDefault(_notification_icon);
	
	var _aui_dropdown = __webpack_require__(333);
	
	var _aui_dropdown2 = _interopRequireDefault(_aui_dropdown);
	
	var _aui_dropdown2_trigger = __webpack_require__(332);
	
	var _aui_dropdown2_trigger2 = _interopRequireDefault(_aui_dropdown2_trigger);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PropTypes = React.PropTypes;
	
	exports.default = React.createClass({
	
	  displayName: "GroupChatHeaderButtons",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    jid: PropTypes.string,
	    name: PropTypes.string,
	    guest_url: PropTypes.string,
	    room_id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
	    privacy: PropTypes.string,
	    type: PropTypes.string,
	    active_panel: PropTypes.string,
	    is_guest: PropTypes.bool,
	    show_sidebar: PropTypes.bool,
	    read_only_mode: PropTypes.bool,
	    user_is_admin: PropTypes.bool,
	    per_room_notifications_enabled: PropTypes.bool,
	    can_create_room: PropTypes.bool,
	    can_view_guest_access: PropTypes.bool,
	    can_toggle_guest_access: PropTypes.bool,
	    can_manage_room_integrations: PropTypes.bool,
	    web_client_integrations_enabled: PropTypes.bool,
	    web_client_enso_video_enabled: PropTypes.bool,
	    web_client_enso_room_video_enabled: PropTypes.bool,
	    show_integrations_warning_icon: React.PropTypes.bool
	  },
	
	  _startEnsoRoomVideo: function _startEnsoRoomVideo() {
	    _chat_header_actions2.default.startEnsoRoomVideo({
	      jid: this.props.jid,
	      room_id: this.props.room_id,
	      name: this.props.name
	    });
	  },
	
	  _selectPanel: function _selectPanel(type) {
	    this._clearButtonFocus();
	    _chat_header_actions2.default.handlePanelSelect({
	      type: type,
	      room: this.props.jid
	    });
	  },
	
	  _clearButtonFocus: function _clearButtonFocus() {
	    var buttons = ReactDOM.findDOMNode(this).querySelectorAll(".aui-button");
	    for (var i = 0; i < buttons.length; i++) {
	      buttons[i].blur();
	    }
	  },
	
	  _getDropDown: function _getDropDown() {
	    return React.createElement(
	      _aui_dropdown2.default,
	      { className: 'aui-dropdown2-in-header', dropdownID: 'room-actions-drop-down' },
	      React.createElement(_groupchat_room_dropdown2.default, this.props)
	    );
	  },
	
	
	  _getActionsButton: function _getActionsButton() {
	    var classNames = (0, _classnames2.default)({
	      'aui-button': true,
	      'aui-button-light': true,
	      'notification-badge': this.props.show_integrations_warning_icon
	    });
	
	    return React.createElement(
	      _aui_dropdown2_trigger2.default,
	      {
	        id: 'room-actions-btn',
	        dropdownID: 'room-actions-drop-down',
	        className: classNames,
	        arrowless: true,
	        'aria-label': _chat_header_strings2.default.room_actions },
	      React.createElement(
	        'span',
	        { className: 'aui-icon aui-icon-small aui-iconfont-more' },
	        _chat_header_strings2.default.room_actions
	      )
	    );
	  },
	
	  _getNotificationIcon: function _getNotificationIcon() {
	    return this.props.per_room_notifications_enabled && !this.props.is_guest ? React.createElement(_notification_icon2.default, { jid: this.props.jid, room_name: this.props.name }) : null;
	  },
	
	  _getVideoButton: function _getVideoButton() {
	    var is_archived = _utils2.default.room.is_archived(this.props);
	    var is_disabled = is_archived || this.props.read_only_mode;
	
	    if (!this.props.web_client_enso_video_enabled || !this.props.web_client_enso_room_video_enabled || this.props.is_guest) {
	      return null;
	    }
	
	    return React.createElement(
	      'button',
	      {
	        ref: 'video_btn',
	        className: 'hc-video-call-btn-link aui-button aui-button-light',
	        title: _chat_header_strings2.default.video_call,
	        onClick: this._startEnsoRoomVideo,
	        disabled: is_disabled,
	        'data-no-focus': true },
	      React.createElement(
	        'span',
	        { className: 'aui-icon hipchat-icon-small icon-camera-no-slash' },
	        _chat_header_strings2.default.video_call
	      )
	    );
	  },
	
	  _getButtonTitle: function _getButtonTitle(ref, tooltip) {
	    if (this.props.show_sidebar && this.props.active_panel === ref) {
	      return _chat_header_strings2.default['hide_' + tooltip];
	    }
	
	    return _chat_header_strings2.default['show_' + tooltip];
	  },
	
	  _renderButton: function _renderButton(tooltip, ref, icons) {
	    var active = this.props.active_panel === ref && this.props.show_sidebar ? 'active' : '';
	    var title = this._getButtonTitle(ref, tooltip);
	    return React.createElement(
	      'button',
	      { ref: ref + '_btn', className: 'hc-' + ref + '-btn-link aui-button aui-button-light ' + active,
	        onClick: this._selectPanel.bind(null, ref),
	        'aria-label': title },
	      React.createElement(
	        'span',
	        { className: "aui-icon " + icons },
	        _chat_header_strings2.default[ref]
	      )
	    );
	  },
	
	  _getWebClientIntegrationsButtons: function _getWebClientIntegrationsButtons() {
	    var notificationIcon = this._getNotificationIcon(),
	        videoButton = this.props.video_enabled ? this._getVideoButton() : null,
	        sidePanelButton = this._renderButton("sidebar", "integrations", "hipchat-icon-small icon-integrations"),
	        actionsButton = this.props.is_guest ? false : this._getActionsButton();
	
	    return React.createElement(
	      'div',
	      null,
	      notificationIcon,
	      React.createElement(
	        'div',
	        { className: 'aui-buttons' },
	        videoButton
	      ),
	      React.createElement(
	        'div',
	        { className: 'aui-buttons' },
	        sidePanelButton,
	        actionsButton
	      )
	    );
	  },
	
	  _getButtons: function _getButtons() {
	    var notificationIcon = this._getNotificationIcon(),
	        videoButton = this._getVideoButton(),
	        rosterButton = this._renderButton("roster", "roster", "aui-icon-small aui-iconfont-user"),
	        filesButton = this._renderButton("files", "files", "hipchat-icon-small icon-file"),
	        linksButton = this._renderButton("links", "links", "hipchat-icon-small icon-link"),
	        actionsButton = this.props.is_guest ? false : this._getActionsButton();
	
	    return React.createElement(
	      'div',
	      null,
	      notificationIcon,
	      React.createElement(
	        'div',
	        { className: 'aui-buttons' },
	        videoButton
	      ),
	      React.createElement(
	        'div',
	        { className: 'aui-buttons' },
	        rosterButton,
	        filesButton,
	        linksButton
	      ),
	      React.createElement(
	        'div',
	        { className: 'aui-buttons' },
	        actionsButton
	      )
	    );
	  },
	
	  render: function render() {
	    var classNames = (0, _classnames2.default)({
	      'aui-page-header-actions': true,
	      'hc-chat-header-actions': true,
	      'hc-integrations-chat-header-actions': this.props.web_client_integrations_enabled
	    });
	
	    var dropDown = this.props.is_guest ? false : this._getDropDown(),
	        buttons = this.props.web_client_integrations_enabled ? this._getWebClientIntegrationsButtons() : this._getButtons();
	
	    return React.createElement(
	      'div',
	      { className: classNames, ref: 'actions' },
	      buttons,
	      dropDown
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _room_dropdown_actions = __webpack_require__(287);
	
	var _room_dropdown_actions2 = _interopRequireDefault(_room_dropdown_actions);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _aui_dropdown2_interactive_link = __webpack_require__(559);
	
	var _aui_dropdown2_interactive_link2 = _interopRequireDefault(_aui_dropdown2_interactive_link);
	
	var _aui_section = __webpack_require__(320);
	
	var _aui_section2 = _interopRequireDefault(_aui_section);
	
	var _analytics_keys = __webpack_require__(197);
	
	var _analytics_keys2 = _interopRequireDefault(_analytics_keys);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _dialog_strings = __webpack_require__(203);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'RoomDropDown',
	
	  propTypes: {
	    jid: React.PropTypes.string,
	    name: React.PropTypes.string,
	    guest_url: React.PropTypes.string,
	    room_id: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
	    privacy: React.PropTypes.string,
	    is_archived: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.bool]),
	    user_is_admin: React.PropTypes.bool,
	    read_only_mode: React.PropTypes.bool,
	    per_room_notifications_enabled: React.PropTypes.bool,
	    can_view_guest_access: React.PropTypes.bool,
	    can_toggle_guest_access: React.PropTypes.bool,
	    can_manage_room_integrations: React.PropTypes.bool,
	    show_integrations_warning_icon: React.PropTypes.bool
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	  _getState: function _getState() {
	    return {
	      user_id: _configuration_store2.default.get('user_id'),
	      web_server: _configuration_store2.default.get('web_server')
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    _configuration_store2.default.on(['change:user_id', 'change:web_server'], this._onChange);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _configuration_store2.default.off(['change:user_id', 'change:web_server'], this._onChange);
	  },
	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },
	
	
	  // Event Listeners
	
	  _onRoomNotificationsClick: function _onRoomNotificationsClick() {
	    _dialog_actions2.default.showRoomNotificationsDialog({
	      jid: this.props.jid,
	      room_name: this.props.name
	    });
	    _analytics_actions2.default.roomNotificationDropdownClicked();
	  },
	  _onArchiveRoomClick: function _onArchiveRoomClick() {
	    _dialog_actions2.default.showArchiveRoomDialog({ archive: true });
	  },
	  _onUnarchiveRoomClick: function _onUnarchiveRoomClick() {
	    _dialog_actions2.default.showArchiveRoomDialog({ archive: false });
	  },
	  _onInviteUserClick: function _onInviteUserClick() {
	    _dialog_actions2.default.showInviteUsersDialog({ type: _analytics_keys2.default.ROOM_MENU });
	    _analytics_actions2.default.roomMenuInviteClicked();
	  },
	  _onRemoveUserClick: function _onRemoveUserClick() {
	    _dialog_actions2.default.showRemoveUsersDialog();
	  },
	  _onChangeTopicClick: function _onChangeTopicClick() {
	    _room_dropdown_actions2.default.editTopic();
	  },
	  _onChangePrivacyClick: function _onChangePrivacyClick() {
	    _dialog_actions2.default.showRoomPrivacyDialog({
	      jid: this.props.jid,
	      name: this.props.name,
	      privacy: this.props.privacy
	    });
	  },
	  _onRenameRoomClick: function _onRenameRoomClick() {
	    _dialog_actions2.default.showRenameRoomDialog({
	      jid: this.props.jid,
	      name: this.props.name
	    });
	  },
	  _onDeleteRoomClick: function _onDeleteRoomClick() {
	    _dialog_actions2.default.showDeleteRoomDialog({
	      jid: this.props.jid,
	      room_id: this.props.room_id,
	      name: this.props.name
	    });
	  },
	  _onEnableGuestClick: function _onEnableGuestClick() {
	    _room_dropdown_actions2.default.enableGuestAccess({ jid: this.props.jid }, this._enableGuestCallback);
	  },
	
	
	  _enableGuestCallback: function _enableGuestCallback(error) {
	    if (error) {
	      this._throwFlagError(error.message || _dialog_strings.enable_guest_fail);
	    }
	  },
	
	  _throwFlagError: function _throwFlagError(errorMessage) {
	    _flag_actions2.default.showFlag({
	      type: "error",
	      body: errorMessage,
	      close: "auto"
	    });
	  },
	
	  _onDisableGuestClick: function _onDisableGuestClick() {
	    _dialog_actions2.default.showDisableGuestAccessDialog();
	  },
	
	  // Permission / State Validators
	
	  _allowInviteUser: function _allowInviteUser() {
	    return (this.props.privacy === 'public' || this.props.privacy === 'private' && this.props.user_is_admin) && this._isNotArchived();
	  },
	  _allowRemoveUser: function _allowRemoveUser() {
	    return this.props.privacy === 'private' && this.props.user_is_admin && this._isNotArchived();
	  },
	  _allowAdminOnUnarchived: function _allowAdminOnUnarchived() {
	    return this.props.user_is_admin && this._isNotArchived();
	  },
	  _allowConfigureIntegrations: function _allowConfigureIntegrations() {
	    return this.props.can_manage_room_integrations && this._isNotArchived();
	  },
	  _isArchived: function _isArchived() {
	    return _utils2.default.room.is_archived({
	      is_archived: this.props.is_archived
	    });
	  },
	  _isNotArchived: function _isNotArchived() {
	    return !this._isArchived();
	  },
	  _archiveEnabled: function _archiveEnabled() {
	    return this.props.user_is_admin && this._isNotArchived();
	  },
	  _unarchiveEnabled: function _unarchiveEnabled() {
	    return this.props.user_is_admin && this._isArchived();
	  },
	
	
	  // Renderers
	
	  render: function render() {
	    var inviteUserLink = this._renderLink(_chat_header_strings2.default.invite_users, this._allowInviteUser, this._onInviteUserClick),
	        removeUserLink = this._renderLink(_chat_header_strings2.default.remove_users, this._allowRemoveUser, this._onRemoveUserClick),
	        archiveRoomLink = this._renderLink(_chat_header_strings2.default.archive, this._archiveEnabled, this._onArchiveRoomClick),
	        unarchiveRoomLink = this._renderLink(_chat_header_strings2.default.unarchive, this._unarchiveEnabled, this._onUnarchiveRoomClick),
	        changeTopicLink = this._renderLink(_chat_header_strings2.default.change_topic, this._isNotArchived, this._onChangeTopicClick),
	        changePrivacyLink = this._renderLink(_chat_header_strings2.default.change_privacy, this._allowAdminOnUnarchived, this._onChangePrivacyClick),
	        deleteRoomLink = this._renderLink(_chat_header_strings2.default.delete, this._allowAdminOnUnarchived, this._onDeleteRoomClick),
	        renameRoomLink = this._renderLink(_chat_header_strings2.default.rename, this._allowAdminOnUnarchived, this._onRenameRoomClick),
	        roomNotificationsItem = this.props.per_room_notifications_enabled ? this._getRoomNotificationsItem() : false,
	        integrationsItem = this._getIntegrationsItem(),
	        canViewGuestAccess = this.props.can_view_guest_access,
	        canToggleGuestAccess = this.props.can_toggle_guest_access;
	
	    return React.createElement(
	      'div',
	      { role: 'application', className: 'groupchat-room-dropdown' },
	      React.createElement(
	        _aui_section2.default,
	        null,
	        React.createElement(
	          'ul',
	          { role: 'list' },
	          roomNotificationsItem,
	          integrationsItem
	        )
	      ),
	      React.createElement(
	        _aui_section2.default,
	        null,
	        React.createElement(
	          'ul',
	          { role: 'list' },
	          React.createElement(
	            'li',
	            { className: 'invite-user-action', role: 'listitem' },
	            inviteUserLink
	          ),
	          React.createElement(
	            'li',
	            { className: 'remove-user-action', role: 'listitem' },
	            removeUserLink
	          )
	        )
	      ),
	      React.createElement(
	        _aui_section2.default,
	        null,
	        React.createElement(
	          'ul',
	          { role: 'list' },
	          React.createElement(
	            'li',
	            { className: 'enable-guest-action', role: 'listitem' },
	            React.createElement(
	              _aui_dropdown2_interactive_link2.default,
	              {
	                type: 'radio',
	                interactive: false,
	                checked: !!this.props.guest_url && canViewGuestAccess,
	                disabled: !(canToggleGuestAccess && !this.props.guest_url) || this.props.read_only_mode,
	                onCheck: this._onEnableGuestClick },
	              _chat_header_strings2.default.enable_guest
	            )
	          ),
	          React.createElement(
	            'li',
	            { className: 'disable-guest-action', role: 'listitem' },
	            React.createElement(
	              _aui_dropdown2_interactive_link2.default,
	              {
	                type: 'radio',
	                interactive: false,
	                checked: !this.props.guest_url && canViewGuestAccess,
	                disabled: !(canToggleGuestAccess && this.props.guest_url) || this.props.read_only_mode,
	                onCheck: this._onDisableGuestClick },
	              _chat_header_strings2.default.disable_guest
	            )
	          )
	        )
	      ),
	      React.createElement(
	        _aui_section2.default,
	        null,
	        React.createElement(
	          'ul',
	          { role: 'list' },
	          React.createElement(
	            'li',
	            { className: 'archive-room-action', role: 'listitem' },
	            archiveRoomLink
	          ),
	          React.createElement(
	            'li',
	            { className: 'unarchive-room-action', role: 'listitem' },
	            unarchiveRoomLink
	          ),
	          React.createElement(
	            'li',
	            { className: 'change-topic-action', role: 'listitem' },
	            changeTopicLink
	          ),
	          React.createElement(
	            'li',
	            { className: 'change-privacy-action', role: 'listitem' },
	            changePrivacyLink
	          ),
	          React.createElement(
	            'li',
	            { className: 'delete-room-action', role: 'listitem' },
	            deleteRoomLink
	          ),
	          React.createElement(
	            'li',
	            { className: 'rename-room-action', role: 'listitem' },
	            renameRoomLink
	          )
	        )
	      )
	    );
	  },
	
	
	  /**
	   * Render an anchor link
	   * @param {string} text. the content of the link. also used as the title attr
	   * @param {function} validator. function to call to see if the link should be active.
	   *   determines whether the link has a disabled class and aria-disabled attr
	   * @param {function} callback. method to call when the link is clicked if it is not disabled
	   */
	  _renderLink: function _renderLink(text, validator, callback) {
	    var isAvailable = validator();
	    var handler = function handler() {
	      if (validator()) {
	        callback();
	      }
	    };
	
	    return React.createElement(
	      'a',
	      { title: text,
	        className: isAvailable ? '' : 'disabled',
	        'aria-disabled': isAvailable ? 'false' : 'true',
	        onClick: handler },
	      text
	    );
	  },
	  _getRoomNotificationsItem: function _getRoomNotificationsItem() {
	    return React.createElement(
	      'li',
	      { className: 'room-notifications', role: 'listitem' },
	      React.createElement(
	        'a',
	        { title: _chat_header_strings2.default.room_notifications, onClick: this._onRoomNotificationsClick },
	        _chat_header_strings2.default.room_notifications
	      )
	    );
	  },
	  _onIntegrationsClick: function _onIntegrationsClick() {
	    _dialog_actions2.default.showIntegrationsManagementDialog({
	      jid: this.props.jid,
	      room_name: this.props.name
	    });
	    _analytics_actions2.default.roomIntegrationsDropdownClicked(this.props.show_integrations_warning_icon);
	  },
	  _getIntegrationsWarningIcon: function _getIntegrationsWarningIcon() {
	    return React.createElement('span', { className: 'hc-integration-warning-icon aui-icon aui-icon-small aui-iconfont-warning' });
	  },
	  _getIntegrationsItem: function _getIntegrationsItem() {
	    var warningIcon = this.props.show_integrations_warning_icon ? this._getIntegrationsWarningIcon() : null;
	
	    return React.createElement(
	      'li',
	      { className: 'integrations-user-action', role: 'listitem' },
	      React.createElement(
	        'a',
	        { title: _chat_header_strings2.default.integrations, onClick: this._onIntegrationsClick },
	        _chat_header_strings2.default.integrations,
	        warningIcon
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * https://docs.atlassian.com/aui/latest/docs/dropdown2.html
	 *
	 * Interactive links are dropdown links with radio buttons or checkboxes
	 * next to them. Clicking them do not close the dropdown they are in.
	 * You can override this by setting the interactive property to false.
	 *
	 * <div className="aui-dropdown2">
	 *   <div className="aui-dropdown2-section">
	 *     <ul>
	 *       <AUIDropdown2InteractiveLink type="radio">Clicking me won't close the dropdown</AUIDropdown2InteractiveLink>
	 *       <AUIDropdown2InteractiveLink type="radio">Me neither</AUIDropdown2InteractiveLink>
	 *     </ul>
	 *     <ul>
	 *       <AUIDropdown2InteractiveLink type="radio" interactive="false">Clicking me will close the dropdown</AUIDropdown2InteractiveLink>
	 *     </ul>
	 *     <ul>
	 *       <AUIDropdown2InteractiveLink type="checkbox" disabled="true">I'm disabled</AUIDropdown2InteractiveLink>
	 *       <AUIDropdown2InteractiveLink type="checkbox" checked="true">I'm checked</AUIDropdown2InteractiveLink>
	 *     </ul>
	 *   </div>
	 * </div>
	 */
	exports.default = React.createClass({
	
	  displayName: 'AUIDropdown2InteractiveLink',
	
	  propTypes: {
	    type: React.PropTypes.oneOf(['checkbox', 'radio']).isRequired,
	    interactive: React.PropTypes.bool,
	    checked: React.PropTypes.bool,
	    disabled: React.PropTypes.bool,
	    onCheck: React.PropTypes.func,
	    onUncheck: React.PropTypes.func
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      interactive: true,
	      checked: false,
	      disabled: false,
	      onCheck: _.noop,
	      onUncheck: _.noop
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    AJS.$(this.refs.link).on({
	      'aui-dropdown2-item-check': this._onCheck,
	      'aui-dropdown2-item-uncheck': this._onUncheck
	    });
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    AJS.$(this.refs.link).off();
	  },
	  _onCheck: function _onCheck() {
	    if (!this.props.disabled) {
	      this.props.onCheck();
	    }
	  },
	  _onUncheck: function _onUncheck() {
	    if (!this.props.disabled) {
	      this.props.onUncheck();
	    }
	  },
	  render: function render() {
	    var _cx;
	
	    var attrs = {
	      'ref': 'link',
	      'id': this.props.id || _.uniqueId(),
	      'aria-disabled': this.props.disabled,
	      'className': (0, _classnames2.default)((_cx = {}, (0, _defineProperty3.default)(_cx, this.props.className, !!this.props.className), (0, _defineProperty3.default)(_cx, 'aui-dropdown2-radio', this.props.type === 'radio'), (0, _defineProperty3.default)(_cx, 'aui-dropdown2-checkbox', this.props.type === 'checkbox'), (0, _defineProperty3.default)(_cx, 'interactive', this.props.interactive), (0, _defineProperty3.default)(_cx, 'aui-dropdown2-checked', this.props.checked), (0, _defineProperty3.default)(_cx, 'checked', this.props.checked), (0, _defineProperty3.default)(_cx, 'disabled', this.props.disabled), _cx))
	    };
	
	    return React.createElement(
	      'a',
	      attrs,
	      this.props.children
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var PreferencesStore = __webpack_require__(161);
	var PrefKeys = __webpack_require__(164);
	var strings = __webpack_require__(561);
	var DialogActions = __webpack_require__(95);
	var AnalyticsActions = __webpack_require__(196);
	var ApplicationStore = __webpack_require__(190);
	
	module.exports = React.createClass({
	
	  displayName: "NotificationIcon",
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    PreferencesStore.on(['change:' + PrefKeys.ROOM_NOTIFICATION_OVERRIDES], this._onChange);
	    PreferencesStore.on(['change:' + PrefKeys.GLOBAL_NOTIFICATION_SETTING], this._onChange);
	    ApplicationStore.on(['change:active_chat'], this._onChange);
	    this._createTooltip();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    PreferencesStore.off(['change:' + PrefKeys.ROOM_NOTIFICATION_OVERRIDES], this._onChange);
	    PreferencesStore.off(['change:' + PrefKeys.GLOBAL_NOTIFICATION_SETTING], this._onChange);
	    ApplicationStore.off(['change:active_chat'], this._onChange);
	    this._destroyTooltip();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._destroyTooltip();
	    this._createTooltip();
	  },
	
	  _onChange: function _onChange() {
	    if (this.isMounted()) {
	      this.setState(this._getState());
	    }
	  },
	
	  _getState: function _getState() {
	    var jid = ApplicationStore.get('active_chat'),
	        overrides = _.get(PreferencesStore.getRoomNotificationOverrides(), jid),
	        level = _.get(overrides, 'level', PreferencesStore.getGlobalNotificationSetting());
	    return { level: level };
	  },
	
	  _launchRoomNotificationsDialog: function _launchRoomNotificationsDialog() {
	    DialogActions.showRoomNotificationsDialog({
	      jid: ApplicationStore.get('active_chat'),
	      room_name: this.props.room_name
	    });
	    AnalyticsActions.roomNotificationIconClicked();
	  },
	
	  _getIcon: function _getIcon() {
	    var levelIcon = 'icon-volume-' + this.state.level;
	    var classNames = 'aui-icon hipchat-icon-small ' + levelIcon;
	    var title = '' + strings.level_prefix + strings.level[this.state.level];
	    return React.createElement(
	      'div',
	      { ref: 'notif_icon', className: 'hc-room-notif-icon', onClick: this._launchRoomNotificationsDialog },
	      React.createElement('span', { className: classNames, 'aria-label': title, ref: 'icon' })
	    );
	  },
	
	  _createTooltip: function _createTooltip() {
	    AJS.$(ReactDOM.findDOMNode(this.refs.icon)).tooltip({ offset: 10 });
	  },
	  _destroyTooltip: function _destroyTooltip() {
	    AJS.$(ReactDOM.findDOMNode(this.refs.icon)).tooltip('destroy');
	  },
	
	
	  render: function render() {
	    return this._getIcon();
	  }
	});

/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  level_prefix: 'Room notifications: ',
	  level: {
	    loud: _common_strings2.default.loud,
	    normal: _common_strings2.default.normal,
	    quiet: _common_strings2.default.quiet
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _inline_dialog_actions = __webpack_require__(277);
	
	var _inline_dialog_actions2 = _interopRequireDefault(_inline_dialog_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  showGuestAccessInformation: function showGuestAccessInformation(data) {
	    _inline_dialog_actions2.default.showGuestAccessInformation(data);
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 563 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _oto_header_buttons = __webpack_require__(564);
	
	var _oto_header_buttons2 = _interopRequireDefault(_oto_header_buttons);
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _presenceIcon = __webpack_require__(311);
	
	var _presenceIcon2 = _interopRequireDefault(_presenceIcon);
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "OTOHeader",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _getTitle: function _getTitle() {
	    var title;
	    if (this.props.title) {
	      title = React.createElement(
	        "span",
	        { className: "hc-oto-title" },
	        this.props.title
	      );
	    }
	    return title;
	  },
	
	  _getStatus: function _getStatus() {
	    var status;
	    if (this.props.loading_profile) {
	      status = _chat_header_strings2.default.loading;
	    } else {
	      status = this.props.presence_status || _utils2.default.user.chat_header_status(this.props.presence_show);
	    }
	    return status;
	  },
	
	  _getHeaderButtons: function _getHeaderButtons() {
	    return React.createElement(_oto_header_buttons2.default, { jid: this.props.jid,
	      name: this.props.name,
	      active_panel: this.props.active_panel,
	      show_sidebar: this.props.show_sidebar,
	      video_enabled: this.props.video_enabled,
	      read_only_mode: this.props.read_only_mode,
	      web_client_enso_video_enabled: this.props.web_client_enso_video_enabled,
	      web_client_addlive_video_enabled: this.props.web_client_addlive_video_enabled,
	      web_client_integrations_enabled: this.props.web_client_integrations_enabled });
	  },
	
	  render: function render() {
	    var hiddenClasses = (0, _classnames2.default)({
	      'hidden': this.props.loading_profile
	    }),
	        mentionClasses = (0, _classnames2.default)({
	      'hidden': this.props.loading_profile,
	      'mention-name': true
	    }),
	        title = this._getTitle(),
	        headerButtons = this._getHeaderButtons(),
	        status = this._getStatus();
	
	    return React.createElement(
	      "div",
	      { className: "aui-page-header-inner hc-priv-chat", key: 'oto-header-' + this.props.jid },
	      React.createElement(_person_avatar2.default, { avatar_url: this.props.photo_large,
	        size: "large",
	        shouldAnimate: this.props.should_animate_avatar,
	        show_presence: false }),
	      React.createElement(
	        "div",
	        { className: "aui-page-header-main hc-page-header-main" },
	        React.createElement(
	          "h3",
	          null,
	          this.props.name
	        ),
	        "",
	        React.createElement(
	          "span",
	          { className: mentionClasses },
	          '(@' + this.props.mention_name + ')'
	        ),
	        React.createElement(
	          "p",
	          null,
	          React.createElement(_presenceIcon2.default, { presence: this.props.presence_show, uid: this.props.id }),
	          React.createElement(
	            "span",
	            { className: "hc-oto-status" },
	            status
	          ),
	          React.createElement(
	            "span",
	            { className: hiddenClasses },
	            React.createElement(
	              "span",
	              { className: "hc-oto-time" },
	              this.props.time
	            ),
	            title,
	            React.createElement(
	              "a",
	              { href: "mailto:" + this.props.email },
	              this.props.email
	            )
	          )
	        )
	      ),
	      headerButtons
	    );
	  }
	
	});

/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _chat_header_actions = __webpack_require__(285);
	
	var _chat_header_actions2 = _interopRequireDefault(_chat_header_actions);
	
	var _video_buttons = __webpack_require__(565);
	
	var _video_buttons2 = _interopRequireDefault(_video_buttons);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "OTOHeaderButtons",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _selectPanel: function _selectPanel(type) {
	    this._clearButtonFocus();
	    _chat_header_actions2.default.handlePanelSelect({
	      type: type,
	      room: this.props.jid
	    });
	  },
	
	  _clearButtonFocus: function _clearButtonFocus() {
	    var buttons = ReactDOM.findDOMNode(this).querySelectorAll(".aui-button");
	    for (var i = 0; i < buttons.length; i++) {
	      buttons[i].blur();
	    }
	  },
	
	  _getVideoButton: function _getVideoButton() {
	    return React.createElement(_video_buttons2.default, {
	      jid: this.props.jid,
	      name: this.props.name,
	      read_only_mode: this.props.read_only_mode,
	      web_client_enso_video_enabled: this.props.web_client_enso_video_enabled,
	      web_client_addlive_video_enabled: this.props.web_client_addlive_video_enabled });
	  },
	
	  _getButtonTitle: function _getButtonTitle(ref, tooltip) {
	    if (this.props.show_sidebar && this.props.active_panel === ref) {
	      return _chat_header_strings2.default['hide_' + tooltip];
	    }
	
	    return _chat_header_strings2.default['show_' + tooltip];
	  },
	
	  _renderButton: function _renderButton(tooltip, ref, icons) {
	    var active = this.props.active_panel === ref && this.props.show_sidebar ? 'active' : '',
	        title = this._getButtonTitle(ref, tooltip);
	    return React.createElement(
	      'button',
	      {
	        ref: ref + '_btn',
	        className: 'hc-' + ref + '-btn-link aui-button aui-button-light ' + active,
	        onClick: this._selectPanel.bind(null, ref),
	        'aria-label': title },
	      React.createElement(
	        'span',
	        { className: "aui-icon " + icons },
	        _chat_header_strings2.default[ref]
	      )
	    );
	  },
	
	  render: function render() {
	    var videoButton = this.props.video_enabled ? this._getVideoButton() : null,
	        filesButton = !this.props.web_client_integrations_enabled ? this._renderButton("files", "files", "hipchat-icon-small icon-file") : null,
	        linksButton = !this.props.web_client_integrations_enabled ? this._renderButton("links", "links", "hipchat-icon-small icon-link") : null,
	        sidePanelButton = this.props.web_client_integrations_enabled ? this._renderButton("sidebar", "integrations", "hipchat-icon-small icon-integrations") : null;
	
	    return React.createElement(
	      'div',
	      { className: 'aui-page-header-actions hc-chat-header-actions', ref: 'actions' },
	      videoButton,
	      React.createElement(
	        'div',
	        { className: 'aui-buttons' },
	        filesButton,
	        linksButton,
	        sidePanelButton
	      )
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chat_header_strings = __webpack_require__(268);
	
	var _chat_header_strings2 = _interopRequireDefault(_chat_header_strings);
	
	var _chat_header_actions = __webpack_require__(285);
	
	var _chat_header_actions2 = _interopRequireDefault(_chat_header_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _aui_dropdown = __webpack_require__(333);
	
	var _aui_dropdown2 = _interopRequireDefault(_aui_dropdown);
	
	var _aui_dropdown2_trigger = __webpack_require__(332);
	
	var _aui_dropdown2_trigger2 = _interopRequireDefault(_aui_dropdown2_trigger);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _video_service_keys = __webpack_require__(174);
	
	var _video_service_keys2 = _interopRequireDefault(_video_service_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "OTOHeaderVideoButtons",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _startAddliveVideoCall: function _startAddliveVideoCall() {
	    _chat_header_actions2.default.startCall({
	      jid: this.props.jid,
	      name: this.props.name,
	      service: 'addlive',
	      audio_only: false
	    });
	  },
	
	  _startEnsoVideoCall: function _startEnsoVideoCall() {
	    _chat_header_actions2.default.startCall({
	      jid: this.props.jid,
	      name: this.props.name,
	      service: 'enso',
	      audio_only: false
	    });
	  },
	
	  _getVideoSelectButton: function _getVideoSelectButton() {
	    return React.createElement(
	      _aui_dropdown2_trigger2.default,
	      { className: 'hc-video-call-btn-link aui-button aui-button-light',
	        dropdownID: 'video-chat-service-menu',
	        title: _chat_header_strings2.default.video_call,
	        'data-no-focus': 'true' },
	      React.createElement(
	        'span',
	        { className: 'aui-icon hipchat-icon-small icon-camera-no-slash' },
	        _chat_header_strings2.default.video_call
	      )
	    );
	  },
	
	  _getStandardVideoButton: function _getStandardVideoButton(service) {
	    return React.createElement(
	      'button',
	      { ref: 'video_btn',
	        className: 'hc-video-call-btn-link aui-button aui-button-light',
	        onClick: service === _video_service_keys2.default.ENSO ? this._startEnsoVideoCall : this._startAddliveVideoCall,
	        title: _chat_header_strings2.default.video_call,
	        disabled: this.props.read_only_mode,
	        'data-no-focus': 'true' },
	      React.createElement(
	        'span',
	        { className: 'aui-icon hipchat-icon-small icon-camera-no-slash' },
	        _chat_header_strings2.default.video_call
	      )
	    );
	  },
	
	  _getVideoChatButton: function _getVideoChatButton() {
	    var video_service_enabled = [this.props.web_client_addlive_video_enabled, this.props.web_client_enso_video_enabled];
	
	    var button = void 0;
	
	    switch (video_service_enabled.indexOf(false)) {
	      case -1:
	        button = this._getVideoSelectButton();
	        break;
	      case 0:
	        button = this._getStandardVideoButton(_video_service_keys2.default.ENSO);
	        break;
	      case 1:
	        button = this._getStandardVideoButton(_video_service_keys2.default.ADDLIVE);
	        break;
	    }
	
	    return button;
	  },
	
	  _getVideoChatExpandMenu: function _getVideoChatExpandMenu() {
	    return React.createElement(
	      _aui_dropdown2.default,
	      { dropdownID: 'video-chat-service-menu' },
	      React.createElement(
	        'div',
	        { className: 'aui-dropdown2-section' },
	        React.createElement(
	          'ul',
	          null,
	          React.createElement(
	            'li',
	            null,
	            React.createElement(
	              'a',
	              { ref: 'menu_enso_video_btn',
	                className: 'hc-enso-service',
	                target: '_blank',
	                onClick: this._startEnsoVideoCall },
	              _chat_header_strings2.default.enso_video,
	              React.createElement(
	                'span',
	                { className: 'aui-lozenge aui-lozenge-current hc-video-service-lozenge' },
	                'Beta'
	              )
	            )
	          ),
	          React.createElement(
	            'li',
	            null,
	            React.createElement(
	              'a',
	              { ref: 'menu_video_btn',
	                className: 'hc-video-service',
	                target: '_blank',
	                onClick: this._startAddliveVideoCall },
	              _chat_header_strings2.default.hipchat_video
	            )
	          )
	        )
	      )
	    );
	  },
	
	  render: function render() {
	    var provide_select_menu = this.props.web_client_enso_video_enabled && this.props.web_client_addlive_video_enabled;
	    var menu = void 0;
	
	    if (provide_select_menu) {
	      menu = this._getVideoChatExpandMenu();
	    }
	    var classes = (0, _classnames2.default)({
	      'aui-buttons': true,
	      'hc-video-btn-expands': provide_select_menu
	    });
	    return React.createElement(
	      'div',
	      { className: classes },
	      React.createElement(
	        'div',
	        null,
	        this._getVideoChatButton()
	      ),
	      menu
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _message_list = __webpack_require__(567);
	
	var _message_list2 = _interopRequireDefault(_message_list);
	
	var _chat_window_store = __webpack_require__(599);
	
	var _chat_window_store2 = _interopRequireDefault(_chat_window_store);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getChatsState() {
	  return _chat_window_store2.default.getAll();
	}
	
	function getAddonAvatars() {
	  return { addon_avatars: _integrations_store2.default.get('addon_avatars') };
	}
	
	function getInitialChatsState() {
	  return _.extend(getAddonAvatars(), getChatsState());
	}
	
	var PureRenderMixin = React.addons.PureRenderMixin;
	
	module.exports = React.createClass({
	
	  displayName: "ChatPanel",
	
	  mixins: [PureRenderMixin],
	
	  getInitialState: function getInitialState() {
	    return getInitialChatsState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _chat_window_store2.default.on(['change'], this._onChatStateChange);
	    var size = 0;
	    var members = this.state.chats && _.get(this.state, "chats[\"" + this.state.active_chat + "\"].participants.members");
	    if (members) {
	      size = members.length;
	    }
	    _chat_window_actions2.default.chatPanelMounted({ id: this.state.active_chat, size: size });
	    _integrations_store2.default.on("change:addon_avatars", this._onAddonAvatarsChanged);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _chat_window_store2.default.off(['change'], this._onChatStateChange);
	    _integrations_store2.default.off('change:addon_avatars', this._onAddonAvatarsChanged);
	  },
	
	  render: function render() {
	    var styles = {
	      zoom: this.state.zoom_level
	    },
	        chat;
	
	    if (this.state.active_chat && _utils2.default.jid.is_chat(this.state.active_chat) && this.state.chats[this.state.active_chat]) {
	      chat = React.createElement(_message_list2.default, { key: this.state.active_chat,
	        chat: this.state.chats[this.state.active_chat],
	        is_guest: this.props.is_guest,
	        initialized: this.state.initialized,
	        web_server: this.state.web_server,
	        token: this.state.oauth2_token,
	        addon_avatars: this.state.addon_avatars });
	    }
	    return React.createElement(
	      "div",
	      { className: "hc-chat-panel", style: styles },
	      chat
	    );
	  },
	
	  _onChatStateChange: function _onChatStateChange() {
	    this.setState(getChatsState());
	  },
	
	  _onAddonAvatarsChanged: function _onAddonAvatarsChanged() {
	    this.setState(getAddonAvatars());
	  }
	});

/***/ },
/* 567 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _empty_state = __webpack_require__(568);
	
	var _empty_state2 = _interopRequireDefault(_empty_state);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _client_preferences_keys = __webpack_require__(166);
	
	var _client_preferences_keys2 = _interopRequireDefault(_client_preferences_keys);
	
	var _preferences_keys = __webpack_require__(164);
	
	var _preferences_keys2 = _interopRequireDefault(_preferences_keys);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _scroll_events = __webpack_require__(569);
	
	var _scroll_events2 = _interopRequireDefault(_scroll_events);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _history_spinner = __webpack_require__(570);
	
	var _history_spinner2 = _interopRequireDefault(_history_spinner);
	
	var _messages = __webpack_require__(571);
	
	var _messages2 = _interopRequireDefault(_messages);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	(0, _scroll_events2.default)();
	
	var PREFS_CHANGE_KEYS = ['change:' + _client_preferences_keys2.default.HIDE_GIFS_BY_DEFAULT, 'change:' + _client_preferences_keys2.default.HIDE_ATTACHED_CARDS_BY_DEFAULT, 'change:' + _client_preferences_keys2.default.SHOW_UNREAD_DIVIDER, 'change:' + _preferences_keys2.default.CHAT_VIEW, 'change:' + _preferences_keys2.default.THEME, 'change:' + _preferences_keys2.default.HIDE_PRESENCE_MESSAGES, 'change:' + _preferences_keys2.default.USE_24_HR_FORMAT, 'change:' + _preferences_keys2.default.NAME_DISPLAY, 'change:' + _client_preferences_keys2.default.ANIMATED_AVATARS];
	
	exports.default = React.createClass({
	
	  displayName: "ChatWindowMessageList",
	
	  getInitialState: function getInitialState() {
	    return {
	      initialized: false,
	      use24hrTime: _preferences_store2.default.shouldUse24HrTime(),
	      shouldHideGifs: _preferences_store2.default.shouldHideGifsByDefault(),
	      shouldHideAttachedCards: _preferences_store2.default.shouldHideAttachedCardsByDefault(),
	      should_animate_avatar: _preferences_store2.default.shouldAnimateAvatars(),
	      show_join_leave_messages: !_preferences_store2.default.getHidePresenceMessages(),
	      chat_view: _preferences_store2.default.getChatView(),
	      theme: _preferences_store2.default.getTheme(),
	      showUnreadDivider: _preferences_store2.default.shouldShowUnreadMessageDivider(),
	      nameDisplay: _preferences_store2.default.getNameDisplay(),
	      has_scrolled_initial: false
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    this._createDebounced();
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (!this.is_scrolling && !this.props.chat.scroll_frozen && !this._isHistoryEmpty() && !this.will_freeze && this.state.has_scrolled_initial) {
	      this._setScroll();
	    } else if (this.props.chat.scroll_frozen || this.props.chat.ancient_history_is_empty || this.will_freeze) {
	      this.debouncedUnfreezeAbove();
	    }
	  },
	  componentDidMount: function componentDidMount() {
	    var _this = this;
	
	    this.props.chat.isScrolledToBottom = false;
	    this.should_interrupt_autoscroll = false;
	    this.scroll_is_bound = false;
	    this.is_animating = false;
	    this.will_freeze = false;
	    this.is_scrolling = false;
	    this.scrollbox = ReactDOM.findDOMNode(this.refs.scrollbox);
	    this.$scrollbox = $(this.scrollbox);
	    this._throttledShouldSetScroll = _.throttle(this._shouldSetScroll, 100);
	
	    _app_dispatcher2.default.register('add-chat-state-message', this._changeChatStateMessage);
	    _app_dispatcher2.default.register('remove-chat-state-message', this._changeChatStateMessage);
	    _app_dispatcher2.default.register('preserve-scroll-value', this._throttledShouldSetScroll);
	    _app_dispatcher2.default.register('update-scroll-position', this._updateScrollPosition);
	    _app_dispatcher2.default.register('select-panel', this.debouncedResize);
	    _app_dispatcher2.default.register('left-column-width-updated', this.debouncedResize);
	    _app_dispatcher2.default.register('right-column-width-updated', this.debouncedResize);
	    _app_dispatcher2.default.register('scroll-down-on-zoom', this._onZoom); // for Mac App
	    _preferences_store2.default.on(PREFS_CHANGE_KEYS, this._prefsChanged);
	    this._handleScrollPosition();
	    this._handleFrozenScroll();
	    _.forEach(['click', 'mousewheel', 'DOMMouseScroll'], function (event) {
	      _this.scrollbox.addEventListener(event, _this.debouncedOnUserAction);
	    });
	
	    $(window).on('resize', this.debouncedResize);
	    $(document).on('keydown', this.debouncedKeyDown);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var _this2 = this;
	
	    _chat_window_actions2.default.setScrollValue({
	      scrollTop: ReactDOM.findDOMNode(this).scrollTop,
	      should_scroll_to_bottom: this.props.chat.should_scroll_to_bottom,
	      isScrolledToBottom: this._isScrolledToBottom(),
	      jid: this.props.chat.jid
	    });
	    _app_dispatcher2.default.unregister('add-chat-state-message', this._changeChatStateMessage);
	    _app_dispatcher2.default.unregister('remove-chat-state-message', this._changeChatStateMessage);
	    _app_dispatcher2.default.unregister('preserve-scroll-value', this._throttledShouldSetScroll);
	    _app_dispatcher2.default.unregister('update-scroll-position', this._updateScrollPosition);
	    _app_dispatcher2.default.unregister('select-panel', this.debouncedResize);
	    _app_dispatcher2.default.unregister('left-column-width-updated', this.debouncedResize);
	    _app_dispatcher2.default.unregister('right-column-width-updated', this.debouncedResize);
	    _app_dispatcher2.default.unregister('scroll-down-on-zoom', this._onZoom);
	    _preferences_store2.default.off(PREFS_CHANGE_KEYS, this._prefsChanged);
	    _chat_window_actions2.default.chatStoppedScroll(this.props.chat.jid);
	    _.forEach(['click', 'mousewheel', 'DOMMouseScroll'], function (event) {
	      _this2.scrollbox.removeEventListener(event, _this2.debouncedOnUserAction);
	    });
	    $(window).off('resize', this.debouncedResize);
	    $(document).off('keydown', this.debouncedKeyDown);
	    if (this.imageLoad) {
	      clearTimeout(this.imageLoad);
	    }
	    this.debouncedUnfreezeAbove.cancel();
	    this.debouncedUnfreezeBelow.cancel();
	    this.debouncedFreezeAbove.cancel();
	    this.debouncedFreezeBelow.cancel();
	    this.debouncedResize.cancel();
	    this.debouncedOnUserAction.cancel();
	    this.throttledSetScrollPosition.cancel();
	    this._unbindScroll();
	    clearTimeout(this.imageLoadTimeout);
	  },
	  _onKeyDown: function _onKeyDown(e) {
	    if (this.is_scrolling || this.props.chat.scroll_frozen) {
	      return;
	    }
	
	    var node = this.scrollbox,
	        delta = void 0;
	
	    if (e.keyCode === _utils2.default.keyCode.PageUp && node.scrollTop > 0) {
	      delta = -node.offsetHeight;
	    }
	
	    if (e.keyCode === _utils2.default.keyCode.PageDown && node.scrollHeight > node.scrollTop + node.offsetHeight) {
	      delta = node.offsetHeight;
	    }
	    // Home and End buttons should be Mac specific features
	    if (_utils2.default.platform.isMac()) {
	      if (e.keyCode === _utils2.default.keyCode.Home && node.scrollTop > 0) {
	        delta = -node.scrollTop;
	      }
	
	      if (e.keyCode === _utils2.default.keyCode.End && node.scrollHeight > node.scrollTop + node.offsetHeight) {
	        delta = node.scrollHeight - node.offsetHeight - node.scrollTop;
	      }
	    }
	
	    if (delta) {
	      this._animationPromise(delta);
	    }
	  },
	  _animationPromise: function _animationPromise(delta) {
	    var _this3 = this;
	
	    _logger2.default.type('animate-scroll-position').log('delta:', delta);
	    var node = this.scrollbox;
	
	    return new _promise2.default(function (resolve) {
	      _this3._unbindScroll();
	      var duration = _app_config2.default.chat_scroll_duration,
	          originalScollTop = node.scrollTop,
	          start = void 0,
	          incrementValue = void 0;
	
	      _this3.interruptAutoscroll();
	      _this3.is_animating = true;
	
	      var step = function step(timestamp) {
	        if (!start) {
	          start = timestamp;
	        }
	        var progress = Math.floor(timestamp - start);
	        if (progress <= duration) {
	          incrementValue = Math.cos(Math.PI * progress / duration - Math.PI) + 1;
	          node.scrollTop = originalScollTop + delta / 2 * incrementValue;
	          requestAnimationFrame(step);
	        } else {
	          _this3.should_interrupt_autoscroll = false;
	          _this3.is_animating = false;
	          resolve();
	        }
	      };
	      requestAnimationFrame(step);
	    }).then(function () {
	      _this3._checkScrollForHistoryFetch();
	      _this3._checkScrollForScrolledToBottom();
	      _this3._setScrollPosition();
	      _.debounce(_this3._bindScroll, 300, { leading: false, trailing: true });
	    });
	  },
	  _handleFrozenScroll: function _handleFrozenScroll() {
	    if (this.props.chat.scroll_frozen && this.props.chat.oldest_mid_before_fetch && !this.props.chat.scrollTop) {
	
	      this.props.chat.scroll_frozen = false;
	      this.state.has_scrolled_initial = true;
	
	      var row = $('[data-mid=' + this.props.chat.oldest_mid_before_fetch + ']').parents('.hc-chat-row')[0];
	      if (row) {
	        var node = ReactDOM.findDOMNode(this),
	            scrollWrap = $(node).find('.scroll-wrap')[0];
	        this.props.chat.scrollTop = row.getBoundingClientRect().top - scrollWrap.getBoundingClientRect().top - _app_config2.default.frozen_scroll_offset;
	        _logger2.default.type('message-list').log('Scroll to oldest element before fetch. mid:', this.props.chat.oldest_mid_before_fetch, this.props.chat.scrollTop);
	      }
	    }
	  },
	  _prefsChanged: function _prefsChanged() {
	    this.setState({
	      shouldHideGifs: _preferences_store2.default.shouldHideGifsByDefault(),
	      shouldHideAttachedCards: _preferences_store2.default.shouldHideAttachedCardsByDefault(),
	      chat_view: _preferences_store2.default.getChatView(),
	      show_join_leave_messages: !_preferences_store2.default.getHidePresenceMessages(),
	      should_animate_avatar: _preferences_store2.default.shouldAnimateAvatars(),
	      use24hrTime: _preferences_store2.default.shouldUse24HrTime(),
	      nameDisplay: _preferences_store2.default.getNameDisplay()
	    });
	  },
	  _handleScrollPosition: function _handleScrollPosition() {
	    if (this.isMounted()) {
	      if (!this.is_scrolling && !this.is_animating) {
	        if (this.props.chat.should_scroll_to_bottom) {
	          this._scrollToWithoutTrigger();
	        } else {
	          this._setScroll();
	          this._bindScroll();
	        }
	      }
	    }
	  },
	  _onResize: function _onResize() {
	    if (!this.is_scrolling && !this.is_animating) {
	      if (!this._isScrolledToBottom()) {
	        this._scrollToWithoutTrigger();
	      } else {
	        this._setScroll();
	        this._bindScroll();
	      }
	    } else {
	      this._onZoom();
	    }
	  },
	  _onZoom: function _onZoom() {
	    this.is_scrolling = false;
	    this._scrollToWithoutTrigger();
	  },
	  _getFirstName: function _getFirstName() {
	    if (this.props.chat.name) {
	      return this.props.chat.name.split(' ')[0];
	    }
	  },
	  render: function render() {
	    var composingMessageClasses = (0, _classnames2.default)({
	      'hidden': !this.props.chat.is_composing,
	      'hc-composing-message': true,
	      'hc-classic-neue': this.state.chat_view === "classic_neue"
	    }),
	        showSpinner = _.isEmpty(this.props.chat.messages) && this.props.chat.fetching_ancient,
	        historySpinner = this.props.chat.ancient_history_is_empty ? false : this._getHistorySpinner(),
	        showEmptyState = (this.props.chat.has_no_message_history || !_.isEmpty(this.props.chat.messages) && _.every(this.props.chat.messages, 'is_presence_message') && !this.state.show_join_leave_messages) && !this.props.chat.has_been_cleared,
	        panel = void 0;
	
	    if (showSpinner) {
	      panel = React.createElement(
	        'div',
	        { className: 'spinwrap' },
	        React.createElement(_spinner2.default, { spin: true, spinner_class: 'hc-loading-spinner medium-spinner' })
	      );
	    } else if (showEmptyState) {
	      panel = React.createElement(_empty_state2.default, { jid: this.props.chat.jid,
	        type: this.props.chat.type,
	        chatName: this.props.chat.name,
	        firstName: this._getFirstName(),
	        web_server: this.props.web_server });
	    } else {
	      panel = React.createElement(
	        'div',
	        { className: 'scroll-wrap' },
	        historySpinner,
	        React.createElement(_messages2.default, {
	          messages: this.props.chat.messages,
	          show_join_leave_messages: this.state.show_join_leave_messages,
	          should_animate_avatar: this.state.should_animate_avatar,
	          shouldHideGifs: this.state.shouldHideGifs,
	          shouldHideAttachedCards: this.state.shouldHideAttachedCards,
	          use24hrTime: this.state.use24hrTime,
	          showUnreadDivider: this.state.showUnreadDivider,
	          nameDisplay: this.state.nameDisplay,
	          chat_view: this.state.chat_view,
	          chat_type: this.props.chat.type,
	          chat_id: this.props.chat.id,
	          is_guest: this.props.is_guest,
	          integrationsEnabled: _integrations_store2.default.get("enabled"),
	          addon_avatars: this.props.addon_avatars }),
	        React.createElement(
	          'div',
	          { className: composingMessageClasses, ref: 'composing_msg' },
	          this.props.chat.name + ' is typing...'
	        )
	      );
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-chat-scrollbox message-list', ref: 'scrollbox' },
	      panel
	    );
	  },
	  _getHistorySpinner: function _getHistorySpinner() {
	    return React.createElement(
	      'div',
	      { style: { display: 'none' }, ref: 'historySpinnerWrapper' },
	      React.createElement(_history_spinner2.default, null)
	    );
	  },
	  _checkScrollForHistoryFetch: function _checkScrollForHistoryFetch() {
	    if (!this.props.chat.ancient_history_is_empty && ReactDOM.findDOMNode(this).scrollTop <= 0 && !this.props.is_guest && !this.props.chat.has_been_cleared) {
	      this.fetchHistory();
	      return true;
	    }
	  },
	  _checkScrollForScrolledToBottom: function _checkScrollForScrolledToBottom() {
	    this.props.chat.should_scroll_to_bottom = this._isScrolledToBottom();
	  },
	  _isScrolledToBottom: function _isScrolledToBottom() {
	    var node = ReactDOM.findDOMNode(this);
	    var scrollPosition = node.scrollTop + node.offsetHeight;
	    return node.scrollHeight > scrollPosition - _app_config2.default.scroll_to_bottom_offset && node.scrollHeight < scrollPosition + _app_config2.default.scroll_to_bottom_offset;
	  },
	  _updateScrollPosition: function _updateScrollPosition(data) {
	    if (!this.props.chat.should_scroll_to_bottom && this.props.chat.scrollTop > data.offsetTop) {
	      this.$scrollbox.data('skipScrollStartEvent', true);
	      this.props.chat.scrollTop += data.heightDiff;
	    }
	  },
	  _setScrollPosition: function _setScrollPosition() {
	    if (!this.props.chat.message_action_active) {
	      this._checkScrollForScrolledToBottom();
	    }
	
	    var node = ReactDOM.findDOMNode(this),
	        scrollVal = this.props.chat.should_scroll_to_bottom ? node.scrollHeight : node.scrollTop;
	    if (!this.is_animating && !this.props.chat.scroll_frozen && this.state.has_scrolled_initial) {
	      _chat_window_actions2.default.setScrollValue({
	        scrollTop: scrollVal,
	        isScrolledToBottom: this._isScrolledToBottom(),
	        oldestVisibleMessageMid: this._getOldestVisibleMessageMid(),
	        should_scroll_to_bottom: this.props.chat.should_scroll_to_bottom,
	        jid: this.props.chat.jid
	      });
	    }
	  },
	  _getOldestVisibleMessageMid: function _getOldestVisibleMessageMid() {
	    return $(".msg-line:visible:first").data("mid");
	  },
	  _maintainScrollPosition: function _maintainScrollPosition(action, position, should_scroll_to_bottom) {
	    if (!this.isMounted()) {
	      return;
	    } else if (should_scroll_to_bottom && action === 'unfreeze') {
	      this._unbindScroll();
	      $(ReactDOM.findDOMNode(this)).find('.scroll-wrap').css({
	        position: 'relative',
	        bottom: '',
	        top: ''
	      }).parent('.message-list').css({
	        overflowY: 'auto'
	      });
	      this._scrollToWithoutTrigger();
	      this.props.chat.scroll_frozen = false;
	      return;
	    }
	    var node = ReactDOM.findDOMNode(this);
	    this._unbindScroll();
	    var top,
	        scrollWrap = $(node).find('.scroll-wrap')[0],
	        bottom = scrollWrap.getBoundingClientRect().bottom - node.getBoundingClientRect().bottom;
	    switch (action) {
	      case 'freeze':
	        if (!this.props.chat.scroll_frozen) {
	          this.$scrollbox.off('scrollstart');
	          this.$scrollbox.off('scrollstop');
	          this.props.chat.scroll_frozen = true;
	          top = node.getBoundingClientRect().top - scrollWrap.getBoundingClientRect().top;
	          switch (position) {
	            case 'above':
	              node.scrollTop = 0;
	              $(scrollWrap).css({
	                position: 'absolute',
	                top: '',
	                bottom: -bottom
	              }).parent('.message-list').css({
	                overflowY: 'hidden'
	              });
	              break;
	            case 'below':
	              node.scrollTop = 0;
	              $(scrollWrap).css({
	                position: 'absolute',
	                top: -top,
	                bottom: ''
	              }).parent('.message-list').css({
	                overflowY: 'hidden'
	              });
	              break;
	          }
	        }
	        break;
	      case 'unfreeze':
	        if (this.props.chat.scroll_frozen && !this.props.chat.fetching_ancient) {
	          $(ReactDOM.findDOMNode(this.refs.historySpinnerWrapper)).hide();
	          this.props.chat.scroll_frozen = false;
	          top = scrollWrap.getBoundingClientRect().top - node.getBoundingClientRect().top;
	          $(scrollWrap).css({
	            position: 'relative',
	            bottom: '',
	            top: ''
	          }).parent('.message-list').css({
	            overflowY: 'auto'
	          });
	          this._checkScrollForScrolledToBottom();
	          this._scrollToWithoutTrigger(-top);
	          this.props.chat.scrollTop = -top;
	          this._bindScroll();
	        }
	        break;
	    }
	  },
	  _createDebounced: function _createDebounced() {
	    function unfreezeAbove() {
	      this._maintainScrollPosition('unfreeze', 'above', this.props.chat.should_scroll_to_bottom);
	    }
	    function unfreezeBelow() {
	      this._maintainScrollPosition('unfreeze', 'below', this.props.chat.should_scroll_to_bottom);
	    }
	    function freezeAbove() {
	      this._maintainScrollPosition('freeze', 'above', this.props.chat.should_scroll_to_bottom);
	    }
	    function freezeBelow() {
	      this._maintainScrollPosition('freeze', 'below', this.props.chat.should_scroll_to_bottom);
	    }
	    this.debouncedBindScroll = _.debounce(this._bindScroll, 300, { 'leading': false, 'trailing': true });
	    this.debouncedUnfreezeAbove = _.debounce(unfreezeAbove, 600, { 'leading': false, 'trailing': true });
	    this.debouncedUnfreezeBelow = _.debounce(unfreezeBelow, 600, { 'leading': false, 'trailing': true });
	    this.debouncedFreezeAbove = _.debounce(freezeAbove, 500, { 'leading': true, 'trailing': false });
	    this.debouncedFreezeBelow = _.debounce(freezeBelow, 500, { 'leading': true, 'trailing': false });
	    this.debouncedResize = _.debounce(this._onResize, 200, { leading: false, trailing: true });
	    this.debouncedKeyDown = _.debounce(this._onKeyDown, 20, { leading: true, trailing: false });
	    this.throttledSetScrollPosition = _.throttle(this._setScrollPosition, 50, { leading: false, trailing: true });
	    this.debouncedOnUserAction = _.throttle(this._onUserAction, 200, { leading: true, trailing: true });
	    this.initialized = true;
	  },
	  _shouldSetScroll: function _shouldSetScroll() {
	    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    if (this.isMounted() && !this.is_scrolling && !this.props.chat.scroll_frozen && !this._isHistoryEmpty() && !this.will_freeze && this.props.chat.should_scroll_to_bottom && !this._isScrolledToBottom()) {
	      this._setScroll(opts);
	    }
	  },
	  _isHistoryEmpty: function _isHistoryEmpty() {
	    return this.props.chat.ancient_history_is_empty && this.props.chat.messages.length === 0;
	  },
	  _setScroll: function _setScroll() {
	    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var node = ReactDOM.findDOMNode(this);
	    if (!this.is_scrolling) {
	      if (!this.props.chat.scroll_frozen && !this.is_animating && !this.props.chat.message_action_active) {
	        if (this.props.chat.should_scroll_to_bottom) {
	          if (this.state.has_scrolled_initial && opts.animation) {
	            this._animateScroll();
	          } else {
	            this._scrollToWithoutTrigger();
	            if (!this.state.has_scrolled_initial) {
	              this.state.has_scrolled_initial = true;
	              this._setScrollPosition();
	            }
	          }
	        } else {
	          this._bindScroll();
	          if (!this.state.has_scrolled_initial) {
	            this.state.has_scrolled_initial = true;
	          }
	          node.scrollTop = this.props.chat.scrollTop;
	          this._setScrollPosition();
	        }
	      }
	    }
	  },
	  _animateScroll: function _animateScroll(val) {
	    var _this4 = this;
	
	    var node = ReactDOM.findDOMNode(this);
	    if (val || this.scrollbox.scrollHeight - node.offsetHeight - node.scrollTop > 2) {
	      var promise = new _promise2.default(function (resolve) {
	        _this4._unbindScroll();
	        var duration = _app_config2.default.chat_scroll_duration,
	            scrollTo = (val || _this4.scrollbox.scrollHeight) - node.offsetHeight;
	        _this4.interruptAutoscroll();
	        var originalScollTop = node.scrollTop,
	            delta = scrollTo - originalScollTop,
	            count = 0,
	            start,
	            incrementValue;
	        _this4.is_animating = true;
	        var step = function step(timestamp) {
	          if (!start) {
	            start = timestamp;
	          }
	          var progress = timestamp - start;
	          if (progress < duration && !_this4.should_interrupt_autoscroll) {
	            count = count + 1;
	            //Ease-in-out trig function here
	            incrementValue = Math.cos(Math.PI * progress / duration - Math.PI) + 1;
	            node.scrollTop = originalScollTop + delta / 2 * incrementValue;
	            requestAnimationFrame(step);
	          } else {
	            if (!_this4.should_interrupt_autoscroll && _this4.props.chat.should_scroll_to_bottom) {
	              _this4._scrollToWithoutTrigger();
	            }
	            _this4.should_interrupt_autoscroll = false;
	            node.scrollTop = node.scrollHeight;
	            _this4.props.chat.should_scroll_to_bottom = true;
	            _this4.is_animating = false;
	            resolve();
	          }
	        };
	        requestAnimationFrame(step);
	      });
	      promise.then(function () {
	        _.debounce(_this4._bindScroll, 300, { leading: false, trailing: true });
	      });
	    }
	  },
	  _changeChatStateMessage: function _changeChatStateMessage(data) {
	    if (this.props.chat.should_scroll_to_bottom && this.props.chat.jid === data.jid && this.props.chat.is_composing) {
	      var composing_height = ReactDOM.findDOMNode(this).getBoundingClientRect().bottom - ReactDOM.findDOMNode(this.refs.composing_msg).getBoundingClientRect().top;
	      if (composing_height) {
	        this._animateScroll(ReactDOM.findDOMNode(this).scrollHeight - composing_height);
	      }
	    }
	  },
	  _scrollToWithoutTrigger: function _scrollToWithoutTrigger(val) {
	    var _this5 = this;
	
	    if (!this.is_scrolling) {
	      this._unbindScroll();
	      try {
	        var node = ReactDOM.findDOMNode(this);
	        node.scrollTop = val || node.scrollHeight;
	        this.props.chat.scrollTop = node.scrollTop;
	
	        if (!val) {
	          this.props.chat.should_scroll_to_bottom = true;
	          this.props.chat.isScrolledToBottom = true;
	        }
	
	        this.$scrollbox.bind('scroll.resolver', function () {
	          _this5.$scrollbox.unbind('scroll.resolver');
	        });
	      } finally {
	        this.debouncedBindScroll();
	      }
	    }
	  },
	  interruptAutoscroll: function interruptAutoscroll() {
	    if (this.is_animating) {
	      this.should_interrupt_autoscroll = true;
	    }
	  },
	  _onUserAction: function _onUserAction() {
	    this.should_interrupt_autoscroll = true;
	    this._bindScroll();
	  },
	  fetchHistory: function fetchHistory() {
	    var _this6 = this;
	
	    if (!this.props.chat.ancient_history_is_empty) {
	      this._unbindScroll();
	      var spinWrap = ReactDOM.findDOMNode(this.refs.historySpinnerWrapper);
	      this.props.chat.should_scroll_to_bottom = false;
	      this.props.chat.scrollTop = 0;
	      this.should_interrupt_autoscroll = true;
	      this.will_freeze = true;
	      _chat_window_actions2.default.requestAncientHistory({
	        jid: this.props.chat.jid
	      });
	      $(spinWrap).slideDown(200, function () {
	        if (!_this6.props.chat.ancient_history_is_empty) {
	          _this6.will_freeze = false;
	          _this6.debouncedFreezeAbove();
	        }
	      });
	    }
	  },
	  _chatIsScrolling: function _chatIsScrolling() {
	    _chat_window_actions2.default.chatStartedScroll(this.props.chat.jid);
	    this.is_scrolling = true;
	  },
	  _scrollStop: function _scrollStop() {
	    _logger2.default.type('message-list').log('Scroll stop');
	    this.should_interrupt_autoscroll = false;
	    this.is_animating = false;
	    this.is_scrolling = false;
	    _chat_window_actions2.default.chatStoppedScroll(this.props.chat.jid);
	    this._checkScrollForHistoryFetch();
	    this._checkScrollForScrolledToBottom();
	    this._setScrollPosition();
	  },
	  _unbindScroll: function _unbindScroll() {
	    this.$scrollbox.unbind('scroll.resolver');
	    if (this.scroll_is_bound) {
	      this.$scrollbox.off();
	      this.is_scrolling = false;
	      this.scroll_is_bound = false;
	    }
	  },
	  _bindScroll: function _bindScroll() {
	    if (!this.scroll_is_bound) {
	      _logger2.default.type('message-list').log('Bind scroll');
	      this.$scrollbox.on('scrollstart', this._chatIsScrolling);
	      this.$scrollbox.on('scrollstop', this._scrollStop);
	      this.$scrollbox.on('scroll', this.throttledSetScrollPosition);
	      this.scroll_is_bound = true;
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ChatWindowEmptyState",
	
	  propTypes: {
	    chatName: React.PropTypes.string,
	    firstName: React.PropTypes.string,
	    type: React.PropTypes.string,
	    jid: React.PropTypes.string,
	    web_server: React.PropTypes.string
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      chatName: "",
	      firstName: "",
	      jid: "",
	      web_server: "",
	      type: ""
	    };
	  },
	
	  _getEmptyState: function _getEmptyState() {
	    var emptyState;
	    if (this.props.type === "chat") {
	      emptyState = this._getOTOEmptyState();
	    } else {
	      emptyState = this._getGroupChatEmptyState();
	    }
	    return emptyState;
	  },
	
	  _getGroupChatEmptyState: function _getGroupChatEmptyState() {
	    return React.createElement(
	      "div",
	      { ref: "empty_state", className: "empty-state groupchat" },
	      React.createElement("div", { className: "empty-state-img" }),
	      React.createElement(
	        "div",
	        { className: "empty-state-msg" },
	        React.createElement(
	          "p",
	          { className: "empty-header" },
	          "Welcome to the ",
	          this.props.chatName,
	          " room!"
	        ),
	        React.createElement(
	          "p",
	          { className: "empty-msg" },
	          "This window is kinda empty, huh? It fills up fast when you",
	          React.createElement("br", null),
	          "start chatting with your friends. Happy chatting!"
	        )
	      )
	    );
	  },
	
	  _getOTOEmptyState: function _getOTOEmptyState() {
	    return React.createElement(
	      "div",
	      { ref: "empty_state", className: "empty-state chat" },
	      React.createElement("div", { className: "empty-state-img" }),
	      React.createElement(
	        "div",
	        { className: "empty-state-msg" },
	        React.createElement(
	          "p",
	          { className: "empty-header" },
	          "Say Hello to ",
	          this.props.chatName,
	          "!"
	        ),
	        React.createElement(
	          "p",
	          { className: "empty-msg" },
	          "You haven't talked to ",
	          this.props.firstName,
	          " before. Why not break the ice with",
	          React.createElement("br", null),
	          "an emoticon? (fonzie) ",
	          React.createElement("img", { src: "https://" + this.props.web_server + "/wc/assets/img/embedded/fonzie@3x.png", width: "34", height: "25" })
	        )
	      )
	    );
	  },
	
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "empty" },
	      this._getEmptyState()
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 569 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
	  var dispatch = $.event.dispatch || $.event.handle;
	
	  var special = $.event.special,
	      uid1 = 'D' + +new Date(),
	      uid2 = 'D' + (+new Date() + 1);
	
	  special.scrollstart = {
	
	    setup: function setup(data) {
	      var _this = this;
	
	      var _data = $.extend({
	        latency: special.scrollstop.latency
	      }, data);
	
	      var handler = function (evt) {
	        var _self = this;
	        evt.type = 'scrollstart';
	
	        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }
	
	        dispatch.apply(_self, [evt].concat(args));
	      }.bind(this);
	
	      var debouncedHandler = _.debounce(handler, _data.latency, { leading: true, trailing: false });
	
	      $(this).on('scroll', function (evt) {
	        if (!$(_this).data('skipScrollStartEvent')) {
	          debouncedHandler(evt);
	        } else {
	          $(_this).data('skipScrollStartEvent', false);
	        }
	      }).data(uid1, debouncedHandler);
	    },
	
	    teardown: function teardown() {
	      $(this).data(uid1).cancel();
	      $(this).off('scroll', $(this).data(uid1));
	      $(this).removeData(uid1);
	    }
	  };
	
	  special.scrollstop = {
	
	    latency: 250,
	
	    setup: function setup(data) {
	
	      var _data = $.extend({
	        latency: special.scrollstop.latency
	      }, data);
	
	      var handler = _.debounce(function (evt) {
	        var _self = this,
	            _args = arguments;
	        evt.type = 'scrollstop';
	        dispatch.apply(_self, _args);
	        $(this).data('skipScrollStartEvent', false);
	      }.bind(this), _data.latency, { leading: false, trailing: true });
	
	      $(this).on('scroll', handler).data(uid2, handler);
	    },
	
	    teardown: function teardown() {
	      $(this).data(uid2).cancel();
	      $(this).off('scroll', $(this).data(uid2));
	      $(this).removeData(uid2);
	    }
	  };
	};

/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	  displayName: "HistorySpinner",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return {
	      history_loading: false
	    };
	  },
	  componentDidMount: function componentDidMount() {
	
	    _app_dispatcher2.default.register({
	      'requesting-ancient-history': this._requestingAncientHistory,
	      'ancient-history-fetched': this._ancientHistoryFetched
	    });
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _app_dispatcher2.default.unregister({
	      'requesting-ancient-history': this._requestingAncientHistory,
	      'ancient-history-fetched': this._ancientHistoryFetched
	    });
	  },
	  _requestingAncientHistory: function _requestingAncientHistory() {
	    this.setState({
	      history_loading: true
	    });
	  },
	  _ancientHistoryFetched: function _ancientHistoryFetched() {
	    this.setState({
	      history_loading: false
	    });
	  },
	  render: function render() {
	    return React.createElement(_spinner2.default, { spin: this.state.history_loading,
	      spinner_class: 'hc-chat-spinner medium-spinner' });
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.doSendersMatch = doSendersMatch;
	exports.shouldGroupMessage = shouldGroupMessage;
	exports.shouldAttachMessage = shouldAttachMessage;
	exports.groupByDate = groupByDate;
	exports.groupNearbyMessages = groupNearbyMessages;
	exports.groupContainsLastRead = groupContainsLastRead;
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _card_helper = __webpack_require__(572);
	
	var _card_helper2 = _interopRequireDefault(_card_helper);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _message_group = __webpack_require__(573);
	
	var _message_group2 = _interopRequireDefault(_message_group);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PureRenderMixin = React.addons.PureRenderMixin;
	
	var nonGroupingTypes = ['notification', 'twitter_user', 'twitter_status', 'info'];
	
	/**
	 * Checks to see if two messages have the same sender by checking sender_id or
	 * sender. sender_id could be null in old btf servers
	 *
	 * @param {Object} message1
	 * @param {Object} message2
	 * @returns boolean
	 */
	function doSendersMatch(message1, message2) {
	  if (message1.sender_id || message2.sender_id) {
	    return message1.sender_id === message2.sender_id;
	  }
	  return message1.sender === message2.sender;
	}
	
	/**
	 * Determines if the current message should be grouped with the previous message
	 *
	 * @param {Object} the first message object in the group
	 * @param {Object} the previous message object
	 * @param {Object} the current message object
	 *
	 * @returns Boolean
	 */
	function shouldGroupMessage(firstInGroup, previousMsg, message) {
	  return doSendersMatch(firstInGroup, message) && message.time - previousMsg.time <= 300 && firstInGroup.color === message.color && !previousMsg.last_read_message && ! ~nonGroupingTypes.indexOf(message.type) && ! ~nonGroupingTypes.indexOf(firstInGroup.type) && message.status !== 'failed' && previousMsg.status !== 'failed' && (message.type !== 'image' || message.type === 'image' && firstInGroup.type === 'image' && _utils2.default.getRealMid(firstInGroup.mid) === _utils2.default.getRealMid(message.mid));
	}
	
	/**
	 * Determines if the current message should be attached to the previous message
	 *
	 * @param {Boolean} whether card attachment is enabled
	 * @param {Object} the previous message object
	 * @param {Object} the current message object
	 *
	 * @returns Boolean
	 */
	function shouldAttachMessage(attachEnabled, previousMsg, message) {
	  var previousMidToAttach = _utils2.default.getAttachToMid(previousMsg) || previousMsg.mid,
	      msgMidToAttachTo = _utils2.default.getAttachToMid(message);
	
	  return attachEnabled && _card_helper2.default.isValidCard(message.card) && previousMidToAttach === msgMidToAttachTo;
	}
	
	/*
	 * Split single message array into array of message groups grouped by date.
	 *
	 * @param {Object[]} messages array of messages
	 *
	 * @returns {{date: string, messages: Object[]}[]} array of message groups
	 */
	function groupByDate(messages) {
	  var result = [],
	      lastDate = null,
	      group = null;
	
	  messages.forEach(function (message) {
	    var currentDate = _utils2.default.format_time_for_separator(message.sortTime || message.time);
	
	    if (lastDate === null || lastDate !== currentDate) {
	      lastDate = currentDate;
	      group = {
	        date: currentDate,
	        messages: [message]
	      };
	      result.push(group);
	    } else {
	      group.messages.push(message);
	    }
	  });
	
	  return result;
	}
	
	/*
	 * Split single message array into array of message groups.
	 *
	 * @param {Object[]} messages array of messages
	 * @param feature_flags the configured feature flags
	 *
	 * @returns {{key: string, messages: Object[]}[]} array of message groups
	 */
	function groupNearbyMessages(messages) {
	  var attach_enabled = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  var result = [],
	      firstInGroupMsg = null,
	      group = null;
	
	  messages.forEach(function (msg, i) {
	    if (firstInGroupMsg === null || !(shouldGroupMessage(firstInGroupMsg, messages[i - 1], msg) || shouldAttachMessage(attach_enabled, messages[i - 1], msg))) {
	      firstInGroupMsg = msg;
	      group = {
	        key: 'msg-group-' + msg.mid,
	        messages: [msg]
	      };
	      result.push(group);
	    } else {
	      group.messages.push(msg);
	    }
	  });
	
	  return result;
	}
	
	/**
	 * Determines if any of the messages in the group are the last read message
	 * used for styling the message group
	 *
	 * @param {Object} a message group object with an array of message objects
	 *
	 * @returns Boolean
	 */
	function groupContainsLastRead(group) {
	  return !! ~_.findLastIndex(group.messages, { last_read_message: true });
	}
	
	exports.default = React.createClass({
	  displayName: 'ChatWindowMessages',
	
	  // messages are immutable
	  // addons_avatars is also immutable object (we create new instance each time)
	  // other props are primitives
	  // so we can use PureRenderMixin here
	  mixins: [PureRenderMixin],
	
	  renderMessageGroup: function renderMessageGroup(group) {
	    var props = this.props;
	    var lastReadGroup = groupContainsLastRead(group);
	    var attachedCardsToggleEnabled = _.get(this.feature_flags, 'web_client_attach_to_collapsable_enabled');
	    return React.createElement(_message_group2.default, {
	      group: group,
	      key: group.key,
	      shouldHideGifs: props.shouldHideGifs,
	      shouldHideAttachedCards: props.shouldHideAttachedCards,
	      should_animate_avatar: props.should_animate_avatar,
	      attachedCardsToggleEnabled: attachedCardsToggleEnabled,
	      use24hrTime: props.use24hrTime,
	      shouldShowLastViewed: props.showUnreadDivider,
	      lastReadGroup: lastReadGroup,
	      nameDisplay: props.nameDisplay,
	      chat_view: props.chat_view,
	      chat_type: props.chat_type,
	      chat_id: props.chat_id,
	      is_guest: props.is_guest,
	      integrationsEnabled: props.integrationsEnabled,
	      addon_avatars: props.addon_avatars,
	      honest_messages_enabled: this.feature_flags.web_client_honest_messages,
	      message_editing_enabled: this.feature_flags.web_client_message_editing });
	  },
	  componentWillMount: function componentWillMount() {
	    this.feature_flags = _configuration_store2.default.get('feature_flags');
	    _app_dispatcher2.default.register('updated:config', this._updateConfig);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _app_dispatcher2.default.unregister('updated:config', this._updateConfig);
	  },
	  renderDateMessages: function renderDateMessages(_ref) {
	    var date = _ref.date;
	    var messages = _ref.messages;
	
	    var attach_enabled = _.get(this.feature_flags, 'web_client_attach_to_rendering_enabled') && _card_helper2.default.cardsEnabled(this.feature_flags);
	    var groupedMessages = groupNearbyMessages(messages, attach_enabled);
	
	    return React.createElement(
	      'div',
	      { className: 'date-block', key: date.replace(/\s/g, '') },
	      React.createElement(
	        'div',
	        { className: 'date-divider', 'data-copyable': '{"format": "date-divider"}' },
	        React.createElement(
	          'span',
	          null,
	          date
	        )
	      ),
	      groupedMessages.map(this.renderMessageGroup)
	    );
	  },
	  render: function render() {
	    var messages = this.props.messages;
	
	    if (!this.props.show_join_leave_messages) {
	      messages = messages.filter(function (msg) {
	        return !msg.is_presence_message;
	      });
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'hc-messages' },
	      groupByDate(messages).map(this.renderDateMessages)
	    );
	  },
	  _updateConfig: function _updateConfig(config) {
	    this.feature_flags = _.get(config, 'feature_flags');
	  }
	});

/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _set = __webpack_require__(525);
	
	var _set2 = _interopRequireDefault(_set);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = __webpack_require__(90);
	
	var validTypes = new _set2.default(['link', 'media', 'file', 'image', 'application']);
	
	var CardHelper = {
	
	  cardsEnabled: function cardsEnabled(feature_flags) {
	    return feature_flags && feature_flags.web_client_cards_enabled;
	  },
	
	  isValidStyle: function isValidStyle(card) {
	    return card && validTypes.has(card.style);
	  },
	
	  isLink: function isLink(card) {
	    return card && card.style === 'link';
	  },
	
	  isMedia: function isMedia(card) {
	    return card && card.style === 'media';
	  },
	
	  isFile: function isFile(card) {
	    return card && card.style === 'file';
	  },
	
	  isImage: function isImage(card) {
	    return card && card.style === 'image';
	  },
	
	  isApplication: function isApplication(card) {
	    return card && card.style === 'application';
	  },
	
	  isValidCard: function isValidCard(card) {
	
	    if (!card) {
	      return false;
	    }
	
	    if (!CardHelper.isValidStyle(card)) {
	      return false;
	    }
	
	    if (card.id === undefined) {
	      logger.warn('Card does not have an id');
	      return false;
	    }
	
	    if (CardHelper.isLink(card)) {
	
	      if (card.title === undefined) {
	        logger.warn('Link Card needs a title');
	        return false;
	      }
	
	      if (card.description === undefined) {
	        logger.warn('Link Cards needs a description');
	        return false;
	      }
	    }
	
	    if (CardHelper.isImage(card)) {
	      if (card.url === undefined) {
	        logger.warn('Image Card does not have a url');
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	};
	
	module.exports = CardHelper;

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _card_helper = __webpack_require__(572);
	
	var _card_helper2 = _interopRequireDefault(_card_helper);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _message = __webpack_require__(447);
	
	var _message2 = _interopRequireDefault(_message);
	
	var _notification = __webpack_require__(574);
	
	var _notification2 = _interopRequireDefault(_notification);
	
	var _info = __webpack_require__(578);
	
	var _info2 = _interopRequireDefault(_info);
	
	var _file = __webpack_require__(579);
	
	var _file2 = _interopRequireDefault(_file);
	
	var _file_error = __webpack_require__(581);
	
	var _file_error2 = _interopRequireDefault(_file_error);
	
	var _link = __webpack_require__(583);
	
	var _link2 = _interopRequireDefault(_link);
	
	var _image = __webpack_require__(584);
	
	var _image2 = _interopRequireDefault(_image);
	
	var _video = __webpack_require__(587);
	
	var _video2 = _interopRequireDefault(_video);
	
	var _user_state = __webpack_require__(588);
	
	var _user_state2 = _interopRequireDefault(_user_state);
	
	var _twitter_status = __webpack_require__(589);
	
	var _twitter_status2 = _interopRequireDefault(_twitter_status);
	
	var _twitter_user = __webpack_require__(590);
	
	var _twitter_user2 = _interopRequireDefault(_twitter_user);
	
	var _wrapper = __webpack_require__(591);
	
	var _wrapper2 = _interopRequireDefault(_wrapper);
	
	var _attached_cards_toggle = __webpack_require__(597);
	
	var _attached_cards_toggle2 = _interopRequireDefault(_attached_cards_toggle);
	
	var _message_wrapper = __webpack_require__(598);
	
	var _message_wrapper2 = _interopRequireDefault(_message_wrapper);
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var message_types = {
	  message: _message2.default,
	  notification: _notification2.default,
	  info: _info2.default,
	  file: _file2.default,
	  file_error: _file_error2.default,
	  link: _link2.default,
	  image: _image2.default,
	  video: _video2.default,
	  user_state: _user_state2.default,
	  twitter_status: _twitter_status2.default,
	  twitter_user: _twitter_user2.default
	};
	
	var actionable_message_types = [_message2.default, _notification2.default, _file_error2.default, _file2.default, _image2.default];
	
	var editable_message_types = [_message2.default, _file2.default, _file_error2.default];
	
	var CSSTransitionGroup = React.addons.CSSTransitionGroup;
	
	exports.default = React.createClass({
	
	  displayName: 'ChatWindowMessageGroup',
	
	  // group is immutable
	  // addons_avatars is immutable object
	  // others are primitives
	  // so we can use DeepEqualRenderMixin
	  mixins: [_deep_equal_render_mixin2.default],
	
	  getMsg: function getMsg() {
	    return this.props.group.messages[0];
	  },
	
	
	  /**
	   * Returns true if the message type requires full messaging to user of time or status
	   * @param {object} msg
	   */
	  doesNeedFullMessaging: function doesNeedFullMessaging(msg) {
	    return !_.includes(['image', 'user_state', 'twitter_status', 'twitter_user', 'info'], msg.type);
	  },
	  getSeparator: function getSeparator(withSeparator) {
	    return withSeparator ? React.createElement(
	      'span',
	      { className: 'separator' },
	      ''
	    ) : false;
	  },
	
	
	  /**
	   * Returns the time (if applicable for this message type) wrapped in proper spans & classes
	   * and formatted to either 12 or 24 hr time based on current preference passed via props
	   * @param {boolean} withSeparator
	   */
	  _getTimeDisplay: function _getTimeDisplay(mid, withSeparator) {
	    var msg = this.getMsg(),
	        timeDisplay;
	
	    if (this.doesNeedFullMessaging(msg)) {
	      timeDisplay = React.createElement(
	        'span',
	        { className: 'hc-chat-status-time' },
	        this.getSeparator(withSeparator),
	        React.createElement(
	          'span',
	          { className: 'hc-chat-time' },
	          _utils2.default.format_time(msg.date, this.props.use24hrTime)
	        )
	      );
	    }
	
	    return timeDisplay;
	  },
	  _getEditedIndicator: function _getEditedIndicator(withSeparator) {
	    if (this.doesNeedFullMessaging(this.getMsg()) && _.some(this.props.group.messages, 'replace')) {
	      return React.createElement(
	        'span',
	        { className: 'hc-chat-status-edited' },
	        this.getSeparator(withSeparator),
	        React.createElement(
	          'span',
	          { className: 'hc-chat-edited' },
	          _chat_panel_strings2.default.edited
	        )
	      );
	    }
	  },
	
	
	  /**
	   * Returns messaging to indicate that a group of messages are unconfirmed
	   * @param {boolean} withSeparator
	   */
	  _getUnconfirmedMessaging: function _getUnconfirmedMessaging(mid, withSeparator) {
	    var msg = this.getMsg(),
	        unconfirmedMessaging;
	
	    if (this.doesNeedFullMessaging(msg)) {
	      unconfirmedMessaging = React.createElement(
	        'span',
	        { className: 'hc-chat-status-unconfirmed' },
	        this.getSeparator(withSeparator),
	        React.createElement(
	          'span',
	          { ref: 'unconfirmed_messaging', className: 'unconfirmed-messaging' },
	          _chat_panel_strings2.default.unconfirmed_message_group
	        )
	      );
	    }
	
	    return unconfirmedMessaging;
	  },
	
	
	  /**
	   * Returns messaging to indicate that a message has failed
	   * @param {boolean} withSeparator
	   */
	  _getFailedMessaging: function _getFailedMessaging(mid, withSeparator) {
	    var msg = this.getMsg(),
	        failedMessaging;
	
	    if (this.doesNeedFullMessaging(msg)) {
	      failedMessaging = React.createElement(
	        'span',
	        { className: 'hc-chat-status-failed' },
	        this.getSeparator(withSeparator),
	        React.createElement(
	          'span',
	          { ref: 'failed_messaging', className: 'failed-messaging' },
	          _chat_panel_strings2.default.failed_message
	        ),
	        React.createElement(
	          'span',
	          { ref: 'failed_message_actions', className: 'failed-message-actions' },
	          React.createElement(
	            'a',
	            { onClick: this.onFailedMessageRetryClick },
	            _chat_panel_strings2.default.failed_message_retry
	          ),
	          React.createElement(
	            'a',
	            { onClick: this.onFailedMessageCancelClick },
	            _chat_panel_strings2.default.failed_message_cancel
	          )
	        )
	      );
	    }
	
	    return failedMessaging;
	  },
	  onFailedMessageRetryClick: function onFailedMessageRetryClick() {
	    _chat_window_actions2.default.onFailedRetry(this.getMsg());
	    _analytics_actions2.default.failedMessageRetried();
	  },
	  onFailedMessageCancelClick: function onFailedMessageCancelClick() {
	    _chat_window_actions2.default.onFailedCancel(this.getMsg());
	    _analytics_actions2.default.failedMessageCanceled();
	  },
	
	
	  /**
	   * Get the appropriate sender text string. For Image/Emote messages -- defaults are applied
	   * Pass in either 'name' or 'mentions' to return
	   * @param {string} nameDisplay - either 'names' or 'mentions'
	   */
	  _getSenderText: function _getSenderText(nameDisplay) {
	    var sender_text = void 0;
	    var msg = this.getMsg();
	    if (msg.type === 'image') {
	      sender_text = 'Image';
	    } else if (msg.isEmote) {
	      sender_text = '';
	    } else if (nameDisplay === 'mentions' && msg.sender_mention) {
	      sender_text = '@' + msg.sender_mention;
	    } else {
	      sender_text = msg.sender;
	    }
	    return sender_text;
	  },
	  _getAvatarUrl: function _getAvatarUrl() {
	    var msg = this.getMsg(),
	        sender = _.get(msg, 'notification_sender');
	
	    if (_.get(sender, 'type', '') === 'addon') {
	      return _.get(this.props.addon_avatars, [sender.id, 'url']);
	    }
	
	    return msg.sender_avatar;
	  },
	
	
	  /**
	   * Get the avatar markup
	   */
	  _getAvatarDisplay: function _getAvatarDisplay(avatarClickable) {
	    var msg = this.getMsg();
	    var avatar_url = this._getAvatarUrl();
	    var hasAvatar = avatar_url && msg.type !== 'info';
	    var avatarClickHandler = avatarClickable ? this.onSenderClicked : _.noop;
	
	    if (hasAvatar) {
	      return React.createElement(_person_avatar2.default, { name: msg.sender,
	        size: 'medium',
	        avatar_url: avatar_url,
	        show_presence: false,
	        shouldAnimate: this.props.should_animate_avatar,
	        onClick: avatarClickHandler });
	    }
	
	    var sender = _.get(msg, 'notification_sender');
	    if (!this._isAddon(sender) && this._isAvatarRequired(msg)) {
	      return this._getAvatarWithInitials(msg.sender);
	    }
	
	    return false;
	  },
	  _isAddon: function _isAddon(sender) {
	    return _.get(sender, 'type', '') === 'addon';
	  },
	
	
	  /**
	   * Defines if the avatar is required
	   * @param msg
	   * @private
	   * @returns {Boolean}
	   */
	  _isAvatarRequired: function _isAvatarRequired(msg) {
	    return msg.type === 'message';
	  },
	
	
	  /**
	   * Returns avatar with initials
	   */
	  _getAvatarWithInitials: function _getAvatarWithInitials(sender) {
	    var bgColor = _app_config2.default.default_guest_avatar_bg;
	
	    return React.createElement(_person_avatar2.default, { name: sender,
	      size: 'medium',
	      avatar_bg_color: bgColor,
	      show_presence: false });
	  },
	
	
	  /**
	   * Get the sender name
	   */
	  _getSenderName: function _getSenderName(params) {
	    var msg = this.getMsg();
	    var hasSenderName = msg.type !== 'info';
	    if (hasSenderName) {
	      return React.createElement(
	        'span',
	        { ref: 'sender_text', className: 'sender-name', onClick: this.onSenderClicked, 'aria-label': params.tooltip },
	        params.sender
	      );
	    }
	  },
	
	
	  /**
	   * Generates all the common values for the message group display, then branches based
	   * on which chatView is currently applied
	   */
	  render: function render() {
	    var _cx;
	
	    var msg = this.getMsg(),
	        sender = this._getSenderText(this.props.nameDisplay),
	        tooltip = this._getSenderText(this.props.nameDisplay === 'mentions' ? 'name' : 'mentions'),
	        isUnconfirmedGroup = this.isUnconfirmedGroup(),
	        isFailedGroup = this.isFailedGroup(),
	        rowClasses = (0, _classnames2.default)((_cx = {
	      'hc-chat-row': true
	    }, (0, _defineProperty3.default)(_cx, 'hc-msg-' + msg.color + ' hc-msg-' + msg.type, !isFailedGroup), (0, _defineProperty3.default)(_cx, 'hc-classic-neue', this.isClassicNeueView()), (0, _defineProperty3.default)(_cx, 'hc-chat-row-unconfirmed', isUnconfirmedGroup), (0, _defineProperty3.default)(_cx, 'hc-chat-row-failed', isFailedGroup), (0, _defineProperty3.default)(_cx, 'unread-line-row', this.props.lastReadGroup), _cx)),
	        chatClasses = (0, _classnames2.default)({
	      'hc-chat-msg': true,
	      'image-link': msg.type === 'image'
	    });
	
	    if (this.isClassicNeueView()) {
	      return this._renderClassicNeueView({
	        rowClasses: rowClasses, chatClasses: chatClasses, sender: sender, tooltip: tooltip, isFailedGroup: isFailedGroup, isUnconfirmedGroup: isUnconfirmedGroup
	      });
	    }
	
	    return this._renderStandardView({
	      rowClasses: rowClasses, chatClasses: chatClasses, sender: sender, tooltip: tooltip, isFailedGroup: isFailedGroup, isUnconfirmedGroup: isUnconfirmedGroup
	    });
	  },
	  isClassicNeueView: function isClassicNeueView() {
	    // guest user forced to use standard view because DAL:guest-fetched-room-participants call don't return sender_avatar
	    return this.props.chat_view === 'classic_neue' && !this.props.is_guest;
	  },
	  isUnconfirmedGroup: function isUnconfirmedGroup() {
	    // A group of all unconfirmed messages renders differently than a group of messages with a mix of statuses
	    return _.every(this.props.group.messages, { status: 'unconfirmed' }) && this.props.honest_messages_enabled;
	  },
	  isFailedGroup: function isFailedGroup() {
	    // Failed messages should always be in their own group, so here we only check the first message
	    return this.getMsg().status === 'failed';
	  },
	
	
	  /**
	   * Renders the standard view for the chat messages -- that includes the
	   * sender to the left and time to the right, with the messages stacked in between
	   */
	  _renderStandardView: function _renderStandardView(params) {
	    var msg = this.getMsg(),
	        senderClasses = (0, _classnames2.default)({
	      'hc-chat-from': true,
	      'invisible': msg.type === 'user_state'
	    }),
	        failedGroupMessaging;
	
	    if (params.isFailedGroup) {
	      failedGroupMessaging = this._getFailedMessaging(msg.mid, false);
	    }
	
	    return React.createElement(
	      'div',
	      { className: params.rowClasses, ref: 'message_group_root', onClick: this._onMessageClicked },
	      React.createElement(
	        'div',
	        { className: senderClasses },
	        React.createElement(
	          'span',
	          { onClick: this.onSenderClicked, ref: 'sender_text', className: 'sender-name', 'aria-label': params.tooltip },
	          params.sender
	        )
	      ),
	      React.createElement(
	        'div',
	        { className: params.chatClasses },
	        this._renderMessages(),
	        failedGroupMessaging
	      )
	    );
	  },
	
	
	  /**
	   * Renders the 'classic_neue' view for the chat messages -- that includes
	   * the avatar on the left with the sender/time/status above the messages
	   */
	  _renderClassicNeueView: function _renderClassicNeueView(params) {
	    var msg = this.getMsg(),
	        fromAddon = _.get(msg, 'notification_sender.type', 'user') === 'addon',
	        avatar = this._getAvatarUrl(),
	        hasAvatar = avatar && msg.type !== 'info',
	        avatarClickable = hasAvatar && !fromAddon,
	        avatarClasses = (0, _classnames2.default)({
	      'hc-chat-from': true,
	      'no-action': !avatarClickable,
	      'invisible': msg.type === 'user_state'
	    }),
	        timeDisplay,
	        failedGroupMessaging,
	        unconfirmedGroupMessaging,
	        editedIndicator;
	
	    if (params.isFailedGroup) {
	      failedGroupMessaging = this._getFailedMessaging(msg.mid, true);
	    } else if (params.isUnconfirmedGroup) {
	      unconfirmedGroupMessaging = this._getUnconfirmedMessaging(msg.mid, true);
	    } else {
	      timeDisplay = this._getTimeDisplay(msg.mid, true);
	      editedIndicator = this._getEditedIndicator(true);
	    }
	
	    return React.createElement(
	      'div',
	      { className: params.rowClasses, ref: 'message_group_root', onClick: this._onMessageClicked },
	      React.createElement(
	        'div',
	        { className: avatarClasses },
	        this._getAvatarDisplay(avatarClickable)
	      ),
	      React.createElement(
	        'div',
	        { className: params.chatClasses },
	        this._getSenderName(params),
	        React.createElement(
	          CSSTransitionGroup,
	          { transitionName: 'message-confirm-state', transitionAppear: false, transitionEnterTimeout: 150, transitionLeaveTimeout: 150 },
	          unconfirmedGroupMessaging,
	          failedGroupMessaging,
	          timeDisplay,
	          editedIndicator
	        ),
	        this._renderMessages()
	      )
	    );
	  },
	
	
	  /**
	   * Renders the blue line that denotes unread messages
	   */
	  _renderBlueLine: function _renderBlueLine() {
	    if (!this.props.shouldShowLastViewed) {
	      return;
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'unread-line', key: 'unread-line-' + _.uniqueId() },
	      React.createElement('hr', null)
	    );
	  },
	
	
	  /**
	   * Renders all the messages in the group
	   */
	  _renderMessages: function _renderMessages() {
	    var _this = this;
	
	    var integrationsEnabled = this.props.integrationsEnabled;
	    var uniqueMesssages = _.uniq(this.props.group.messages);
	    var attachedCardsToggleEnabled = this.props.attachedCardsToggleEnabled;
	    var attachedTo = _.uniq(uniqueMesssages.reduce(function (current, message) {
	      if (_card_helper2.default.isValidCard(message.card)) {
	        var attachToMid = _utils2.default.getAttachToMid(message);
	        if (attachToMid) {
	          current.push(attachToMid);
	        }
	      }
	      return current;
	    }, []));
	
	    var collapsed = null;
	    var messageMarkup = [];
	
	    uniqueMesssages.forEach(function (message, index, arr) {
	      try {
	        var MessageType = message_types[message.type];
	        if (!MessageType) {
	          return undefined;
	        }
	
	        var msg = React.createElement(MessageType, {
	          key: 'msg-' + message.mid,
	          ref: 'msg_' + message.mid,
	          msg: message,
	          use24hrTime: _this.props.use24hrTime,
	          shouldHideAttachedCards: _this.props.shouldHideAttachedCards,
	          shouldHideGifs: _this.props.shouldHideGifs });
	
	        if (attachedCardsToggleEnabled && attachedTo.indexOf(message.mid) >= 0) {
	          if (_utils2.default.isAttachedCardsCollapsed(message, _this.props.shouldHideAttachedCards)) {
	            collapsed = message.mid;
	          } else {
	            collapsed = null;
	          }
	
	          var toggle = React.createElement(_attached_cards_toggle2.default, { key: message.mid,
	            mid: message.mid,
	            collapsed: !!collapsed });
	          msg = [toggle, msg];
	        } else {
	          msg = [msg];
	        }
	
	        var time = _this._getTimeDisplay(message.mid, false);
	        var editedIndicator = _this._getEditedIndicator(false);
	        // For standard view, show the time or unconfirmed status only for the top message
	        if (index === 0 && !_this.isClassicNeueView()) {
	          if (_this.isUnconfirmedGroup()) {
	            var unconfirmedGroupMessaging = _this._getUnconfirmedMessaging(message.mid, false);
	            msg.unshift(unconfirmedGroupMessaging);
	          } else if (time && !_this.isFailedGroup()) {
	            if (editedIndicator) {
	              msg.unshift(editedIndicator);
	            }
	            msg.unshift(time);
	          }
	        }
	
	        if (collapsed && _card_helper2.default.isValidCard(message.card)) {
	          var attachToMid = _utils2.default.getAttachToMid(message);
	          if (collapsed === attachToMid) {
	            return undefined;
	          }
	        }
	
	        var innerMessage = void 0,
	            isEditableType = _.includes(editable_message_types, MessageType),
	            isActionableType = _.includes(actionable_message_types, MessageType);
	        if (isActionableType && integrationsEnabled && _this.props.chat_type === 'groupchat' || isActionableType && _this.props.message_editing_enabled && _this.props.chat_type === 'chat') {
	          innerMessage = React.createElement(
	            _wrapper2.default,
	            { key: 'actionable-message-' + message.mid,
	              msg: message,
	              is_editable: isEditableType && message.sender_is_current_user && message.body !== '',
	              chat_type: _this.props.chat_type,
	              message_editing_enabled: _this.props.message_editing_enabled },
	            msg
	          );
	        } else {
	          innerMessage = msg;
	        }
	
	        messageMarkup.push(React.createElement(_message_wrapper2.default, { key: 'msg-wrapper-' + message.mid,
	          messageStatus: message.status,
	          innerMessage: innerMessage,
	          is_guest: _this.props.is_guest,
	          chat_id: _this.props.chat_id,
	          honest_messages_enabled: _this.props.honest_messages_enabled,
	          msg: message }));
	
	        if (message.last_read_message) {
	          messageMarkup.push(_this._renderBlueLine());
	        }
	      } catch (e) {
	        _logger2.default.warn(message);
	      }
	    });
	
	    return messageMarkup;
	  },
	  onSenderClicked: function onSenderClicked(e) {
	    e.preventDefault();
	    var msg = this.getMsg();
	    var mentionName = msg.sender_mention;
	    if (mentionName) {
	      _chat_window_actions2.default.senderClick({ mention: '@' + mentionName });
	    } else {
	      _logger2.default.warn('Sender mention does not exists', msg);
	    }
	  },
	  _onMessageClicked: function _onMessageClicked(evt) {
	    if (evt.target) {
	      var target = _utils.dom.findParentMatching(evt.target, _utils.dom.matchers.tag("a"), ReactDOM.findDOMNode(this.refs.message_group_root));
	
	      if (target) {
	        if (!_.get(window, 'HC.isEmbeddedComponent')) {
	
	          if (!target.hasAttribute("rel")) {
	            target.setAttribute('rel', "noreferrer");
	          }
	
	          target.setAttribute('target', '_blank');
	        }
	      }
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _card = __webpack_require__(575);
	
	var _card2 = _interopRequireDefault(_card);
	
	var _mention_emoticon_tooltip_mixin = __webpack_require__(449);
	
	var _mention_emoticon_tooltip_mixin2 = _interopRequireDefault(_mention_emoticon_tooltip_mixin);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _scrolling_media_observer_mixin = __webpack_require__(450);
	
	var _scrolling_media_observer_mixin2 = _interopRequireDefault(_scrolling_media_observer_mixin);
	
	var _utils = __webpack_require__(99);
	
	var _integration_link_helper = __webpack_require__(576);
	
	var _integration_link_helper2 = _interopRequireDefault(_integration_link_helper);
	
	var _quote = __webpack_require__(451);
	
	var _quote2 = _interopRequireDefault(_quote);
	
	var _code = __webpack_require__(452);
	
	var _code2 = _interopRequireDefault(_code);
	
	var _monospace = __webpack_require__(453);
	
	var _monospace2 = _interopRequireDefault(_monospace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "NotificationMessageType",
	
	  mixins: [_mention_emoticon_tooltip_mixin2.default, _deep_equal_render_mixin2.default, _scrolling_media_observer_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    this._createTooltips();
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    this._destroyTooltips();
	  },
	
	  render: function render() {
	    var cardData = this.getCard(),
	        notification = this.renderNotification();
	
	    return cardData ? this.renderCard(cardData, notification) : notification;
	  },
	
	  getCard: function getCard() {
	    return _.get(this.props, "msg.card");
	  },
	
	  renderCard: function renderCard(cardData, fallback) {
	    return React.createElement(_card2.default, (0, _extends3.default)({}, cardData, {
	      fallback: fallback,
	      _setScroll: this.props._setScroll,
	      onClick: this.onLinkClick }));
	  },
	
	  renderNotification: function renderNotification() {
	    var notification = void 0,
	        content = void 0,
	        msg = this.props.msg;
	
	    if (msg.format === 'html') {
	      notification = msg.xhtml_im_body;
	    } else {
	      notification = msg.rendered_body;
	    }
	
	    if (msg.format === 'quotation') {
	      content = React.createElement(
	        'div',
	        { className: 'notification msg-line', 'data-mid': msg.mid, onClick: this.onLinkClick },
	        React.createElement(_quote2.default, { mid: msg.mid, body: notification })
	      );
	    } else if (msg.format === 'code') {
	      content = React.createElement(
	        'div',
	        { className: 'notification msg-line', 'data-mid': msg.mid, onClick: this.onLinkClick },
	        React.createElement(_code2.default, { mid: msg.mid, body: notification })
	      );
	    } else if (msg.format === 'monospace') {
	      content = React.createElement(
	        'div',
	        { className: 'notification msg-line', 'data-mid': msg.mid, onClick: this.onLinkClick },
	        React.createElement(_monospace2.default, { mid: msg.mid, body: notification })
	      );
	    } else {
	      content = React.createElement('div', { className: 'notification msg-line',
	        'data-mid': msg.mid,
	        'data-copyable': '{"format": "notification", "mid": "' + msg.mid + '"}',
	        dangerouslySetInnerHTML: { __html: notification }, onClick: this.onLinkClick });
	    }
	
	    return content;
	  },
	
	  onLinkClick: function onLinkClick(event) {
	    if (event.target) {
	
	      var targetLink = _utils.dom.findParentMatching(event.target, _utils.dom.matchers.tag("a"), ReactDOM.findDOMNode(this));
	
	      if (targetLink) {
	        var target = targetLink.getAttribute("data-target");
	        var targetOptions = targetLink.getAttribute("data-target-options");
	        var href = targetLink.getAttribute("href");
	
	        if (_integration_link_helper2.default.handleNotificationLink(target, targetOptions, href, this.props.msg)) {
	          event.stopPropagation();
	          event.preventDefault();
	        }
	      }
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__(91);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _card_helper = __webpack_require__(572);
	
	var _card_helper2 = _interopRequireDefault(_card_helper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var urlAndUrl2xObject = React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.shape({
	  url: React.PropTypes.string.isRequired,
	  'url@2x': React.PropTypes.string
	})]); /*global CardDrawer*/
	
	
	exports.default = React.createClass({
	
	  displayName: "Card",
	
	  propTypes: {
	    id: React.PropTypes.string.isRequired,
	    title: React.PropTypes.string.isRequired,
	    description: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.object]),
	    style: React.PropTypes.oneOf(['file', 'link', 'image', 'application', 'media']),
	    icon: urlAndUrl2xObject,
	    format: React.PropTypes.oneOf(['medium', 'compact']),
	    thumbnail: React.PropTypes.shape({
	      url: React.PropTypes.string.isRequired,
	      'url@2x': React.PropTypes.string,
	      width: React.PropTypes.number,
	      height: React.PropTypes.number
	    }),
	    attributes: React.PropTypes.arrayOf(React.PropTypes.shape({
	      label: React.PropTypes.string,
	      value: React.PropTypes.shape({
	        icon: urlAndUrl2xObject,
	        label: React.PropTypes.string.isRequired
	      })
	    })),
	    fallback: React.PropTypes.element,
	    show_always: React.PropTypes.bool
	  },
	
	  options: {
	    "type": "link",
	    "format": "compact",
	    "responsive": false
	  },
	
	  /**
	   * Cards are immutable and there are not going to change their state in their entire existence
	   * That is why we pass false to guarantee performance with React.
	   * @returns {boolean}
	   */
	  shouldComponentUpdate: function shouldComponentUpdate() {
	    return false;
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onClick: _.noop
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return this._getState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    var node = ReactDOM.findDOMNode(this);
	    this.thumbnailLink = node.querySelector(".atlascard .thumbnail > a");
	    this.title = node.querySelector(".atlascard .title > a");
	    this.activity = node.querySelector(".atlascard .activity-expander");
	
	    if (this.thumbnailLink) {
	      this.thumbnailLink.addEventListener('click', this._onClick);
	    }
	
	    if (this.title) {
	      this.title.addEventListener('click', this._onClick);
	    }
	
	    if (this.activity) {
	      this.activity.addEventListener('click', this._onActivityExpanded);
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    if (this.thumbnailLink) {
	      this.thumbnailLink.removeEventListener('click', this._onClick);
	    }
	
	    if (this.title) {
	      this.title.removeEventListener('click', this._onClick);
	    }
	
	    if (this.activity) {
	      this.activity.removeEventListener('click', this._onActivityExpanded);
	    }
	  },
	
	  render: function render() {
	
	    if (!this.cardsEnabled() || !this.isValid()) {
	      return this.fallback();
	    }
	
	    var cardData = _.clone(this.props);
	    cardData.fallback = {}; // We don't want to pass the fallback if it exists
	    cardData.date = 0; // If we don't set this IE11 & Edge go boom
	    var options = _.clone(this.options);
	
	    try {
	
	      this.processCard(options, cardData);
	      var cardDrawer = new CardDrawer(cardData, options);
	      return React.createElement('div', { 'data-mid': this.props.mid,
	        onClick: this.props.onClick,
	        dangerouslySetInnerHTML: { __html: cardDrawer.render() } });
	    } catch (err) {
	      this._logError(err, this.props);
	      return this.fallback();
	    }
	  },
	
	  _onClick: function _onClick(evt) {
	    var urlLink = { url: this.props.url };
	
	    if (_file_helper2.default.shouldOpenFileViewer(evt) && _file_helper2.default.fileViewerSupports(urlLink)) {
	      evt.preventDefault();
	      _file_viewer_actions2.default.openInFileViewer(urlLink);
	    }
	  },
	
	  /**
	   * We want that if activity cards are the last message and you
	   * expanded to be able to expand and don't have to scroll to see it.
	   * If the activity is in the top of the chat, we don't need to scroll anything
	   * @param evt the event
	   * @private
	   */
	  _onActivityExpanded: function _onActivityExpanded(evt) {
	    var node = $(ReactDOM.findDOMNode(this));
	    var shouldScroll = node.offset().top > $(window).height() / 2;
	    if (shouldScroll) {
	      _chat_window_actions2.default.preserveScrollValue({ animation: false });
	    }
	  },
	
	  _getState: function _getState() {
	    return {
	      feature_flags: _configuration_store2.default.get("feature_flags")
	    };
	  },
	
	  processCard: function processCard(options, cardData) {
	
	    if (this.isImage() || this.isFile()) {
	
	      options.format = "narrow";
	      cardData.title = cardData.title || this.props.url.match("[^/]*$");
	    } else if (this.isLink() || this.isMedia()) {
	
	      options.format = _.get(cardData, 'format', "compact");
	      cardData.site = this._getHostname(this.props.url);
	    } else if (this.isApplication()) {
	
	      options.format = _.get(cardData, 'format', "compact");
	      options.type = cardData.type = "application";
	    }
	
	    if (this.state.feature_flags.web_client_cards_feedback_enabled) {
	      options.feedback = {
	        url: this._feedbackUrl(cardData),
	        label: 'Feedback',
	        tooltip: 'Let the HipChat team know what you think about cards.'
	      };
	    }
	  },
	
	  /**
	   * Will check the required fields for each type to be rendered
	   */
	  isValid: function isValid() {
	    return _card_helper2.default.isValidCard(this.props);
	  },
	
	  fallback: function fallback() {
	    return this.props.fallback ? this.props.fallback : React.createElement('div', null);
	  },
	
	  /**
	   * If the card has a show_always it will render despite any feature flag.
	   * This happens with links that already rolled out
	   * @returns true if enabled, false if not
	   */
	  cardsEnabled: function cardsEnabled() {
	    return this.props.show_always || _card_helper2.default.cardsEnabled(this.state.feature_flags);
	  },
	
	  isValidStyle: function isValidStyle() {
	    return _card_helper2.default.isValidStyle(this.props);
	  },
	
	  isLink: function isLink() {
	    return _card_helper2.default.isLink(this.props);
	  },
	
	  isMedia: function isMedia() {
	    return _card_helper2.default.isMedia(this.props);
	  },
	
	  isFile: function isFile() {
	    return _card_helper2.default.isFile(this.props);
	  },
	
	  isImage: function isImage() {
	    return _card_helper2.default.isImage(this.props);
	  },
	
	  isApplication: function isApplication() {
	    return _card_helper2.default.isApplication(this.props);
	  },
	
	  _getHostname: function _getHostname(url) {
	    var link = document.createElement('a');
	    link.href = url;
	    return link.hostname;
	  },
	
	  _feedbackUrl: function _feedbackUrl(cardData) {
	    return _app_config2.default.cards.feedback_url + encodeURIComponent((0, _stringify2.default)(cardData));
	  },
	
	  _logError: function _logError(error, data) {
	    _logger2.default.error(error);
	    _logger2.default.error(data);
	    this.valid = false;
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _dialog_actions = __webpack_require__(95);
	
	var _dialog_actions2 = _interopRequireDefault(_dialog_actions);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _integrations_actions = __webpack_require__(420);
	
	var _integrations_actions2 = _interopRequireDefault(_integrations_actions);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _route_actions = __webpack_require__(577);
	
	var _route_actions2 = _interopRequireDefault(_route_actions);
	
	var _uri = __webpack_require__(142);
	
	var _uri2 = _interopRequireDefault(_uri);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function parseOptions(options) {
	  if (_.isString(options) && !_.isEmpty(options)) {
	    try {
	      options = JSON.parse(options);
	    } catch (error) {
	      _logger2.default.error('[ChatPanel:routeLinkAction]', 'target options are not valid JSON', error.message);
	      options = {};
	    }
	  }
	  return options || {};
	}
	
	function handleTarget(message, target, targetOptions) {
	  var targetModule = _integration_helper2.default.split_full_key(target);
	  var data = targetOptions;
	  if (message) {
	    var parameters = _integration_helper2.default.extractIntegrationParametersFromMessage(message);
	    data = _.extend({ urlTemplateValues: { message: parameters }, parameters: parameters }, targetOptions);
	  }
	
	  var sender = message.notification_sender;
	  if (sender && sender.type === "addon") {
	    if (targetModule.length === 2) {
	      if (sender.id === targetModule[0]) {
	        _integrations_actions2.default.open(targetModule[0], targetModule[1], data, null, "link");
	      } else {
	        _logger2.default.error('[HC-Integrations]', 'Unable to invoke action for \'' + targetModule[0] + '\' from plugin \'' + sender.id + '\'');
	      }
	    } else if (targetModule.length === 1) {
	      _integrations_actions2.default.open(sender.id, targetModule[0], data, null, "link");
	    } else {
	      _logger2.default.error('[HC-Integrations]', 'Unknown link target from notification: \'' + target + '\'');
	    }
	  } else {
	    _logger2.default.error('[HC-Integrations]', 'Unable to invoke action link - message not sent from addon: \'' + target + '\'');
	  }
	}
	
	exports.default = {
	
	  handleNotificationLink: function handleNotificationLink(dataTarget, dataTargetOptions, href, message) {
	
	    var targetUrl = _uri2.default.parse(href);
	    var targetOptions = parseOptions(dataTargetOptions);
	    var isLegacyConnectDialog = dataTarget === 'dialog';
	
	    if (targetUrl && isLegacyConnectDialog) {
	
	      _analytics_actions2.default.connectDialogLinkClickedEvent(targetUrl.getDomain());
	
	      _dialog_actions2.default.showAddonDialog({
	        addon_key: targetUrl.getDomain(),
	        module_key: 'module-key',
	        addon_url: href,
	        addon_options: targetOptions
	      });
	
	      return true;
	    }
	
	    if (targetUrl && targetUrl.isHipchatNative(_configuration_store2.default.get('base_url'))) {
	
	      if (targetUrl.containsRoom()) {
	        _route_actions2.default.selectRoom(targetUrl.getRoom(), true);
	      } else if (targetUrl.containsUser()) {
	        _route_actions2.default.selectOTO(targetUrl.getUser(), true);
	      } else {
	        _logger2.default.error('[HC-Integrations], `malformed native link`');
	      }
	
	      var target = targetUrl.getParameterValue('target');
	      if (target || dataTarget) {
	        handleTarget(message, target || dataTarget, targetOptions);
	      }
	      return true;
	    }
	
	    if (dataTarget) {
	      handleTarget(message, dataTarget, targetOptions);
	      return true;
	    }
	
	    return false;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _path_parameter_converters = __webpack_require__(430);
	
	var _path_parameter_converters2 = _interopRequireDefault(_path_parameter_converters);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _common_strings = __webpack_require__(183);
	
	var _common_strings2 = _interopRequireDefault(_common_strings);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var idToUserConverters = [_path_parameter_converters2.default.get("idToUser"), _path_parameter_converters2.default.get("jidToUser"), _path_parameter_converters2.default.get("halfJidToUser"), _path_parameter_converters2.default.get("mentionNameToUser")];
	var idToRoomConverters = [_path_parameter_converters2.default.get("idToRoom"), _path_parameter_converters2.default.get("jidToRoom"), _path_parameter_converters2.default.get("halfJidToRoom"), _path_parameter_converters2.default.get("nameToRoom")];
	
	exports.default = {
	  selectRoom: function selectRoom(room_id) {
	    var set_route = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    var room = _.reduce(idToRoomConverters, function (accumulator, idToRoomConverter) {
	      if (_.isUndefined(accumulator) && idToRoomConverter.handle(room_id)) {
	        return idToRoomConverter.convert(room_id);
	      }
	
	      return accumulator;
	    }, room);
	
	    if (!_.isUndefined(room)) {
	
	      var activeChatJid = _.get(_application_store2.default.data, 'active_chat');
	
	      if (set_route) {
	        _app_dispatcher2.default.dispatch('set-route', { jid: room.jid });
	      }
	
	      if (!_.get(_application_store2.default.data, 'activeRooms["' + room.jid + '"]')) {
	        _app_dispatcher2.default.dispatch('open-room', { jid: room.jid });
	      }
	
	      if (activeChatJid !== room.jid) {
	        _app_dispatcher2.default.dispatch('new-active-chat', { jid: room.jid });
	      }
	    } else {
	      _flag_actions2.default.showFlag({
	        type: "warning",
	        body: _common_strings2.default.room_not_found,
	        close: "auto",
	        title: "",
	        delay: 5000
	      });
	    }
	  },
	  selectOTO: function selectOTO(user_id) {
	    var set_route = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    var user = _.reduce(idToUserConverters, function (accumulator, idToUserConverter) {
	      if (_.isUndefined(accumulator) && idToUserConverter.handle(user_id)) {
	        return idToUserConverter.convert(user_id);
	      }
	
	      return accumulator;
	    }, user);
	
	    if (!_.isUndefined(user)) {
	
	      var activeChatJid = _.get(_application_store2.default.data, 'active_chat');
	
	      if (set_route) {
	        _app_dispatcher2.default.dispatch('set-route', { jid: user.jid });
	      }
	
	      if (!_.get(_application_store2.default.data, 'activeRooms["' + user.jid + '"]')) {
	        _app_dispatcher2.default.dispatch('open-room', { jid: user.jid });
	      }
	
	      if (activeChatJid !== user.jid) {
	        _app_dispatcher2.default.dispatch('new-active-chat', { jid: user.jid });
	      }
	    } else {
	      _flag_actions2.default.showFlag({
	        type: "warning",
	        body: _common_strings2.default.user_not_found,
	        close: "auto",
	        title: "",
	        delay: 3000
	      });
	    }
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _emoticons = __webpack_require__(110);
	
	var _emoticons2 = _interopRequireDefault(_emoticons);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "InfoMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    _emoticons2.default._replaceSpecials(ReactDOM.findDOMNode(this));
	  },
	
	  render: function render() {
	    return React.createElement('div', { className: 'info msg-line',
	      'data-copyable': '{"format": "info"}',
	      'data-mid': this.props.msg.mid,
	      'data-presence-message': this.props.msg.is_presence_message,
	      dangerouslySetInnerHTML: { __html: this.props.msg.rendered_body } });
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _app_actions = __webpack_require__(195);
	
	var _app_actions2 = _interopRequireDefault(_app_actions);
	
	var _mention_emoticon_tooltip_mixin = __webpack_require__(449);
	
	var _mention_emoticon_tooltip_mixin2 = _interopRequireDefault(_mention_emoticon_tooltip_mixin);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _scrolling_media_observer_mixin = __webpack_require__(450);
	
	var _scrolling_media_observer_mixin2 = _interopRequireDefault(_scrolling_media_observer_mixin);
	
	var _file_thumbnail = __webpack_require__(580);
	
	var _file_thumbnail2 = _interopRequireDefault(_file_thumbnail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "FileMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default, _mention_emoticon_tooltip_mixin2.default, _scrolling_media_observer_mixin2.default],
	
	  getInitialState: function getInitialState() {
	    return {
	      userExpanded: null
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    var msg = this.props.msg;
	
	    this._initRenderStrategies();
	
	    if (this._renderStrategies[msg.file_data.file_type]) {
	      this.renderStrategy = this._renderStrategies[msg.file_data.file_type];
	    } else {
	      this.renderStrategy = this._renderStrategies.file;
	    }
	  },
	  _isUserExpanded: function _isUserExpanded() {
	    return !this.props.msg.is_collapsed;
	  },
	  _shouldBeExpanded: function _shouldBeExpanded() {
	    if (this.props.shouldHideAttachedCards) {
	      return false;
	    }
	    if (this.props.shouldHideGifs) {
	      return this.props.msg.file_data.file_ext !== 'gif';
	    }
	    return true;
	  },
	  _isExpanded: function _isExpanded() {
	    if (this.state.userExpanded === null) {
	      return this._shouldBeExpanded() ? this._isUserExpanded() : false;
	    }
	    return this.state.userExpanded;
	  },
	  _getDescription: function _getDescription() {
	    if (this.props.msg.rendered_body) {
	      return React.createElement('span', { className: 'description', dangerouslySetInnerHTML: { __html: this.props.msg.rendered_body } });
	    }
	    return '';
	  },
	  render: function render() {
	    return this.renderStrategy();
	  },
	  _initRenderStrategies: function _initRenderStrategies() {
	    this._renderStrategies = {
	      img: this._renderImgMessage,
	      video: this._renderVideoMessage,
	      file: this._renderFileMessage
	    };
	  },
	  _renderImgMessage: function _renderImgMessage() {
	    var msg = this.props.msg;
	    var fileName = msg.file_data.file_name;
	
	    var isExpanded = this._isExpanded(),
	        toggleClasses = (0, _classnames2.default)({
	      'toggle-image': true,
	      'collapse': isExpanded,
	      'expand': !isExpanded
	    }),
	        fileMetaClasses = (0, _classnames2.default)({
	      'file-meta': true,
	      'with-preview': true,
	      'compact': !isExpanded
	    });
	    return React.createElement(
	      'div',
	      { 'data-mid': msg.mid,
	        className: 'msg-line',
	        'data-copyable': '{"format": "file", "mid": "' + msg.mid + '"}' },
	      React.createElement(
	        'div',
	        { className: 'toggle-wrap', onClick: this._toggleImage },
	        React.createElement('span', { className: toggleClasses })
	      ),
	      this._renderThumbnail(),
	      React.createElement(
	        'div',
	        { className: fileMetaClasses },
	        React.createElement(
	          'a',
	          { href: msg.file_data.url, onClick: this._onClick },
	          fileName
	        ),
	        React.createElement(
	          'span',
	          { className: 'file-size' },
	          msg.file_data.file_size
	        )
	      ),
	      this._getDescription()
	    );
	  },
	  _renderThumbnail: function _renderThumbnail() {
	    if (this._isExpanded()) {
	      return React.createElement(_file_thumbnail2.default, {
	        file: this.props.msg.file_data,
	        onClick: this._onClick });
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'file-preview-wrapper info' },
	      React.createElement(
	        'i',
	        null,
	        _chat_panel_strings2.default.image_hidden
	      )
	    );
	  },
	  _renderVideoMessage: function _renderVideoMessage() {
	    var msg = this.props.msg;
	    var fileName = msg.file_data.file_name;
	
	    return React.createElement(
	      'div',
	      { 'data-mid': msg.mid,
	        className: 'msg-line',
	        'data-copyable': '{"format": "file", "mid": "' + msg.mid + '"}' },
	      React.createElement(
	        'div',
	        { className: 'file-preview-wrapper video-wrap' },
	        React.createElement('span', { className: 'file-video-default-poster', onClick: this._onClick })
	      ),
	      React.createElement(
	        'div',
	        { className: 'file-meta with-preview' },
	        React.createElement(
	          'a',
	          { href: msg.file_data.url, onClick: this._onClick },
	          fileName
	        ),
	        React.createElement(
	          'span',
	          { className: 'file-size' },
	          msg.file_data.file_size
	        )
	      ),
	      this._getDescription()
	    );
	  },
	  _renderFileMessage: function _renderFileMessage() {
	    var msg = this.props.msg;
	    var fileName = msg.file_data.file_name;
	    var fileIcons = (0, _classnames2.default)({
	      'aui-icon': true,
	      'hipchat-icon-small': true,
	      'hc-file-icon': true
	    });
	    fileIcons = fileIcons + " " + _utils2.default.file.get_icon_class(fileName);
	
	    return React.createElement(
	      'div',
	      { 'data-mid': msg.mid,
	        className: 'msg-line',
	        'data-copyable': '{"format": "file", "mid": "' + msg.mid + '"}' },
	      React.createElement(
	        'div',
	        { className: 'file-meta' },
	        React.createElement('span', { className: fileIcons }),
	        React.createElement(
	          'a',
	          { href: msg.file_data.url, onClick: this._onClick },
	          fileName
	        ),
	        React.createElement(
	          'span',
	          { className: 'file-size' },
	          msg.file_data.file_size
	        )
	      ),
	      this._getDescription()
	    );
	  },
	  _toggleImage: function _toggleImage() {
	    var isExpanded = this._isExpanded();
	    this.setState({
	      userExpanded: !isExpanded
	    });
	    _chat_window_actions2.default.toggleImage({
	      jid: this.props.msg.room,
	      mid: this.props.msg.mid
	    });
	  },
	  _videoTypeSupported: function _videoTypeSupported(ext) {
	    var video = document.createElement("video");
	    if (video.canPlayType) {
	      return {
	        mp4: video.canPlayType('video/mp4; codecs="mp4v.20.8"') || video.canPlayType('video/mp4; codecs="avc1.42E01E"') || video.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"'),
	        m4v: video.canPlayType('video/mp4; codecs="mp4v.20.8"') || video.canPlayType('video/mp4; codecs="avc1.42E01E"') || video.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"'),
	        ogv: video.canPlayType('video/ogg; codecs="theora"'),
	        webm: video.canPlayType('video/webm; codecs="vp8, vorbis"')
	      }[ext];
	    }
	    return false;
	  },
	  _onClick: function _onClick(evt) {
	    if (_file_helper2.default.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      if (evt.metaKey) {
	        var url = this.props.msg.file_data.url;
	        _app_actions2.default.openExternalWindow(url, '_blank');
	      } else {
	        _file_viewer_actions2.default.openInFileViewer(this.props.msg.file_data);
	      }
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _file_error = __webpack_require__(581);
	
	var _file_error2 = _interopRequireDefault(_file_error);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'FileThumbnail',
	
	  propTypes: {
	    file: React.PropTypes.object.isRequired,
	    onClick: React.PropTypes.func.isRequired
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      thumbIsLoading: false,
	      thumbIsLoaded: false,
	      imageIsMounted: false,
	      error: null
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    _app_dispatcher2.default.register({
	      'thumbnail-is-loading': this._thumbnailIsLoading,
	      'thumbnail-loaded-success': this._thumbnailLoadedSuccess,
	      'thumbnail-loaded-error': this._thumbnailLoadedError
	    });
	
	    if (this.props.file.file_type === 'img') {
	      this.tryFetchThumbnail(this.props.file);
	    }
	  },
	  componentDidMount: function componentDidMount() {
	    if (this.props.file.file_type === 'img') {
	      this._appendThumbnail();
	    }
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.file.file_type === 'img' && !this.state.imageIsMounted) {
	      this._appendThumbnail();
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _app_dispatcher2.default.unregister({
	      'thumbnail-is-loading': this._thumbnailIsLoading,
	      'thumbnail-loaded-success': this._thumbnailLoadedSuccess,
	      'thumbnail-loaded-error': this._thumbnailLoadedError
	    });
	  },
	  _thumbnailIsLoading: function _thumbnailIsLoading(instance) {
	    if (instance === this) {
	      this.setState({ thumbIsLoading: true });
	    }
	  },
	  _thumbnailLoadedSuccess: function _thumbnailLoadedSuccess(instance) {
	    if (instance === this) {
	      this.setState({
	        thumbIsLoaded: true,
	        thumbIsLoading: false,
	        error: null
	      });
	    }
	  },
	  _thumbnailLoadedError: function _thumbnailLoadedError(data) {
	    if (data.instance === this) {
	      this.setState({
	        thumbIsLoaded: true,
	        thumbIsLoading: false,
	        error: data.error,
	        imageIsMounted: false
	      });
	    }
	  },
	  _appendThumbnail: function _appendThumbnail() {
	    var node = ReactDOM.findDOMNode(this.refs.preview_thumbnail_container);
	    if (node !== null) {
	      node.appendChild(this.props.file.preview_thumbnail);
	      this.setState({ imageIsMounted: true });
	    }
	  },
	  render: function render() {
	    if (this.state.error) {
	      return React.createElement(_file_error2.default, { code: this.state.error.code,
	        isLoading: this.state.thumbIsLoading,
	        onClick: this.tryFetchThumbnail });
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'file-preview-wrapper', onClick: this.props.onClick },
	      React.createElement('a', { href: this.props.file.url,
	        target: '_blank',
	        title: _file_helper2.default.basename(this.props.file.name),
	        onClick: this._onClick,
	        ref: 'preview_thumbnail_container' })
	    );
	  },
	  tryFetchThumbnail: function tryFetchThumbnail() {
	    var _this = this;
	
	    this.loadThumbnail().then(function () {
	      _chat_window_actions2.default.thumbnailLoadedSuccess(_this);
	    }, function (error) {
	      error = error || null;
	
	      _chat_window_actions2.default.thumbnailLoadedError({ error: error, instance: _this });
	    });
	  },
	  loadThumbnail: function loadThumbnail() {
	    var _this2 = this;
	
	    var file = this.props.file;
	    var loadThumb = new _promise2.default(function (resolve, reject) {
	      var timeout = _app_config2.default.message_image_loading_timeout;
	
	      if (file.preview_thumbnail._isLoaded) {
	        return _promise2.default.resolve(true);
	      }
	
	      if (file.is_authenticated) {
	        _chat_window_actions2.default.fetchSignedThumbnail(file, function (data) {
	          _utils2.default.image.changeSrc(file.preview_thumbnail, data.temp_url, timeout).then(resolve, reject);
	        }, function (err) {
	          if (err.status) {
	            var error = {
	              code: err.status
	            };
	            reject(error);
	          }
	        });
	      } else {
	        _utils2.default.image.changeSrc(file.preview_thumbnail, file.thumb_url, timeout).then(resolve, reject);
	      }
	
	      _chat_window_actions2.default.thumbnailIsLoading(_this2);
	    });
	
	    return loadThumb;
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _file_error_strings = __webpack_require__(582);
	
	var _file_error_strings2 = _interopRequireDefault(_file_error_strings);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _spinner = __webpack_require__(329);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	  displayName: "FileErrorMessageType",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  propTypes: {
	    code: React.PropTypes.number.isRequired,
	    title: React.PropTypes.string,
	    isLoading: React.PropTypes.bool,
	    description: React.PropTypes.string,
	    onClick: React.PropTypes.func
	  },
	
	  render: function render() {
	    var stringObject = _file_error_strings2.default[this.props.code] || _file_error_strings2.default.default_error;
	    var title = this.props.title || stringObject.title;
	    var description = this.props.description || stringObject.description;
	    var classNames = (0, _classnames2.default)({
	      'file-error-message': true
	    });
	
	    return React.createElement(
	      'div',
	      { className: classNames },
	      React.createElement(
	        'h3',
	        null,
	        title
	      ),
	      React.createElement(
	        'div',
	        null,
	        description
	      ),
	      React.createElement(
	        'div',
	        null,
	        this.props.onClick ? this.renderTryAgainButton() : ''
	      )
	    );
	  },
	  renderTryAgainButton: function renderTryAgainButton() {
	    if (this.props.isLoading) {
	      return React.createElement(
	        'div',
	        { className: 'file-error-spinner' },
	        React.createElement(_spinner2.default, { size: 'small', spin: !!this.props.isLoading })
	      );
	    }
	    return React.createElement(
	      'a',
	      { onClick: this.props.onClick },
	      'Try again'
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 582 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  401: {
	    title: 'Not authenticated',
	    description: 'We couldn\'t authenticate your account. If this keeps happening, try logging in again.'
	  },
	  403: {
	    title: 'Not authorized',
	    description: 'You don\'t have permission to view this file.'
	  },
	  404: {
	    title: 'File not found',
	    description: 'We couldn\'t find the file.'
	  },
	  default_error: {
	    title: 'We couldn\'t load the file',
	    description: 'There\'s a problem loading the file from the server.'
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(191);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _card = __webpack_require__(575);
	
	var _card2 = _interopRequireDefault(_card);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "LinkMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  render: function render() {
	
	    var data = _.clone(this.props.msg.link_details);
	    data.icon = data.favicon_url || data.icon && data.icon.url;
	    data.description = data.desc || data.description;
	    data.url = data.id = data.full_url || data.url;
	    data.title = data.header_text || data.title;
	    data.style = 'link';
	
	    return React.createElement(_card2.default, (0, _extends3.default)({}, data, { show_always: 'true' }));
	  },
	
	  _getHostname: function _getHostname(url) {
	    var link = document.createElement('a');
	    link.href = url;
	    return link.hostname;
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	var _image = __webpack_require__(585);
	
	var _image2 = _interopRequireDefault(_image);
	
	var _gifv = __webpack_require__(586);
	
	var _gifv2 = _interopRequireDefault(_gifv);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ImageMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  getInitialState: function getInitialState() {
	    return {
	      userExpanded: null,
	      timeout: false
	    };
	  },
	
	  _isGifV: function _isGifV() {
	    return this.props.msg.type === 'image' && !!_.get(this.props.msg, 'link_details.mp4');
	  },
	
	  _isUserExpanded: function _isUserExpanded() {
	    return !this.props.msg.is_collapsed;
	  },
	
	  _shouldBeExpanded: function _shouldBeExpanded() {
	    var extension = _utils2.default.file.get_extension(this.props.msg.link_details.image);
	    if (this.props.shouldHideAttachedCards) {
	      return false;
	    }
	    if (this.props.shouldHideGifs) {
	      return !/^gif/.test(extension);
	    }
	    return true;
	  },
	
	  _isExpanded: function _isExpanded() {
	    if (this.state.userExpanded === null) {
	      return this._shouldBeExpanded() ? this._isUserExpanded() : false;
	    }
	    return this.state.userExpanded;
	  },
	
	  _getCollapsedImage: function _getCollapsedImage() {
	    return React.createElement(
	      'div',
	      { className: 'info' },
	      React.createElement(
	        'i',
	        null,
	        _chat_panel_strings2.default.image_hidden
	      )
	    );
	  },
	
	  _getExpandedImage: function _getExpandedImage() {
	    var props = {
	      ref: "image",
	      msg: this.props.msg
	    },
	        content;
	
	    if (this._isGifV()) {
	      content = React.createElement(_gifv2.default, props);
	    } else {
	      content = React.createElement(_image2.default, props);
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'image-preview-wrapper' },
	      content
	    );
	  },
	
	  _onClick: function _onClick(evt) {
	    if (_file_helper2.default.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      _file_viewer_actions2.default.openInFileViewer(this.props.msg.link_details);
	    }
	  },
	
	  _toggleImage: function _toggleImage() {
	    var isExpanded = this._isExpanded();
	    this.setState({
	      userExpanded: !isExpanded
	    });
	    _chat_window_actions2.default.toggleImage({
	      jid: this.props.msg.room,
	      mid: this.props.msg.mid
	    });
	  },
	
	  render: function render() {
	    var isExpanded = this._isExpanded(),
	        toggleClasses = (0, _classnames2.default)({
	      'toggle-image': true,
	      'collapse': isExpanded,
	      'expand': !isExpanded
	    }),
	        content;
	
	    if (isExpanded) {
	      content = this._getExpandedImage();
	    } else {
	      content = this._getCollapsedImage();
	    }
	
	    return React.createElement(
	      'div',
	      { className: 'msg-line', 'data-mid': this.props.msg.mid },
	      React.createElement(
	        'div',
	        { className: 'toggle-wrap', onClick: this._toggleImage },
	        React.createElement('span', { className: toggleClasses })
	      ),
	      content
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _scrolling_media_observer_mixin = __webpack_require__(450);
	
	var _scrolling_media_observer_mixin2 = _interopRequireDefault(_scrolling_media_observer_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'ImageComponentType',
	
	  mixins: [_deep_equal_render_mixin2.default, _scrolling_media_observer_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    this._setImageSrc();
	
	    if (this.props.msg.media_loaded) {
	      var img = ReactDOM.findDOMNode(this.refs.image);
	      var size = _.get(this.props.msg, 'media_sizes', {})[this.props.msg.link_details.image];
	      if (size && size.width && size.height) {
	        img.width = size.width;
	
	        img.height = size.height;
	      }
	    }
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (!this.state.failed) {
	      this._setImageSrc();
	    }
	  },
	  _setImageSrc: function _setImageSrc() {
	    var img = ReactDOM.findDOMNode(this.refs.image);
	    var src = this.props.msg.link_details.image;
	
	    if (img.src !== src) {
	      img.src = this.props.msg.link_details.image;
	    }
	  },
	
	
	  _onClick: function _onClick(evt) {
	    if (_file_helper2.default.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      _file_viewer_actions2.default.openInFileViewer(this.props.msg.link_details);
	    }
	  },
	
	  render: function render() {
	    return React.createElement(
	      'a',
	      { href: this.props.msg.link_details.url,
	        target: '_blank',
	        title: _file_helper2.default.basename(this.props.msg.link_details.url),
	        onClick: this._onClick },
	      React.createElement('img', { ref: 'image', src: '' })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 586 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	var _scrolling_media_observer_mixin = __webpack_require__(450);
	
	var _scrolling_media_observer_mixin2 = _interopRequireDefault(_scrolling_media_observer_mixin);
	
	var _image = __webpack_require__(585);
	
	var _image2 = _interopRequireDefault(_image);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	  displayName: 'gifv',
	
	
	  mixins: [_deep_equal_render_mixin2.default, _scrolling_media_observer_mixin2.default],
	
	  componentDidMount: function componentDidMount() {
	    var video = ReactDOM.findDOMNode(this.refs.video),
	        mp4 = ReactDOM.findDOMNode(this.refs.mp4),
	        webm = ReactDOM.findDOMNode(this.refs.webm),
	        mp4Url = this.props.msg.link_details.mp4,
	        webmUrl = this._getWebM();
	
	    if (video) {
	      if (!this._canPlayMp4()) {
	        video.src = webmUrl;
	      } else {
	        video.src = mp4Url;
	      }
	      mp4.src = mp4Url;
	      webm.src = webmUrl;
	
	      if (this.props.msg.media_loaded) {
	        var src = this._canPlayMp4() ? mp4Url : webmUrl;
	        var size = _.get(this.props.msg, 'media_sizes', {})[src];
	
	        if (size && size.width && size.height) {
	          video.width = size.width;
	          video.height = size.height;
	        } else {
	          this.setState({
	            failed: true
	          });
	        }
	      }
	    }
	  },
	
	  getVideo: function getVideo() {
	    return React.createElement(
	      'a',
	      { href: this.props.msg.link_details.url,
	        target: '_blank',
	        title: this.props.msg.link_details.name || this.props.msg.link_details.url },
	      React.createElement(
	        'video',
	        { ref: 'video',
	          mute: 'true',
	          loop: 'true',
	          src: '',
	          autoPlay: 'true' },
	        React.createElement('source', { ref: 'mp4', src: '' }),
	        React.createElement('source', { ref: 'webm', src: '' })
	      )
	    );
	  },
	  getFailedState: function getFailedState() {
	    return React.createElement(_image2.default, this.props);
	  },
	
	
	  render: function render() {
	    return this.state.failed ? this.getFailedState() : this.getVideo();
	  },
	
	  // (sadpanda).
	  // The .mp4 version doesn't play in the Windows Chromium app. We can't just fall
	  // back to the .gif version, because Imgur reserves the right to delete them if
	  // they are over 20 Mb. Platform will be giving us the .webm info soon (see
	  // https://jira.atlassian.com/browse/HC-23799). When that lands, remove this.
	  _getWebM: function _getWebM() {
	    return this.props.msg.link_details.webm || this.props.msg.link_details.mp4.replace(/\.mp4/, '.webm');
	  },
	  _canPlayMp4: function _canPlayMp4() {
	    var video = ReactDOM.findDOMNode(this.refs.video);
	    return video.canPlayType && video.canPlayType('video/mp4');
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _card = __webpack_require__(575);
	
	var _card2 = _interopRequireDefault(_card);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "VideoMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  render: function render() {
	    return React.createElement(_card2.default, { id: this.props.msg.mid, url: this.props.msg.link_details.url,
	      style: 'link', thumbnail: { url: this.props.msg.link_details.thumb },
	      icon: '/wc/assets/img/youtube-favicon-32.png',
	      title: this.props.msg.link_details.title,
	      description: '',
	      fallback: this.getFallbackMessage(), mid: this.props.msg.mid });
	  },
	
	  /**
	   * This message is going to be deprecated when cards are fully functional
	   * @returns {XML}
	   * @deprecated
	   */
	  getFallbackMessage: function getFallbackMessage() {
	    return React.createElement(
	      'div',
	      { className: 'msg-line', 'data-mid': this.props.msg.mid },
	      React.createElement(
	        'div',
	        { 'data-mid': this.props.msg.mid, className: 'video-wrap' },
	        React.createElement(
	          'a',
	          { href: this.props.msg.link_details.url, className: 'file-video-default-poster', onClick: this._onClick },
	          React.createElement('img', { src: this.props.msg.link_details.thumb })
	        ),
	        React.createElement(
	          'p',
	          { className: 'linkTitle' },
	          React.createElement(
	            'a',
	            { href: this.props.msg.link_details.url, target: '_blank' },
	            this.props.msg.link_details.title
	          )
	        ),
	        React.createElement(
	          'p',
	          { className: 'linkDesc' },
	          _utils2.default.formatNumber(this.props.msg.link_details.views),
	          ' views',
	          React.createElement('br', null),
	          this.props.msg.link_details.author
	        )
	      )
	    );
	  },
	
	  _onClick: function _onClick(evt) {
	    if (_file_helper2.default.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      _file_viewer_actions2.default.openInFileViewer(this.props.msg.link_details);
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "UserStateMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "state info msg-line", "data-mid": this.props.msg.mid },
	      this.props.msg.body
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "TwitterStatusMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  componentWillMount: function componentWillMount() {
	    this.onTwitterEmbedRendered = function (evt) {
	      _app_dispatcher2.default.dispatch('twitter-card-rendered', { element: evt.target });
	      twttr.events.unbind('rendered', this.onTwitterEmbedRendered);
	    };
	    this._isEmbedded = window.HC && HC.isEmbeddedComponent ? true : false;
	    if (!this._isEmbedded && _app_config2.default.render_twitter_cards) {
	      this._debouncedTwttrLoad = _.debounce(twttr.widgets.load, 100, { leading: true, trailing: false });
	      twttr.events.bind('rendered', this.onTwitterEmbedRendered);
	    }
	  },
	
	  componentDidMount: function componentDidMount() {
	    if (!this._isEmbedded && _app_config2.default.render_twitter_cards) {
	      this._debouncedTwttrLoad();
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    if (!this._isEmbedded && _app_config2.default.render_twitter_cards) {
	      twttr.events.unbind('rendered', this.onTwitterEmbedRendered);
	    }
	  },
	
	  render: function render() {
	    var tweet;
	    if (this._isEmbedded || !_app_config2.default.render_twitter_cards) {
	      tweet = React.createElement('div', { 'data-mid': this.props.msg.mid, className: 'link-wrap', dangerouslySetInnerHTML: {
	          __html: '<a class="linkImage" name="link" target="_blank" href="http://twitter.com/' + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + '" >' + '<img class="twitterAvatar" height="48" width="48" src="' + (this.props.msg.link_details.profile_image_url || this.props.msg.link_details.profileImageUrl) + '" />' + '</a><p class="tweet">' + this.props.msg.body + '</p>' + '<p class="linkDesc tweet"> ' + this.props.msg.link_details.name + ' (<a target="_blank" href="http://twitter.com/' + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + '" >@' + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + '</a>) via ' + this.props.msg.link_details.source + '</p>'
	        } });
	    } else {
	      tweet = React.createElement(
	        'blockquote',
	        { className: 'twitter-tweet hidden' },
	        React.createElement(
	          'p',
	          null,
	          this.props.msg.body
	        ),
	        React.createElement(
	          'a',
	          { href: this.props.msg.link_details.url },
	          this.props.msg.link_details.url
	        )
	      );
	    }
	    return React.createElement(
	      'div',
	      { className: 'msg-line', 'data-mid': this.props.msg.mid },
	      tweet
	    );
	  }
	
	}); /*global twttr, HC*/
	
	module.exports = exports['default'];

/***/ },
/* 590 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _deep_equal_render_mixin = __webpack_require__(367);
	
	var _deep_equal_render_mixin2 = _interopRequireDefault(_deep_equal_render_mixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "TwitterUserMessageType",
	
	  mixins: [_deep_equal_render_mixin2.default],
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'msg-line', 'data-mid': this.props.msg.mid },
	      React.createElement('div', { 'data-mid': this.props.msg.mid, className: 'link-wrap', dangerouslySetInnerHTML: {
	          __html: '<a class="linkImage" name="link" target="_blank" href="http://twitter.com/' + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + '" >' + '<img class="twitterAvatar" height="48" width="48" src="' + (this.props.msg.link_details.profile_image_url || this.props.msg.link_details.profileImageUrl) + '" />' + '</a><p class="linkDesc tweet">' + this.props.msg.link_details.name + ' (<a target="_blank" href="http://twitter.com/' + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + '" >@' + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + '</a>)</p>' + '<p class="followers">' + _utils2.default.formatNumber(this.props.msg.link_details.followers) + ' followers</p>'
	        } })
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _integrations_strings = __webpack_require__(437);
	
	var _integrations_strings2 = _interopRequireDefault(_integrations_strings);
	
	var _actions_dropdown = __webpack_require__(592);
	
	var _actions_dropdown2 = _interopRequireDefault(_actions_dropdown);
	
	var _integration_dropdown_action = __webpack_require__(593);
	
	var _integration_dropdown_action2 = _interopRequireDefault(_integration_dropdown_action);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _edit_message = __webpack_require__(594);
	
	var _edit_message2 = _interopRequireDefault(_edit_message);
	
	var _delete_message = __webpack_require__(596);
	
	var _delete_message2 = _interopRequireDefault(_delete_message);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ActionableMessageWrapper",
	
	  propTypes: {
	    msg: React.PropTypes.shape({
	      mid: React.PropTypes.string,
	      room: React.PropTypes.string
	    }),
	    onActive: React.PropTypes.func,
	    onInactive: React.PropTypes.func
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      "active": false
	    };
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _app_dispatcher2.default.unregister('chat-is-scrolling', this._dismiss);
	  },
	  _onShow: function _onShow() {
	    _chat_window_actions2.default.displayMessageAction({ jid: this.props.msg.room });
	    _app_dispatcher2.default.registerOnce('chat-is-scrolling', this._dismiss);
	    this.setState({ "active": true });
	  },
	  _onDismiss: function _onDismiss() {
	    _chat_window_actions2.default.hideMessageAction({ jid: this.props.msg.room });
	    _app_dispatcher2.default.unregister('chat-is-scrolling', this._dismiss);
	    this.setState({ "active": false });
	  },
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      "actionable-msg-container": true,
	      "msg-line": true,
	      "hc-message-actions-active": this.state.active
	    });
	
	    var dropdown = React.createElement(_actions_dropdown2.default, { icon: 'aui-iconfont-more',
	      dropdown_id: "message-actions-" + this.props.msg.mid,
	      lazy_options: this._renderOptions,
	      location_horizontal: 'left',
	      onShow: this._onShow,
	      onHide: this._onDismiss });
	
	    return React.createElement(
	      'div',
	      { className: classes, key: this.props.msg.mid },
	      dropdown,
	      this.props.children
	    );
	  },
	  _renderOptions: function _renderOptions() {
	    var _this = this;
	
	    var extensions = _integrations_store2.default.getExtensionsByLocationAndContext("hipchat.message.action", { message: this.props.msg });
	
	    var options = [],
	        editControls = void 0;
	
	    if (extensions.length > 0) {
	      options = _.map(extensions, function (action) {
	        return React.createElement(_integration_dropdown_action2.default, { action: action,
	          msg: _this.props.msg,
	          key: _integration_helper2.default.to_full_key(action.addon_key + ":" + action.key) });
	      });
	    } else if (!this.props.is_editable || !this.props.message_editing_enabled) {
	      options = [React.createElement(
	        'li',
	        { key: this.props.msg.mid },
	        React.createElement(
	          'a',
	          { className: 'disabled', title: _integrations_strings2.default.empty_message_actions_title },
	          _integrations_strings2.default.empty_message_actions
	        )
	      )];
	    }
	
	    if (this.props.message_editing_enabled && this.props.is_editable) {
	      editControls = React.createElement(
	        'div',
	        { className: 'aui-dropdown2-section' },
	        React.createElement(
	          'ul',
	          null,
	          React.createElement(_edit_message2.default, { msg: this.props.msg }),
	          React.createElement(_delete_message2.default, { msg: this.props.msg })
	        )
	      );
	    }
	
	    var optionsSection = void 0;
	    if (this.props.message_editing_enabled && editControls && options.length > 0) {
	      optionsSection = React.createElement(
	        'div',
	        { className: 'aui-dropdown2-section' },
	        React.createElement(
	          'ul',
	          { className: 'aui-list-truncate' },
	          options
	        )
	      );
	    } else {
	      optionsSection = React.createElement(
	        'ul',
	        { className: 'aui-list-truncate' },
	        options
	      );
	    }
	
	    return React.createElement(
	      'div',
	      null,
	      editControls,
	      optionsSection
	    );
	  },
	  _dismiss: function _dismiss() {
	    _chat_window_actions2.default.dismissActionsDropDown();
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var AppDispatcher = __webpack_require__(9);
	
	module.exports = React.createClass({
	
	  displayName: "ActionsDropDown",
	
	  propTypes: {
	    dropdown_id: React.PropTypes.string,
	    lazy_options: React.PropTypes.func,
	    onShow: React.PropTypes.func,
	    onHide: React.PropTypes.func,
	    default_option: React.PropTypes.oneOf(["first", "last"])
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onShow: _.noop,
	      onHide: _.noop,
	      onItemSelect: _.noop,
	      button_class: "aui-button aui-button-subtle aui-dropdown2-trigger-arrowless",
	      default_option: "first"
	    };
	  },
	  shouldComponentUpdate: function shouldComponentUpdate() {
	    // We don't want this component to update after its initial render, as it's DOM is mutated by the
	    //  drop down component
	    return false;
	  },
	  componentDidMount: function componentDidMount() {
	    // Listen to show / hide events as these let us update the application state
	    this._getContainer().on("aui-dropdown2-hide", this._onDismiss);
	    this._getContainer().on("aui-dropdown2-show", this._onShow);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._getContainer().off();
	    $(window).off("resize", this._dismiss);
	    AppDispatcher.unregister("dismiss-active-actions-dropdown", this._dismiss);
	  },
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-dropdown" },
	      this._renderTrigger(),
	      this._renderContainer()
	    );
	  },
	  _onShow: function _onShow() {
	    var trigger = this._getTrigger();
	    var container = this._getContainer();
	
	    // Manually render menu items if we are using deferred rendering
	    //  as DOM has already been modified by AUI DropDown
	    if (this.props.lazy_options) {
	      ReactDOM.render(this._renderOptions(), container[0]);
	    }
	
	    //If too close to bottom, float above '...' menu. This case is handled better in AUI
	    //   5.8, so we should remove this when that becomes available TODO: HC-19161
	    if ($('body').height() < container.position().top + container.height() || this.props.location === "above") {
	      container.css("top", container.position().top - container.outerHeight() - trigger.outerHeight() + "px");
	      container.addClass("hc-dropdown-above");
	      trigger.addClass("hc-dropdown-above");
	    }
	
	    if (this.props.location_horizontal === "left") {
	      container.css("left", trigger.offset().left + trigger.outerWidth() - container.outerWidth());
	    }
	
	    // If the user scrolls, we want to dismiss the popup for now
	    AppDispatcher.registerOnce("dismiss-active-actions-dropdown", this._dismiss);
	    $(window).one("resize", this._dismiss);
	
	    if (this.props.default_option === "last") {
	      container.one("aui-dropdown2-item-selected", function () {
	        container.find(".active.aui-dropdown2-active").removeClass("active aui-dropdown2-active");
	        container.find("a").last().addClass("active aui-dropdown2-active");
	      });
	    }
	
	    this.props.onShow();
	  },
	  _onDismiss: function _onDismiss() {
	    var container = this._getContainer();
	    var trigger = this._getTrigger();
	
	    container.removeAttr('style');
	    container.removeClass("hc-dropdown-above");
	    trigger.removeClass("hc-dropdown-above");
	
	    // Unregister the is scrolling listener in case it wasn't the bit that triggered this dismiss
	    $(window).off("resize", this._dismiss);
	    AppDispatcher.unregister("dismiss-active-actions-dropdown", this._dismiss);
	
	    // Remove all menu items
	    if (this.props.lazy_options) {
	      ReactDOM.unmountComponentAtNode(container[0]);
	    }
	
	    this.props.onHide();
	  },
	  _renderContainer: function _renderContainer() {
	    var options;
	    if (!this.props.lazy_options) {
	      options = this._renderOptions();
	    }
	
	    return React.createElement(
	      "div",
	      { className: "aui-style-default aui-dropdown2 hc-dropdown-container", id: this.props.dropdown_id, "aria-hidden": "true" },
	      options
	    );
	  },
	  _renderTrigger: function _renderTrigger() {
	    return React.createElement(
	      "button",
	      { className: "hc-dropdown-trigger aui-dropdown2-trigger " + this.props.button_class,
	        "aria-owns": this.props.dropdown_id,
	        "aria-haspopup": "true",
	        "data-container": this.props.container,
	        id: this.props.dropdown_id + "-trigger",
	        "data-no-focus": true },
	      React.createElement("span", { className: "aui-icon aui-icon-small " + this.props.icon })
	    );
	  },
	  _renderOptions: function _renderOptions() {
	    var options = this.props.children;
	
	    if (this.props.lazy_options) {
	      options = this.props.lazy_options();
	    }
	
	    return React.createElement(
	      "div",
	      { className: "aui-dropdown2-section" },
	      options
	    );
	  },
	  _getContainer: function _getContainer() {
	    // TODO: HC-20466 - use $ instead of AJS.$ when we consolidate jquery instances
	    return AJS.$("#" + this.props.dropdown_id);
	  },
	  _getTrigger: function _getTrigger() {
	    // TODO: HC-20466 - use $ instead of AJS.$ when we consolidate jquery instances
	    return AJS.$("#" + this.props.dropdown_id + "-trigger");
	  },
	  _dismiss: function _dismiss() {
	    this._getTrigger().trigger("aui-button-invoke");
	  }
	});

/***/ },
/* 593 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var IntegrationsActions = __webpack_require__(420);
	
	module.exports = React.createClass({
	
	  displayName: "ActionsDropDownItem",
	
	  propTypes: {
	    msg: React.PropTypes.shape({
	      mid: React.PropTypes.string,
	      room: React.PropTypes.string
	    }),
	    action: React.PropTypes.shape({
	      addon_key: React.PropTypes.string,
	      full_key: React.PropTypes.string,
	      key: React.PropTypes.string,
	      target: React.PropTypes.shape({
	        key: React.PropTypes.string
	      })
	    }),
	    action_type: React.PropTypes.string
	  },
	
	  componentDidMount: function componentDidMount() {
	    // Manually attach event listener, as event is triggered from AUI
	    ReactDOM.findDOMNode(this.refs.element).addEventListener("click", this._onClick);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    ReactDOM.findDOMNode(this.refs.element).removeEventListener("click", this._onClick);
	  },
	
	  render: function render() {
	    var action = this.props.action;
	
	    return React.createElement(
	      "li",
	      { key: action.full_key },
	      React.createElement(
	        "a",
	        { ref: "element",
	          "data-addon_key": action.addon_key,
	          "data-action_key": action.key },
	        action.name
	      )
	    );
	  },
	  _onClick: function _onClick() {
	    IntegrationsActions.invokeAction(this.props.action, { msg: this.props.msg });
	  }
	});

/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chat_input_strings = __webpack_require__(263);
	
	var _chat_input_strings2 = _interopRequireDefault(_chat_input_strings);
	
	var _message_actions = __webpack_require__(595);
	
	var _message_actions2 = _interopRequireDefault(_message_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "EditMessage",
	
	  propTypes: {
	    msg: React.PropTypes.shape({
	      mid: React.PropTypes.string,
	      room: React.PropTypes.string,
	      body: React.PropTypes.string
	    })
	  },
	
	  render: function render() {
	    return React.createElement(
	      'a',
	      { title: _chat_input_strings2.default.edit_message, onClick: this._onClick },
	      _chat_input_strings2.default.edit_message
	    );
	  },
	  _onClick: function _onClick() {
	    _message_actions2.default.initiateMessageEdit(this.props.msg);
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 595 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	
	  initiateMessageEdit: function initiateMessageEdit(msg) {
	    _app_dispatcher2.default.dispatch('initiate-edit-message', msg);
	  },
	
	  initiateMessageDelete: function initiateMessageDelete(msg) {
	    _app_dispatcher2.default.dispatch('initiate-delete-message', msg);
	  }
	
	};
	module.exports = exports['default'];

/***/ },
/* 596 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chat_input_strings = __webpack_require__(263);
	
	var _chat_input_strings2 = _interopRequireDefault(_chat_input_strings);
	
	var _message_actions = __webpack_require__(595);
	
	var _message_actions2 = _interopRequireDefault(_message_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "DeleteMessage",
	
	  propTypes: {
	    msg: React.PropTypes.shape({
	      mid: React.PropTypes.string,
	      room: React.PropTypes.string,
	      body: React.PropTypes.string
	    })
	  },
	
	  render: function render() {
	    return React.createElement(
	      'a',
	      { title: _chat_input_strings2.default.delete_message, onClick: this._onClick },
	      _chat_input_strings2.default.delete_message
	    );
	  },
	  _onClick: function _onClick() {
	    _message_actions2.default.initiateMessageDelete(this.props.msg);
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 597 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _chat_window_actions = __webpack_require__(178);
	
	var _chat_window_actions2 = _interopRequireDefault(_chat_window_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "AttachedCardsToggle",
	
	  propTypes: {
	    mid: React.PropTypes.string,
	    collapsed: React.PropTypes.bool
	  },
	
	  _onToggle: function _onToggle() {
	    _chat_window_actions2.default.toggleAttachedCards(this.props.mid);
	  },
	  render: function render() {
	    var collapsed = this.props.collapsed;
	    var classes = (0, _classnames2.default)({
	      "toggle-attached": true,
	      "expand": collapsed,
	      "collapse": !collapsed
	    });
	    var toggleText = collapsed ? "Show card" : "Hide card";
	
	    return React.createElement(
	      'div',
	      { className: 'toggle-attached-container', title: toggleText, onClick: this._onToggle },
	      React.createElement(
	        'span',
	        { className: classes },
	        toggleText
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 598 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _video_utils = __webpack_require__(132);
	
	var _video_utils2 = _interopRequireDefault(_video_utils);
	
	var _video_actions = __webpack_require__(172);
	
	var _video_actions2 = _interopRequireDefault(_video_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "ChatWindowMessageWrapper",
	
	  _onClick: function _onClick(evt) {
	    var isLink = _.get(evt, 'target.tagName', '').toLowerCase() === 'a';
	    var url = _.get(evt, 'target.href', null);
	    var jid = this.props.msg.room;
	    var room_id = this.props.chat_id;
	
	    if (!this.props.is_guest && isLink && !!url && _video_utils2.default.isVideoLink(url)) {
	      evt.preventDefault();
	      _video_actions2.default.joinRoomVideoCall({ url: url, jid: jid, room_id: room_id });
	    }
	  },
	  render: function render() {
	    var msgRef = void 0,
	        msgClasses = void 0;
	
	    if (this.props.messageStatus === 'failed') {
	      msgRef = 'failed_message';
	      msgClasses = 'msg-status msg-failed';
	    } else if (this.props.messageStatus === 'flaky') {
	      msgRef = 'flaky_message';
	      msgClasses = 'msg-status msg-fail-container msg-flaky hc-msg-loading';
	    } else if (this.props.messageStatus === 'unconfirmed') {
	      msgRef = 'unconfirmed_message';
	      if (this.props.honest_messages_enabled) {
	        msgClasses = 'msg-status msg-unconfirmed';
	      } else {
	        msgClasses = 'msg-status msg-confirmed';
	      }
	    } else {
	      msgRef = 'confirmed_message';
	      if (this.props.msg.type === 'file') {
	        msgClasses = 'msg-status msg-confirmed hc-msg-file';
	      } else {
	        msgClasses = 'msg-status msg-confirmed';
	      }
	    }
	
	    return React.createElement(
	      'div',
	      { ref: msgRef, onClick: this._onClick, className: msgClasses },
	      this.props.innerMessage
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 599 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _keys = __webpack_require__(100);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _toConsumableArray2 = __webpack_require__(117);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _getIterator2 = __webpack_require__(114);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _defineProperty2 = __webpack_require__(157);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _freeze = __webpack_require__(136);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	var _isFrozen = __webpack_require__(600);
	
	var _isFrozen2 = _interopRequireDefault(_isFrozen);
	
	exports.hasEmoticons = hasEmoticons;
	exports.sortMessages = sortMessages;
	exports.withoutManufacturedMessages = withoutManufacturedMessages;
	exports.getMessageCountToPreserveInBg = getMessageCountToPreserveInBg;
	exports.getMessageCountToPreserve = getMessageCountToPreserve;
	exports.addSortTime = addSortTime;
	exports.addNewMessages = addNewMessages;
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _dal = __webpack_require__(206);
	
	var _dal2 = _interopRequireDefault(_dal);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _network_status_helper = __webpack_require__(218);
	
	var _network_status_helper2 = _interopRequireDefault(_network_status_helper);
	
	var _emoticons = __webpack_require__(110);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _analytics = __webpack_require__(603);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function deepFreeze(o) {
	  if (!(0, _isFrozen2.default)(o)) {
	    (0, _freeze2.default)(o);
	  }
	
	  if (_.isArray(o)) {
	    o.forEach(deepFreeze);
	  } else if (_.isObject(o)) {
	    _.forOwn(o, deepFreeze);
	  }
	
	  return o;
	} /*global HC*/
	
	
	var NoMessages = deepFreeze([]);
	
	/*
	 * Create message clone with updated fields.
	 *
	 * @param {Object} msg source message
	 * @param {Object|Function} patch object with new message fields or function which returns such object.
	 * @returns {Object} cloned message with updated fields.
	 */
	function patchMsg(msg, patch) {
	  if (_.isFunction(patch)) {
	    patch = patch(msg);
	  }
	  return _.defaultsDeep({}, patch, msg);
	}
	
	function sortingIdentity(msg) {
	  return [msg.sortTime || msg.time, msg.time];
	}
	
	function insertSortedMsg(messages, msg) {
	  var pos = _.sortedLastIndexBy(messages, msg, sortingIdentity);
	  messages.splice(pos, 0, msg);
	}
	
	function patchMsgByMid(chat, mid, patch) {
	  var pos = _.findIndex(chat.messages, { mid: mid });
	  if (pos === -1) {
	    return undefined;
	  }
	
	  var original = chat.messages[pos];
	  var patched = patchMsg(original, patch);
	
	  var messages = _.clone(chat.messages);
	
	  if (original.time === patched.time) {
	    // replace old msg
	    messages.splice(pos, 1, patched);
	  } else {
	    // remove old msg
	    messages.splice(pos, 1);
	    // insert new one
	    insertSortedMsg(messages, patched);
	  }
	
	  deepFreeze(messages);
	
	  chat.messages = messages;
	
	  return patched;
	}
	
	var emoticonsRegExp = /\([a-z0-9]*\)/gi;
	
	function hasEmoticons(str) {
	  emoticonsRegExp.lastIndex = 0;
	  return emoticonsRegExp.test(str) || !!_.findKey(_emoticons.smileys, function (smiley) {
	    smiley.regex.lastIndex = 0;
	    return smiley.regex.test(str);
	  });
	}
	
	function sortMessages(messages) {
	  return _.sortBy(messages, sortingIdentity);
	}
	
	function isIgnoredMessage(msg) {
	  return msg.is_presence_message || msg.is_missed_call_message || _.includes(['unconfirmed', 'failed', 'flaky'], msg.status);
	}
	
	function withoutManufacturedMessages(messages) {
	  return _.reject(messages, isIgnoredMessage);
	}
	
	function getMessageCountToPreserveInBg(chat, messages) {
	  var unreadMessagesCount = chat.unreadCount || 0;
	
	  if (chat.isScrolledToBottom) {
	    return _app_config2.default.chat_room_trim_buffer + unreadMessagesCount;
	  }
	
	  var visibleMsgsCount = messages.length - _.findLastIndex(messages, { mid: chat.oldestVisibleMessageMid });
	  return _app_config2.default.chat_room_trim_buffer + unreadMessagesCount + visibleMsgsCount;
	}
	
	function getMessageCountToPreserve(chat, messages) {
	  if (chat.isScrolledToBottom && messages.length > _app_config2.default.chat_room_trim_buffer) {
	    return messages.length - 1;
	  }
	
	  return messages.length;
	}
	
	function addSortTime(msg, lookupMessageByMid) {
	  var attach_reordering_enabled = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	  if (!attach_reordering_enabled) {
	    // not enabled
	    return;
	  }
	
	  if (msg.sortTime) {
	    // previously done
	    return;
	  }
	
	  var attachTo = _utils2.default.getAttachToMid(msg);
	  if (!attachTo) {
	    return;
	  }
	
	  var parent = lookupMessageByMid(attachTo);
	  if (parent) {
	    msg.sortTime = parent.time;
	
	    // Original times are in seconds
	    var deltaMins = (msg.time - parent.time) / 60;
	    if (deltaMins > _app_config2.default.notification_attach_to_reorder_limit_mins) {
	      // Outside the allowed send window, don't reorder the notification
	      msg.sortTime = msg.time;
	    }
	  }
	}
	
	function addNewMessages(messages, newMessages) {
	  var attach_reordering_enabled = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	  if (!newMessages.length) {
	    return messages;
	  }
	
	  var result = _.clone(messages);
	
	  var newMessagesByMid = null;
	  var messagesByMid = null;
	
	  /**
	   * Finds a message by it's mid in newMessages, or if not found messages.
	   *
	   * Will lazily initialise the mapping from mid to message to avoid doing it if not required.
	   *
	   * @param mid
	   * @return the found message, if not undefined
	   */
	  function lookupMessageByMid(mid) {
	    var msg = void 0;
	
	    if (!newMessagesByMid) {
	      newMessagesByMid = _.keyBy(newMessages, 'mid');
	    }
	
	    msg = newMessagesByMid[mid];
	
	    if (!msg) {
	      if (!messagesByMid) {
	        messagesByMid = _.keyBy(messages, 'mid');
	      }
	
	      msg = messagesByMid[mid];
	    }
	
	    return msg;
	  }
	
	  // insert new messages using binary search
	  newMessages.forEach(function (msg) {
	    addSortTime(msg, lookupMessageByMid, attach_reordering_enabled);
	
	    // check if there is already message with such mid
	    var pos = _.findIndex(result, { mid: msg.mid });
	    if (pos > -1) {
	      // if yes then replace it with new instance
	      result.splice(pos, 1, msg);
	    } else {
	      // if no then just add new message
	      insertSortedMsg(result, msg);
	    }
	  });
	
	  return result;
	}
	
	var ChatWindowStore = function (_Store) {
	  (0, _inherits3.default)(ChatWindowStore, _Store);
	
	  function ChatWindowStore() {
	    (0, _classCallCheck3.default)(this, ChatWindowStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ChatWindowStore).call(this));
	
	    _this.local = {
	      should_queue_changes: {},
	      queued_messages: {},
	      echoed_chats: {},
	      replacement_messages: {},
	      flaky_network_failed_timestamp: false,
	      flaky_network_recoverable_timestamp: false,
	      failed_messages: [],
	      messages_timers: {},
	      history_timers: {}
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(ChatWindowStore, [{
	    key: 'getNowTimestamp',
	    value: function getNowTimestamp() {
	      var now = Date.now() / 1000;
	      return _utils2.default.format_time_for_history(now);
	    }
	  }, {
	    key: 'getChatDefaults',
	    value: function getChatDefaults() {
	      return {
	        name: '',
	        jid: '',
	        messages: [],
	        oldest_timestamp: '',
	        newest_timestamp: this.getNowTimestamp(),
	        oldest_mid: '',
	        newest_mid: '',
	        scrollTop: '',
	        isScrolledToBottom: true,
	        active: false,
	        fully_initialized: false,
	        fetching_recent: false,
	        fetching_ancient: false,
	        ancient_history_is_empty: false,
	        has_no_message_history: false,
	        should_scroll_to_bottom: true,
	        ancient_msgs: {},
	        recent_msgs: {},
	        is_composing: false,
	        last_active: false,
	        has_been_cleared: false
	      };
	    }
	  }, {
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        current_user: {},
	        chats: {},
	        active_chat: false,
	        active_chat_changed_token: null,
	        mentionRegex: null,
	        emoticons: {},
	        preferences: {},
	        initialized: false,
	        replace_text_emoticons: _preferences_store2.default.shouldReplaceTextEmoticons(),
	        chat_show_sidebar: _preferences_store2.default.shouldShowChatSidebar(),
	        groupchat_show_sidebar: _preferences_store2.default.shouldShowGroupChatSidebar(),
	        zoom_level: 1,
	        web_server: ''
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit() {
	          _this2.set('active_chat', _preferences_store2.default.getChatToFocus());
	        },
	        'initialize-chat-window-store': function initializeChatWindowStore(data) {
	          _this2.set(data);
	        }
	      });
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(config) {
	          _this2.set({
	            attach_reordering_enabled: _.get(config, 'feature_flags.web_client_attach_to_message_reorder_enabled'),
	            honest_messages_enabled: _.get(config, 'feature_flags.web_client_honest_messages')
	          });
	        },
	        'updated:emoticons': function updatedEmoticons(emoticons) {
	          _this2.updateEmoticons(emoticons);
	        },
	        'updated:web_server': function updatedWeb_server(server) {
	          _this2.data.web_server = server;
	        },
	        'updated:current_user': function updatedCurrent_user(user) {
	          _this2.data.current_user.user_jid = user.user_jid;
	          _this2.data.current_user.is_guest = user.is_guest;
	        },
	        'updated:mentionRegex': function updatedMentionRegex(regex) {
	          _this2.data.mentionRegex = regex;
	        },
	        'updated:activeRooms': function updatedActiveRooms(rooms) {
	          _this2.updateRooms(rooms);
	        },
	        'updated:newMessages': function updatedNewMessages(messages) {
	          _this2.updateChatMessages(messages);
	        },
	        'updated:preferences': function updatedPreferences(newPreferences) {
	          _this2._onPreferencesUpdated(newPreferences);
	        },
	        'before:updated:active_chat': function beforeUpdatedActive_chat(jid) {
	          var chat = _this2.data.chats[_this2.data.active_chat];
	          if (!chat) {
	            return;
	          }
	          if (jid !== _this2.data.active_chat) {
	            // if switching rooms, clear indicated last read
	            chat.last_read_indicated = null;
	          }
	          if (_this2.data.chats[_this2.data.active_chat].fully_initialized) {
	            _this2.flushQueue(_this2.data.active_chat);
	            _this2.updateMessageBounds(chat);
	            chat.last_active = new Date();
	          }
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          if (_utils2.default.jid.is_chat(jid) && _this2.data.chats[jid] && _this2.data.initialized) {
	            _this2.handleRoomSelect(jid);
	          } else {
	            _this2.set('active_chat', jid);
	          }
	          _app_dispatcher2.default.dispatch('close-file-viewer');
	        },
	        'send-message': function sendMessage(data) {
	          _this2.data.chats[data.jid].should_scroll_to_bottom = true;
	          if (!_this2.data.chats[data.jid].fetching_ancient) {
	            _this2.flushQueue(data.jid);
	          }
	        },
	        'upload-file': function uploadFile(data) {
	          _this2.data.chats[data.jid].should_scroll_to_bottom = true;
	        },
	        'toggle-image': function toggleImage(data) {
	          _this2.toggleImage(data.jid, data.mid);
	        },
	        'retry-failed-message': function retryFailedMessage(msg) {
	          _this2.resendMessage(msg);
	        },
	        'cancel-failed-message': function cancelFailedMessage(msg) {
	          _this2.removeFailedMessage(msg);
	        },
	        'clear-messages': function clearMessages(data) {
	          var chat = _this2.data.chats[data.jid];
	          if (chat) {
	            chat.messages = NoMessages;
	            chat.has_been_cleared = true;
	            _this2.updateChats(data.jid);
	          }
	        },
	        'app-state-ready': function appStateReady() {
	          if (_this2.data.current_user.is_guest) {
	            _this2.data.chats[_this2.data.active_chat].fully_initialized = true;
	          }
	          _this2.set('initialized', true);
	          if (_utils2.default.jid.is_chat(_this2.data.active_chat)) {
	            _this2.handleRoomSelect(_this2.data.active_chat);
	          }
	        },
	        'readstate-received': function readstateReceived() {
	          if (_utils2.default.jid.is_chat(_this2.data.active_chat) && _this2.data.chats[_this2.data.active_chat]) {
	            _this2.handleRoomSelect(_this2.data.active_chat);
	          }
	        },
	        'initial-join-presence-sent': function initialJoinPresenceSent(data) {
	          if (_this2.data.chats[data.jid] && data.with_history) {
	            _this2.initialJoinWithHistory(data.jid);
	            _this2.handleRoomSelect(data.jid);
	          }
	        },
	        'set-scroll-value': function setScrollValue(data) {
	          _.assign(_this2.data.chats[data.jid], {
	            scrollTop: data.scrollTop,
	            isScrolledToBottom: data.isScrolledToBottom,
	            should_scroll_to_bottom: data.should_scroll_to_bottom
	          });
	        },
	        'message-media-loaded': function messageMediaLoaded(data) {
	          if (!_this2.data.chats[data.jid]) {
	            _logger2.default.type('message-media-loaded').error('Room is not found', data.jid);
	            return;
	          }
	          var msg = patchMsgByMid(_this2.data.chats[data.jid], data.mid, {
	            media_loaded: true
	          });
	          if (msg) {
	            _this2.updateChats(msg.room);
	          }
	        },
	        'message-media-size-found': function messageMediaSizeFound(data) {
	          if (!_this2.data.chats[data.jid]) {
	            _logger2.default.type('message-media-size-found').error('Room is not found', data.jid);
	            return;
	          }
	          var msg = patchMsgByMid(_this2.data.chats[data.jid], data.mid, {
	            media_sizes: (0, _defineProperty3.default)({}, data.src, data.size)
	          });
	          if (msg) {
	            _this2.updateChats(msg.room);
	          }
	        },
	        'display-message-action': function displayMessageAction(data) {
	          var chat = _.get(_this2.data.chats, data.jid, {});
	          var should_scroll_to_bottom = chat.should_scroll_to_bottom;
	          var message_action_active = chat.message_action_active || false;
	          var next_state = { should_scroll_to_bottom: should_scroll_to_bottom, message_action_active: message_action_active };
	
	          var states = _.get(chat, "message_action_previous_state", []);
	          states.push(next_state);
	
	          _.assign(_this2.data.chats[data.jid], {
	            should_scroll_to_bottom: false,
	            isScrolledToBottom: false,
	            message_action_active: true,
	            message_action_previous_state: states
	          });
	        },
	        'hide-message-action': function hideMessageAction(data) {
	          var chat = _.get(_this2.data.chats, data.jid, {});
	          var previous_states = _.get(chat, "message_action_previous_state", [{
	            should_scroll_to_bottom: chat.should_scroll_to_bottom,
	            message_action_active: false
	          }]);
	
	          var previous_state = previous_states.pop();
	          var should_scroll_to_bottom = previous_state.should_scroll_to_bottom;
	          var message_action_active = previous_state.message_action_active;
	
	          _.assign(_this2.data.chats[data.jid], {
	            should_scroll_to_bottom: should_scroll_to_bottom,
	            message_action_active: message_action_active,
	            message_action_previous_state: previous_states
	          });
	
	          // Force chat to bottom if was previously at bottom of screen
	          _this2.updateChats(data.jid);
	        },
	        'chat-is-scrolling': function chatIsScrolling(data) {
	          _this2.local.should_queue_changes[data.jid] = data.scrolling;
	          if (!data.scrolling) {
	            _this2.flushQueue(data.jid);
	          }
	        },
	        'requesting-ancient-history': function requestingAncientHistory(data) {
	          if (!_this2.data.current_user.is_guest) {
	            _this2.fetchXMPPHistory(data.jid);
	          }
	        },
	        'network-down': function networkDown() {
	          _this2.local.flaky_network_failed_timestamp = _utils2.default.now() + _dal2.default.Connection.getSessionRecoveryTime();
	          _this2.local.flaky_network_recoverable_timestamp = _utils2.default.now() + _app_config2.default.flaky_network_message_timeout;
	        },
	        'network-up': function networkUp() {
	          _this2.local.flaky_network_failed_timestamp = false;
	          _this2.local.flaky_network_recoverable_timestamp = false;
	        },
	        'strophe-reconnected': function stropheReconnected() {
	          //after strophe reconnects, we need to defer this until after the config is updated due to the startup iq coming in
	          _app_dispatcher2.default.registerOnce('after:updated:config', function () {
	            _app_dispatcher2.default.dispatch('hide-join-messages');
	            _this2.local.flaky_network_failed_timestamp = false;
	            _this2.local.flaky_network_recoverable_timestamp = false;
	            if (!_this2.data.current_user.is_guest) {
	              _.forEach(_.filter(_this2.data.chats, 'fully_initialized'), function (room) {
	                _this2.fetchAPIHistory(room.jid);
	              });
	
	              _.forEach(_this2.data.chats, function (room) {
	                if (room.fetching_ancient) {
	                  _this2.fetchXMPPHistory(room.jid, true);
	                }
	              });
	
	              if (_utils2.default.jid.is_chat(_this2.data.active_chat) && _this2.data.chats[_this2.data.active_chat] && !_this2.data.chats[_this2.data.active_chat].fully_initialized) {
	                _this2.fetchXMPPHistory(_this2.data.active_chat, true);
	              }
	            }
	          });
	        },
	        'show-empty-state': function showEmptyState(data) {
	          _this2.data.chats[data.jid].ancient_history_is_empty = true;
	          _this2.updateChats(data.jid);
	        },
	        'status-message-received': function statusMessageReceived(data) {
	          _this2.handleUserStateMessage(data);
	        },
	        'replacement-message-received': function replacementMessageReceived(data) {
	          if (_this2.local.replacement_messages[data.jid]) {
	            _this2.local.replacement_messages[data.jid].push(data);
	          } else {
	            _this2.local.replacement_messages[data.jid] = [data];
	          }
	        },
	        'set-chat-panel-zoom': function setChatPanelZoom(data) {
	          _this2.set({
	            zoom_level: data.zoom
	          });
	        },
	        'toggle-attached-cards': function toggleAttachedCards(anchor_mid) {
	          _this2.toggleAttachedCards(anchor_mid);
	        },
	        'before:API:fetched-recent-history': function beforeAPIFetchedRecentHistory(data) {
	          var chat = _this2.data.chats[data.jid];
	          if (chat) {
	            // Blow away all messages if the fetched messages begin with a mid that we haven't received yet
	            if (data.mid && _.map(data.results, 'id').indexOf(data.mid) === -1) {
	              _this2.removeChatMessages(data.jid);
	            }
	          }
	        },
	        'API:fetched-recent-history': function APIFetchedRecentHistory(data) {
	          _this2.handleRecentHistoryFetched(data);
	        },
	        'get-last-message-sent-by-current-user': function getLastMessageSentByCurrentUser(data) {
	          data.cb(_this2.getLastSentMessageByCurrentUser(data.jid));
	        },
	        'get-public-url-from-thumbnail': function getPublicUrlFromThumbnail(url, jid, cb) {
	          _this2.getPublicUrlFromThumbnail(url, jid, cb);
	        }
	      });
	    }
	  }, {
	    key: 'updateEmoticons',
	    value: function updateEmoticons(emoticons) {
	      this.data.emoticons = emoticons;
	    }
	  }, {
	    key: 'getPublicUrlFromThumbnail',
	    value: function getPublicUrlFromThumbnail(url, jid, cb) {
	      var file = null;
	      var fileUrl = null;
	      var activeChat = this.get('chats')[jid];
	      var messages = activeChat && activeChat.messages || [];
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = (0, _getIterator3.default)(messages), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var message = _step.value;
	
	          if (message.file_data && message.file_data.preview_thumbnail) {
	            if (message.file_data.preview_thumbnail.src === url) {
	              file = message.file_data;
	              break;
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      if (file && file.is_authenticated) {
	        fileUrl = file.url;
	      }
	
	      cb(fileUrl);
	    }
	  }, {
	    key: 'updateRooms',
	    value: function updateRooms(rooms) {
	      var _this3 = this;
	
	      var hasChanged,
	          jids = _.keys(rooms),
	          deleted = _.difference(_.keys(this.data.chats), jids);
	
	      if (deleted.length) {
	        this.data.chats = _.omit(this.data.chats, deleted);
	        hasChanged = true;
	      } else {
	        _.forEach(jids, function (jid) {
	          if (_this3.data.chats[jid]) {
	            // Update Room Name
	            if (_this3.data.chats[jid].name !== rooms[jid].name) {
	              _this3.data.chats[jid].name = rooms[jid].name;
	              hasChanged = true;
	            }
	
	            _.assign(_this3.data.chats[jid], rooms[jid]);
	          } else {
	            _this3.data.chats[jid] = _.assign({}, _this3.getChatDefaults(), {
	              name: rooms[jid].name,
	              jid: jid,
	              active: jid === _this3.data.active_chat,
	              last_active: new Date()
	            });
	            _this3.data.chats[jid].messages = NoMessages;
	            hasChanged = true;
	          }
	        });
	      }
	
	      if (hasChanged) {
	        this.set({
	          chats: this.data.chats,
	          active_chat_changed_token: {}
	        });
	      }
	    }
	  }, {
	    key: 'handleRoomSelect',
	    value: function handleRoomSelect(jid) {
	      var chat = this.data.chats[jid];
	      if ((!chat.fully_initialized || chat.newest_mid === "") && !chat.has_no_message_history && !this.data.current_user.is_guest) {
	        this.fetchXMPPHistory(jid);
	      }
	      this.updateMessageBounds(chat);
	
	      var messages = chat.messages;
	
	      // only update last read if user is switching chats
	      if (jid !== this.data.active_chat) {
	        chat.messages = this.updateLastReadForMessages(chat);
	        this.data.active_chat = jid;
	      }
	
	      // if messages array changed then freeze it again
	      if (messages !== chat.messages) {
	        deepFreeze(chat.messages);
	      }
	
	      if (!chat.has_been_cleared) {
	        this.checkIfEmpty(jid);
	      }
	
	      this.updateAncientHistoryMarker(jid);
	      this.updateChats(jid);
	    }
	  }, {
	    key: 'updateLastReadForMessages',
	    value: function updateLastReadForMessages(chat) {
	      var messages = [];
	
	      // only set last_read_indicated if last_read_message and most_recent_message are not the same
	      if (_.get(chat, 'last_read_message.mid') !== _.get(chat, 'most_recent_message.mid')) {
	        chat.last_read_indicated = _.clone(chat.last_read_message);
	      }
	
	      chat.messages.forEach(function (currentMsg, index, arr) {
	        var currentMsgTime = Number(currentMsg.ts) || Number(currentMsg.time);
	        var nextMsg = arr[index + 1];
	        var nextMsgTime = null;
	        var lastReadIndicatedTime = _.get(chat, 'last_read_indicated.timestamp');
	        if (nextMsg) {
	          nextMsgTime = Number(nextMsg.ts) || Number(nextMsg.time);
	        }
	        // clear previous last_read_message on message
	        if (_.get(currentMsg, 'last_read_message')) {
	          currentMsg = patchMsg(currentMsg, { last_read_message: false });
	        }
	        if (lastReadIndicatedTime >= currentMsgTime && nextMsg && lastReadIndicatedTime < nextMsgTime) {
	          // if there is an attached message update the last_read_indicated so it will appear after it
	          if (_.get(nextMsg, 'attach-to.id') === currentMsg.mid) {
	            chat.last_read_indicated = {
	              mid: nextMsg.mid,
	              timestamp: nextMsg.ts
	            };
	          } else {
	            return messages.push(patchMsg(currentMsg, { last_read_message: true }));
	          }
	        }
	        return messages.push(currentMsg);
	      });
	
	      return messages;
	    }
	  }, {
	    key: 'updateMessageBounds',
	    value: function updateMessageBounds(chat) {
	      if (_.isEmpty(chat.messages)) {
	        this.resetMessageBounds(chat);
	        return;
	      }
	
	      var messages = withoutManufacturedMessages(chat.messages);
	
	      if (!messages.length) {
	        return;
	      }
	
	      var first = _.head(messages),
	          last = _.last(messages);
	
	      _.assign(chat, {
	        newest_timestamp: _utils2.default.format_time_for_history(last.time),
	        newest_mid: last.mid.split('-link')[0],
	        oldest_timestamp: _utils2.default.format_time_for_history(first.time),
	        oldest_mid: first.mid.split('-link')[0]
	      });
	    }
	  }, {
	    key: 'resetMessageBounds',
	    value: function resetMessageBounds(chat) {
	      _.assign(chat, {
	        oldest_timestamp: '',
	        newest_timestamp: this.getNowTimestamp(),
	        oldest_mid: '',
	        newest_mid: ''
	      });
	    }
	  }, {
	    key: 'trimMessages',
	    value: function trimMessages(chat) {
	      var messages = withoutManufacturedMessages(chat.messages),
	          numMessagesToPreserve,
	          numMessagesToDelete;
	
	      if (this.chatIsBackgrounded(chat.jid)) {
	        numMessagesToPreserve = getMessageCountToPreserveInBg(chat, messages);
	      } else {
	        numMessagesToPreserve = getMessageCountToPreserve(chat, messages);
	      }
	      numMessagesToDelete = messages.length - numMessagesToPreserve;
	
	      if (numMessagesToDelete > 0) {
	        var _ref;
	
	        var messagesToDelete = _.take(messages, numMessagesToDelete);
	        return (_ref = _).without.apply(_ref, [chat.messages].concat((0, _toConsumableArray3.default)(messagesToDelete)));
	      }
	
	      return chat.messages;
	    }
	  }, {
	    key: 'chatIsBackgrounded',
	    value: function chatIsBackgrounded(jid) {
	      var chat = this.getChat(jid);
	      var idleMinutesAgo = (0, _moment2.default)().subtract(_app_config2.default.chat_room_idle_timeout_minutes, 'minutes');
	      return chat && chat.jid !== this.data.active_chat && chat.last_active !== false && (0, _moment2.default)(chat.last_active).isBefore(idleMinutesAgo);
	    }
	  }, {
	    key: 'getChat',
	    value: function getChat(jid) {
	      return this.data.chats[jid];
	    }
	  }, {
	    key: 'updateChatMessages',
	    value: function updateChatMessages(chats) {
	      var _this4 = this;
	
	      var chat;
	      _.forEach(chats, function (messages, jid) {
	        chat = _this4.data.chats[jid];
	        if (chat) {
	          var chat_is_backgrounded_and_empty = jid !== _this4.data.active_chat && _.isEmpty(chat.messages),
	
	
	          // If the messages array is only join/leave messages, this is false
	          contains_real_messages = _.reject(messages, 'is_presence_message').length;
	
	          if ((chat.fetching_ancient || chat_is_backgrounded_and_empty) && !chat.fetching_recent) {
	            _.merge(chat.ancient_msgs, messages);
	            if (chat_is_backgrounded_and_empty && !HC.isEmbeddedComponent && !_this4.data.current_user.is_guest && contains_real_messages) {
	              _this4.fetchXMPPHistory(jid);
	            }
	          }
	          if (!(chat_is_backgrounded_and_empty && !contains_real_messages)) {
	            _this4.addMessages(jid, _.keyBy(messages, 'mid'));
	          }
	        }
	      });
	    }
	  }, {
	    key: '_onPreferencesUpdated',
	    value: function _onPreferencesUpdated() {
	      var prefsObj = {
	        preferences: _preferences_store2.default.getAll()
	      };
	
	      //onShouldReplaceTextEmoticonsUpdated
	      if (this.get('replace_text_emoticons') !== _preferences_store2.default.shouldReplaceTextEmoticons()) {
	        prefsObj['replace_text_emoticons'] = _preferences_store2.default.shouldReplaceTextEmoticons();
	        prefsObj['chats'] = this._getFormattedChats();
	      }
	
	      //onOtherPreferencesUpdated
	      prefsObj['chat_show_sidebar'] = _preferences_store2.default.shouldShowChatSidebar();
	      prefsObj['groupchat_show_sidebar'] = _preferences_store2.default.shouldShowGroupChatSidebar();
	
	      this.set(prefsObj);
	    }
	  }, {
	    key: '_getFormattedChats',
	    value: function _getFormattedChats() {
	      var chats = _.clone(this.get('chats')),
	          messages = void 0,
	          formattedMessages = void 0,
	          formatter = function formatter(result, message) {
	        var patchedMsg = message;
	
	        if (hasEmoticons(message.body)) {
	          patchedMsg = patchMsg(message, {
	            rendered_body: _utils2.default.escapeAndLinkify(message.body, {
	              do_emoticons: _preferences_store2.default.shouldReplaceTextEmoticons()
	            })
	          });
	        }
	        result.push(patchedMsg);
	
	        return result;
	      };
	
	      _.forOwn(chats, function (chat, chatId) {
	        messages = chat.messages;
	        formattedMessages = messages ? messages.reduce(formatter, []) : [];
	        chat.messages = formattedMessages;
	        chats[chatId] = chat;
	      });
	
	      return chats;
	    }
	  }, {
	    key: 'removeChatMessages',
	    value: function removeChatMessages(jid) {
	      var chat = this.data.chats[jid];
	
	      if (chat) {
	        chat.messages = NoMessages;
	        chat.hasMessages = false;
	        this.resetMessageBounds(chat);
	        this.updateChats(jid);
	      }
	    }
	  }, {
	    key: 'scheduleConfirmationFailed',
	    value: function scheduleConfirmationFailed(chat, message) {
	      var _this5 = this;
	
	      if (!chat || !_.includes(['unconfirmed', 'failed'], message.status)) {
	        return;
	      }
	
	      var timers = this.local.messages_timers[chat.jid] || {};
	      this.local.messages_timers[chat.jid] = timers;
	      var msgTimers = timers[message.mid] || {};
	      timers[message.mid] = msgTimers;
	
	      if (!msgTimers.failed_timer) {
	        var delay = this.local.flaky_network_failed_timestamp ? this.local.flaky_network_failed_timestamp - _utils2.default.now() : _app_config2.default.default_message_confirmation_timeout;
	
	        if (!_network_status_helper2.default.isOnline() || !_dal2.default.isConnected()) {
	          // cause message to immediately fail if we are not connected/online
	          delay = 0;
	        }
	
	        msgTimers.failed_timer = setTimeout(function () {
	          var msg = patchMsgByMid(chat, message.mid, { status: 'failed' });
	          if (msg) {
	            _this5.cancelMessageTimers(chat.jid, message.mid);
	            _this5.local.failed_messages.push(msg);
	            _this5.updateChats(msg.room);
	          }
	        }, delay);
	      }
	      if (!msgTimers.flaky_timer && !this.data.honest_messages_enabled) {
	        var _delay = this.local.flaky_network_recoverable_timestamp ? this.local.flaky_network_recoverable_timestamp - _utils2.default.now() : _app_config2.default.flaky_network_message_timeout;
	        msgTimers.flaky_timer = setTimeout(function () {
	          var msg = patchMsgByMid(chat, message.mid, { status: 'flaky' });
	          if (msg) {
	            _this5.cancelMessageTimers(chat.jid, message.mid, 'flaky_timer');
	            _this5.updateChats(msg.room);
	          }
	        }, _delay);
	      }
	    }
	  }, {
	    key: 'cancelMessageTimers',
	    value: function cancelMessageTimers(jid, mid, timer_name) {
	      var timers = this.local.messages_timers[jid];
	      if (!timers) {
	        return;
	      }
	
	      var msgTimers = timers[mid];
	      if (!msgTimers) {
	        return;
	      }
	
	      if (timer_name) {
	        clearTimeout(msgTimers[timer_name]);
	        msgTimers[timer_name] = undefined;
	      } else {
	        clearTimeout(msgTimers.failed_timer);
	        clearTimeout(msgTimers.flaky_timer);
	        delete timers[mid];
	      }
	    }
	  }, {
	    key: 'removeFailedMessage',
	    value: function removeFailedMessage(msg) {
	      var chat = _.get(this.data, ['chats', msg.room]);
	      if (!chat) {
	        return;
	      }
	      var shouldUpdate = this.maybeRemoveMsg(chat, msg.mid);
	      _.remove(this.local.failed_messages, { mid: msg.mid });
	
	      if (shouldUpdate) {
	        this.updateChats(msg.room);
	      }
	    }
	  }, {
	    key: 'resendMessage',
	    value: function resendMessage(msg) {
	      _app_dispatcher2.default.dispatch('resend-message', {
	        text: msg.original_body || msg.body,
	        jid: msg.room,
	        id: msg.mid
	      });
	
	      var chat = this.data.chats[msg.room];
	      if (!chat) {
	        return;
	      }
	
	      //When reattempting a send on a failed message, we want to put it to the bottom of the chat
	      var newTime = _.last(chat.messages).time + 1;
	
	      patchMsgByMid(chat, msg.mid, { status: 'unconfirmed', time: newTime });
	      this.scheduleConfirmationFailed(chat, msg);
	
	      this.updateChats(msg.room);
	    }
	  }, {
	    key: 'addMessages',
	    value: function addMessages(jid, messages) {
	      var chat = this.data.chats[jid];
	      if (!chat || _.isEmpty(messages)) {
	        return;
	      }
	
	      chat.has_no_message_history = false;
	      chat.has_been_cleared = false;
	      if (this.local.should_queue_changes[jid]) {
	        var queued_messages = this.local.queued_messages[jid] || {};
	        this.local.queued_messages[jid] = _.merge(queued_messages, messages);
	        return;
	      }
	
	      _.forEach(messages, this.scheduleConfirmationFailed.bind(this, chat));
	
	      var currentMessages = chat.messages;
	
	      var echoedMessages = this.filterMessages(jid, messages);
	      if (echoedMessages.length) {
	        var _ref2;
	
	        chat.messages = (_ref2 = _).without.apply(_ref2, [chat.messages].concat((0, _toConsumableArray3.default)(echoedMessages)));
	      }
	
	      var newMessages = _.values(messages);
	
	      this.removeOldPresenceMessages(chat, newMessages);
	
	      chat.messages = addNewMessages(chat.messages, newMessages, this.data.attach_reordering_enabled);
	
	      if (this.chatIsBackgrounded(jid)) {
	        chat.messages = this.trimMessages(chat);
	      }
	
	      chat.messages = this.replaceMessageContent(jid);
	
	      var newest_mid = chat.newest_mid;
	
	      this.updateMessageBounds(chat);
	
	      if (jid !== this.get('active_chat') && newest_mid !== chat.newest_mid) {
	        chat.should_scroll_to_bottom = true;
	      }
	
	      if (!this.chatIsBackgrounded(jid) && chat.fetching_ancient) {
	        chat.messages = this.updateLastReadForMessages(chat);
	      }
	
	      // if messages array changed then freeze it again
	      if (currentMessages !== chat.messages) {
	        deepFreeze(chat.messages);
	      }
	
	      if (chat.fully_initialized) {
	        chat.hasMessages = true;
	        chat.fetching_recent = false;
	        chat.fetching_ancient = false;
	        this.updateChats(jid);
	      }
	    }
	  }, {
	    key: 'flushQueue',
	    value: function flushQueue(jid) {
	      this.local.should_queue_changes[jid] = false;
	      this.addMessages(jid, this.local.queued_messages[jid]);
	      this.local.queued_messages[jid] = {};
	    }
	  }, {
	    key: 'updateChats',
	    value: function updateChats(jid) {
	      if (this.data.chats[jid]) {
	        var updates = {
	          chats: this.data.chats,
	          active_chat: this.data.active_chat
	        };
	
	        if (jid === this.data.active_chat) {
	          // active_chat_changed_token is used as a proxy (checking reference equality) to know if active_chat data changed
	          // and avoid re-rendering chat_panel if it didn't
	          updates["active_chat_changed_token"] = {};
	        }
	        this.set(updates);
	      }
	    }
	  }, {
	    key: 'handleUserStateMessage',
	    value: function handleUserStateMessage(data) {
	      var _this6 = this;
	
	      var jid = _utils2.default.jid.bare_jid(data.message.from),
	          chat = this.data.chats[jid],
	          user = _utils2.default.jid.bare_jid(_.get(data, 'message.delay.from_jid')) || _utils2.default.jid.bare_jid(_.get(data, 'message.from'));
	      if (chat && user) {
	        switch (data.type) {
	          case 'active':
	            if (user !== this.data.current_user.user_jid) {
	              this.removeChatStateMessage(jid);
	              clearTimeout(this.local.composing_timeout);
	            }
	            break;
	          case 'composing':
	            if (user !== this.data.current_user.user_jid) {
	              var last_received = _.findLast(chat.messages, { mid: chat.newest_mid });
	              if (!last_received || data.message.ts - last_received.ts > 1) {
	                //don't show composing message if it's been received less than a second from the last message
	                this.addChatStateMessage(jid);
	                clearTimeout(this.local.composing_timeout);
	                this.local.composing_timeout = setTimeout(function (user_jid) {
	                  _this6.removeChatStateMessage(user_jid);
	                }, _app_config2.default.composing_message_linger_timeout, jid);
	              }
	            }
	            break;
	          default:
	            break;
	        }
	        this.updateChats(jid);
	      }
	    }
	  }, {
	    key: 'fetchAPIHistory',
	    value: function fetchAPIHistory(jid) {
	      if (this.data.chats[jid] && !this.data.current_user.is_guest) {
	        this.data.chats[jid].fetching = true;
	        _app_dispatcher2.default.dispatch('API:fetch-recent-history', {
	          params: {
	            'not-before': this.data.chats[jid].newest_mid || '',
	            'max-results': _app_config2.default.message_retrieval_chunk_size
	          },
	          path: {
	            'identifier': /@chat/.test(jid) ? _utils2.default.jid.user_id(jid) : this.data.chats[jid].id,
	            'type': /@chat/.test(jid) ? 'user' : 'room'
	          },
	          jid: jid
	        });
	      }
	    }
	  }, {
	    key: 'initialJoinWithHistory',
	    value: function initialJoinWithHistory(jid) {
	      if (!this.data.current_user.is_guest) {
	        this.data.chats[jid].fetching_ancient = true;
	        this.local.should_queue_changes[jid] = true;
	      }
	    }
	  }, {
	    key: 'fetchXMPPHistoryCallback',
	    value: function fetchXMPPHistoryCallback(data) {
	      var _this7 = this;
	
	      var jid = data.from;
	      var id = data.id;
	      var error = data.error;
	
	
	      if (!error) {
	        this.handleAncientHistoryLoaded({ jid: jid, id: id });
	        delete this.local.history_timers[jid];
	      } else {
	
	        _logger2.default.type('fetch-history').error(jid, data.error);
	
	        if (!this.local.history_timers[jid]) {
	          this.local.history_timers[jid] = {
	            timer: null,
	            attempts: 0
	          };
	        }
	
	        if (this.local.history_timers[jid].attempts === _app_config2.default.chat_history_fetching_attempts) {
	          _logger2.default.type('fetch-history').info("We are reaching max attempts for fetching history:", jid);
	          return;
	        }
	
	        this.local.history_timers[jid].timer = setTimeout(function () {
	          var chat = _this7.data.chats[jid];
	          if (chat && !chat.fully_initialized) {
	            _this7.fetchXMPPHistory(jid, true);
	          }
	        }, _app_config2.default.chat_history_fetching_attempt_timeout);
	
	        this.local.history_timers[jid].attempts++;
	      }
	    }
	  }, {
	    key: 'fetchXMPPHistory',
	    value: function fetchXMPPHistory(jid, force_update) {
	      if (this.data.current_user.is_guest) {
	        return false;
	      }
	
	      _analytics_dispatcher2.default.dispatch('analytics-request-history', { jid: jid });
	
	      if (!this.data.chats[jid].fetching_ancient || force_update) {
	        var oldest = this.data.chats[jid].oldest_timestamp || null,
	            cb = this.fetchXMPPHistoryCallback.bind(this);
	
	        this.data.chats[jid].oldest_mid_before_fetch = _.get(this.data.chats[jid], 'messages[0].mid', '');
	        this.data.chats[jid].fetching_ancient = true;
	        this.local.should_queue_changes[jid] = true;
	
	        _app_dispatcher2.default.dispatch('request-ancient-history', { jid: jid, oldest: oldest }, cb);
	      }
	    }
	  }, {
	    key: 'handleRecentHistoryFetched',
	    value: function handleRecentHistoryFetched(data) {
	      var chat = this.data.chats[data.jid];
	      if (_utils2.default.jid.is_chat(data.jid) && chat) {
	        chat.populated_recent = true;
	        this.checkIfEmpty(data.jid);
	      }
	      this.updateAncientHistoryMarker(data.jid);
	    }
	  }, {
	    key: 'handleAncientHistoryLoaded',
	    value: function handleAncientHistoryLoaded(data) {
	      var chat = this.data.chats[data.jid];
	      if (chat) {
	        var queueSize = 0;
	        this.flushQueue(data.jid);
	        if (_.isEmpty(chat.ancient_msgs)) {
	          chat.ancient_history_is_empty = true;
	        } else {
	          queueSize = (0, _keys2.default)(chat.ancient_msgs).length;
	          chat.ancient_msgs = {};
	        }
	        chat.fetching_ancient = false;
	        if (!chat.fully_initialized) {
	          chat.fully_initialized = true;
	          _app_dispatcher2.default.dispatch('chat-fully-initialized', { jid: data.jid });
	        }
	        this.checkIfEmpty(data.jid);
	        this.updateChats(data.jid);
	        _app_dispatcher2.default.dispatch('ancient-history-fetched', {});
	
	        this.sendHistoryLoadedAnalytics({
	          jid: data.jid,
	          size: queueSize,
	          id: _.get(this.data.chats, [data.jid, "id"])
	        });
	      }
	    }
	  }, {
	    key: 'sendHistoryLoadedAnalytics',
	    value: function sendHistoryLoadedAnalytics(data) {
	      _analytics_dispatcher2.default.dispatch('analytics-history-loaded', data);
	
	      // executing this action from with the then() of the uiAvailablePromise handles the corner case that the
	      // chat has completed loading before the UI is available for interaction.
	      _analytics.uiAvailablePromise.then(function () {
	        _analytics_actions2.default.handleLaunchToChatComplete(data);
	      });
	    }
	  }, {
	    key: 'updateAncientHistoryMarker',
	    value: function updateAncientHistoryMarker(jid) {
	      var chat = this.data.chats[jid];
	      if (chat && chat.messages.length >= _app_config2.default.message_retrieval_chunk_size) {
	        chat.ancient_history_is_empty = false;
	      }
	    }
	  }, {
	    key: 'checkIfEmpty',
	    value: function checkIfEmpty(jid) {
	      var chat = this.data.chats[jid];
	      if (chat && !chat.fetching_ancient && !chat.fetching_recent && _.isEmpty(chat.messages) && (!this.local.queued_messages[jid] || _.isEmpty(this.local.queued_messages[jid]))) {
	        chat.has_no_message_history = true;
	        if (!chat.fully_initialized) {
	          chat.fully_initialized = true;
	        }
	      }
	    }
	  }, {
	    key: 'filterMessages',
	    value: function filterMessages(jid, messages) {
	      var _this8 = this;
	
	      var chat = this.data.chats[jid];
	      var echoedMessages = [];
	      _.forEach(messages, function (msg) {
	        var echoedMsg = _.find(chat.messages, { mid: msg.id });
	        if (echoedMsg) {
	          // message is echo of previously sent message
	          _this8._markEchoedMessage(jid, msg);
	          echoedMessages.push(echoedMsg);
	        } else if (_app_config2.default.slash_replacement_regex.test(msg.body) && msg.id && !msg.is_history_message) {
	          var replacements = _this8.local.replacement_messages[jid];
	          var replacementIndex = _.findIndex(replacements, { mid: msg.mid });
	          replacements.splice(replacementIndex, 1); // delete echoed replacement message
	          delete messages[msg.mid];
	        } else if (messages[msg.id]) {
	          // echo exists in current messages set
	          _this8._markEchoedMessage(jid, msg);
	          delete messages[msg.id];
	        } else if (_this8._wasMessagesAlreadyEchoed(jid, msg)) {
	          // echo has already been received
	          _this8._markEchoedMessage(jid, msg);
	          delete messages[msg.mid];
	        } else if (jid === _utils2.default.jid.bare_jid(msg.from)) {
	          chat.is_composing = false;
	          clearTimeout(_this8.local.composing_timeout);
	        }
	      });
	
	      return echoedMessages;
	    }
	  }, {
	    key: '_wasMessagesAlreadyEchoed',
	    value: function _wasMessagesAlreadyEchoed(jid, msg) {
	      return this.local.echoed_chats[jid] && this.local.echoed_chats[jid].messages[msg.id];
	    }
	  }, {
	    key: '_markEchoedMessage',
	    value: function _markEchoedMessage(jid, msg) {
	      this.cancelMessageTimers(jid, msg.id);
	      msg.is_echo = true;
	
	      var falseFailedMsg = _.findIndex(this.local.failed_messages, { mid: msg.id });
	
	      if (falseFailedMsg !== -1) {
	        this.local.failed_messages.splice(falseFailedMsg, 1);
	      }
	
	      if (!this.local.echoed_chats[jid]) {
	        this.local.echoed_chats[jid] = { messages: {} };
	      }
	      this.local.echoed_chats[jid].messages[msg.id] = msg;
	    }
	  }, {
	    key: 'addChatStateMessage',
	    value: function addChatStateMessage(jid) {
	      if (!this.data.chats[jid].is_composing) {
	        if (jid === this.data.active_chat) {
	          this.smoothChangeChatStateMessage(jid, true);
	        }
	        this.data.chats[jid].is_composing = true;
	      }
	    }
	  }, {
	    key: 'removeChatStateMessage',
	    value: function removeChatStateMessage(jid) {
	      if (this.data.chats[jid].is_composing) {
	        if (jid === this.data.active_chat) {
	          this.smoothChangeChatStateMessage(jid, false);
	        } else {
	          this.data.chats[jid].is_composing = false;
	        }
	      }
	    }
	  }, {
	    key: 'smoothChangeChatStateMessage',
	    value: function smoothChangeChatStateMessage(jid, isComposing) {
	      var _this9 = this;
	
	      this.local.should_queue_changes[jid] = true;
	      var action = isComposing ? 'add' : 'remove';
	      var promise = new _promise2.default(function (res) {
	        setTimeout(function () {
	          res(jid);
	        }, _app_config2.default.chat_scroll_duration);
	        _app_dispatcher2.default.dispatch(action + '-chat-state-message', { jid: jid });
	      });
	
	      promise.then(function (chat_jid) {
	        _this9.data.chats[chat_jid].is_composing = isComposing;
	        _this9.flushQueue(chat_jid);
	        _this9.updateChats(chat_jid);
	      });
	    }
	  }, {
	    key: 'replaceMessageContent',
	    value: function replaceMessageContent(jid) {
	      var replacements = this.local.replacement_messages[jid];
	
	      var messages = this.data.chats[jid].messages;
	
	      if (_.isEmpty(replacements)) {
	        return messages;
	      }
	
	      messages = _.clone(messages);
	
	      replacements.forEach(function (replacementMsg) {
	        // remove replacement messages from message array
	        var pos = _.findLastIndex(messages, { mid: replacementMsg.mid });
	        if (pos > -1) {
	          messages.splice(pos, 1);
	        }
	
	        // replacements for ninja edit
	        pos = _.findLastIndex(messages, function (entry) {
	          return entry.time <= replacementMsg.time && String(entry.sender_id) === String(replacementMsg.sender_id);
	        });
	        if (pos > -1 && !replacementMsg.edited_message) {
	          var oldMsg = messages[pos];
	
	          var newBody = void 0;
	
	          // If the message is an emote, re-apply the emote replacement (as we don't
	          // persist the replacement on the message directly).
	          if (oldMsg.isEmote) {
	            var emote = oldMsg.body.slice(0, 3);
	            var emoteMessage = oldMsg.body.slice(3);
	            newBody = emoteMessage.replace(replacementMsg.text_to_replace, replacementMsg.replacement_text);
	            newBody = _utils2.default.replaceEmoteMessage(emote + newBody, oldMsg.sender);
	          } else {
	            newBody = oldMsg.body.replace(replacementMsg.text_to_replace, replacementMsg.replacement_text);
	          }
	
	          var newMsg = patchMsg(oldMsg, { body: newBody });
	          _utils2.default.formatMessageBody(newMsg);
	          messages.splice(pos, 1, newMsg);
	        }
	
	        // replacements for new message edit
	        pos = _.findIndex(messages, { mid: _.get(replacementMsg, 'replace.id') });
	        if (pos > -1 && replacementMsg.edited_message || pos > -1 && replacementMsg.is_deleted) {
	          var patchObj = {
	            body: replacementMsg.edited_message,
	            replace: replacementMsg.replace,
	            is_deleted: replacementMsg.is_deleted
	          };
	          if (_.get(messages[pos], 'file_data.desc', false)) {
	            patchObj['file_data'] = {
	              desc: replacementMsg.edited_message,
	              is_deleted: replacementMsg.is_deleted
	            };
	          }
	          var _newMsg = patchMsg(messages[pos], patchObj);
	          _utils2.default.formatMessageBody(_newMsg);
	          messages.splice(pos, 1, _newMsg);
	        }
	      });
	
	      this.local.replacement_messages[jid].length = 0;
	
	      return _.sortBy(messages, "time");
	    }
	  }, {
	    key: 'toggleImage',
	    value: function toggleImage(jid, mid) {
	      var chat = this.data.chats[jid],
	          origMsg = void 0;
	
	      if (chat && chat.messages) {
	        origMsg = _.find(chat.messages, function (msg) {
	          return msg.mid === mid;
	        });
	
	        if (origMsg) {
	          var collapsed = !!origMsg.is_collapsed;
	          patchMsgByMid(chat, mid, { is_collapsed: !collapsed });
	          this.updateChats(jid);
	        }
	      }
	    }
	  }, {
	    key: 'toggleAttachedCards',
	    value: function toggleAttachedCards(anchor_mid) {
	      var chat = this.data.chats[this.data.active_chat],
	          origMsg = void 0;
	
	      if (chat && chat.messages) {
	        origMsg = _.find(chat.messages, function (msg) {
	          return msg.mid === anchor_mid;
	        });
	
	        if (origMsg) {
	          var collapsedDefault = _preferences_store2.default.shouldHideAttachedCardsByDefault();
	          var collapsed = _utils2.default.isAttachedCardsCollapsed(origMsg, collapsedDefault);
	          patchMsgByMid(chat, anchor_mid, { is_attached_cards_collapsed: !collapsed });
	          this.updateChats(this.data.active_chat);
	        }
	      }
	      this.updateChats(this.data.active_chat);
	    }
	  }, {
	    key: 'getLastSentMessageByCurrentUser',
	    value: function getLastSentMessageByCurrentUser(jid) {
	      var _this10 = this;
	
	      var editableTypes = {
	        'message': true,
	        'file': true
	      };
	      var lastMessages = _.filter(this.data.chats[jid].messages, function (msg) {
	        var current_user_id = _utils2.default.jid.user_id(_this10.data.current_user.user_jid);
	        return msg.sender_id === current_user_id && editableTypes[msg.type];
	      });
	      return _.last(_.sortBy(lastMessages, "time"));
	    }
	  }, {
	    key: 'removeOldPresenceMessages',
	    value: function removeOldPresenceMessages(chat, new_messages) {
	      var _this11 = this;
	
	      if (!_.isObject(chat) || !_.isArray(new_messages)) {
	        return true;
	      }
	
	      var user_jids = new_messages.reduce(function (prev, curr) {
	        if (curr.is_presence_message && curr.user_jid) {
	          prev.push(curr.user_jid);
	        }
	        return prev;
	      }, []);
	
	      if (user_jids.length && _.isArray(chat.messages)) {
	        var old_presence_messages = chat.messages.filter(function (message) {
	          return message.is_presence_message && _.includes(user_jids, message.user_jid);
	        });
	
	        old_presence_messages.forEach(function (msg) {
	          return _this11.maybeRemoveMsg(chat, msg.mid);
	        });
	      }
	    }
	  }, {
	    key: 'maybeRemoveMsg',
	    value: function maybeRemoveMsg(chat, mid) {
	      var pos = _.findIndex(chat.messages, { mid: mid });
	      if (pos === -1) {
	        return false;
	      }
	
	      var messages = _.clone(chat.messages);
	      messages.splice(pos, 1);
	      deepFreeze(messages);
	
	      chat.messages = messages;
	
	      return true;
	    }
	  }]);
	  return ChatWindowStore;
	}(_store2.default);
	
	exports.default = new ChatWindowStore();

/***/ },
/* 600 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(601), __esModule: true };

/***/ },
/* 601 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(602);
	module.exports = __webpack_require__(18).Object.isFrozen;

/***/ },
/* 602 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(44);
	
	__webpack_require__(15)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.uiAvailablePromise = undefined;
	
	var _promise = __webpack_require__(59);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Wrap the first change of AppStore::ui_available as a Promise,
	// so that components that mount after the value is set can
	// still hook into the event
	var uiAvailablePromise = new _promise2.default(function (resolve, reject) {
	  _app_dispatcher2.default.registerOnce('updated:ui_available', resolve);
	});
	
	exports.uiAvailablePromise = uiAvailablePromise;

/***/ },
/* 604 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _chat_input = __webpack_require__(605);
	
	var _chat_input2 = _interopRequireDefault(_chat_input);
	
	var _markdown_link = __webpack_require__(474);
	
	var _markdown_link2 = _interopRequireDefault(_markdown_link);
	
	var _read_only_store = __webpack_require__(334);
	
	var _read_only_store2 = _interopRequireDefault(_read_only_store);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "ChatInputBox",
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  getInitialState: function getInitialState() {
	    return this.getInputBoxState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    _roster_store2.default.on(['change:chat_type'], this._onChange);
	    _preferences_store2.default.on(['change:showChatSidebar', 'change:showGroupChatSidebar'], this._onChange);
	    _read_only_store2.default.on(['change:read_only_mode', 'change:read_only_input_markdown'], this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _roster_store2.default.off(['change:chat_type'], this._onChange);
	    _preferences_store2.default.off(['change:showChatSidebar', 'change:showGroupChatSidebar'], this._onChange);
	    _read_only_store2.default.off(['change:read_only_mode', 'change:read_only_input_markdown'], this._onChange);
	  },
	
	  getInputBoxState: function getInputBoxState() {
	    return {
	      chat_type: _roster_store2.default.get("chat_type"),
	      chat_sidebar_visible: _preferences_store2.default.shouldShowChatSidebar(),
	      groupchat_sidebar_visible: _preferences_store2.default.shouldShowGroupChatSidebar(),
	      read_only_mode: _read_only_store2.default.get('read_only_mode'),
	      read_only_input_markdown: _read_only_store2.default.get('read_only_input_markdown')
	    };
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this.getInputBoxState());
	  },
	
	  _sidebarVisible: function _sidebarVisible() {
	    return this.state[this.state.chat_type + '_sidebar_visible'];
	  },
	
	  render: function render() {
	    var chatBoxClasses = (0, _classnames2.default)({
	      'hc-chat-box': true,
	      'sidebar-hidden': !this._sidebarVisible(),
	      'hc-read-only-mode': this.state.read_only_mode
	    });
	
	    var input;
	
	    if (this.state.read_only_mode) {
	      input = React.createElement(
	        _markdown_link2.default,
	        null,
	        this.state.read_only_input_markdown
	      );
	    } else {
	      input = React.createElement(_chat_input2.default, { is_guest: this.props.is_guest, chat_type: this.state.chat_type });
	    }
	
	    return React.createElement(
	      'div',
	      { className: chatBoxClasses },
	      input
	    );
	  }
	
	});

/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chat_input_store = __webpack_require__(270);
	
	var _chat_input_store2 = _interopRequireDefault(_chat_input_store);
	
	var _flag_actions = __webpack_require__(204);
	
	var _flag_actions2 = _interopRequireDefault(_flag_actions);
	
	var _chat_input_actions = __webpack_require__(261);
	
	var _chat_input_actions2 = _interopRequireDefault(_chat_input_actions);
	
	var _file_uploader_actions = __webpack_require__(260);
	
	var _file_uploader_actions2 = _interopRequireDefault(_file_uploader_actions);
	
	var _autocomplete_actions = __webpack_require__(606);
	
	var _autocomplete_actions2 = _interopRequireDefault(_autocomplete_actions);
	
	var _message_actions = __webpack_require__(595);
	
	var _message_actions2 = _interopRequireDefault(_message_actions);
	
	var _mention_autocomplete = __webpack_require__(607);
	
	var _mention_autocomplete2 = _interopRequireDefault(_mention_autocomplete);
	
	var _emoticon_auto_complete = __webpack_require__(613);
	
	var _emoticon_auto_complete2 = _interopRequireDefault(_emoticon_auto_complete);
	
	var _slash_command_auto_complete = __webpack_require__(614);
	
	var _slash_command_auto_complete2 = _interopRequireDefault(_slash_command_auto_complete);
	
	var _tooltip = __webpack_require__(460);
	
	var _tooltip2 = _interopRequireDefault(_tooltip);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _forms_strings = __webpack_require__(262);
	
	var _forms_strings2 = _interopRequireDefault(_forms_strings);
	
	var _video_service_keys = __webpack_require__(174);
	
	var _video_service_keys2 = _interopRequireDefault(_video_service_keys);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _analytics_actions = __webpack_require__(196);
	
	var _analytics_actions2 = _interopRequireDefault(_analytics_actions);
	
	var _chat_action_button = __webpack_require__(615);
	
	var _chat_action_button2 = _interopRequireDefault(_chat_action_button);
	
	var _presence = __webpack_require__(184);
	
	var _presence2 = _interopRequireDefault(_presence);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _analytics = __webpack_require__(603);
	
	var _slash_command_helper = __webpack_require__(275);
	
	var slashCommandHelper = _interopRequireWildcard(_slash_command_helper);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var getInputState = function getInputState() {
	  return _chat_input_store2.default.getAll();
	};
	
	var lastPosn = 0;
	
	var sentActiveMessageDelay = _app_config2.default.sent_active_message_delay;
	var sentComposingMessageTimeout = void 0;
	
	var composingIntervalTimer = _app_config2.default.sent_composing_message_interval;
	var sentComposingMessageInterval = void 0;
	
	function getSelection() {
	  var hasText = false;
	  if (typeof window.getSelection !== "undefined") {
	    hasText = window.getSelection().toString();
	  } else if (typeof document.selection !== "undefined" && document.selection.type === "Text") {
	    hasText = document.selection.createRange().text;
	  }
	
	  return hasText;
	}
	
	function onDocClick(evt) {
	  var correspondingUseElement = evt.target.correspondingUseElement || evt.target;
	
	  if (evt.target !== document && !$(correspondingUseElement).is('.hc-ac-name, #hc-message-input')) {
	    _autocomplete_actions2.default.dismissMentionAutoComplete();
	    _autocomplete_actions2.default.dismissEmoticonAutoComplete();
	  }
	}
	
	var ProgressBarSelector = '#upload-progress-bar';
	
	exports.default = React.createClass({
	
	  displayName: "ChatInput",
	
	  getInitialState: function getInitialState() {
	    return getInputState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    var textArea = ReactDOM.findDOMNode(this.refs.message);
	    this._setTextAreaLayout(textArea);
	    document.addEventListener('click', this._focusIfAllowed);
	    _chat_input_store2.default.on('change', this._onChange);
	    this._debouncedOnCaretUpdate = _.debounce(this._onCaretUpdate, 20, { leading: true, trailing: true });
	    this._debouncedWindowResize = _.debounce(function () {
	      return $(window).trigger('resize');
	    }, 100, { leading: true, trailing: false });
	    this._debouncedShouldSendChatStateMessage = _.debounce(this._shouldSendChatStateMessage, 200, { leading: true, trailing: false });
	    _app_dispatcher2.default.register("application-focused", this._focusIfAllowed);
	    _app_dispatcher2.default.register("new-active-chat", this._focusIfAllowed);
	    _app_dispatcher2.default.register("hide-modal-dialog", this._focusIfAllowed);
	    _app_dispatcher2.default.register("hide-inline-dialog", this._focusIfAllowed);
	    this._focus();
	    this._moveCaretToEnd();
	    $(document).on('click', onDocClick);
	    AJS.$(document).on('aui-dropdown2-show', this._blur);
	    AJS.$(document).on('aui-dropdown2-hide', this._focusIfAllowed);
	    _analytics.uiAvailablePromise.then(this._sendLaunchToChat);
	    if (this.state.text) {
	      this._autoSize();
	    }
	    this._setUploadProgress(this.state.upload_progress, null);
	    if (this.state.file && this.state.attachment_expanded && this.state.file.file_obj && !this.state.file_error && !this.state.uploading) {
	      _chat_input_actions2.default.openTooltip({
	        type: 'upload_preview',
	        data: {
	          file: this.state.file.file_obj
	        }
	      });
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    this._debouncedOnCaretUpdate.cancel();
	    this._debouncedWindowResize.cancel();
	    this._debouncedShouldSendChatStateMessage.cancel();
	    document.removeEventListener('click', this._focusIfAllowed);
	    _chat_input_store2.default.off('change', this._onChange);
	    _app_dispatcher2.default.unregister("application-focused", this._focusIfAllowed);
	    _app_dispatcher2.default.unregister("new-active-chat", this._focusIfAllowed);
	    _app_dispatcher2.default.unregister("hide-modal-dialog", this._focusIfAllowed);
	    _app_dispatcher2.default.unregister("hide-inline-dialog", this._focusIfAllowed);
	    $(document).off('click', onDocClick);
	    AJS.$(document).off('aui-dropdown2-show', this._blur);
	    AJS.$(document).off('aui-dropdown2-hide', this._focusIfAllowed);
	    _autocomplete_actions2.default.dismissMentionAutoComplete();
	    _autocomplete_actions2.default.dismissEmoticonAutoComplete();
	    _chat_input_actions2.default.closeTooltip({ type: 'upload_preview' });
	  },
	
	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    if (this.state.active_chat !== nextState.active_chat) {
	      if (!nextState.attachment_expanded || !nextState.file.file_obj) {
	        _chat_input_actions2.default.closeTooltip({ type: 'upload_preview' });
	      }
	      _analytics_dispatcher2.default.dispatch('analytics-active-chat-changed', { jid: nextState.active_chat });
	    } else if (!this.state.text && nextState.text) {
	      _analytics_dispatcher2.default.dispatch('analytics-set-message-value', nextState.text);
	    }
	  },
	
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    this._autoSize();
	    if (this.state.active_chat_id !== prevState.active_chat_id) {
	      this._moveCaretToEnd();
	    } else if (this.state.new_forced_caret_position) {
	      _utils2.default.setCaretPosition(ReactDOM.findDOMNode(this.refs.message), this.state.new_forced_caret_position);
	      _chat_input_actions2.default.resetNewForcedCaretPosition();
	    }
	    if (prevState.file && this.state.file && prevState.file.file_obj && !this.state.file.file_obj) {
	      _chat_input_actions2.default.closeTooltip({ type: 'upload_preview' });
	    }
	    this._setUploadProgress(this.state.upload_progress, prevState.upload_progress);
	  },
	
	  _setUploadProgress: function _setUploadProgress(current, prev) {
	    if (document.querySelector(ProgressBarSelector)) {
	      if (current !== null) {
	        AJS.progressBars.update(ProgressBarSelector, current);
	      } else if (current === null && prev !== null) {
	        AJS.progressBars.setIndeterminate(ProgressBarSelector);
	      }
	    }
	  },
	
	
	  _setTextAreaLayout: function _setTextAreaLayout(textArea) {
	    var computedStyle = window.getComputedStyle(textArea, null);
	
	    this._textAreaLayout['maxHeight'] = parseInt(computedStyle.maxHeight, 10) || 210;
	    this._textAreaLayout['scrollHeight'] = textArea.clientHeight;
	  },
	
	  _textAreaLayout: {
	    maxHeight: 0,
	    scrollHeight: 0
	  },
	
	  _sendLaunchToChat: function _sendLaunchToChat() {
	    var activeChat = _chat_input_store2.default.get('active_chat'),
	        isRoom = _utils2.default.jid.is_room(activeChat),
	
	    // 0 if room, 1 if OTO. We can assume we're not in the lobby or search
	    // because we don't render the chat input there
	    size = isRoom ? 0 : 1;
	
	    _analytics_actions2.default.handleLaunchToChat({ size: size });
	  },
	
	  _autoSize: function _autoSize() {
	    var textArea = ReactDOM.findDOMNode(this.refs.message);
	
	    if (this._textAreaLayout['scrollHeight'] !== textArea.scrollHeight) {
	      var chatInput = ReactDOM.findDOMNode(this);
	
	      // Changes of textArea height also affect message list height (and it's scroll position).
	      // So to avoid redundant scroll jumps we should preserve height of the chatInput during textArea height changes.
	      chatInput.style.height = chatInput.clientHeight + 'px';
	
	      textArea.style.height = 0;
	      textArea.style.height = textArea.scrollHeight + 'px';
	
	      chatInput.style.height = '';
	
	      if (textArea.scrollHeight >= this._textAreaLayout['maxHeight']) {
	        if (textArea.style.overflowY !== 'visible') {
	          textArea.style.overflowY = "visible";
	          $(ReactDOM.findDOMNode(this)).find(".hc-text-input").addClass('hc-textarea-has-scroll');
	        }
	      } else {
	        if (textArea.style.overflowY !== 'hidden') {
	          textArea.style.overflowY = "hidden";
	          $(ReactDOM.findDOMNode(this)).find(".hc-text-input").removeClass('hc-textarea-has-scroll');
	        }
	      }
	      this._textAreaLayout['scrollHeight'] = textArea.scrollHeight;
	      this._debouncedWindowResize();
	    }
	  },
	
	  _getAutoComplete: function _getAutoComplete() {
	    var autoComplete;
	
	    if (this.state.active_autocomplete === "mention" && this.state.mention_list.length) {
	      autoComplete = React.createElement(_mention_autocomplete2.default, {
	        ref: 'mentionAC',
	        mention_text: this.state.mention_text,
	        mention_list: this.state.mention_list,
	        mention_results_count: this.state.mention_results_count,
	        mention_selected_item: this.state.mention_selected_item,
	        should_animate_avatar: this.state.should_animate_avatar,
	        textarea_ref: this.refs.message });
	    } else if (this.state.active_autocomplete === "emoticon" && this.state.emoticon_list.length) {
	      autoComplete = React.createElement(_emoticon_auto_complete2.default, {
	        ref: 'emoticonAC',
	        emoticon_text: this.state.emoticon_text,
	        emoticon_list: this.state.emoticon_list,
	        emoticon_results_count: this.state.emoticon_results_count,
	        emoticon_selected_item: this.state.emoticon_selected_item,
	        path_prefix: this.state.path_prefix,
	        textarea_ref: this.refs.message });
	    } else if (this.state.active_autocomplete === "slash_command" && this.state.slash_command_list.length) {
	      autoComplete = React.createElement(_slash_command_auto_complete2.default, {
	        ref: 'slash_commandAC',
	        slash_command_results_count: this.state.slash_command_results_count,
	        slash_command_selected_item: this.state.slash_command_selected_item,
	        slash_commands_list: this.state.slash_command_list,
	        textarea_ref: this.refs.message
	      });
	    }
	    return autoComplete;
	  },
	
	  render: function render() {
	    var textInputClasses = (0, _classnames2.default)({
	      "hc-textwrapper": true,
	      "hc-text-input": true,
	      "hc-file-sharing-disabled": !this.state.can_share_files
	    });
	    var textareaClasses = (0, _classnames2.default)({
	      'mousetrap': true,
	      'textarea': true,
	      'hc-textarea': true
	    });
	    var autoComplete = this._getAutoComplete();
	
	    return React.createElement(
	      'form',
	      { className: 'aui' },
	      React.createElement(
	        'table',
	        { width: '100%', height: '100%', cellSpacing: '0' },
	        React.createElement(
	          'tbody',
	          null,
	          React.createElement(
	            'tr',
	            null,
	            React.createElement(_chat_action_button2.default, {
	              ref: 'file_btn',
	              active_chat: this.state.active_chat,
	              on_keydown: this._onKeydown,
	              file_name: this.state.file_name,
	              attachment_expanded: this.state.attachment_expanded,
	              uploading: this.state.uploading,
	              file_error: this.state.file_error,
	              file_error_message: this.state.file_error_message,
	              file_extension: this.state.file_extension,
	              can_share_files: this.state.can_share_files,
	              chat_type: this.props.chat_type }),
	            React.createElement(
	              'td',
	              { height: '100%' },
	              React.createElement(
	                'div',
	                { className: 'hc-text-input-autocomplete-container' },
	                autoComplete
	              ),
	              React.createElement(
	                'div',
	                { className: textInputClasses },
	                React.createElement('textarea', {
	                  id: _app_config2.default.chat_input_id,
	                  className: textareaClasses,
	                  rows: '1',
	                  onChange: this._onValueChange,
	                  onKeyDown: this._onKeydown,
	                  onKeyUp: this._debouncedOnCaretUpdate,
	                  onClick: this._debouncedOnCaretUpdate,
	                  onPaste: this._onPaste,
	                  value: this.state.text,
	                  ref: 'message' }),
	                React.createElement(
	                  'div',
	                  { className: 'smiley-icon', onClick: this._onSmileyClick },
	                  React.createElement(
	                    'span',
	                    { className: 'aui-icon hipchat-icon-small icon-emoticon' },
	                    'Emoticons'
	                  ),
	                  React.createElement(_tooltip2.default, { type: 'smiley_selector' })
	                )
	              )
	            )
	          )
	        )
	      )
	    );
	  },
	
	  _onChange: function _onChange(evt) {
	    this._debouncedOnCaretUpdate(evt);
	    this.setState(getInputState());
	  },
	
	  _onCaretUpdate: function _onCaretUpdate(evt) {
	    if (this.state.chat_type === 'chat' && evt.keyCode) {
	      this._debouncedShouldSendChatStateMessage(evt);
	    }
	    var node = ReactDOM.findDOMNode(this.refs.message),
	        caretPosn = _utils2.default.getCaretPosition(node),
	        msgText = node.value,
	        msgMention = msgText,
	        endSelectedPosition = _utils2.default.getEndSelection(node);
	    if (endSelectedPosition !== caretPosn) {
	      msgMention = msgText.slice(0, caretPosn) + msgText.slice(endSelectedPosition);
	    }
	    if (caretPosn !== lastPosn || caretPosn === lastPosn && _utils2.default.keyCode.isSelected(evt)) {
	      lastPosn = caretPosn;
	      this._processEmoticonText(msgText, caretPosn);
	      var activeChat = this.state.active_chat;
	      if (!_utils2.default.jid.is_private_chat(activeChat)) {
	        this._processMentionText(msgMention, caretPosn);
	      }
	      this._processSlashCommandText(msgText, caretPosn);
	      _chat_input_actions2.default.setCaretPosition(caretPosn);
	    }
	  },
	
	  _processMentionText: function _processMentionText(msgText, caretPosn) {
	    if (this.state.active_autocomplete !== 'mention' && this.state.active_autocomplete) {
	      return;
	    }
	    _autocomplete_actions2.default.processMentionText({
	      text: msgText,
	      caret_position: caretPosn
	    });
	  },
	
	  _processEmoticonText: function _processEmoticonText(msgText, caretPosn) {
	    if (this.state.active_autocomplete !== 'emoticon' && this.state.active_autocomplete) {
	      return;
	    }
	    _autocomplete_actions2.default.processEmoticonText({
	      text: msgText,
	      caret_position: caretPosn
	    });
	  },
	
	  _processSlashCommandText: function _processSlashCommandText(msgText, caretPosn) {
	    if (this.state.active_autocomplete !== 'slash_command' && this.state.active_autocomplete) {
	      return;
	    }
	    _autocomplete_actions2.default.processSlashCommandText({
	      text: msgText,
	      caret_position: caretPosn
	    });
	  },
	
	
	  _processPresence: function _processPresence(text) {
	    var index = text.indexOf(' '),
	        show_type = text,
	        payload = {
	      type: 'showAndStatus'
	    },
	        status;
	
	    if (_.includes(text, ' ')) {
	      status = text.substr(index).trim();
	      if (status) {
	        payload.status = status;
	      }
	      show_type = show_type.substr(0, index);
	    }
	
	    switch (show_type.substr(1)) {
	      case 'available':
	      case 'here':
	      case 'back':
	        payload.show = _presence2.default.AVAILABLE;
	        break;
	
	      case 'away':
	        payload.show = _presence2.default.AWAY;
	        break;
	
	      case 'dnd':
	        payload.show = _presence2.default.DND;
	        break;
	    }
	
	    _current_user_actions2.default.changeStatus(payload);
	  },
	
	  _clearFileInput: function _clearFileInput() {
	    var node = document.getElementById('fileInput');
	    if (node) {
	      node.value = null;
	    }
	  },
	
	  _onKeydown: function _onKeydown(evt) {
	    if (!this.state.initialized) {
	      return;
	    }
	
	    this.state.text = _utils2.default.strings.stripHiddenCharacters(this.state.text);
	
	    if (this.state.active_autocomplete) {
	      _mouse_position2.default.useLatest();
	      var $node = $(ReactDOM.findDOMNode(this.refs[this.state.active_autocomplete + 'AC']));
	      if ($node.find('.aui-inline-dialog.show').length) {
	        // up
	        if (evt.keyCode === _utils2.default.keyCode.UpArrow) {
	          _autocomplete_actions2.default.navigateAutoComplete({
	            autocomplete: this.state.active_autocomplete,
	            direction: "up"
	          });
	          evt.preventDefault();
	        }
	
	        // down
	        if (evt.keyCode === _utils2.default.keyCode.DownArrow) {
	          _autocomplete_actions2.default.navigateAutoComplete({
	            autocomplete: this.state.active_autocomplete,
	            direction: "down"
	          });
	          evt.preventDefault();
	        }
	
	        // tab or enter
	        if (evt.keyCode === _utils2.default.keyCode.Tab || evt.keyCode === _utils2.default.keyCode.Enter) {
	          if (this.state.active_autocomplete === "mention") {
	            _autocomplete_actions2.default.mentionSelected();
	          } else if (this.state.active_autocomplete === "emoticon") {
	            _autocomplete_actions2.default.emoticonSelected();
	          } else if (this.state.active_autocomplete === "slash_command") {
	            _autocomplete_actions2.default.slashCommandSelected();
	          }
	          evt.preventDefault();
	          return;
	        }
	      }
	    } else if (evt.keyCode === _utils2.default.keyCode.Tab) {
	      if (this.state.attachment_expanded && evt.shiftKey) {
	        // Only allow tab-backward if we're uploading
	      } else {
	          // Don't allow tab-forward (or any tab if we're not uploading)
	          evt.preventDefault();
	        }
	      return;
	    } else if (evt.keyCode === _utils2.default.keyCode.Enter && (evt.ctrlKey || evt.altKey)) {
	      // let the default shift+enter behavior bubble up, since modifying the text by adding a '\n' results in weird behavior
	      evt.shiftKey = true;
	      return;
	    }
	    // escape
	    if (evt.keyCode === _utils2.default.keyCode.Esc) {
	      if (!this.state.active_autocomplete) {
	        // Always make sure we focus the message input
	        ReactDOM.findDOMNode(this.refs.message).focus();
	        _chat_input_actions2.default.closeTooltip({ type: 'upload_preview' });
	        _chat_input_actions2.default.closeAttachment({ jid: this.state.active_chat });
	      }
	      _autocomplete_actions2.default.dismissMentionAutoComplete();
	      _autocomplete_actions2.default.dismissEmoticonAutoComplete();
	      evt.preventDefault();
	    }
	
	    if (this.state.message_editing_enabled && this.state.text === '' && evt.keyCode === _utils2.default.keyCode.UpArrow && !_utils2.default.keyCode.isModified(evt)) {
	      evt.preventDefault();
	      _chat_input_actions2.default.getLastMessageSentByCurrentUser(this.state.active_chat, _message_actions2.default.initiateMessageEdit);
	    }
	
	    if (evt.keyCode === _utils2.default.keyCode.Enter && !evt.shiftKey) {
	      evt.preventDefault();
	      if (this.state.text && this._invalidMessageLength(this.state.text)) {
	        // Message is too long
	        _chat_input_actions2.default.showMessageLengthError();
	      } else if (!this.state.uploading && this.state.attachment_expanded && !this.state.file_error) {
	        if (this.state.text && this._invalidFileDescriptionLength(this.state.text)) {
	          // File description is too long
	          _chat_input_actions2.default.showFileDescriptionLengthError();
	        } else {
	          _file_uploader_actions2.default.uploadFile({
	            file: this.state.file,
	            fileName: this.state.file_name,
	            jid: this.state.active_chat,
	            room_id: this.state.active_chat_id,
	            message: this.state.text
	          });
	          this._sendUploadAnalyticsEvent();
	          _chat_input_actions2.default.closeTooltip({ type: 'upload_preview' });
	          ReactDOM.findDOMNode(this.refs.message).focus();
	          this._clearFileInput();
	        }
	      } else if (this.state.text.trim().length) {
	        var command = slashCommandHelper.matchCommand({
	          text: this.state.text,
	          jid: this.state.active_chat,
	          is_guest: this.props.is_guest,
	          video_enabled: this.state.video_enabled,
	          room_video_enabled: this.state.video_enabled && this.state.web_client_enso_video_enabled && this.state.web_client_enso_room_video_enabled
	        });
	
	        slashCommandHelper.executeCommand(command, {
	          jid: this.state.active_chat,
	          text: this.state.text,
	          videoService: this.state.web_client_enso_video_enabled ? _video_service_keys2.default.ENSO : _video_service_keys2.default.ADDLIVE,
	          room_id: this.state.active_chat_id,
	          room_is_archived: this.state.room_is_archived
	        });
	
	        if (command) {
	          _analytics_actions2.default.slashCommandUsed({
	            room: _utils2.default.jid.is_room(this.state.active_chat) ? this.state.active_chat_id : null,
	            slashUsed: command.name
	          });
	        }
	
	        if (command && command.should_send_message || !command) {
	
	          if (_utils2.default.jid.is_private_chat(this.state.active_chat) && !this.state.can_use_oto_chats) {
	
	            _flag_actions2.default.showFlag({
	              type: 'warning',
	              close: 'auto',
	              body: _forms_strings2.default.fail.oto_chats_disabled
	            });
	
	            return;
	          }
	
	          if (this.state.room_is_archived) {
	
	            _flag_actions2.default.showFlag({
	              type: 'warning',
	              close: 'auto',
	              body: _forms_strings2.default.fail.sent_message_in_archived_room
	            });
	
	            return;
	          }
	
	          _chat_input_actions2.default.sendMessage({
	            text: this.state.text,
	            jid: this.state.active_chat,
	            id: this.state.message_id,
	            active_chat_id: this.state.active_chat_id,
	            chat_type: this.state.chat_type
	          });
	        }
	      }
	    }
	  },
	
	  _shouldSendChatStateMessage: function _shouldSendChatStateMessage(evt) {
	    if (evt.keyCode === _utils2.default.keyCode.Delete || evt.keyCode === _utils2.default.keyCode.Backspace) {
	      return false;
	    }
	
	    this._updateDelay();
	    if (this.state.text.trim().length && !sentComposingMessageInterval && this.state.user_state === 'active') {
	      this._sendComposingStateMessage();
	    } else if (this.state.user_state === 'composing') {
	      if (!this.state.text.trim().length || !sentComposingMessageTimeout) {
	        this._sendActiveStateMessage();
	      }
	    }
	  },
	
	  _updateDelay: function _updateDelay() {
	    var _this = this;
	
	    clearTimeout(sentComposingMessageTimeout);
	    sentComposingMessageTimeout = setTimeout(function () {
	      _this._sendActiveStateMessage();
	      clearTimeout(sentComposingMessageTimeout);
	      sentComposingMessageTimeout = null;
	    }, sentActiveMessageDelay);
	  },
	
	  _sendComposingStateMessage: function _sendComposingStateMessage() {
	    var _this2 = this;
	
	    this._sentState('composing');
	    sentComposingMessageInterval = setInterval(function () {
	      _this2._sentState('composing');
	    }, composingIntervalTimer);
	  },
	
	  _sendActiveStateMessage: function _sendActiveStateMessage() {
	    clearInterval(sentComposingMessageInterval);
	    sentComposingMessageInterval = null;
	    this._sentState('active');
	  },
	
	  _sentState: function _sentState(state) {
	    _chat_input_actions2.default.setUserState({
	      jid: this.state.active_chat,
	      type: 'chat',
	      state: state
	    });
	  },
	
	  _onValueChange: function _onValueChange(evt) {
	
	    if (!this.state.initialized) {
	      return;
	    }
	
	    _chat_input_actions2.default.setMsgValue({
	      text: evt.target.value
	    });
	  },
	
	  _invalidMessageLength: function _invalidMessageLength(text) {
	    return text.length >= _app_config2.default.max_message_text_length;
	  },
	
	  _invalidFileDescriptionLength: function _invalidFileDescriptionLength(text) {
	    return text.length > _app_config2.default.max_file_description_length;
	  },
	
	  _focusingDisabled: function _focusingDisabled() {
	    var disabled = false;
	    if (window.HC && window.HC.Config && window.HC.Config.composeMessageDisabled) {
	      disabled = window.HC.Config.composeMessageDisabled;
	    }
	
	    return disabled;
	  },
	
	  _focusIfAllowed: function _focusIfAllowed(e) {
	    var _this3 = this;
	
	    if (!e || !$(e.target).closest('[data-no-focus]').length) {
	      _.delay(function () {
	        var activeEl = _.get(document.activeElement, 'tagName');
	        if (_this3.isMounted() && !_this3._focusingDisabled() && !_.includes(["INPUT", "TEXTAREA"], activeEl) && document.querySelectorAll(".aui-blanket").length === 0 && $(".aui-dropdown2[aria-hidden='false']").length === 0) {
	          _this3._focus();
	        }
	      }, _app_config2.default.modal_transition_allowance);
	    }
	  },
	
	  _focus: function _focus() {
	    var selection = getSelection();
	    if (!this._isFocused() && !selection) {
	      ReactDOM.findDOMNode(this.refs.message).focus();
	    }
	  },
	
	  _blur: function _blur() {
	    ReactDOM.findDOMNode(this.refs.message).blur();
	  },
	
	  _moveCaretToEnd: function _moveCaretToEnd() {
	    if (this.state.text) {
	      _utils2.default.setCaretPosition(ReactDOM.findDOMNode(this.refs.message), this.state.text.length);
	      _chat_input_actions2.default.setCaretPosition(this.state.text.length);
	    }
	  },
	
	  _isFocused: function _isFocused() {
	    return ReactDOM.findDOMNode(this.refs.message) === document.activeElement;
	  },
	
	  _onSmileyClick: function _onSmileyClick(evt) {
	    var className = evt.currentTarget.className;
	    if (! ~className.indexOf(' selected')) {
	      evt.currentTarget.className += ' selected';
	
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: "hipchat.client.emoticon.dialog.launched"
	      });
	    } else {
	      evt.currentTarget.className = className.replace(' selected', '');
	    }
	    _chat_input_actions2.default.toggleTooltip({
	      type: 'smiley_selector',
	      data: {
	        smileys: this.state.smileys,
	        user_is_admin: this.state.user_is_admin,
	        web_server: this.state.web_server
	      }
	    });
	  },
	
	  _sendUploadAnalyticsEvent: function _sendUploadAnalyticsEvent() {
	    var fileType = _utils2.default.file.get_selected_file_type(this.state.file);
	    var roomType = _utils2.default.room.detect_chat_type(this.state.active_chat) === "groupchat" ? "room" : "oto";
	    _analytics_actions2.default.fileUploadRequested(fileType.minor, roomType, this.state.file_selection_source);
	  },
	
	
	  _onPaste: function _onPaste(evt) {
	    if (!this.state.uploading) {
	      _file_uploader_actions2.default.filePasted(evt);
	    }
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	/**
	 * AutoCompleteActions
	 */
	
	var AppDispatcher = __webpack_require__(9);
	
	var AutoCompleteActions = {
	
	  processEmoticonText: function processEmoticonText(data) {
	    AppDispatcher.dispatch("process-emoticon-text", {
	      text: data.text,
	      caret_position: data.caret_position
	    });
	  },
	
	  dismissEmoticonAutoComplete: function dismissEmoticonAutoComplete() {
	    AppDispatcher.dispatch("dismiss-emoticon-autocomplete");
	  },
	
	  emoticonSelected: function emoticonSelected() {
	    AppDispatcher.dispatch("emoticon-selected");
	  },
	
	  processMentionText: function processMentionText(data) {
	    AppDispatcher.dispatch('process-mention-text', {
	      text: data.text,
	      caret_position: data.caret_position
	    });
	  },
	
	  processSlashCommandText: function processSlashCommandText(_ref) {
	    var text = _ref.text;
	    var caret_position = _ref.caret_position;
	
	    AppDispatcher.dispatch('process-slash-command-text', { text: text, caret_position: caret_position });
	  },
	
	
	  dismissMentionAutoComplete: function dismissMentionAutoComplete() {
	    AppDispatcher.dispatch("dismiss-mention-autocomplete");
	  },
	
	  navigateAutoComplete: function navigateAutoComplete(data) {
	    AppDispatcher.dispatch("navigate-autocomplete", {
	      autocomplete: data.autocomplete,
	      direction: data.direction
	    });
	  },
	
	  mentionSelected: function mentionSelected() {
	    AppDispatcher.dispatch("mention-selected");
	  },
	
	  menuItemHovered: function menuItemHovered(data) {
	    AppDispatcher.dispatch("menu-item-hovered", {
	      type: data.type,
	      index: data.index
	    });
	  },
	
	  slashCommandSelected: function slashCommandSelected() {
	    AppDispatcher.dispatch("slash-command-selected");
	  }
	};
	
	module.exports = AutoCompleteActions;

/***/ },
/* 607 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var AutoCompleteBox = __webpack_require__(608);
	var utils = __webpack_require__(99);
	
	module.exports = React.createClass({
	
	  displayName: "MentionAutoComplete",
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.mention_results_count > 0) {
	      this._scrollIntoView();
	    }
	  },
	
	  _scrollIntoView: function _scrollIntoView() {
	    var $node = $(ReactDOM.findDOMNode(this));
	    var container = $node.find('.aui-inline-dialog-contents.contents').get(0);
	
	    utils.scrollIntoViewIfNeeded($node.find('li.hc-autocomplete-item-selected').get(0), container, false);
	  },
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'hc-mention-ac hc-chat-input-autocomplete' },
	      React.createElement(AutoCompleteBox, { key: 'mention_auto_complete',
	        type: 'mention',
	        list: this.props.mention_list,
	        should_animate_avatar: this.props.should_animate_avatar,
	        textarea_ref: this.props.textarea_ref,
	        selected_item: this.props.mention_selected_item,
	        ref: 'acBox' })
	    );
	  }
	
	});

/***/ },
/* 608 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var TextareaCaretMirror = __webpack_require__(609);
	var MentionAutoCompleteRow = __webpack_require__(610);
	var EmoticonAutoCompleteItem = __webpack_require__(611);
	var SlashCommandAutoCompleteItem = __webpack_require__(612);
	var emoticons = __webpack_require__(110);
	var cx = __webpack_require__(313);
	
	module.exports = React.createClass({
	
	  displayName: "AutoCompleteBox",
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      list: []
	    };
	  },
	
	  _boxParams: {
	    boxArrowType: "left",
	    arrow_offsets: {
	      left: 30,
	      top: 10
	    },
	    offset_left: 30,
	    offset_top: 10,
	    offset_left_shift: 200 //boxWidth - 30px - 30px
	  },
	
	  componentDidMount: function componentDidMount() {
	    this._positionAutoComplete();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._positionAutoComplete();
	  },
	
	  _positionAutoComplete: function _positionAutoComplete() {
	    if (!this.refs.caret) {
	      return;
	    }
	    var arrowOffsets = this._boxParams.arrow_offsets;
	    var $acBox = $(ReactDOM.findDOMNode(this.refs.acBox));
	    var $caret = $(ReactDOM.findDOMNode(this.refs.caret)).find(".hc-textarea-caret");
	    var $textarea = $(ReactDOM.findDOMNode(this.props.textarea_ref));
	    var textareaWidth = $textarea.width();
	    var caretLeftPosition = $caret.position().left;
	
	    var css = {};
	    var left = void 0;
	    var top = void 0;
	    var isRightBox = this._isRightBoxType(textareaWidth, caretLeftPosition);
	
	    if ($caret.length) {
	      left = $caret.position().left - arrowOffsets.left;
	      top = $caret.position().top - $textarea.scrollTop() - $(ReactDOM.findDOMNode(this.refs.container)).height() - arrowOffsets.top;
	
	      if (isRightBox) {
	        this._boxParams.boxArrowType = 'right';
	        left -= this._boxParams.offset_left_shift;
	      } else {
	        this._boxParams.boxArrowType = 'left';
	      }
	      css.left = left + 'px';
	      css.top = top + 'px';
	    } else {
	      top = $textarea.scrollTop() - $(ReactDOM.findDOMNode(this.refs.container)).height() - arrowOffsets.top;
	      css.top = top + 'px';
	    }
	
	    $acBox.css(css);
	  },
	
	  _isRightBoxType: function _isRightBoxType(textareaWidth, caretLeftPosition) {
	    return textareaWidth / 2 < caretLeftPosition;
	  },
	
	  _getMentionAutoCompleteContent: function _getMentionAutoCompleteContent() {
	    var _this = this;
	
	    var results = this.props.list.map(function (user, idx) {
	      var isSelected = false,
	          mention_match_markup = "@" + user.mention_match_markup;
	      if (idx === _this.props.selected_item) {
	        isSelected = true;
	      }
	      return React.createElement(MentionAutoCompleteRow, { show: user.presence.show,
	        hidden_presence: user.hidden_presence,
	        photo_url: user.photo_url,
	        name_match_markup: user.name_match_markup,
	        mention_match_markup: mention_match_markup,
	        selected: isSelected,
	        should_animate_avatar: _this.props.should_animate_avatar,
	        key: idx,
	        idx: idx,
	        user_id: user.id });
	    });
	    return results;
	  },
	
	  _getEmoticonAutoCompleteContent: function _getEmoticonAutoCompleteContent() {
	    var _this2 = this;
	
	    var results = this.props.list.map(function (emoticon, idx) {
	      var isSelected = false;
	      if (idx === _this2.props.selected_item) {
	        isSelected = true;
	      }
	      return React.createElement(EmoticonAutoCompleteItem, { src: _.get(emoticons._getEmoticonInfo(emoticon.shortcut), 'src'),
	        match_markup: emoticon.match_markup,
	        shortcut: emoticon.shortcut,
	        selected: isSelected,
	        key: idx,
	        idx: idx });
	    });
	    return results;
	  },
	
	  _getSlashCommandAutoCompleteContent: function _getSlashCommandAutoCompleteContent() {
	    var _this3 = this;
	
	    var results = this.props.list.map(function (command, idx) {
	      var isSelected = false;
	      if (idx === _this3.props.selected_item) {
	        isSelected = true;
	      }
	      return React.createElement(SlashCommandAutoCompleteItem, {
	        name: command.name,
	        description: command.description,
	        usage: command.usage,
	        selected: isSelected,
	        key: idx,
	        idx: idx });
	    });
	    return results;
	  },
	
	
	  _getAutoCompleteContent: function _getAutoCompleteContent() {
	    var content;
	    if (this.props.type) {
	      switch (this.props.type) {
	        case "mention":
	          content = this._getMentionAutoCompleteContent();
	          break;
	        case "emoticon":
	          content = this._getEmoticonAutoCompleteContent();
	          break;
	        case "slash_command":
	          content = this._getSlashCommandAutoCompleteContent();
	          break;
	      }
	    }
	    return content;
	  },
	
	  render: function render() {
	    var content = this._getAutoCompleteContent(),
	        isRight = this._boxParams.boxArrowType === 'right',
	        classes = cx({
	      'aui-inline-dialog': true,
	      'show': this.props.list.length > 0
	    }),
	        arrowClasses = cx('aui-inline-dialog-arrow', 'arrow', 'aui-css-arrow', 'aui-bottom-arrow', {
	      'right': isRight
	    });
	
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "div",
	        { className: classes, ref: "acBox" },
	        React.createElement(
	          "div",
	          { className: "aui-inline-dialog-contents contents", ref: "container" },
	          React.createElement(
	            "ul",
	            null,
	            content
	          )
	        ),
	        React.createElement("div", { className: arrowClasses })
	      ),
	      React.createElement(TextareaCaretMirror, { ref: "caret", textarea_ref: this.props.textarea_ref })
	    );
	  }
	
	});

/***/ },
/* 609 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(99);
	
	module.exports = React.createClass({
	
	  displayName: "TextAreaCaretMirror",
	
	  render: function render() {
	    if (!this.props.textarea_ref) {
	      return React.createElement('div', null);
	    }
	    var $src = $(this.props.textarea_ref);
	    if ($src.length < 1) {
	      return React.createElement('div', null);
	    }
	    var caretPosn = utils.getCaretPosition($src.get(0)),
	        pre = $src.val().substring(0, caretPosn),
	        post = $src.val().substring(caretPosn),
	        containerStyles = {
	      'position': 'absolute',
	      'overflow': 'auto',
	      'whiteSpace': 'pre-wrap',
	      'wordWrap': 'break-word',
	      'top': 0,
	      'left': -9999
	    },
	        caretStyles = {
	      'position': 'absolute'
	    },
	        stylesToMirror = [
	    // Box Styles.
	    'boxSizing', 'height', 'width', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'
	
	    // Font stuff.
	    , 'fontFamily', 'fontSize', 'fontStyle', 'fontVariant', 'fontWeight'
	
	    // Spacing etc.
	    , 'wordSpacing', 'letterSpacing', 'lineHeight', 'textDecoration', 'textIndent', 'textTransform'
	
	    // The direction.
	    , 'direction'];
	    for (var i = 0; i < stylesToMirror.length; i++) {
	      containerStyles[stylesToMirror[i]] = $src.css(stylesToMirror[i]);
	    }
	    return React.createElement(
	      'div',
	      { style: containerStyles },
	      pre,
	      React.createElement('span', { ref: 'caret', className: 'hc-textarea-caret', style: caretStyles }),
	      post
	    );
	  }
	
	});

/***/ },
/* 610 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _autocomplete_actions = __webpack_require__(606);
	
	var _autocomplete_actions2 = _interopRequireDefault(_autocomplete_actions);
	
	var _person_avatar = __webpack_require__(310);
	
	var _person_avatar2 = _interopRequireDefault(_person_avatar);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: 'MentionAutoCompleteRow',
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _onMentionMenuItemHover: function _onMentionMenuItemHover(evt) {
	    if (_mouse_position2.default.hasChanged(evt)) {
	      _autocomplete_actions2.default.menuItemHovered({
	        type: 'mention',
	        index: this.props.idx
	      });
	    }
	  },
	
	
	  _onMentionSelected: function _onMentionSelected() {
	    _autocomplete_actions2.default.mentionSelected();
	  },
	
	  _getAvatar: function _getAvatar() {
	    var avatar = void 0;
	
	    if (this.props.photo_url) {
	      avatar = React.createElement(_person_avatar2.default, { size: 'small',
	        presence: this.props.show,
	        avatar_url: this.props.photo_url,
	        active: true,
	        shouldAnimate: this.props.should_animate_avatar,
	        key: this.props.user_id,
	        uid: this.props.user_id });
	    } else {
	      avatar = React.createElement(
	        'span',
	        { className: 'aui-avatar aui-avatar-project aui-avatar-small' },
	        React.createElement(
	          'span',
	          { className: 'aui-avatar-inner' },
	          React.createElement('div', { className: 'mention-group-icon' })
	        )
	      );
	    }
	    return avatar;
	  },
	
	  render: function render() {
	    var avatar = this._getAvatar(),
	        classes = (0, _classnames2.default)({
	      'hc-autocomplete-item': true,
	      'hc-autocomplete-item-selected': this.props.selected
	    });
	
	    return React.createElement(
	      'li',
	      { className: classes, onClick: this._onMentionSelected, 'data-index': this.props.idx },
	      React.createElement(
	        'div',
	        { className: 'hc-ac-row', onMouseOver: this._onMentionMenuItemHover },
	        React.createElement(
	          'div',
	          { className: 'hc-ac-avatar' },
	          avatar
	        ),
	        React.createElement('span', { className: 'hc-ac-name', dangerouslySetInnerHTML: { __html: this.props.name_match_markup || '' } }),
	        React.createElement('span', { className: 'hc-ac-mention-name', dangerouslySetInnerHTML: { __html: this.props.mention_match_markup || '' } })
	      )
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _autocomplete_actions = __webpack_require__(606);
	
	var _autocomplete_actions2 = _interopRequireDefault(_autocomplete_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _link_utils = __webpack_require__(108);
	
	var _link_utils2 = _interopRequireDefault(_link_utils);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MAX_WIDTH = 20;
	
	exports.default = React.createClass({
	
	  displayName: "EmoticonAutoCompleteItem",
	
	  propTypes: {
	    "match_markup": React.PropTypes.string.isRequired
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _onEmoticonMenuItemHover: function _onEmoticonMenuItemHover(evt) {
	    if (_mouse_position2.default.hasChanged(evt)) {
	      _autocomplete_actions2.default.menuItemHovered({
	        type: 'emoticon',
	        index: this.props.idx
	      });
	    }
	  },
	
	
	  _onEmoticonSelected: function _onEmoticonSelected() {
	    _autocomplete_actions2.default.emoticonSelected();
	  },
	
	  _onRetinaImageNonExistent: function _onRetinaImageNonExistent(evt) {
	    evt.target.src = _link_utils2.default.remove_resolution(evt.target.src);
	  },
	
	  _getWidth: function _getWidth() {
	    if (this.props.width && this.props.width < MAX_WIDTH) {
	      return this.props.width;
	    }
	    return MAX_WIDTH;
	  },
	
	
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      'hc-autocomplete-item': true,
	      'hc-autocomplete-item-selected': this.props.selected
	    });
	
	    return React.createElement(
	      "li",
	      { className: classes, onClick: this._onEmoticonSelected, "data-index": this.props.idx },
	      React.createElement(
	        "div",
	        { onMouseOver: this._onEmoticonMenuItemHover },
	        React.createElement(
	          "div",
	          { className: "hc-ac-preview" },
	          React.createElement("img", { src: this.props.src, alt: this.props.shortcut, key: this.props.shortcut, onError: this._onRetinaImageNonExistent })
	        ),
	        React.createElement("span", { className: "hc-ac-name", dangerouslySetInnerHTML: { __html: this.props.match_markup || '' } })
	      )
	    );
	  }
	
	});
	module.exports = exports['default'];

/***/ },
/* 612 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _autocomplete_actions = __webpack_require__(606);
	
	var _autocomplete_actions2 = _interopRequireDefault(_autocomplete_actions);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _reactAddonsPureRenderMixin = __webpack_require__(314);
	
	var _reactAddonsPureRenderMixin2 = _interopRequireDefault(_reactAddonsPureRenderMixin);
	
	var _mouse_position = __webpack_require__(187);
	
	var _mouse_position2 = _interopRequireDefault(_mouse_position);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "SlashCommandAutoCompleteItem",
	
	  propTypes: {
	    name: React.PropTypes.string.isRequired,
	    usage: React.PropTypes.string,
	    description: React.PropTypes.string.isRequired
	  },
	
	  mixins: [_reactAddonsPureRenderMixin2.default],
	
	  _onMenuItemHover: function _onMenuItemHover(evt) {
	    if (_mouse_position2.default.hasChanged(evt)) {
	      _autocomplete_actions2.default.menuItemHovered({
	        type: 'slash_command',
	        index: this.props.idx
	      });
	    }
	  },
	  _onMenuItemSelected: function _onMenuItemSelected() {
	    _autocomplete_actions2.default.slashCommandSelected();
	  },
	  render: function render() {
	    var classes = (0, _classnames2.default)({
	      'hc-autocomplete-item': true,
	      'hc-autocomplete-item-selected': this.props.selected
	    });
	
	    return React.createElement(
	      "li",
	      { className: classes, onClick: this._onMenuItemSelected, "data-index": this.props.idx },
	      React.createElement(
	        "div",
	        { onMouseOver: this._onMenuItemHover },
	        React.createElement(
	          "div",
	          { className: "hc-ac-name-container" },
	          React.createElement(
	            "span",
	            { className: "hc-ac-name" },
	            this.props.name
	          ),
	          React.createElement(
	            "span",
	            { className: "hc-ac-usage" },
	            this.props.usage
	          )
	        ),
	        React.createElement(
	          "div",
	          { className: "hc-ac-description" },
	          this.props.description
	        )
	      )
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var AutoCompleteBox = __webpack_require__(608);
	var utils = __webpack_require__(99);
	
	module.exports = React.createClass({
	
	  displayName: "EmoticonAutoComplete",
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.emoticon_results_count > 0) {
	      this._scrollIntoView();
	    }
	  },
	
	  _scrollIntoView: function _scrollIntoView() {
	    var $node = $(ReactDOM.findDOMNode(this));
	    var container = $node.find('.aui-inline-dialog-contents.contents').get(0);
	
	    utils.scrollIntoViewIfNeeded($node.find('li.hc-autocomplete-item-selected').get(0), container, false);
	  },
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'hc-emoticon-ac hc-chat-input-autocomplete' },
	      React.createElement(AutoCompleteBox, { key: 'emoticon_auto_complete',
	        type: 'emoticon',
	        path_prefix: this.props.path_prefix,
	        list: this.props.emoticon_list,
	        box_type: this.props.box_type,
	        textarea_ref: this.props.textarea_ref,
	        selected_item: this.props.emoticon_selected_item,
	        ref: 'acBox' })
	    );
	  }
	
	});

/***/ },
/* 614 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _auto_complete_box = __webpack_require__(608);
	
	var _auto_complete_box2 = _interopRequireDefault(_auto_complete_box);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "SlashCommandAutoComplete",
	
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.slash_command_results_count > 0) {
	      this._scrollIntoView();
	    }
	  },
	  _scrollIntoView: function _scrollIntoView() {
	    var $node = $(ReactDOM.findDOMNode(this));
	    var container = $node.find('.aui-inline-dialog-contents.contents').get(0);
	
	    _utils2.default.scrollIntoViewIfNeeded($node.find('li.hc-autocomplete-item-selected').get(0), container, false);
	  },
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'hc-slash-command-ac hc-chat-input-autocomplete' },
	      React.createElement(_auto_complete_box2.default, { key: 'slash_command_auto_complete',
	        type: 'slash_command',
	        offset_left: -20,
	        list: this.props.slash_commands_list,
	        selected_item: this.props.slash_command_selected_item,
	        textarea_ref: this.props.textarea_ref,
	        ref: 'acBox' })
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 615 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _integration_dropdown_action = __webpack_require__(593);
	
	var _integration_dropdown_action2 = _interopRequireDefault(_integration_dropdown_action);
	
	var _dropdown_action = __webpack_require__(616);
	
	var _dropdown_action2 = _interopRequireDefault(_dropdown_action);
	
	var _actions_dropdown = __webpack_require__(592);
	
	var _actions_dropdown2 = _interopRequireDefault(_actions_dropdown);
	
	var _file_uploader = __webpack_require__(617);
	
	var _file_uploader2 = _interopRequireDefault(_file_uploader);
	
	var _file_error_tooltip = __webpack_require__(618);
	
	var _file_error_tooltip2 = _interopRequireDefault(_file_error_tooltip);
	
	var _tooltip = __webpack_require__(460);
	
	var _tooltip2 = _interopRequireDefault(_tooltip);
	
	var _file_uploader_actions = __webpack_require__(260);
	
	var _file_uploader_actions2 = _interopRequireDefault(_file_uploader_actions);
	
	var _chat_input_actions = __webpack_require__(261);
	
	var _chat_input_actions2 = _interopRequireDefault(_chat_input_actions);
	
	var _integrations_store = __webpack_require__(421);
	
	var _integrations_store2 = _interopRequireDefault(_integrations_store);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _integration_helper = __webpack_require__(167);
	
	var _integration_helper2 = _interopRequireDefault(_integration_helper);
	
	var _chat_input_strings = __webpack_require__(263);
	
	var _chat_input_strings2 = _interopRequireDefault(_chat_input_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getState() {
	  return {
	    integrations: _integrations_store2.default.getExtensionsByLocation("hipchat.input.action"),
	    integrations_enabled: _integrations_store2.default.get('enabled')
	  };
	}
	
	module.exports = React.createClass({
	
	  displayName: "ChatActionsButton",
	
	  getInitialState: function getInitialState() {
	    return getState();
	  },
	  componentDidMount: function componentDidMount() {
	    _integrations_store2.default.on(["change:integrations", "change:integrations_enabled", "change:active_chat"], this._updateState);
	  },
	  componentWillUpdate: function componentWillUpdate(nextProps) {
	    if (nextProps.attachment_expanded && !this.props.attachment_expanded) {
	      _chat_input_actions2.default.dismissActionsDropDown();
	    }
	    if (nextProps.active_chat !== this.props.active_chat) {
	      this._clearFileInputValue();
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _integrations_store2.default.off(["change:integrations", "change:integrations_enabled", "change:active_chat"], this._updateState);
	  },
	  _updateState: function _updateState() {
	    return this.setState(getState());
	  },
	  _onFileChosen: function _onFileChosen(evt) {
	    _file_uploader_actions2.default.fileChosen(evt, "browse");
	  },
	  _openFilePicker: function _openFilePicker(evt) {
	    evt.preventDefault();
	    if (!this.props.attachment_expanded) {
	      _file_uploader_actions2.default.openFilePicker();
	    }
	  },
	  _clearFileInputValue: function _clearFileInputValue() {
	    var node = ReactDOM.findDOMNode(this.refs.fileInput);
	    if (node) {
	      node.value = null;
	    }
	  },
	  _getContentsState: function _getContentsState() {
	    var val = "upload";
	    if (this.props.attachment_expanded) {
	      val = "uploading";
	    } else if (this.state.integrations_enabled && this.state.integrations.length > 0 && this.props.chat_type === "groupchat") {
	      val = "integrations";
	    } else {
	      val = "upload";
	    }
	    return val;
	  },
	  _getFileIcon: function _getFileIcon() {
	    return this._getContentsState() === "uploading" ? _utils2.default.file.get_icon_class(this.props.file_name) : "icon-attachment";
	  },
	  _getAttachButton: function _getAttachButton() {
	    var fileIcon = this._getFileIcon();
	    var linkClasses = (0, _classnames2.default)("aui-icon", "hipchat-icon-small", "hc-file-icon", fileIcon);
	
	    return React.createElement(
	      'a',
	      { className: 'hc-attach', onClick: this._openFilePicker },
	      React.createElement('span', { className: linkClasses, title: _chat_input_strings2.default.attachment })
	    );
	  },
	  _getIntegrationsDropDown: function _getIntegrationsDropDown() {
	    return React.createElement(_actions_dropdown2.default, { dropdown_id: 'input_actions_dropdown',
	      icon: 'aui-iconfont-add',
	      lazy_options: this._renderOptions,
	      onShow: this._onShow,
	      location: 'above',
	      default_option: 'last' });
	  },
	  _getFileButtonContents: function _getFileButtonContents(contentsState) {
	    var action;
	
	    switch (contentsState) {
	      case "uploading":
	      case "upload":
	        action = this._getAttachButton();
	        break;
	
	      case "integrations":
	        action = this._getIntegrationsDropDown();
	        break;
	    }
	    return action;
	  },
	  render: function render() {
	    var contentsState = this._getContentsState();
	    var action = this._getFileButtonContents(contentsState);
	    var showFileError = this.props.file_error && this.props.attachment_expanded;
	    var fileError = showFileError ? this._getFileError() : null;
	    var fileBtnClasses = (0, _classnames2.default)({
	      "hc-file-btn": contentsState === "uploading" || contentsState === "upload",
	      "has-file": contentsState === "uploading",
	      "input_actions_trigger": contentsState === "integrations",
	      "hidden": !this.props.can_share_files
	    });
	
	    return React.createElement(
	      'td',
	      { id: 'hc-chat-actions', ref: 'fileBtn', className: fileBtnClasses },
	      React.createElement('input', { className: 'hidden', ref: 'fileInput', type: 'file', id: 'fileInput', onChange: this._onFileChosen, multiple: 'false' }),
	      React.createElement(_tooltip2.default, { type: 'upload_preview' }),
	      fileError,
	      action,
	      React.createElement(_file_uploader2.default, {
	        on_keydown: this.props.on_keydown,
	        file_name: this.props.file_name,
	        file_error: this.props.file_error,
	        file_extension: this.props.file_extension,
	        attachment_expanded: this.props.attachment_expanded,
	        uploading: this.props.uploading,
	        active_chat: this.props.active_chat })
	    );
	  },
	  _renderOptions: function _renderOptions() {
	    var _this = this;
	
	    var options = _.map(this.state.integrations, function (action) {
	      return React.createElement(_integration_dropdown_action2.default, { key: _integration_helper2.default.to_full_key(action.addon_key, action.key),
	        action: action,
	        msg: _this.props.msg });
	    });
	
	    return [React.createElement(
	      'ul',
	      { key: 'items', className: 'aui-list-truncate' },
	      options,
	      React.createElement(_dropdown_action2.default, { onClick: this._openFilePicker,
	        key: 'upload-file',
	        item_id: 'hc-chat-actions-upload-file',
	        title: _chat_input_strings2.default.upload_file })
	    ), React.createElement('div', { key: 'arrow', id: 'hc-chat-actions-arrow' })];
	  },
	
	
	  _onShow: function _onShow() {
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: 'hipchat.client.integrations.input.action.open'
	    });
	  },
	
	  _getFileError: function _getFileError() {
	    return React.createElement(_file_error_tooltip2.default, { anchor: ReactDOM.findDOMNode(this.refs.fileBtn), error: this.props.file_error_message });
	  }
	});

/***/ },
/* 616 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = React.createClass({
	
	  displayName: "GenericDropDownAction",
	
	  propTypes: {
	    onClick: React.PropTypes.func,
	    title: React.PropTypes.string,
	    item_id: React.PropTypes.string
	  },
	
	  componentDidMount: function componentDidMount() {
	    // Manually attach event listener, as event is triggered from AUI
	    ReactDOM.findDOMNode(this.refs.element).addEventListener("click", this._onClick);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    ReactDOM.findDOMNode(this.refs.element).removeEventListener("click", this._onClick);
	  },
	
	  render: function render() {
	    return React.createElement(
	      "li",
	      null,
	      React.createElement(
	        "a",
	        { id: this.props.item_id, ref: "element" },
	        this.props.title
	      )
	    );
	  },
	
	
	  _onClick: function _onClick(evt) {
	    this.props.onClick(evt);
	  }
	});

/***/ },
/* 617 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _file_uploader_actions = __webpack_require__(260);
	
	var _file_uploader_actions2 = _interopRequireDefault(_file_uploader_actions);
	
	var _chat_input_actions = __webpack_require__(261);
	
	var _chat_input_actions2 = _interopRequireDefault(_chat_input_actions);
	
	var _chat_input_strings = __webpack_require__(263);
	
	var _chat_input_strings2 = _interopRequireDefault(_chat_input_strings);
	
	var _classnames = __webpack_require__(313);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = React.createClass({
	
	  displayName: "ChatInputFileUploader",
	
	  componentWillUpdate: function componentWillUpdate(nextProps) {
	    if (nextProps.attachment_expanded && !this.props.attachment_expanded) {
	      _.defer(this._checkShouldFocus);
	    }
	  },
	
	
	  _checkShouldFocus: function _checkShouldFocus() {
	    var re = new RegExp('^' + _chat_input_strings2.default.upload_default_name + '\\.');
	    if (re.test(this.props.file_name)) {
	      this._focusAndSelect();
	    }
	  },
	
	  _focusAndSelect: function _focusAndSelect() {
	    var input = ReactDOM.findDOMNode(this.refs.name_input);
	    if (input !== document.activeElement) {
	      input.focus();
	    }
	  },
	
	  _onFileNameClick: function _onFileNameClick(e) {
	    this._onFocus(e);
	  },
	
	  _onFileNameChange: function _onFileNameChange(e) {
	    _file_uploader_actions2.default.changeFileName({ file_name: e.target.value });
	  },
	
	  _onFocus: function _onFocus(e) {
	    var input = e.target;
	    // Perform the selection after a timeout since the default behavior will be to "select everything"
	    _.defer(function () {
	      var dotIndex = input.value.lastIndexOf('.');
	      if (dotIndex !== -1) {
	        input.setSelectionRange(0, dotIndex);
	      }
	    });
	  },
	
	  _onBlur: function _onBlur(e) {
	    var input = e.target;
	    if (!input.value) {
	      input.value = _chat_input_strings2.default.upload_default_name + '.' + this.props.file_extension;
	    } else if (!!this.props.file_extension && !/\.\S+$/.test(input.value)) {
	      // Ensure the filename ends with an extension
	      if (input.value.indexOf('.') === -1) {
	        input.value += '.' + this.props.file_extension;
	      } else {
	        input.value += this.props.file_extension;
	      }
	    }
	    this._onFileNameChange(e);
	  },
	
	  _onKeyDown: function _onKeyDown(e) {
	    if (e.keyCode === _utils2.default.keyCode.Tab) {
	      // Don't allow shift-tab (only tab forward into message input)
	      if (e.shiftKey) {
	        e.preventDefault();
	      }
	    } else {
	      this.props.on_keydown(e);
	    }
	  },
	
	  _closeAttachmentInput: function _closeAttachmentInput(e) {
	    e.stopPropagation();
	    var fileInput = document.getElementById('fileInput');
	    if (fileInput) {
	      fileInput.value = null;
	    }
	    _chat_input_actions2.default.closeTooltip({ type: 'upload_preview' });
	    _chat_input_actions2.default.closeAttachment({ jid: this.props.active_chat });
	  },
	
	  render: function render() {
	    var uploadClassNames = (0, _classnames2.default)({ hidden: !this.props.attachment_expanded, "upload-input": true }),
	        linkClassNames = (0, _classnames2.default)({ hidden: this.props.uploading, "close-upload": true }),
	        progressBarClasses = (0, _classnames2.default)({ hidden: !this.props.uploading, "aui-progress-indicator": true }),
	        textInputClasses = (0, _classnames2.default)({ hidden: this.props.uploading, error: this.props.file_error });
	
	    return React.createElement(
	      'div',
	      { ref: 'file_uploader', className: uploadClassNames },
	      React.createElement('input', { ref: 'name_input', id: 'upload-name-input', type: 'text', value: this.props.file_name,
	        onClick: this._onFileNameClick,
	        onChange: this._onFileNameChange,
	        onFocus: this._onFocus,
	        onBlur: this._onBlur,
	        className: textInputClasses,
	        onKeyDown: this._onKeyDown }),
	      React.createElement(
	        'a',
	        { ref: 'file_link', className: linkClassNames, onClick: this._closeAttachmentInput },
	        React.createElement('span', { className: 'aui-icon hipchat-icon-small hc-close-icon icon-close' })
	      ),
	      React.createElement(
	        'div',
	        { ref: 'upload_progress', id: 'upload-progress-bar', className: progressBarClasses },
	        React.createElement('span', { className: 'aui-progress-indicator-value' })
	      )
	    );
	  }
	});

/***/ },
/* 618 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = React.createClass({
	
	  displayName: "FileErrorTooltip",
	
	  componentDidMount: function componentDidMount() {
	    this._positionTooltip();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this._positionTooltip();
	  },
	
	  _positionTooltip: function _positionTooltip() {
	    if (!this.props.anchor) {
	      return true;
	    }
	    var elem = ReactDOM.findDOMNode(this),
	        anchor = this.props.anchor,
	        bottom = anchor.offsetHeight,
	        left = -elem.offsetWidth / 2 + anchor.offsetWidth / 2;
	
	    elem.style.bottom = bottom + 'px';
	    elem.style.left = left + 'px';
	  },
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'tipsy aui-form-notification-tooltip aui-form-notification-tooltip-error tipsy-s', role: 'tooltip' },
	      React.createElement('div', { className: 'tipsy-arrow tipsy-arrow-s' }),
	      React.createElement(
	        'div',
	        { className: 'tipsy-inner' },
	        this.props.error
	      )
	    );
	  }
	
	});

/***/ },
/* 619 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var cx = __webpack_require__(313);
	
	module.exports = React.createClass({
	
	  displayName: 'ResizeOverlay',
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      'show-overlay': false
	    };
	  },
	
	  render: function render() {
	    var classNames = cx({
	      'overlay': true,
	      'resize-overlay': true,
	      'show-overlay': this.props.show_overlay
	    });
	
	    return React.createElement('div', { className: classNames });
	  }
	});

/***/ },
/* 620 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _file_viewer_actions = __webpack_require__(435);
	
	var _file_viewer_actions2 = _interopRequireDefault(_file_viewer_actions);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _file_helper = __webpack_require__(177);
	
	var _file_helper2 = _interopRequireDefault(_file_helper);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _roster_store = __webpack_require__(271);
	
	var _roster_store2 = _interopRequireDefault(_roster_store);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var normalize = _file_helper2.default.transformForFileViewer.bind(_file_helper2.default); /*global FileViewer, videojs*/
	
	var isSupported = _file_helper2.default.fileViewerSupports.bind(_file_helper2.default);
	var guessMimeType = _file_helper2.default._guessMimeType.bind(_file_helper2.default);
	
	/**
	 * Creates files loader function for FileViewer
	 *
	 * @returns {Function}
	 */
	function getModuleLoader() {
	
	  var getAssetBaseUri = function getAssetBaseUri() {
	    var isMacNative = _utils2.default.clientSubType.isMac(_application_store2.default.get('client_subtype')),
	        assetBasePath = _application_store2.default.get('asset_base_uri');
	
	    if (isMacNative) {
	      assetBasePath = '/wc/';
	    }
	    return assetBasePath;
	  };
	
	  var toInternal = function toInternal(name) {
	    return {
	      'pdf-viewer': 'pdf-view'
	    }[name];
	  };
	
	  var modules = {
	    'pdf-config': {
	      workerSrc: getAssetBaseUri() + 'vendor/pdfjs/pdf.worker.min.js',
	      viewer: getAssetBaseUri() + 'vendor/pdfjs/'
	    },
	    'pdf-viewer': null
	  };
	
	  return function (moduleName) {
	    if (!modules[moduleName]) {
	      (function () {
	        var dfd = new $.Deferred();
	        var assetBaseUri = getAssetBaseUri();
	
	        if (moduleName === 'pdf-viewer') {
	          _spi2.default.fetchPdfViewerResources(moduleName, assetBaseUri).then(function (data) {
	            dfd.resolve(FileViewer.require(toInternal(moduleName)));
	          }).catch(function (err) {
	            dfd.reject(err);
	          });
	        } else if (moduleName === 'pdf-config') {
	          dfd.resolve(modules[moduleName]);
	        } else {
	          dfd.reject('Module ' + moduleName + ' is undefined.');
	        }
	
	        modules[moduleName] = dfd.promise();
	      })();
	    }
	
	    return modules[moduleName];
	  };
	}
	
	module.exports = React.createClass({
	
	  displayName: 'FileViewer',
	
	  componentWillMount: function componentWillMount() {
	    _app_dispatcher2.default.register({
	      'open-in-file-viewer': this._open,
	      'open-external-file-in-file-viewer': this._openExternalFile,
	      'file-download-stop': this._stopDownloadIndicator,
	      'close-file-viewer': this._closeFileViewer
	    });
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    _app_dispatcher2.default.unregister({
	      'open-in-file-viewer': this._open,
	      'open-external-file-in-file-viewer': this._openExternalFile,
	      'file-download-stop': this._stopDownloadIndicator,
	      'close-file-viewer': this._closeFileViewer,
	
	      // the following two events may or may not have been registered
	      'files-fetched': this._updateCollection,
	      'links-fetched': this._updateCollection
	    });
	
	    if (this._viewer) {
	
	      if (this._viewer.isOpen()) {
	        this._viewer.close();
	      }
	
	      this._viewer.off();
	      this._viewer = null;
	    }
	  },
	
	  render: function render() {
	    var styles = {
	      display: 'none'
	    };
	    return React.createElement('div', { style: styles });
	  },
	
	  _viewer: null,
	
	  _closeFileViewer: function _closeFileViewer() {
	    if (this._viewer !== null && this._viewer.isOpen()) {
	      this._viewer.close();
	    }
	  },
	
	  _onViewerClose: function _onViewerClose() {
	    var event = document.createEvent('CustomEvent');
	    event.initCustomEvent('click', false, false, null);
	
	    document.dispatchEvent(event);
	
	    _file_viewer_actions2.default.fileViewerClosed();
	  },
	
	  _open: function _open(item) {
	    var currentFile = normalize(item);
	
	    if (typeof FileViewer === "undefined") {
	      return false;
	    }
	    if (!this._viewer) {
	      this._setupViewer();
	    }
	
	    var filesList = this._combineFilesAndLinks();
	
	    if (!this._filesHaveBeenFetched()) {
	      this._fetchFiles();
	    }
	    if (!this._linksHaveBeenFetched()) {
	      this._fetchLinks();
	    }
	
	    var filesToShow = this._findFilesToShow(currentFile, filesList);
	
	    this._viewer.setFiles(filesToShow);
	    this._viewer.open({ srcDownload: currentFile.srcDownload }, 'main');
	  },
	
	  _openExternalFile: function _openExternalFile(data) {
	    var item = data.file;
	    var currentFile = normalize(item);
	
	    if (typeof FileViewer === 'undefined') {
	      return;
	    }
	    if (!this._viewer) {
	      this._setupViewer();
	    }
	
	    var filesList = data.filesList || [currentFile];
	
	    for (var i = filesList.length - 1; i >= 0; i--) {
	      var tmpfile = filesList[i];
	      if (tmpfile.url === currentFile.url) {
	        tmpfile.src = currentFile.src;
	      }
	      filesList[i] = normalize(tmpfile);
	    }
	
	    var filesToShow = this._findFilesToShow(currentFile, filesList);
	
	    this._viewer.setFiles(filesToShow);
	    this._viewer.open({ srcDownload: currentFile.srcDownload }, 'main');
	  },
	
	  _setupViewer: function _setupViewer() {
	    this._viewer = new FileViewer({
	      metaBar: {
	        defaultAvatar: ''
	      },
	      moduleBackend: getModuleLoader(),
	      analyticsBackend: this._sendAnalytics,
	      isPreviewGenerated: this._isPreviewGenerated,
	      generatePreview: this._fetchSignedURL
	    });
	
	    this.debouncedInitiateDownload = _.debounce(this._initiateDownload, 2000, { leading: true, trailing: false });
	
	    AJS.I18n.keys['cp.error.default.header'] = "We couldn't authenticate your account.";
	
	    this._viewer.on('fv.close', this._onViewerClose);
	    this._viewer.on('fv.download', this._onFileDownload);
	
	    videojs.options.techOrder = ['html5', 'youtube'];
	
	    _app_dispatcher2.default.register({
	      'files-fetched': this._updateCollection,
	      'links-fetched': this._updateCollection
	    });
	  },
	
	  _onFileDownload: function _onFileDownload(e) {
	    var file = this._viewer.getCurrent();
	    if (file.is_authenticated) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.debouncedInitiateDownload(file);
	    }
	  },
	  _initiateDownload: function _initiateDownload(file) {
	    // this._startDownloadIndicator();
	    this._fetchSignedURL(file, true).then(function (data) {
	      _spi2.default.downloadFile(data);
	    }).fail(function (error) {
	      _logger2.default.warn(error);
	    });
	  },
	  _startDownloadIndicator: function _startDownloadIndicator() {
	    var _this = this;
	
	    _.attempt(function () {
	      _this._viewer._view.fileContentView.getLayerForName('content').$el.hide();
	      _this._viewer._view.fileContentView.getLayerForName('spinner').startSpin();
	    });
	  },
	  _stopDownloadIndicator: function _stopDownloadIndicator() {
	    var _this2 = this;
	
	    _.attempt(function () {
	      _this2._viewer._view.fileContentView.getLayerForName('spinner').stopSpin();
	      _this2._viewer._view.fileContentView.getLayerForName('content').$el.show();
	    });
	  },
	
	
	  _filesHaveBeenFetched: function _filesHaveBeenFetched() {
	    // We can't check if the files have already been fetched. Therefore, we simply assume they haven't been fetched
	    // if there are not files in the room.
	    return _roster_store2.default.get('files').length;
	  },
	
	  _linksHaveBeenFetched: function _linksHaveBeenFetched() {
	    // We can't check if the links have already been fetched. Therefore, we simply assume they haven't been fetched
	    // if there are not links in the room.
	    return _roster_store2.default.get('links').length;
	  },
	
	  _fetchFiles: function _fetchFiles() {
	    _app_dispatcher2.default.dispatch('fetch-files', { room: _roster_store2.default.data.active_chat });
	  },
	
	  _fetchLinks: function _fetchLinks() {
	    _app_dispatcher2.default.dispatch('fetch-links', { room: _roster_store2.default.data.active_chat });
	  },
	
	  _fetchSignedURL: function _fetchSignedURL(file) {
	    var download = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    var deferred = new $.Deferred();
	
	    var resolveCb = function resolveCb(data) {
	      deferred.resolve(download ? data.temp_download_url : data.temp_url, guessMimeType(data));
	    };
	
	    var rejectCb = function rejectCb(err) {
	      deferred.reject(err);
	    };
	
	    _file_viewer_actions2.default.fetchSignedFile({ url: file.srcDownload || file.attributes.src }, resolveCb, rejectCb);
	    return deferred.promise();
	  },
	  _isPreviewGenerated: function _isPreviewGenerated(file) {
	    var deferred = new $.Deferred();
	    if (file.attributes.is_authenticated) {
	      deferred.resolve(false);
	    } else {
	      deferred.resolve(true, file.attributes.url, file.attributes.type);
	    }
	    return deferred;
	  },
	
	
	  // combines links and files, normalizes and then sorts them by date
	  _combineFilesAndLinks: function _combineFilesAndLinks() {
	    var files = _roster_store2.default.get('files');
	    var links = _roster_store2.default.get('links').filter(isSupported);
	    return _.sortBy(files.concat(links), 'date').map(normalize);
	  },
	
	  _updateCollection: function _updateCollection() {
	    if (!this._viewer.isOpen()) {
	      return;
	    }
	
	    var filesList = this._combineFilesAndLinks();
	    var currentFile = this._viewer.getCurrent();
	    var currentSrc = currentFile && currentFile.srcDownload;
	
	    var filesToShow = this._findFilesToShow(currentFile, filesList);
	    this._viewer.setFiles(filesToShow, { srcDownload: currentSrc });
	  },
	
	  // In certain cases, the file to be shown show is not part of the files list:
	  //  - The list of files / links has not been fetched yet
	  //  - The file and link lists only include the latest items. However, a user
	  //    can open older files / links via the chat panel
	  //  - Links posted by a bot are not included in the link list.
	  // In those cases, we will only show the selected file and ignore the file/link list.
	  _findFilesToShow: function _findFilesToShow(currentFile, filesList) {
	    var val;
	    if (this._fileIsInList(currentFile, filesList)) {
	      val = filesList;
	    } else {
	      val = [currentFile];
	    }
	    return val;
	  },
	
	  _fileIsInList: function _fileIsInList(file, list) {
	    var match = _.find(list, function (x) {
	      return x.srcDownload === file.srcDownload;
	    });
	
	    return !!match;
	  },
	
	  _sendAnalytics: function _sendAnalytics(key, data) {
	    _analytics_dispatcher2.default.dispatch('analytics-event', {
	      name: key,
	      properties: data
	    });
	  }
	
	});

/***/ },
/* 621 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _app_config = __webpack_require__(121);
	
	exports.default = React.createClass({
	
	  displayName: 'Tipsify',
	  mixin: [React.addons.PureRenderMixin],
	  debouncedMouseOver: null,
	
	  getInitialState: function getInitialState() {
	    return {
	      showTooltip: false,
	      tooltip: '',
	      currentTarget: null
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    this.debouncedMouseOver = _.debounce(function (e) {
	      return _this._onMouseOver(e);
	    }, _app_config.tipsify.delay);
	    document.addEventListener('mouseover', this.debouncedMouseOver);
	    document.addEventListener('mouseout', this._onDocumentMouseOut);
	    window.addEventListener('blur', this._hideTooltip);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    document.removeEventListener('mouseover', this.debouncedMouseOver);
	    document.removeEventListener('mouseout', this._onDocumentMouseOut);
	    window.removeEventListener('blur', this._hideTooltip);
	    this.debouncedMouseOver = null;
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.refs.content && this.state.currentTarget) {
	      this._positionTooltip();
	    }
	  },
	  _onDocumentMouseOut: function _onDocumentMouseOut(e) {
	    this.debouncedMouseOver.cancel();
	  },
	  _onMouseOver: function _onMouseOver(e) {
	    var target = this._getTarget(e.target);
	    if (!target || this._isSameTarget(target)) {
	      return;
	    }
	
	    var tooltip = this._getTooltip(target);
	    this._showTooltip(tooltip, target);
	  },
	  _onMouseOut: function _onMouseOut(e) {
	    if (this._isSameTarget(this._getTarget(e.toElement))) {
	      return;
	    }
	    this._hideTooltip();
	  },
	  _onClick: function _onClick() {
	    this._hideTooltip();
	  },
	  _getTarget: function _getTarget(target) {
	    if (!target || target === document.body) {
	      return null;
	    }
	
	    var iterations = 0,
	        tooltip = null;
	
	    while (target && !tooltip && iterations <= _app_config.tipsify.max_dom_traverse_depth) {
	      tooltip = this._getTooltip(target);
	      if (tooltip) {
	        return target;
	      }
	      target = target.parentElement;
	      iterations++;
	    }
	
	    return null;
	  },
	  _getTooltip: function _getTooltip(target) {
	    if (!target || target.hasAttribute('data-tipsify-ignore')) {
	      return null;
	    }
	
	    return target.getAttribute('aria-label');
	  },
	  _showTooltip: function _showTooltip(tooltip, target) {
	    this.setState({
	      showTooltip: true,
	      tooltip: this._stripTags(tooltip).replace(/\n/g, '<br />'),
	      currentTarget: target
	    });
	
	    target.addEventListener('mouseout', this._onMouseOut);
	    target.addEventListener('click', this._onClick);
	  },
	  _hideTooltip: function _hideTooltip() {
	    if (!this.state.currentTarget) {
	      return;
	    }
	
	    this.state.currentTarget.removeEventListener('mouseout', this._onMouseOut);
	    this.state.currentTarget.removeEventListener('click', this._onClick);
	
	    this.setState({
	      showTooltip: false,
	      tooltip: '',
	      currentTarget: null
	    });
	  },
	  _stripTags: function _stripTags(str) {
	    return str.replace(/<\/?[^>]+>/g, '');
	  },
	  _isSameTarget: function _isSameTarget(target) {
	    return target === this.state.currentTarget;
	  },
	  _isInvalidPosition: function _isInvalidPosition(rect) {
	    return rect.left === 0 && rect.right === 0 && rect.top === 0 && rect.bottom === 0 && rect.width === 0 && rect.height === 0;
	  },
	  _positionTooltip: function _positionTooltip() {
	    var content = ReactDOM.findDOMNode(this.refs.content);
	    content.style.padding = '0'; // Reset padding to make sure that we the correct width of the element
	
	    var contentRect = content.getBoundingClientRect(),
	        bodyRect = document.body.getBoundingClientRect(),
	        targetRect = this.state.currentTarget.getBoundingClientRect(),
	        left = targetRect.left + (targetRect.width - contentRect.width) / 2,
	        top = targetRect.top + targetRect.height + _app_config.tipsify.distance,
	        overflowX = left + contentRect.width - (bodyRect.width - _app_config.tipsify.window_margin),
	        overflowY = top + contentRect.height - (bodyRect.height - _app_config.tipsify.window_margin);
	
	    if (this._isInvalidPosition(targetRect)) {
	      this._hideTooltip();
	      return;
	    }
	
	    if (overflowX > 0) {
	      left -= overflowX;
	      content.style.padding = '0 ' + overflowX * 2 + 'px 0 0'; // This is needed for repositioning the arrow
	    }
	
	    if (overflowY > 0) {
	      top = targetRect.top - contentRect.height - _app_config.tipsify.distance;
	      content.className = 'tipsify-content reversed';
	    }
	
	    content.style.left = left + 'px';
	    content.style.top = top + 'px';
	
	    AJS.layer(content);
	  },
	  _renderTooltip: function _renderTooltip() {
	    if (!this.state.showTooltip) {
	      return null;
	    }
	
	    var tooltip = { __html: this.state.tooltip };
	
	    return React.createElement(
	      'div',
	      { className: 'tipsify-content', ref: 'content' },
	      React.createElement('div', { className: 'tipsify-content-inner', dangerouslySetInnerHTML: tooltip })
	    );
	  },
	  render: function render() {
	    var tooltip = this._renderTooltip();
	    return React.createElement(
	      'div',
	      { id: 'tipsify' },
	      tooltip
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 622 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _analytics_dispatcher = __webpack_require__(173);
	
	var _analytics_dispatcher2 = _interopRequireDefault(_analytics_dispatcher);
	
	var _routes = __webpack_require__(623);
	
	var _routes2 = _interopRequireDefault(_routes);
	
	var _logger = __webpack_require__(90);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var WindowStore = function (_Store) {
	  (0, _inherits3.default)(WindowStore, _Store);
	
	  function WindowStore() {
	    (0, _classCallCheck3.default)(this, WindowStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(WindowStore).call(this));
	
	    _this.router = (0, _routes2.default)();
	    _this.data = {
	      active_chat: '',
	      initialized: false
	    };
	    _this.throttledSelectRoom = _.throttle(function (data) {
	      _this.setHash(data.jid);
	    }, 100, { leading: true, trailing: false });
	    _this.registerCallbacks();
	    return _this;
	  }
	
	  (0, _createClass3.default)(WindowStore, [{
	    key: 'registerCallbacks',
	    value: function registerCallbacks() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'hc-init': function hcInit() {
	          _this2.setBodyClasses();
	        },
	        'before:app-state-ready': function beforeAppStateReady() {
	          if (window.location.pathname === '/chat/search') {
	            _this2.setHash(_preferences_store2.default.get('chatToFocus'));
	          } else {
	            _this2.router.route(window.location.pathname + window.location.search);
	          }
	          _this2.data.initialized = true;
	        }
	      });
	      _app_dispatcher2.default.register({
	        'set-route': function setRoute(data) {
	          if (_this2.data.initialized && data.jid !== _this2.data.active_chat) {
	            _this2.throttledSelectRoom(data);
	          }
	        },
	        'set-multiple-routes': function setMultipleRoutes(data) {
	          if (_this2.data.initialized && data.jid !== _this2.data.active_chat) {
	            _this2.setHash(data.jid);
	          }
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.data.active_chat = jid;
	        },
	        'updated:preferences': function updatedPreferences() {
	          _this2.setBodyClasses();
	        }
	      });
	      // Only send window analytics once, after the first chat finishes loading
	      // (at this point we can be sure that the window dimensions will be properly set)
	      _analytics_dispatcher2.default.registerOnce({
	        'analytics-history-loaded': function analyticsHistoryLoaded(data) {
	          _this2.sendWindowAnalytics();
	        }
	      });
	    }
	  }, {
	    key: 'getAppDimensions',
	    value: function getAppDimensions() {
	      var leftSidebarVisible = _preferences_store2.default.shouldShowNavigationSidebar();
	      var leftSidebarWidth = leftSidebarVisible ? _preferences_store2.default.getLeftColumnWidth() : 0;
	      var rightSidebarVisible = _preferences_store2.default.shouldShowGroupChatSidebar();
	      var rightSidebarWidth = rightSidebarVisible ? _preferences_store2.default.getRightColumnWidth() : 0;
	
	      return {
	        leftSidebarWidth: leftSidebarWidth,
	        rightSidebarWidth: rightSidebarWidth,
	        chatPanelWidth: window.innerWidth - leftSidebarWidth - rightSidebarWidth,
	        windowWidth: window.innerWidth,
	        windowHeight: window.innerHeight
	      };
	    }
	  }, {
	    key: 'sendWindowAnalytics',
	    value: function sendWindowAnalytics() {
	      _analytics_dispatcher2.default.dispatch("analytics-event", {
	        name: "hipchat.client.app.dimensions",
	        properties: this.getAppDimensions()
	      });
	    }
	  }, {
	    key: 'setHash',
	    value: function setHash(jid) {
	      var allRooms = _application_store2.default.get("allRooms");
	      var newPath = this.router.reverse(jid, allRooms);
	      if (newPath !== window.location.pathname) {
	        try {
	          this.router.route(newPath);
	        } catch (err) {
	          _logger2.default.error(err);
	          _logger2.default.type('router').error(err);
	        }
	      }
	    }
	  }, {
	    key: 'setBodyClasses',
	    value: function setBodyClasses() {
	      var classes = [_preferences_store2.default.getDensity(), _preferences_store2.default.getTheme()].join(' '),
	          $body = document.body;
	
	      if ($body.className !== classes) {
	        $body.className = classes;
	      }
	    }
	  }]);
	  return WindowStore;
	}(_store2.default);
	
	module.exports = new WindowStore();

/***/ },
/* 623 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    route: _page2.default,
	    reverse: reverseRoute
	  };
	};
	
	var _page = __webpack_require__(624);
	
	var _page2 = _interopRequireDefault(_page);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _chat_panel_strings = __webpack_require__(185);
	
	var _chat_panel_strings2 = _interopRequireDefault(_chat_panel_strings);
	
	var _integrations_actions = __webpack_require__(420);
	
	var _integrations_actions2 = _interopRequireDefault(_integrations_actions);
	
	var _route_actions = __webpack_require__(577);
	
	var _route_actions2 = _interopRequireDefault(_route_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function handleInvalidAction() {
	  _app_dispatcher2.default.dispatch('show-flag', {
	    type: "warning",
	    body: _chat_panel_strings2.default.integration_does_not_exist,
	    close: "auto",
	    title: ""
	  });
	}
	
	function handleInvalidRoom(jid) {
	  _app_dispatcher2.default.dispatch('show-flag', {
	    type: "warning",
	    body: _chat_panel_strings2.default.room_doesnt_exist,
	    close: "auto",
	    title: ""
	  });
	  _app_dispatcher2.default.dispatch('close-room', { jid: jid });
	}
	
	var routes = {
	
	  /**
	   * Supports:
	   * /user/<user_id>
	   * /room/<user jid>
	   * /room/<user half jid -- i.e., 10804_563@... the part before @>
	   * /user/<mention_name>
	   * */
	  '/chat/user/:id': function chatUserId(ctx) {
	    _route_actions2.default.selectOTO(decodeURIComponent(ctx.params.id));
	  },
	
	  /**
	   * Supports:
	   *   /room/<room_id>
	   *   /room/<room jid's>
	   *   /room/<room half jid's -- i.e., 10804_hc_team@... the part before @>
	   *   /room/<display name>
	   * */
	  '/chat/room/:id': function chatRoomId(ctx) {
	    _route_actions2.default.selectRoom(decodeURIComponent(ctx.params.id));
	  },
	
	  /**
	   * Supports
	   * /room/<room_id>/addon/<plugin_key>/module/<module_key>
	   *
	   */
	  '/chat/room/:roomId/addon/:addonKey/module/:moduleKey': function chatRoomRoomIdAddonAddonKeyModuleModuleKey(ctx) {
	    var roomId = decodeURIComponent(ctx.params.roomId);
	    var addonKey = decodeURIComponent(ctx.params.addonKey);
	    var moduleKey = decodeURIComponent(ctx.params.moduleKey);
	    _route_actions2.default.selectRoom(roomId);
	    if (!_integrations_actions2.default.open(addonKey, moduleKey)) {
	      handleInvalidAction(roomId, addonKey, moduleKey);
	    }
	  },
	
	  '/chat/lobby': function chatLobby() {
	    _app_dispatcher2.default.dispatch('new-active-chat', { jid: 'lobby' });
	  },
	
	  '/chat/search': function chatSearch() {
	    _app_dispatcher2.default.dispatch('new-active-chat', { jid: 'search' });
	  }
	};
	
	_app_dispatcher2.default.registerOnce({
	  'hipchat-client-configured': function hipchatClientConfigured() {
	    _page2.default.start({ hashbang: !_application_store2.default.get('html5_routing_enabled'), click: false });
	    _.forOwn(routes, function (cb, path) {
	      (0, _page2.default)(path, cb);
	    });
	  }
	});
	
	function reverseRoute(jid, allRooms) {
	  var chatType = void 0;
	  var pathPrefix = '/chat';
	  var chatPath = void 0;
	
	  if (_utils2.default.jid.is_chat(jid)) {
	    chatType = _utils2.default.jid.is_room(jid) ? 'room' : 'user';
	    if (chatType === 'room') {
	      var room = allRooms[jid];
	      if (room) {
	        chatPath = pathPrefix + '/' + chatType + '/' + encodeURIComponent(room.id);
	      } else {
	        //handle invalid room id and don't set a new route
	        handleInvalidRoom(jid);
	        return false;
	      }
	    } else {
	      var id = _utils2.default.jid.user_id(jid);
	      chatPath = pathPrefix + '/' + chatType + '/' + encodeURIComponent(id);
	    }
	  } else {
	    chatType = _utils2.default.jid.is_search(jid) ? 'search' : 'lobby';
	    chatPath = pathPrefix + '/' + chatType;
	  }
	
	  return chatPath;
	}
	
	module.exports = exports['default'];

/***/ },
/* 624 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {  /* globals require, module */
	
	  'use strict';
	
	  /**
	   * Module dependencies.
	   */
	
	  var pathtoRegexp = __webpack_require__(625);
	
	  /**
	   * Module exports.
	   */
	
	  module.exports = page;
	
	  /**
	   * Detect click event
	   */
	  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';
	
	  /**
	   * To work properly with the URL
	   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
	   */
	
	  var location = ('undefined' !== typeof window) && (window.history.location || window.location);
	
	  /**
	   * Perform initial dispatch.
	   */
	
	  var dispatch = true;
	
	
	  /**
	   * Decode URL components (query string, pathname, hash).
	   * Accommodates both regular percent encoding and x-www-form-urlencoded format.
	   */
	  var decodeURLComponents = true;
	
	  /**
	   * Base path.
	   */
	
	  var base = '';
	
	  /**
	   * Running flag.
	   */
	
	  var running;
	
	  /**
	   * HashBang option
	   */
	
	  var hashbang = false;
	
	  /**
	   * Previous context, for capturing
	   * page exit events.
	   */
	
	  var prevContext;
	
	  /**
	   * Register `path` with callback `fn()`,
	   * or route `path`, or redirection,
	   * or `page.start()`.
	   *
	   *   page(fn);
	   *   page('*', fn);
	   *   page('/user/:id', load, user);
	   *   page('/user/' + user.id, { some: 'thing' });
	   *   page('/user/' + user.id);
	   *   page('/from', '/to')
	   *   page();
	   *
	   * @param {string|!Function|!Object} path
	   * @param {Function=} fn
	   * @api public
	   */
	
	  function page(path, fn) {
	    // <callback>
	    if ('function' === typeof path) {
	      return page('*', path);
	    }
	
	    // route <path> to <callback ...>
	    if ('function' === typeof fn) {
	      var route = new Route(/** @type {string} */ (path));
	      for (var i = 1; i < arguments.length; ++i) {
	        page.callbacks.push(route.middleware(arguments[i]));
	      }
	      // show <path> with [state]
	    } else if ('string' === typeof path) {
	      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);
	      // start [options]
	    } else {
	      page.start(path);
	    }
	  }
	
	  /**
	   * Callback functions.
	   */
	
	  page.callbacks = [];
	  page.exits = [];
	
	  /**
	   * Current path being processed
	   * @type {string}
	   */
	  page.current = '';
	
	  /**
	   * Number of pages navigated to.
	   * @type {number}
	   *
	   *     page.len == 0;
	   *     page('/login');
	   *     page.len == 1;
	   */
	
	  page.len = 0;
	
	  /**
	   * Get or set basepath to `path`.
	   *
	   * @param {string} path
	   * @api public
	   */
	
	  page.base = function(path) {
	    if (0 === arguments.length) return base;
	    base = path;
	  };
	
	  /**
	   * Bind with the given `options`.
	   *
	   * Options:
	   *
	   *    - `click` bind to click events [true]
	   *    - `popstate` bind to popstate [true]
	   *    - `dispatch` perform initial dispatch [true]
	   *
	   * @param {Object} options
	   * @api public
	   */
	
	  page.start = function(options) {
	    options = options || {};
	    if (running) return;
	    running = true;
	    if (false === options.dispatch) dispatch = false;
	    if (false === options.decodeURLComponents) decodeURLComponents = false;
	    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
	    if (false !== options.click) {
	      document.addEventListener(clickEvent, onclick, false);
	    }
	    if (true === options.hashbang) hashbang = true;
	    if (!dispatch) return;
	    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
	    page.replace(url, null, true, dispatch);
	  };
	
	  /**
	   * Unbind click and popstate event handlers.
	   *
	   * @api public
	   */
	
	  page.stop = function() {
	    if (!running) return;
	    page.current = '';
	    page.len = 0;
	    running = false;
	    document.removeEventListener(clickEvent, onclick, false);
	    window.removeEventListener('popstate', onpopstate, false);
	  };
	
	  /**
	   * Show `path` with optional `state` object.
	   *
	   * @param {string} path
	   * @param {Object=} state
	   * @param {boolean=} dispatch
	   * @param {boolean=} push
	   * @return {!Context}
	   * @api public
	   */
	
	  page.show = function(path, state, dispatch, push) {
	    var ctx = new Context(path, state);
	    page.current = ctx.path;
	    if (false !== dispatch) page.dispatch(ctx);
	    if (false !== ctx.handled && false !== push) ctx.pushState();
	    return ctx;
	  };
	
	  /**
	   * Goes back in the history
	   * Back should always let the current route push state and then go back.
	   *
	   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
	   * @param {Object=} state
	   * @api public
	   */
	
	  page.back = function(path, state) {
	    if (page.len > 0) {
	      // this may need more testing to see if all browsers
	      // wait for the next tick to go back in history
	      history.back();
	      page.len--;
	    } else if (path) {
	      setTimeout(function() {
	        page.show(path, state);
	      });
	    }else{
	      setTimeout(function() {
	        page.show(base, state);
	      });
	    }
	  };
	
	
	  /**
	   * Register route to redirect from one path to other
	   * or just redirect to another route
	   *
	   * @param {string} from - if param 'to' is undefined redirects to 'from'
	   * @param {string=} to
	   * @api public
	   */
	  page.redirect = function(from, to) {
	    // Define route from a path to another
	    if ('string' === typeof from && 'string' === typeof to) {
	      page(from, function(e) {
	        setTimeout(function() {
	          page.replace(/** @type {!string} */ (to));
	        }, 0);
	      });
	    }
	
	    // Wait for the push state and replace it with another
	    if ('string' === typeof from && 'undefined' === typeof to) {
	      setTimeout(function() {
	        page.replace(from);
	      }, 0);
	    }
	  };
	
	  /**
	   * Replace `path` with optional `state` object.
	   *
	   * @param {string} path
	   * @param {Object=} state
	   * @param {boolean=} init
	   * @param {boolean=} dispatch
	   * @return {!Context}
	   * @api public
	   */
	
	
	  page.replace = function(path, state, init, dispatch) {
	    var ctx = new Context(path, state);
	    page.current = ctx.path;
	    ctx.init = init;
	    ctx.save(); // save before dispatching, which may redirect
	    if (false !== dispatch) page.dispatch(ctx);
	    return ctx;
	  };
	
	  /**
	   * Dispatch the given `ctx`.
	   *
	   * @param {Context} ctx
	   * @api private
	   */
	  page.dispatch = function(ctx) {
	    var prev = prevContext,
	      i = 0,
	      j = 0;
	
	    prevContext = ctx;
	
	    function nextExit() {
	      var fn = page.exits[j++];
	      if (!fn) return nextEnter();
	      fn(prev, nextExit);
	    }
	
	    function nextEnter() {
	      var fn = page.callbacks[i++];
	
	      if (ctx.path !== page.current) {
	        ctx.handled = false;
	        return;
	      }
	      if (!fn) return unhandled(ctx);
	      fn(ctx, nextEnter);
	    }
	
	    if (prev) {
	      nextExit();
	    } else {
	      nextEnter();
	    }
	  };
	
	  /**
	   * Unhandled `ctx`. When it's not the initial
	   * popstate then redirect. If you wish to handle
	   * 404s on your own use `page('*', callback)`.
	   *
	   * @param {Context} ctx
	   * @api private
	   */
	  function unhandled(ctx) {
	    if (ctx.handled) return;
	    var current;
	
	    if (hashbang) {
	      current = base + location.hash.replace('#!', '');
	    } else {
	      current = location.pathname + location.search;
	    }
	
	    if (current === ctx.canonicalPath) return;
	    page.stop();
	    ctx.handled = false;
	    location.href = ctx.canonicalPath;
	  }
	
	  /**
	   * Register an exit route on `path` with
	   * callback `fn()`, which will be called
	   * on the previous context when a new
	   * page is visited.
	   */
	  page.exit = function(path, fn) {
	    if (typeof path === 'function') {
	      return page.exit('*', path);
	    }
	
	    var route = new Route(path);
	    for (var i = 1; i < arguments.length; ++i) {
	      page.exits.push(route.middleware(arguments[i]));
	    }
	  };
	
	  /**
	   * Remove URL encoding from the given `str`.
	   * Accommodates whitespace in both x-www-form-urlencoded
	   * and regular percent-encoded form.
	   *
	   * @param {string} val - URL component to decode
	   */
	  function decodeURLEncodedURIComponent(val) {
	    if (typeof val !== 'string') { return val; }
	    return decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
	  }
	
	  /**
	   * Initialize a new "request" `Context`
	   * with the given `path` and optional initial `state`.
	   *
	   * @constructor
	   * @param {string} path
	   * @param {Object=} state
	   * @api public
	   */
	
	  function Context(path, state) {
	    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;
	    var i = path.indexOf('?');
	
	    this.canonicalPath = path;
	    this.path = path.replace(base, '') || '/';
	    if (hashbang) this.path = this.path.replace('#!', '') || '/';
	
	    this.title = document.title;
	    this.state = state || {};
	    this.state.path = path;
	    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
	    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
	    this.params = {};
	
	    // fragment
	    this.hash = '';
	    if (!hashbang) {
	      if (!~this.path.indexOf('#')) return;
	      var parts = this.path.split('#');
	      this.path = parts[0];
	      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';
	      this.querystring = this.querystring.split('#')[0];
	    }
	  }
	
	  /**
	   * Expose `Context`.
	   */
	
	  page.Context = Context;
	
	  /**
	   * Push state.
	   *
	   * @api private
	   */
	
	  Context.prototype.pushState = function() {
	    page.len++;
	    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
	  };
	
	  /**
	   * Save the context state.
	   *
	   * @api public
	   */
	
	  Context.prototype.save = function() {
	    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
	  };
	
	  /**
	   * Initialize `Route` with the given HTTP `path`,
	   * and an array of `callbacks` and `options`.
	   *
	   * Options:
	   *
	   *   - `sensitive`    enable case-sensitive routes
	   *   - `strict`       enable strict matching for trailing slashes
	   *
	   * @constructor
	   * @param {string} path
	   * @param {Object=} options
	   * @api private
	   */
	
	  function Route(path, options) {
	    options = options || {};
	    this.path = (path === '*') ? '(.*)' : path;
	    this.method = 'GET';
	    this.regexp = pathtoRegexp(this.path,
	      this.keys = [],
	      options);
	  }
	
	  /**
	   * Expose `Route`.
	   */
	
	  page.Route = Route;
	
	  /**
	   * Return route middleware with
	   * the given callback `fn()`.
	   *
	   * @param {Function} fn
	   * @return {Function}
	   * @api public
	   */
	
	  Route.prototype.middleware = function(fn) {
	    var self = this;
	    return function(ctx, next) {
	      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
	      next();
	    };
	  };
	
	  /**
	   * Check if this route matches `path`, if so
	   * populate `params`.
	   *
	   * @param {string} path
	   * @param {Object} params
	   * @return {boolean}
	   * @api private
	   */
	
	  Route.prototype.match = function(path, params) {
	    var keys = this.keys,
	      qsIndex = path.indexOf('?'),
	      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
	      m = this.regexp.exec(decodeURIComponent(pathname));
	
	    if (!m) return false;
	
	    for (var i = 1, len = m.length; i < len; ++i) {
	      var key = keys[i - 1];
	      var val = decodeURLEncodedURIComponent(m[i]);
	      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
	        params[key.name] = val;
	      }
	    }
	
	    return true;
	  };
	
	
	  /**
	   * Handle "populate" events.
	   */
	
	  var onpopstate = (function () {
	    var loaded = false;
	    if ('undefined' === typeof window) {
	      return;
	    }
	    if (document.readyState === 'complete') {
	      loaded = true;
	    } else {
	      window.addEventListener('load', function() {
	        setTimeout(function() {
	          loaded = true;
	        }, 0);
	      });
	    }
	    return function onpopstate(e) {
	      if (!loaded) return;
	      if (e.state) {
	        var path = e.state.path;
	        page.replace(path, e.state);
	      } else {
	        page.show(location.pathname + location.hash, undefined, undefined, false);
	      }
	    };
	  })();
	  /**
	   * Handle "click" events.
	   */
	
	  function onclick(e) {
	
	    if (1 !== which(e)) return;
	
	    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
	    if (e.defaultPrevented) return;
	
	
	
	    // ensure link
	    // use shadow dom when available
	    var el = e.path ? e.path[0] : e.target;
	    while (el && 'A' !== el.nodeName) el = el.parentNode;
	    if (!el || 'A' !== el.nodeName) return;
	
	
	
	    // Ignore if tag has
	    // 1. "download" attribute
	    // 2. rel="external" attribute
	    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;
	
	    // ensure non-hash for the same path
	    var link = el.getAttribute('href');
	    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;
	
	
	
	    // Check for mailto: in the href
	    if (link && link.indexOf('mailto:') > -1) return;
	
	    // check target
	    if (el.target) return;
	
	    // x-origin
	    if (!sameOrigin(el.href)) return;
	
	
	
	    // rebuild path
	    var path = el.pathname + el.search + (el.hash || '');
	
	    // strip leading "/[drive letter]:" on NW.js on Windows
	    if (typeof process !== 'undefined' && path.match(/^\/[a-zA-Z]:\//)) {
	      path = path.replace(/^\/[a-zA-Z]:\//, '/');
	    }
	
	    // same page
	    var orig = path;
	
	    if (path.indexOf(base) === 0) {
	      path = path.substr(base.length);
	    }
	
	    if (hashbang) path = path.replace('#!', '');
	
	    if (base && orig === path) return;
	
	    e.preventDefault();
	    page.show(orig);
	  }
	
	  /**
	   * Event button.
	   */
	
	  function which(e) {
	    e = e || window.event;
	    return null === e.which ? e.button : e.which;
	  }
	
	  /**
	   * Check if `href` is the same origin.
	   */
	
	  function sameOrigin(href) {
	    var origin = location.protocol + '//' + location.hostname;
	    if (location.port) origin += ':' + location.port;
	    return (href && (0 === href.indexOf(origin)));
	  }
	
	  page.sameOrigin = sameOrigin;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(113)))

/***/ },
/* 625 */
/***/ function(module, exports, __webpack_require__) {

	var isarray = __webpack_require__(626)
	
	/**
	 * Expose `pathToRegexp`.
	 */
	module.exports = pathToRegexp
	module.exports.parse = parse
	module.exports.compile = compile
	module.exports.tokensToFunction = tokensToFunction
	module.exports.tokensToRegExp = tokensToRegExp
	
	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
	  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
	  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
	  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
	].join('|'), 'g')
	
	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {String} str
	 * @return {Array}
	 */
	function parse (str) {
	  var tokens = []
	  var key = 0
	  var index = 0
	  var path = ''
	  var res
	
	  while ((res = PATH_REGEXP.exec(str)) != null) {
	    var m = res[0]
	    var escaped = res[1]
	    var offset = res.index
	    path += str.slice(index, offset)
	    index = offset + m.length
	
	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1]
	      continue
	    }
	
	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path)
	      path = ''
	    }
	
	    var prefix = res[2]
	    var name = res[3]
	    var capture = res[4]
	    var group = res[5]
	    var suffix = res[6]
	    var asterisk = res[7]
	
	    var repeat = suffix === '+' || suffix === '*'
	    var optional = suffix === '?' || suffix === '*'
	    var delimiter = prefix || '/'
	    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')
	
	    tokens.push({
	      name: name || key++,
	      prefix: prefix || '',
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      pattern: escapeGroup(pattern)
	    })
	  }
	
	  // Match any characters still remaining.
	  if (index < str.length) {
	    path += str.substr(index)
	  }
	
	  // If the path exists, push it onto the end.
	  if (path) {
	    tokens.push(path)
	  }
	
	  return tokens
	}
	
	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {String}   str
	 * @return {Function}
	 */
	function compile (str) {
	  return tokensToFunction(parse(str))
	}
	
	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length)
	
	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^' + tokens[i].pattern + '$')
	    }
	  }
	
	  return function (obj) {
	    var path = ''
	    var data = obj || {}
	
	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i]
	
	      if (typeof token === 'string') {
	        path += token
	
	        continue
	      }
	
	      var value = data[token.name]
	      var segment
	
	      if (value == null) {
	        if (token.optional) {
	          continue
	        } else {
	          throw new TypeError('Expected "' + token.name + '" to be defined')
	        }
	      }
	
	      if (isarray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
	        }
	
	        if (value.length === 0) {
	          if (token.optional) {
	            continue
	          } else {
	            throw new TypeError('Expected "' + token.name + '" to not be empty')
	          }
	        }
	
	        for (var j = 0; j < value.length; j++) {
	          segment = encodeURIComponent(value[j])
	
	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	          }
	
	          path += (j === 0 ? token.prefix : token.delimiter) + segment
	        }
	
	        continue
	      }
	
	      segment = encodeURIComponent(value)
	
	      if (!matches[i].test(segment)) {
	        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	      }
	
	      path += token.prefix + segment
	    }
	
	    return path
	  }
	}
	
	/**
	 * Escape a regular expression string.
	 *
	 * @param  {String} str
	 * @return {String}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
	}
	
	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {String} group
	 * @return {String}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$\/()])/g, '\\$1')
	}
	
	/**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {RegExp} re
	 * @param  {Array}  keys
	 * @return {RegExp}
	 */
	function attachKeys (re, keys) {
	  re.keys = keys
	  return re
	}
	
	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {String}
	 */
	function flags (options) {
	  return options.sensitive ? '' : 'i'
	}
	
	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {RegExp} path
	 * @param  {Array}  keys
	 * @return {RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g)
	
	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        pattern: null
	      })
	    }
	  }
	
	  return attachKeys(path, keys)
	}
	
	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {Array}  path
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = []
	
	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source)
	  }
	
	  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
	
	  return attachKeys(regexp, keys)
	}
	
	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {String} path
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  var tokens = parse(path)
	  var re = tokensToRegExp(tokens, options)
	
	  // Attach keys back to the regexp.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] !== 'string') {
	      keys.push(tokens[i])
	    }
	  }
	
	  return attachKeys(re, keys)
	}
	
	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {Array}  tokens
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function tokensToRegExp (tokens, options) {
	  options = options || {}
	
	  var strict = options.strict
	  var end = options.end !== false
	  var route = ''
	  var lastToken = tokens[tokens.length - 1]
	  var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)
	
	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i]
	
	    if (typeof token === 'string') {
	      route += escapeString(token)
	    } else {
	      var prefix = escapeString(token.prefix)
	      var capture = token.pattern
	
	      if (token.repeat) {
	        capture += '(?:' + prefix + capture + ')*'
	      }
	
	      if (token.optional) {
	        if (prefix) {
	          capture = '(?:' + prefix + '(' + capture + '))?'
	        } else {
	          capture = '(' + capture + ')?'
	        }
	      } else {
	        capture = prefix + '(' + capture + ')'
	      }
	
	      route += capture
	    }
	  }
	
	  // In non-strict mode we allow a slash at the end of match. If the path to
	  // match already ends with a slash, we remove it for consistency. The slash
	  // is valid at the end of a path match, not in the middle. This is important
	  // in non-ending mode, where "/test/" shouldn't match "/test//route".
	  if (!strict) {
	    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
	  }
	
	  if (end) {
	    route += '$'
	  } else {
	    // In non-ending mode, we need the capturing groups to match as much as
	    // possible by using a positive lookahead to the end or next path segment.
	    route += strict && endsWithSlash ? '' : '(?=\\/|$)'
	  }
	
	  return new RegExp('^' + route, flags(options))
	}
	
	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(String|RegExp|Array)} path
	 * @param  {Array}                 [keys]
	 * @param  {Object}                [options]
	 * @return {RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  keys = keys || []
	
	  if (!isarray(keys)) {
	    options = keys
	    keys = []
	  } else if (!options) {
	    options = {}
	  }
	
	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, keys, options)
	  }
	
	  if (isarray(path)) {
	    return arrayToRegexp(path, keys, options)
	  }
	
	  return stringToRegexp(path, keys, options)
	}


/***/ },
/* 626 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 627 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _header = __webpack_require__(308);
	
	var _header2 = _interopRequireDefault(_header);
	
	var _inline_dialog_manager_mixin = __webpack_require__(338);
	
	var _inline_dialog_manager_mixin2 = _interopRequireDefault(_inline_dialog_manager_mixin);
	
	var _inline_dialog_container = __webpack_require__(465);
	
	var _inline_dialog_container2 = _interopRequireDefault(_inline_dialog_container);
	
	var _flags_container = __webpack_require__(475);
	
	var _flags_container2 = _interopRequireDefault(_flags_container);
	
	var _guest_body_layout = __webpack_require__(628);
	
	var _guest_body_layout2 = _interopRequireDefault(_guest_body_layout);
	
	var _file_viewer = __webpack_require__(620);
	
	var _file_viewer2 = _interopRequireDefault(_file_viewer);
	
	var _tipsify = __webpack_require__(621);
	
	var _tipsify2 = _interopRequireDefault(_tipsify);
	
	__webpack_require__(622);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = React.createClass({
	
	  displayName: "GuestLayout",
	
	  mixins: [_inline_dialog_manager_mixin2.default],
	
	  render: function render() {
	    return React.createElement(
	      'div',
	      { id: 'page' },
	      React.createElement(_header2.default, { is_guest: this.props.is_guest }),
	      React.createElement(_guest_body_layout2.default, { is_guest: this.props.is_guest }),
	      React.createElement(_inline_dialog_container2.default, { is_guest: this.props.is_guest }),
	      React.createElement(_flags_container2.default, null),
	      React.createElement(_file_viewer2.default, { ref: 'fileViewer', items: this.props.files }),
	      React.createElement(_tipsify2.default, null)
	    );
	  }
	});
	module.exports = exports['default'];

/***/ },
/* 628 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var GeneralErrorsStore = __webpack_require__(482),
	    LayoutStore = __webpack_require__(483),
	    MainCol = __webpack_require__(498),
	    GeneralErrorDisplay = __webpack_require__(629);
	
	module.exports = React.createClass({
	
	  displayName: "GuestBodyLayout",
	
	  getInitialState: function getInitialState() {
	    return {
	      errors: GeneralErrorsStore.get('errors'),
	      ready: LayoutStore.get('ready'),
	      web_server: GeneralErrorsStore.get('web_server')
	    };
	  },
	
	  componentDidMount: function componentDidMount() {
	    GeneralErrorsStore.on('change', this._onChange);
	    LayoutStore.on('change:ready', this._onChange);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    GeneralErrorsStore.off('change', this._onChange);
	    LayoutStore.off('change:ready', this._onChange);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    $(window).trigger("resize");
	  },
	
	  _onChange: function _onChange() {
	    this.setState(this.getInitialState());
	  },
	
	  render: function render() {
	    var body;
	
	    if (this.state.errors.length) {
	      body = React.createElement(GeneralErrorDisplay, { errors: this.state.errors });
	    } else {
	      body = React.createElement(
	        "div",
	        { className: "hc-layout" },
	        React.createElement(MainCol, { ref: "main_column", is_guest: this.props.is_guest })
	      );
	    }
	
	    return body;
	  }
	});

/***/ },
/* 629 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var GeneralError403 = __webpack_require__(630);
	var GeneralError500 = __webpack_require__(631);
	
	module.exports = React.createClass({
	
	  displayName: "GeneralErrorDisplay",
	
	  render: function render() {
	    var stanza = this.props.errors[0],
	        error;
	
	    if (stanza.error.code === "500") {
	      error = React.createElement(GeneralError500, { error: stanza, web_server: this.props.web_server });
	    } else {
	      error = React.createElement(GeneralError403, { error: stanza, web_server: this.props.web_server });
	    }
	    return error;
	  }
	
	});

/***/ },
/* 630 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var strings = __webpack_require__(183);
	
	function getErrorMessage(error) {
	  var hasText = _.get(error, "error.text.__text");
	  return hasText ? error.error.text.__text : "An error occurred";
	}
	
	module.exports = React.createClass({
	
	  displayName: "GeneralError403",
	
	  render: function render() {
	    var errorMessage = getErrorMessage(this.props.error);
	
	    return React.createElement(
	      "section",
	      { role: "main", className: "general-error-display aui-page-notification aui-page-size-medium" },
	      React.createElement(
	        "div",
	        { className: "aui-page-panel" },
	        React.createElement(
	          "div",
	          { className: "aui-page-pannel-inner" },
	          React.createElement(
	            "section",
	            { className: "aui-page-panel-content" },
	            React.createElement(
	              "h1",
	              null,
	              React.createElement("img", { src: "https://" + this.props.web_server + "/wc/assets/img/embedded/notsureif@3x.png", alt: "Not sure if", title: "Not sure if", className: "error-emoticon", width: "38", height: "50" }),
	              " ",
	              strings.youre_welcome
	            ),
	            React.createElement(
	              "div",
	              { className: "aui-page-notification-description" },
	              React.createElement(
	                "p",
	                null,
	                React.createElement(
	                  "strong",
	                  null,
	                  errorMessage
	                )
	              ),
	              React.createElement(
	                "p",
	                null,
	                React.createElement(
	                  "a",
	                  { href: "https://" + this.props.web_server + "/sign_in" },
	                  strings.sign_in
	                )
	              )
	            )
	          )
	        )
	      )
	    );
	  }
	
	});

/***/ },
/* 631 */
/***/ function(module, exports) {

	"use strict";
	
	function getErrorMessage(error) {
	  var hasText = _.get(error, "error.text.__text");
	  return hasText ? error.error.text.__text : "An error occurred";
	}
	
	module.exports = React.createClass({
	
	  displayName: "GeneralError500",
	
	  render: function render() {
	    var errorMessage = getErrorMessage(this.props.error);
	
	    return React.createElement(
	      "section",
	      { role: "main", className: "general-error-display aui-page-notification aui-page-size-medium" },
	      React.createElement(
	        "div",
	        { className: "aui-page-panel" },
	        React.createElement(
	          "div",
	          { className: "aui-page-pannel-inner" },
	          React.createElement(
	            "section",
	            { className: "aui-page-panel-content" },
	            React.createElement(
	              "h1",
	              null,
	              "Whoa! What did you do!? ",
	              React.createElement("img", { className: "error-emoticon", src: "https://" + this.props.web_server + "/wc/assets/img/embedded/troll@3x.png", width: "50", height: "50" })
	            ),
	            React.createElement(
	              "div",
	              { className: "aui-page-notification-description" },
	              React.createElement(
	                "p",
	                null,
	                React.createElement(
	                  "strong",
	                  null,
	                  errorMessage
	                )
	              )
	            )
	          )
	        )
	      )
	    );
	  }
	
	});

/***/ },
/* 632 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Attempt to detect unrecoverable errors
	 *
	 * @module ErrorDetect
	 */
	var ERRORS = {};
	
	var _class = function () {
	  function _class(callback) {
	    (0, _classCallCheck3.default)(this, _class);
	
	    this.callback = callback || function () {};
	  }
	
	  (0, _createClass3.default)(_class, [{
	    key: "_normalizeError",
	    value: function _normalizeError(e) {
	      var err = {};
	      if (e instanceof Error) {
	        err = e;
	      } else if (typeof ErrorEvent !== "undefined" && e instanceof ErrorEvent) {
	        err = e.error || e;
	      }
	      return err;
	    }
	  }, {
	    key: "trigger",
	    value: function trigger(err) {
	      var _this = this;
	
	      _.each(ERRORS, function (def, type) {
	        var detected = false;
	        try {
	          detected = def.detect(err);
	        } catch (ignore) {
	          // we want to ensure we don't trigger window.onerror to avoid recursing
	        }
	
	        if (detected) {
	          var currentTime = Date.now();
	          if (currentTime <= def._last + def.time) {
	            def._count++;
	          } else {
	            def._count = 1;
	          }
	          if (def._count > def.threshold) {
	            def._count = 0;
	            _this.callback.call(_this, type, err);
	          }
	          def._last = currentTime;
	        }
	      });
	    }
	
	    /**
	     * Install the ErrorDetect module, adding an error event handler to the console
	     *
	     * @method install
	     */
	
	  }, {
	    key: "install",
	    value: function install() {
	      var _this2 = this;
	
	      window.addEventListener("error", function (e) {
	        var err = _this2._normalizeError(e);
	        _this2.trigger(err);
	      });
	    }
	
	    /**
	     *
	     * @param {string} type the identifier for this rule
	     * @param {object} options the options hash
	     * @param {function} options.detect the function to determine if this rule is hit
	     * @param {number} options.threshold the threshold of error occurrences
	     * @param {number} options.time the sliding window time in milliseconds in which to count these errors
	     */
	
	  }, {
	    key: "addRule",
	    value: function addRule(type, options) {
	      ERRORS[type] = options;
	    }
	  }]);
	  return _class;
	}();

	exports.default = _class;
	module.exports = exports['default'];

/***/ },
/* 633 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(10);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(22);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(51);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _store = __webpack_require__(97);
	
	var _store2 = _interopRequireDefault(_store);
	
	var _app_dispatcher = __webpack_require__(9);
	
	var _app_dispatcher2 = _interopRequireDefault(_app_dispatcher);
	
	var _app_config = __webpack_require__(121);
	
	var _app_config2 = _interopRequireDefault(_app_config);
	
	var _utils = __webpack_require__(99);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _video_chat = __webpack_require__(634);
	
	var _video_chat2 = _interopRequireDefault(_video_chat);
	
	var _video_call_strings = __webpack_require__(176);
	
	var _video_call_strings2 = _interopRequireDefault(_video_call_strings);
	
	var _video_service_keys = __webpack_require__(174);
	
	var _video_service_keys2 = _interopRequireDefault(_video_service_keys);
	
	var _configuration_store = __webpack_require__(169);
	
	var _configuration_store2 = _interopRequireDefault(_configuration_store);
	
	var _preferences_store = __webpack_require__(161);
	
	var _preferences_store2 = _interopRequireDefault(_preferences_store);
	
	var _application_store = __webpack_require__(190);
	
	var _application_store2 = _interopRequireDefault(_application_store);
	
	var _spi = __webpack_require__(93);
	
	var _spi2 = _interopRequireDefault(_spi);
	
	var _current_user_actions = __webpack_require__(257);
	
	var _current_user_actions2 = _interopRequireDefault(_current_user_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var VideoChatStore = function (_Store) {
	  (0, _inherits3.default)(VideoChatStore, _Store);
	
	  function VideoChatStore() {
	    (0, _classCallCheck3.default)(this, VideoChatStore);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(VideoChatStore).call(this));
	
	    _this.local = {};
	    return _this;
	  }
	
	  (0, _createClass3.default)(VideoChatStore, [{
	    key: 'getDefaults',
	    value: function getDefaults() {
	      return {
	        video_sessions: [],
	        video_enabled: _configuration_store2.default.get('video_enabled'),
	        delayed_video_messages: {},
	        incoming_invites: [],
	        active_chat: '',
	        profiles: {},
	        current_user: {},
	        web_server: _app_config2.default.default_web_server,
	        video_chat_uri: _configuration_store2.default.get('video_chat_uri')
	      };
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      var _this2 = this;
	
	      _app_dispatcher2.default.registerOnce({
	        'app-state-ready': function appStateReady() {
	          _this2.videoChat = new _video_chat2.default(_this2);
	        }
	      });
	      _app_dispatcher2.default.register({
	        'updated:config': function updatedConfig(config) {
	          _this2.set('video_chat_uri', config.video_chat_uri);
	        },
	        'updated:current_user': function updatedCurrent_user(data) {
	          _this2.data.current_user = data;
	        },
	        'updated:web_server': function updatedWeb_server(web_server) {
	          _this2.set("web_server", web_server);
	        },
	        'updated:active_chat': function updatedActive_chat(jid) {
	          _this2.data.active_chat = jid;
	        },
	        'updated:profiles': function updatedProfiles(data) {
	          _this2.handleProfiles(data);
	        },
	        'addlive.video-window-event': function addliveVideoWindowEvent(data) {
	          _this2.handleExternalWindowEvent(data);
	        },
	        'addlive.start-video-call': function addliveStartVideoCall(data) {
	          _this2.initiateVideoCall(data);
	        },
	        'addlive.invite-to-audio-video-call': function addliveInviteToAudioVideoCall(data) {
	          if (data.sender.jid !== _this2.data.current_user.user_jid) {
	            _this2.handleVideoCallInvite(data);
	          }
	        },
	        'addlive.answer-audio-video-call': function addliveAnswerAudioVideoCall(data) {
	          _this2.answerIncomingVideoCall(data);
	        },
	        'addlive.audio-video-call-accepted': function addliveAudioVideoCallAccepted(data) {
	          _this2.videoCallAcceptedByRemoteUser(data);
	        },
	        'addlive.audio-video-call-declined': function addliveAudioVideoCallDeclined(data) {
	          _this2.handleDeclinedMessage(data);
	        },
	        'addlive.decline-audio-video-call': function addliveDeclineAudioVideoCall(data) {
	          _this2.declineIncomingVideoCall(data);
	        },
	        'addlive.audio-video-call-hung-up': function addliveAudioVideoCallHungUp(data) {
	          _this2.handleHangupMessage(data);
	        },
	        'addlive.focus-video-window': function addliveFocusVideoWindow(data) {
	          var session = _this2.getVideoSession(data.jid);
	          if (session && session.window) {
	            session.window.focus();
	          }
	        }
	      });
	    }
	  }, {
	    key: 'handleProfiles',
	    value: function handleProfiles(data) {
	      var _this3 = this;
	
	      _.forOwn(data, function (profile, jid) {
	        if (!_this3.data.profiles[jid]) {
	          _this3.data.profiles[jid] = {
	            jid: jid,
	            name: profile.name,
	            title: profile.title,
	            timezone: profile.timezone || '',
	            timezone_utc_diff: profile.timezone ? parseFloat(profile.timezone['utc_offset']) : 0,
	            email: profile.email,
	            photo: profile.photo_large,
	            photo_small: profile.photo_small
	          };
	        }
	      });
	    }
	  }, {
	    key: 'handleVideoCallInvite',
	    value: function handleVideoCallInvite(data) {
	      var _this4 = this;
	
	      var user = this.getCaller(data.sender.jid),
	          session = this.getCurrentSession(),
	          doInterrupt;
	      this.videoChat.triggerVideoCall(user);
	      if (session) {
	        if (session.jid !== data.message.from) {
	          return undefined;
	        }
	        if (!session.window || !session.window.isConnected) {
	          doInterrupt = true;
	        } else {
	          return true;
	        }
	      } else {
	        _app_dispatcher2.default.dispatch('show-flag', {
	          id: 'video-flag-' + _utils2.default.now(),
	          type: 'video',
	          sender: data.sender.name,
	          photo: user.photo_url,
	          message: data.message,
	          service: _video_service_keys2.default.ADDLIVE
	        });
	      }
	      this.videoChat.notifyForIncomingCall(user, _preferences_store2.default.getShowToasters());
	      var invite = {
	        caller: user,
	        missed_timer: setTimeout(function () {
	          _this4.handleMissedCall(user);
	        }, _app_config2.default.missed_video_call_timeout)
	      };
	      this.data.incoming_invites.push(invite);
	      if (doInterrupt) {
	        this.handleVideoInterruptMessage(data.message);
	      }
	    }
	  }, {
	    key: 'removeInvite',
	    value: function removeInvite(jid) {
	      var invite = _.find(this.data.incoming_invites, { caller: this.getCaller(jid) });
	      if (invite) {
	        clearTimeout(invite.missed_timer);
	        this.videoChat.stopAllSounds();
	        _.pull(this.data.incoming_invites, invite);
	        _app_dispatcher2.default.dispatch("hide-modal-dialog");
	      }
	    }
	  }, {
	    key: 'answerIncomingVideoCall',
	    value: function answerIncomingVideoCall(data) {
	      this.videoChat.stopAllSounds();
	      this.videoChat.stopIncomingNotification(data.from);
	      this.removeInvite(data.from);
	      var audio_only = !_.get(data, 'x.call', {}).hasOwnProperty('video'),
	          url = _.get(data, 'x.url', '');
	      _app_dispatcher2.default.dispatch('send-video-message', {
	        jid: data.from,
	        type: 'accept',
	        service: _video_service_keys2.default.ADDLIVE
	      });
	      this.initiateVideoCall({
	        jid: data.from,
	        type: 'accept',
	        audio_only: audio_only,
	        url: url,
	        service: url ? _video_service_keys2.default.ENSO : _video_service_keys2.default.ADDLIVE
	      });
	      window.app.get_profile(data.from, function (profile) {
	        _spi2.default.callAnswered(data.from, profile);
	        window.app.request_addlive_credentials(data.from, function (d, creds) {
	          _spi2.default.addLiveCredentialsReceived(creds);
	        });
	      });
	    }
	  }, {
	    key: 'declineIncomingVideoCall',
	    value: function declineIncomingVideoCall(data) {
	      this.videoChat.stopAllSounds();
	      this.videoChat.stopIncomingNotification(data.from);
	      this.removeInvite(data.from);
	      _app_dispatcher2.default.dispatch('send-video-message', {
	        jid: data.from,
	        type: 'decline',
	        service: _video_service_keys2.default.ADDLIVE
	      });
	    }
	  }, {
	    key: 'handleMissedCall',
	    value: function handleMissedCall(caller) {
	      this.videoChat.stopAllSounds();
	      this.videoChat.stopIncomingNotification(caller.jid);
	      var msg = {
	        body: _video_call_strings2.default.missed_call_message(caller.name),
	        type: "missed-call",
	        from: caller.jid,
	        delay: false,
	        sender: " "
	      };
	      _app_dispatcher2.default.dispatch(_video_service_keys2.default.ADDLIVE + '.missed-call', msg);
	      _app_dispatcher2.default.dispatch("hide-modal-dialog");
	    }
	  }, {
	    key: 'createCallSession',
	    value: function createCallSession(_ref) {
	      var jid = _ref.jid;
	      var type = _ref.type;
	      var uri = _ref.uri;
	
	      this.data.video_sessions.push({
	        jid: jid,
	        type: type,
	        window: this.videoChat.openVideoUI(uri, jid)
	      });
	      _current_user_actions2.default.onCall();
	    }
	  }, {
	    key: 'isNativeAddLiveWindow',
	    value: function isNativeAddLiveWindow() {
	      return !!_configuration_store2.default.get('feature_flags').web_client_native_addlive_window;
	    }
	  }, {
	    key: 'initiateVideoCall',
	    value: function initiateVideoCall(data) {
	      var _this5 = this;
	
	      var session = this.getCurrentSession();
	
	      if (!session) {
	        var native_video_uri = this.get('video_chat_uri');
	        data.uri = native_video_uri ? native_video_uri + '?user_id=' : 'https://' + this.get('web_server') + '/chat/video/';
	        data.uri += '' + encodeURIComponent(_utils2.default.jid.user_id(data.jid));
	
	        if (data.audio_only) {
	          data.uri += native_video_uri ? '&' : '?';
	          data.uri += 'voice';
	        }
	
	        if (!this.isNativeAddLiveWindow()) {
	          this.createCallSession(data);
	        }
	
	        if (data.type === 'call') {
	          window.app.get_profile(data.jid, function (profile) {
	            _spi2.default.callPlaced(data.jid, profile);
	            if (_this5.isNativeAddLiveWindow()) {
	              _app_dispatcher2.default.dispatch('send-video-message', {
	                jid: data.jid,
	                type: 'call',
	                audio_only: data.audio_only,
	                service: _video_service_keys2.default.ADDLIVE
	              });
	            }
	            window.app.request_addlive_credentials(data.jid, function (d, creds) {
	              _spi2.default.addLiveCredentialsReceived(creds);
	            });
	          });
	        }
	
	        return;
	      }
	
	      // focus call window if connecting or connected to the call
	      if (data.jid === session.jid && session.window) {
	        var isConnected = session.window.isConnected,
	            isConnecting = _.isUndefined(session.window.isConnected); // if disconnected, it would be 'false'
	        if (isConnected || isConnecting) {
	          session.window.focus();
	          return;
	        }
	      }
	
	      // ask if client (currently disconnected) want to switch to other call session
	      if (confirm(_video_call_strings2.default.confirm_leave) && session.window) {
	        this.deleteVideoSession(session.jid);
	        session.window.close();
	
	        this.createCallSession(data);
	      }
	    }
	  }, {
	    key: 'handleDeclinedMessage',
	    value: function handleDeclinedMessage(data) {
	      var session = this.getCurrentSession();
	      if (session && session.jid !== data.message.from) {
	        return;
	      }
	
	      this.videoChat.stopAllSounds();
	      var jid = _utils2.default.jid.bare_jid(data.from),
	          user = this.getCaller(jid);
	      this.videoChat.triggerVideoDeclined(user);
	      _current_user_actions2.default.leaveCall();
	      window.app.get_profile(data.message.from, function (profile) {
	        _spi2.default.callDeclined(data.message.from, profile);
	      });
	    }
	  }, {
	    key: 'handleVideoInterruptMessage',
	    value: function handleVideoInterruptMessage(data) {
	      var user = this.getCaller(data.from);
	      this.videoChat.triggerVideoInterrupt(user);
	    }
	  }, {
	    key: 'handleHangupMessage',
	    value: function handleHangupMessage(data) {
	      var session = this.getCurrentSession();
	      if (session && session.jid !== data.sender.jid) {
	        return;
	      }
	
	      var from = _.get(data, 'message.from') || _.get(data, 'sender.jid');
	      this.videoChat.stopAllSounds();
	      this.videoChat.triggerVideoHangup(data.sender);
	      this.removeInvite(from);
	      _current_user_actions2.default.leaveCall();
	      window.app.get_profile(data.sender.jid, function (profile) {
	        _spi2.default.callHungup(data.sender.jid, profile);
	      });
	    }
	  }, {
	    key: 'videoCallAcceptedByRemoteUser',
	    value: function videoCallAcceptedByRemoteUser(data) {
	      this.videoChat.stopAllSounds();
	      var jid = _utils2.default.jid.bare_jid(data.message.from),
	          user = this.getCaller(jid);
	      this.videoChat.triggerVideoAccept(user);
	    }
	  }, {
	    key: 'deleteVideoSession',
	    value: function deleteVideoSession(jid, delay) {
	      this.videoChat.stopAllSounds();
	      var session = this.getVideoSession(jid);
	      if (delay) {
	        if (session) {
	          session.timeout = setTimeout(function (store) {
	            if (session === store.getCurrentSession()) {
	              store.destroyVideoSession(jid);
	            }
	          }, _app_config2.default.missed_video_call_timeout, this);
	        }
	      }
	    }
	  }, {
	    key: 'sendVideoMessage',
	    value: function sendVideoMessage(jid, args) {
	      if (typeof args === 'string') {
	        args = JSON.parse(args);
	      }
	      // ngvideo app use 'join' instead of accept, so fix it
	      if (args.type === 'join') {
	        args.type = 'accept';
	      }
	      var type = this.determineMessageType(jid, args);
	      var audio_only = _.get(args, 'audio_only', false);
	      switch (type) {
	        case 'call':
	          if (!args.url) {
	            this.videoChat.notifyForOutgoingCall();
	          }
	          break;
	        case 'hangup':
	          this.videoChat.stopAllSounds();
	          _current_user_actions2.default.leaveCall();
	          break;
	        case 'accept':
	          this.videoChat.stopAllSounds();
	          break;
	      }
	      _app_dispatcher2.default.dispatch('send-video-message', {
	        jid: jid,
	        type: type,
	        audio_only: audio_only,
	        url: args.url || '',
	        service: _video_service_keys2.default.ADDLIVE
	      });
	    }
	  }, {
	    key: 'handleExternalWindowEvent',
	    value: function handleExternalWindowEvent(args) {
	      switch (args.type) {
	        case 'video_session_started':
	          this.videoChat.stopAllSounds();
	          break;
	        case 'video_joined':
	          this.removeInvite(args.data);
	          _current_user_actions2.default.onCall();
	          // ensure that this client marked as `remoteAccepted` in ngvideo app
	          this.videoChat.triggerVideoAccept(this.getCaller(args.data));
	          return;
	        case 'video_hangup':
	          if (args.data === this.data.current_user.user_jid) {
	            this.sendVideoMessage(args.data, {
	              type: 'hangup'
	            });
	            _current_user_actions2.default.leaveCall();
	          }
	          break;
	        case 'video_declined':
	          this.sendVideoMessage(args.data, {
	            type: 'decline'
	          });
	          this.deleteVideoSession(args.data);
	          break;
	        case 'video_session_ended':
	          if (!args.data.reloading) {
	            _app_dispatcher2.default.dispatch('send-video-message', {
	              jid: args.data.jid,
	              type: 'hangup',
	              service: _video_service_keys2.default.ADDLIVE
	            });
	            this.videoChat.stopAllSounds();
	            this.destroyVideoSession(args.data.jid);
	            _current_user_actions2.default.leaveCall();
	          }
	          break;
	      }
	    }
	  }, {
	    key: 'determineMessageType',
	    value: function determineMessageType(jid, args) {
	      var session = this.getVideoSession(jid);
	      if (args.type === 'decline' || args.type === 'hangup') {
	        return args.type;
	      }
	      return session.type === 'call' && args.type === 'accept' ? 'call' : 'accept';
	    }
	  }, {
	    key: 'destroyVideoSession',
	    value: function destroyVideoSession(jid) {
	      var session = this.getVideoSession(jid);
	      if (session && session.window) {
	        var _window = session.window;
	        session.window = null;
	        _window.close();
	      }
	      this.data.video_sessions = _.reject(this.data.video_sessions, { jid: jid });
	    }
	  }, {
	    key: 'getVideoSession',
	    value: function getVideoSession(jid) {
	      return _.find(this.data.video_sessions, { jid: jid });
	    }
	  }, {
	    key: 'getCurrentSession',
	    value: function getCurrentSession() {
	      return _.find(this.data.video_sessions, function (session) {
	        return session.window && !session.timeout;
	      });
	    }
	  }, {
	    key: 'getCaller',
	    value: function getCaller(jid) {
	      var roster = this.getRoster();
	      return _.find(roster, { jid: jid });
	    }
	  }, {
	    key: 'getRoster',
	    value: function getRoster() {
	      return _.values(_application_store2.default.get("roster"));
	    }
	  }]);
	  return VideoChatStore;
	}(_store2.default);
	
	exports.default = new VideoChatStore();
	module.exports = exports['default'];

/***/ },
/* 634 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*global util*/
	var notifier = __webpack_require__(180),
	    AppActions = __webpack_require__(195),
	    utils = __webpack_require__(99),
	    appConfig = __webpack_require__(121),
	    AppDispatcher = __webpack_require__(9),
	    strings = __webpack_require__(176),
	    ApplicationStore = __webpack_require__(190),
	    spi = __webpack_require__(93);
	
	var VideoChat = function () {
	  function VideoChat(store) {
	    (0, _classCallCheck3.default)(this, VideoChat);
	
	    this.events = $(document);
	    this.attachBridgeComponents(store);
	    this.subscribeToExternalWindowEvents(this.events);
	  }
	
	  (0, _createClass3.default)(VideoChat, [{
	    key: 'attachBridgeComponents',
	    value: function attachBridgeComponents(store) {
	      window.chat = {
	        events: this.events,
	        current_message_id: 0,
	        delete_video_session: _.bind(store.deleteVideoSession, store),
	        cancel_delete_video_session: function cancel_delete_video_session(jid) {
	          var session = this.get_video_session(jid);
	          if (session && session.timeout) {
	            clearTimeout(session.timeout);
	            delete session.timeout;
	          }
	        },
	        get_video_session: function get_video_session(jid) {
	          return _.find(store.get('video_sessions'), { jid: jid });
	        },
	        set_video_session_type: function set_video_session_type(jid, type) {
	          var session = this.get_video_session(jid);
	          if (session) {
	            session.type = type;
	          }
	        },
	        next_message_id: function next_message_id() {
	          return this.current_message_id++;
	        }
	      };
	
	      window.app = {
	        get_user_info: function get_user_info(jid, return_placeholder) {
	          var bare_jid = util.jid.bare_jid(jid),
	              member = _.find(store.getRoster(), { jid: bare_jid });
	          if (member) {
	            return member;
	          }
	          return return_placeholder ? { name: '' } : null;
	        },
	        current_user_jid: store.get('current_user').user_jid,
	        send_video_message: function send_video_message(jid, args) {
	          store.sendVideoMessage(jid, args);
	        },
	        get_video_session: function get_video_session(jid) {
	          return _.find(store.get('video_sessions'), { jid: jid });
	        },
	        send_delayed_video_message: function send_delayed_video_message(to_jid, args) {
	          var jid = "" + to_jid;
	          if (typeof args === 'string') {
	            args = JSON.parse(args);
	          }
	          var message_id = 'msg-' + args.message_id;
	          if (args.type === 'hangup' || args.type === 'decline') {
	            notifier.stopSounds();
	          }
	          store.data.delayed_video_messages[message_id] = {
	            cancel: function cancel() {
	              delete store.data.delayed_video_messages[message_id];
	              clearTimeout(this.timeout);
	            },
	            timeout: setTimeout(function () {
	              delete store.data.delayed_video_messages[message_id];
	              store.sendVideoMessage(jid, {
	                type: args.type
	              });
	            }, args.timeout || 5000, jid)
	          };
	          return message_id;
	        },
	        attributes: {},
	        set_video_attribute: function set_video_attribute(name, value) {
	          this["" + name] = "" + value;
	        },
	
	        get_video_attribute: function get_video_attribute(name) {
	          return this[name];
	        },
	
	        remove_video_attribute: function remove_video_attribute(name) {
	          delete this[name];
	        },
	
	        cancel_delayed_video_message: function cancel_delayed_video_message(message_id) {
	          var message = store.get('delayed_video_messages')[message_id];
	          if (message) {
	            message.cancel();
	            return true;
	          }
	          return false;
	        },
	        request_addlive_credentials: function request_addlive_credentials(jid, callback) {
	          AppDispatcher.dispatch('request-addlive-credentials', {
	            jid: jid
	          }, callback);
	        },
	
	        get_profile: function get_profile(jid, callback) {
	          var info = store.get('profiles')[jid];
	
	          if (info) {
	            callback(info);
	          } else {
	            AppDispatcher.dispatch('request-profile', jid, function (response) {
	              if (!response || !response.query) {
	                return;
	              }
	              var profile = response.query;
	              var data = {
	                'jid': jid,
	                'name': profile.name,
	                'title': profile.title,
	                'timezone': profile.timezone || '',
	                'timezone_utc_diff': profile.timezone ? parseFloat(profile.timezone['utc_offset']) : 0,
	                'email': profile.email,
	                'photo': profile.photo_large,
	                'photo_small': profile.photo_small
	              };
	              callback(data);
	            });
	          }
	        }
	      };
	
	      window.util = utils;
	
	      window.hipchat = console || { log: _.noop }; // This is fucked up, but it's only used for logging
	    }
	  }, {
	    key: 'notifyForIncomingCall',
	    value: function notifyForIncomingCall(caller, doNotify) {
	      notifier.playSound('incoming_call', true);
	      notifier.setTitleNotification({
	        id: caller.jid,
	        text: strings.incoming_call_notification(caller.name)
	      });
	      if (doNotify) {
	        AppActions.showNotification({
	          group_id: ApplicationStore.get('config').group_id,
	          group_name: ApplicationStore.get('config').group_name,
	          jid: caller.jid,
	          title: caller.name,
	          body: strings.incoming_call_notification(caller.name),
	          icon: ApplicationStore.get('asset_base_uri') + appConfig.notification_icon,
	          type: 'incoming_call'
	        });
	      }
	    }
	  }, {
	    key: 'notifyForOutgoingCall',
	    value: function notifyForOutgoingCall() {
	      notifier.playSound('outgoing_call', true);
	    }
	  }, {
	    key: 'stopAllSounds',
	    value: function stopAllSounds() {
	      notifier.stopSounds();
	    }
	  }, {
	    key: 'stopIncomingNotification',
	    value: function stopIncomingNotification(caller_jid) {
	      notifier.unsetTitleNotification(caller_jid);
	    }
	  }, {
	    key: 'openVideoUI',
	    value: function openVideoUI(url, jid) {
	      var window_size = utils.video.size_window(appConfig.video_width, appConfig.video_height, 640, 360),
	          width = window_size.width,
	          height = window_size.height;
	
	      var width_ratio = width / appConfig.video_width;
	      var height_ratio = height / appConfig.video_height;
	
	      if (width_ratio < 1 && height_ratio < 1) {
	        if (width_ratio < height_ratio) {
	          width = Math.floor(appConfig.video_width * height_ratio);
	        } else {
	          height = Math.floor(appConfig.video_height * width_ratio);
	        }
	      } else if (height_ratio < 1) {
	        width = Math.floor(appConfig.video_width * height_ratio);
	      } else if (width_ratio < 1) {
	        height = Math.floor(appConfig.video_height * width_ratio);
	      }
	
	      var pos = utils.video.center_window(width, height),
	          props = 'resizable=yes,width=' + width + ',height=' + height + ',top=' + pos.top + ',left=' + pos.left,
	          video_window = spi.openInternalWindow(url, 'HipChat', props);
	
	      if (video_window) {
	        $(video_window).on('beforeunload', function (e) {
	          AppDispatcher.dispatch('addlive.video-window-event', {
	            type: 'video_session_ended',
	            data: {
	              jid: jid,
	              reloading: e.currentTarget.reloading
	            }
	          });
	        });
	        video_window.focus();
	        window.video_window = video_window;
	      }
	      return video_window;
	    }
	  }, {
	    key: 'subscribeToExternalWindowEvents',
	    value: function subscribeToExternalWindowEvents(events) {
	      /*
	       * The following is necessary because of how the original web client video module was written
	       */
	      events.on('video_session_ended video_session_started video_declined video_joined video_hangup', function (evt, data) {
	        AppDispatcher.dispatch('addlive.video-window-event', {
	          type: evt.type,
	          data: data
	        });
	      });
	    }
	  }, {
	    key: 'triggerVideoCall',
	    value: function triggerVideoCall(user) {
	      this.events.trigger('video_call', user);
	    }
	  }, {
	    key: 'triggerVideoAccept',
	    value: function triggerVideoAccept(user) {
	      this.events.trigger('video_accept', user);
	    }
	  }, {
	    key: 'triggerVideoHangup',
	    value: function triggerVideoHangup(user) {
	      this.events.trigger('video_hangup', user);
	    }
	  }, {
	    key: 'triggerVideoDeclined',
	    value: function triggerVideoDeclined(user) {
	      this.events.trigger('video_decline', user);
	    }
	  }, {
	    key: 'triggerVideoInterrupt',
	    value: function triggerVideoInterrupt(user) {
	      this.events.trigger('video_interrupt', user);
	    }
	  }, {
	    key: 'triggerVideoUnsupported',
	    value: function triggerVideoUnsupported(data) {
	      this.events.trigger('video_unsupported', data);
	    }
	  }]);
	  return VideoChat;
	}();
	
	module.exports = VideoChat;

/***/ },
/* 635 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _toConsumableArray2 = __webpack_require__(117);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _classCallCheck2 = __webpack_require__(4);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(5);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _chat_window_store = __webpack_require__(599);
	
	var _chat_window_store2 = _interopRequireDefault(_chat_window_store);
	
	var _clipboard_strings = __webpack_require__(636);
	
	var _clipboard_strings2 = _interopRequireDefault(_clipboard_strings);
	
	var _moment = __webpack_require__(103);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ClipboardHelper = function () {
	  function ClipboardHelper() {
	    (0, _classCallCheck3.default)(this, ClipboardHelper);
	
	    this._initialize();
	  }
	
	  (0, _createClass3.default)(ClipboardHelper, [{
	    key: '_initialize',
	    value: function _initialize() {
	      $(document).on('copy', this._doCopy.bind(this));
	    }
	  }, {
	    key: '_doCopy',
	    value: function _doCopy(e) {
	      var activeSelection = window.getSelection(),
	          activeRanges = this._getSelectionRanges(activeSelection);
	
	      if (!activeSelection.rangeCount) {
	        return;
	      }
	      // Abort if the target of the copy is not inside the chat panel. Let the system handle it.
	      if (!$(e.target).parents('.hc-chat-panel').length) {
	        return;
	      }
	
	      var copyableElements = this._getCopyableElements(activeRanges);
	
	      // Abort if there are less than 2 copyable elements
	      if (copyableElements.length < 2) {
	        return;
	      }
	
	      var content = this._getFormattedContent(copyableElements);
	
	      var $textarea = $("<textarea>").css({
	        'width': '1px',
	        'height': '1px',
	        'padding': '0px'
	      }).text(content);
	
	      // this CSS makes it so you can't actually see the textarea when it pops in but
	      // it is still "visible" enough to copy from for some browsers that require it
	      var $clipboardContainer = $("<div id='clipboard-container'>").css({
	        'position': 'fixed',
	        'left': '0px',
	        'top': '0px',
	        'width': '0px',
	        'height': '0px',
	        'z-index': '100',
	        'display': 'block',
	        'opacity': '0'
	      }).append($textarea).appendTo(document.body);
	
	      $textarea.focus().select();
	      try {
	        // Firefox needs this method
	        document.execCommand('copy');
	      } catch (err) {
	        // do nothing, the browser will pick it up.
	      }
	
	      _.defer(function () {
	        // return the previous selection
	        activeSelection.removeAllRanges();
	        activeRanges.forEach(function (range) {
	          return activeSelection.addRange(range);
	        });
	
	        $clipboardContainer.remove();
	      });
	    }
	  }, {
	    key: '_getCopyableElements',
	    value: function _getCopyableElements(selectionRanges) {
	      var copyableElements = [];
	
	      copyableElements = _.map(selectionRanges, function (range) {
	        // go through each range in selectionRanges array
	        // get array of document fragments one for each range
	        // get array of copyable DOM elements from each doc fragment
	        // the '...' is a handy way to convert a nodeList to an array
	        var docFragment = range.cloneContents();
	        return [].concat((0, _toConsumableArray3.default)(docFragment.querySelectorAll('[data-copyable]')));
	      });
	
	      // combine all the DOM elements into a single array
	      return _.flatten(copyableElements);
	    }
	  }, {
	    key: '_getFormattedContent',
	    value: function _getFormattedContent(copyableElements) {
	      var _this = this;
	
	      // get an array of formatted strings for each DOM element
	      var formattedElements = _.reduce(copyableElements, function (acc, element) {
	        var formattedElement = _this._formatElement(element);
	        // remove any empties
	        if (!_.isEmpty(formattedElement)) {
	          acc.push(formattedElement);
	        }
	
	        return acc;
	      }, []);
	
	      // combine into a string
	      return _.join(formattedElements, '\n') || "";
	    }
	  }, {
	    key: '_getSelectionRanges',
	    value: function _getSelectionRanges(selection) {
	      // Firefox creats multiple ranges. We'll collect 'em all.
	      // https://developer.mozilla.org/en-US/docs/Web/API/Selection#Multiple_ranges_in_a_selection
	      var selectionRanges = [];
	      for (var i = 0, len = selection.rangeCount; i < len; ++i) {
	        selectionRanges.push(selection.getRangeAt(i));
	      }
	      return selectionRanges;
	    }
	  }, {
	    key: '_formatElement',
	    value: function _formatElement(el) {
	      var message = '',
	          time = '',
	          senderName = '',
	          body = '',
	          elementData = JSON.parse(el.dataset.copyable),
	          formatStyle = elementData.format;
	
	      // If we included a mid look up the message
	      if (elementData.mid) {
	        message = this._getMessageByMid(elementData.mid);
	        time = (0, _moment2.default)(message.date).format("h:mm A");
	        senderName = message.sender;
	      }
	
	      if (formatStyle === "plain-message") {
	
	        body = this._formatBodyText(el);
	        return '[' + time + '] ' + senderName + ': ' + body;
	      } else if (formatStyle === "notification") {
	
	        body = this._formatBodyText(el);
	        return '[' + time + '] ' + senderName + ': ' + body;
	      } else if (formatStyle === "info") {
	
	        // this covers /topic, /me, etc.
	        body = this._formatBodyText(el);
	        body = body.split('\n'); // for multi-line messages
	        body = _.transform(body, function (result, element) {
	          return result.push('    ' + element);
	        }, []);
	        body = body.join('\n');
	        return '' + body;
	      } else if (formatStyle === "quotation") {
	
	        body = this._formatBodyText(el);
	        body = body.split('\n'); // for multi-line messages
	        body = _.transform(body, function (result, element) {
	          return result.push('    |  ' + element);
	        }, []);
	        body = body.join('\n');
	        return '[' + time + '] ' + senderName + ':\n' + body;
	      } else if (formatStyle === "code") {
	
	        var multilineElement = $('li', el);
	
	        if (multilineElement.length > 0) {
	          body = [];
	          $('li', el).each(function (i, subElement) {
	            body.push('    ' + subElement.lastElementChild.textContent);
	          });
	          body = body.join('\n');
	        } else {
	          body = this._formatBodyText(el);
	          body = '    ' + body;
	        }
	
	        return '[' + time + '] ' + senderName + ':\n' + body;
	      } else if (formatStyle === "file") {
	
	        var fileName = message.file_data.file_name;
	        var fileUrl = message.file_data.url;
	        body = this._formatBodyText(message.rendered_body);
	        return '[' + time + '] ' + senderName + ': ' + body + '\n    ' + _clipboard_strings2.default.file_uploaded + ': ' + fileName + '\n    [' + fileUrl + ']' + '';
	      } else if (formatStyle === "date-divider") {
	
	        body = this._formatBodyText(el);
	        return '---- ' + body + ' ----';
	      }
	
	      return el.lastElementChild.textContent;
	    }
	  }, {
	    key: '_getMessageByMid',
	    value: function _getMessageByMid(mid) {
	      var messages = _chat_window_store2.default.data.chats[_chat_window_store2.default.data.active_chat].messages;
	      return _.find(messages, { 'mid': mid });
	    }
	  }, {
	    key: '_formatBodyText',
	    value: function _formatBodyText(el) {
	      // We get the time stamp and name from ChatWindowStore but not the message body. We retrive the body of the message from
	      // the document fragment because it will have exactly the text the user selected, even if they only selected part of line.
	      var textString = "",
	          nodes = $.parseHTML(el.innerHTML || el);
	
	      if (nodes) {
	        nodes.forEach(function (node) {
	          if (node.nodeName === "BR") {
	            textString += "\n";
	          } else if (node.nodeName === "IMG" && $(node).hasClass('remoticon')) {
	            textString += node.alt;
	          } else {
	            textString += node.textContent;
	          }
	        });
	
	        textString = textString.trim();
	        textString = textString.replace(/\n\n/g, ''); // Some HTML messages have <br> tags that leave new lines at the end of messages. Clear those.
	      }
	
	      return textString;
	    }
	  }]);
	  return ClipboardHelper;
	}();
	
	exports.default = new ClipboardHelper();
	module.exports = exports['default'];

/***/ },
/* 636 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  file_uploaded: "File uploaded"
	};
	module.exports = exports['default'];

/***/ }
/******/ ]);


/** WEBPACK FOOTER **
 ** app-4.30.3.js
 **/